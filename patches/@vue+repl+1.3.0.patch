diff --git a/node_modules/@vue/repl/README.md b/node_modules/@vue/repl/README.md
index be04199..57060b4 100644
--- a/node_modules/@vue/repl/README.md
+++ b/node_modules/@vue/repl/README.md
@@ -33,7 +33,7 @@ const store = new ReplStore({
   showOutput: query.has('showOutput'),
   // starts on a different tab on the output pane if the URL has a outputMode query
   // and default to the "preview" tab
-  outputMode: (query.get('outputMode') || 'preview')
+  outputMode: (query.get('outputMode') || 'preview'),
 
   // specify the default URL to import Vue runtime from in the sandbox
   // default is the CDN link from unpkg.com with version matching Vue's version
diff --git a/node_modules/@vue/repl/dist/repl.d.ts b/node_modules/@vue/repl/dist/repl.d.ts
index 526f787..f1c3dab 100644
--- a/node_modules/@vue/repl/dist/repl.d.ts
+++ b/node_modules/@vue/repl/dist/repl.d.ts
@@ -3,12 +3,40 @@ import { ComponentCustomProps } from 'vue';
 import { ComponentOptionsMixin } from 'vue';
 import * as defaultCompiler from 'vue/compiler-sfc';
 import { DefineComponent } from 'vue';
+import { ExtractPropTypes } from 'vue';
 import { PropType } from 'vue';
 import { SFCAsyncStyleCompileOptions } from 'vue/compiler-sfc';
 import { SFCScriptCompileOptions } from 'vue/compiler-sfc';
 import { SFCTemplateCompileOptions } from 'vue/compiler-sfc';
 import { VNodeProps } from 'vue';
-import { vueCompilerSfc } from 'vue/compiler-sfc';
+
+declare type __VLS_NonUndefinedable<T> = T extends undefined ? never : T;
+
+declare type __VLS_NonUndefinedable_2<T> = T extends undefined ? never : T;
+
+declare type __VLS_TypePropsToRuntimeProps<T> = {
+    [K in keyof T]-?: {} extends Pick<T, K> ? {
+        type: PropType<__VLS_NonUndefinedable<T[K]>>;
+    } : {
+        type: PropType<T[K]>;
+        required: true;
+    };
+};
+
+declare type __VLS_TypePropsToRuntimeProps_2<T> = {
+    [K in keyof T]-?: {} extends Pick<T, K> ? {
+        type: PropType<__VLS_NonUndefinedable_2<T[K]>>;
+    } : {
+        type: PropType<T[K]>;
+        required: true;
+    };
+};
+
+declare type __VLS_WithDefaults<P, D> = {
+    [K in keyof Pick<P, keyof P>]: K extends keyof D ? P[K] & {
+        default: D[K];
+    } : P[K];
+};
 
 export declare function compileFile(store: Store, { filename, code, compiled }: File_2): Promise<void>;
 
@@ -27,56 +55,30 @@ export { File_2 as File }
 
 export declare type OutputModes = 'preview' | 'js' | 'css' | 'ssr';
 
-export declare const Repl: DefineComponent<    {
-store: {
-type: PropType<Store>;
-} & {
-default: () => ReplStore;
-};
-autoResize: {
-type: PropType<boolean>;
-} & {
-default: boolean;
-};
-showCompileOutput: {
-type: PropType<boolean>;
-} & {
-default: boolean;
-};
-showImportMap: {
-type: PropType<boolean>;
-} & {
-default: boolean;
-};
-clearConsole: {
-type: PropType<boolean>;
-} & {
-default: boolean;
-};
-sfcOptions: {
-type: PropType<SFCOptions>;
-};
-layout: {
-type: PropType<string>;
-};
-}, () => void, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<{
-store?: unknown;
-autoResize?: unknown;
-showCompileOutput?: unknown;
-showImportMap?: unknown;
-clearConsole?: unknown;
-sfcOptions?: unknown;
-layout?: unknown;
-} & {
-store: Store;
+export declare const Preview: DefineComponent<__VLS_TypePropsToRuntimeProps_2<{
+show: boolean;
+ssr: boolean;
+}>, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<__VLS_TypePropsToRuntimeProps_2<{
+show: boolean;
+ssr: boolean;
+}>>>, {}>;
+
+export declare const Repl: DefineComponent<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<ReplProps>, {
+store: () => ReplStore;
+autoResize: boolean;
 showCompileOutput: boolean;
+showImportMap: boolean;
+clearConsole: boolean;
+ssr: boolean;
+}>, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<ReplProps>, {
+store: () => ReplStore;
 autoResize: boolean;
+showCompileOutput: boolean;
 showImportMap: boolean;
 clearConsole: boolean;
-} & {
-layout?: string | undefined;
-sfcOptions?: SFCOptions | undefined;
-}>, {
+ssr: boolean;
+}>>>, {
+ssr: boolean;
 store: Store;
 showCompileOutput: boolean;
 autoResize: boolean;
@@ -84,20 +86,29 @@ showImportMap: boolean;
 clearConsole: boolean;
 }>;
 
+export declare interface ReplProps {
+    store?: Store;
+    autoResize?: boolean;
+    showCompileOutput?: boolean;
+    showImportMap?: boolean;
+    clearConsole?: boolean;
+    sfcOptions?: SFCOptions;
+    layout?: string;
+    ssr?: boolean;
+}
+
 export declare class ReplStore implements Store {
     state: StoreState;
     compiler: typeof defaultCompiler;
+    vueVersion?: string;
     options?: SFCOptions;
     initialShowOutput: boolean;
     initialOutputMode: OutputModes;
     private defaultVueRuntimeURL;
+    private defaultVueServerRendererURL;
     private pendingCompiler;
-    constructor({ serializedState, defaultVueRuntimeURL, showOutput, outputMode }?: {
-        serializedState?: string;
-        showOutput?: boolean;
-        outputMode?: OutputModes | string;
-        defaultVueRuntimeURL?: string;
-    });
+    constructor({ serializedState, defaultVueRuntimeURL, defaultVueServerRendererURL, showOutput, outputMode }?: StoreOptions);
+    init(): void;
     setActive(filename: string): void;
     addFile(fileOrFilename: string | File_2): void;
     deleteFile(filename: string): void;
@@ -123,7 +134,9 @@ export declare interface SFCOptions {
 export declare interface Store {
     state: StoreState;
     options?: SFCOptions;
-    compiler: vueCompilerSfc;
+    compiler: typeof defaultCompiler;
+    vueVersion?: string;
+    init: () => void;
     setActive: (filename: string) => void;
     addFile: (filename: string | File_2) => void;
     deleteFile: (filename: string) => void;
@@ -132,12 +145,21 @@ export declare interface Store {
     initialOutputMode: OutputModes;
 }
 
+export declare interface StoreOptions {
+    serializedState?: string;
+    showOutput?: boolean;
+    outputMode?: OutputModes | string;
+    defaultVueRuntimeURL?: string;
+    defaultVueServerRendererURL?: string;
+}
+
 export declare interface StoreState {
     mainFile: string;
     files: Record<string, File_2>;
     activeFile: File_2;
     errors: (string | Error)[];
     vueRuntimeURL: string;
+    vueServerRendererURL: string;
 }
 
 export { }
diff --git a/node_modules/@vue/repl/dist/style.css b/node_modules/@vue/repl/dist/style.css
index b406c10..4323ddf 100644
--- a/node_modules/@vue/repl/dist/style.css
+++ b/node_modules/@vue/repl/dist/style.css
@@ -97,7 +97,7 @@
 }
 }
 
-.file-selector[data-v-6e00d5ce] {
+.file-selector[data-v-7bc917c0] {
   display: flex;
   box-sizing: border-box;
   border-bottom: 1px solid var(--border);
@@ -108,19 +108,19 @@
   position: relative;
   height: var(--header-height);
 }
-.file-selector[data-v-6e00d5ce]::-webkit-scrollbar {
+.file-selector[data-v-7bc917c0]::-webkit-scrollbar {
   height: 1px;
 }
-.file-selector[data-v-6e00d5ce]::-webkit-scrollbar-track {
+.file-selector[data-v-7bc917c0]::-webkit-scrollbar-track {
   background-color: var(--border);
 }
-.file-selector[data-v-6e00d5ce]::-webkit-scrollbar-thumb {
+.file-selector[data-v-7bc917c0]::-webkit-scrollbar-thumb {
   background-color: var(--color-branding);
 }
-.file-selector.has-import-map .add[data-v-6e00d5ce] {
+.file-selector.has-import-map .add[data-v-7bc917c0] {
   margin-right: 10px;
 }
-.file[data-v-6e00d5ce] {
+.file[data-v-7bc917c0] {
   display: inline-block;
   font-size: 13px;
   font-family: var(--font-code);
@@ -128,17 +128,17 @@
   color: var(--text-light);
   box-sizing: border-box;
 }
-.file.active[data-v-6e00d5ce] {
+.file.active[data-v-7bc917c0] {
   color: var(--color-branding);
   border-bottom: 3px solid var(--color-branding);
   cursor: text;
 }
-.file span[data-v-6e00d5ce] {
+.file span[data-v-7bc917c0] {
   display: inline-block;
   padding: 8px 10px 6px;
   line-height: 20px;
 }
-.file.pending input[data-v-6e00d5ce] {
+.file.pending input[data-v-7bc917c0] {
   width: 90px;
   height: 30px;
   line-height: 30px;
@@ -151,14 +151,14 @@
   font-family: var(--font-code);
   font-size: 12px;
 }
-.file .remove[data-v-6e00d5ce] {
+.file .remove[data-v-7bc917c0] {
   display: inline-block;
   vertical-align: middle;
   line-height: 12px;
   cursor: pointer;
   padding-left: 0;
 }
-.add[data-v-6e00d5ce] {
+.add[data-v-7bc917c0] {
   font-size: 18px;
   font-family: var(--font-code);
   color: #999;
@@ -167,13 +167,13 @@
   position: relative;
   top: -1px;
 }
-.add[data-v-6e00d5ce]:hover {
+.add[data-v-7bc917c0]:hover {
   color: var(--color-branding);
 }
-.icon[data-v-6e00d5ce] {
+.icon[data-v-7bc917c0] {
   margin-top: -1px;
 }
-.import-map-wrapper[data-v-6e00d5ce] {
+.import-map-wrapper[data-v-7bc917c0] {
   position: sticky;
   margin-left: auto;
   top: 0;
@@ -186,7 +186,7 @@
     rgba(255, 255, 255, 1) 25%
   );
 }
-.dark .import-map-wrapper[data-v-6e00d5ce] {
+.dark .import-map-wrapper[data-v-7bc917c0] {
   background: linear-gradient(
     90deg,
     rgba(26, 26, 26, 0) 0%,
@@ -746,7 +746,7 @@ span.CodeMirror-selectedtext {
   height: 100%;
 }
 
-.msg[data-v-e083996a] {
+.msg[data-v-3823ae29] {
   position: absolute;
   bottom: 0;
   left: 8px;
@@ -762,12 +762,12 @@ span.CodeMirror-selectedtext {
   display: flex;
   align-items: stretch;
 }
-pre[data-v-e083996a] {
+pre[data-v-3823ae29] {
   margin: 0;
   padding: 12px 20px;
-  overflow: scroll;
+  overflow: auto;
 }
-.dismiss[data-v-e083996a] {
+.dismiss[data-v-3823ae29] {
   position: absolute;
   top: 2px;
   right: 2px;
@@ -783,34 +783,34 @@ pre[data-v-e083996a] {
   color: #fff;
 }
 @media (max-width: 720px) {
-.dismiss[data-v-e083996a] {
+.dismiss[data-v-3823ae29] {
     top: -9px;
     right: -9px;
 }
-.msg[data-v-e083996a] {
+.msg[data-v-3823ae29] {
     bottom: 50px;
 }
 }
-.msg.err[data-v-e083996a] {
+.msg.err[data-v-3823ae29] {
   color: red;
   border-color: red;
   background-color: #ffd7d7;
 }
-.msg.warn[data-v-e083996a] {
+.msg.warn[data-v-3823ae29] {
   --color: rgb(105, 95, 27);
   color: var(--color);
   border-color: var(--color);
   background-color: rgb(247, 240, 205);
 }
-.msg.warn .dismiss[data-v-e083996a] {
+.msg.warn .dismiss[data-v-3823ae29] {
   background-color: var(--color);
 }
-.fade-enter-active[data-v-e083996a],
-.fade-leave-active[data-v-e083996a] {
+.fade-enter-active[data-v-3823ae29],
+.fade-leave-active[data-v-3823ae29] {
   transition: all 0.15s ease-out;
 }
-.fade-enter-from[data-v-e083996a],
-.fade-leave-to[data-v-e083996a] {
+.fade-enter-from[data-v-3823ae29],
+.fade-leave-to[data-v-3823ae29] {
   opacity: 0;
   transform: translate(0, 10px);
 }
@@ -821,31 +821,31 @@ pre[data-v-e083996a] {
   position: relative;
 }
 
-.iframe-container[data-v-fed14756],
-.iframe-container[data-v-fed14756] iframe {
+.iframe-container[data-v-1f12de15],
+.iframe-container[data-v-1f12de15] iframe {
   width: 100%;
   height: 100%;
   border: none;
   background-color: #fff;
 }
 
-.output-container[data-v-79065b94] {
+.output-container[data-v-56582219] {
   height: calc(100% - var(--header-height));
   overflow: hidden;
   position: relative;
 }
-.tab-buttons[data-v-79065b94] {
+.tab-buttons[data-v-56582219] {
   box-sizing: border-box;
   border-bottom: 1px solid var(--border);
   background-color: var(--bg);
   height: var(--header-height);
   overflow: hidden;
 }
-.tab-buttons button[data-v-79065b94] {
+.tab-buttons button[data-v-56582219] {
   padding: 0;
   box-sizing: border-box;
 }
-.tab-buttons span[data-v-79065b94] {
+.tab-buttons span[data-v-56582219] {
   font-size: 13px;
   font-family: var(--font-code);
   text-transform: uppercase;
@@ -854,12 +854,12 @@ pre[data-v-e083996a] {
   padding: 8px 16px 6px;
   line-height: 20px;
 }
-button.active[data-v-79065b94] {
+button.active[data-v-56582219] {
   color: var(--color-branding-dark);
   border-bottom: 3px solid var(--color-branding-dark);
 }
 
-.vue-repl[data-v-75fc3196] {
+.vue-repl[data-v-2f69a4f0] {
   --bg: #fff;
   --bg-soft: #f8f8f8;
   --border: #ddd;
@@ -876,7 +876,7 @@ button.active[data-v-79065b94] {
   overflow: hidden;
   background-color: var(--bg-soft);
 }
-.dark .vue-repl[data-v-75fc3196] {
+.dark .vue-repl[data-v-2f69a4f0] {
   --bg: #1a1a1a;
   --bg-soft: #242424;
   --border: #383838;
@@ -884,7 +884,7 @@ button.active[data-v-79065b94] {
   --color-branding: #42d392;
   --color-branding-dark: #89ddff;
 }
-[data-v-75fc3196] button {
+[data-v-2f69a4f0] button {
   border: none;
   outline: none;
   cursor: pointer;
diff --git a/node_modules/@vue/repl/dist/vue-repl.js b/node_modules/@vue/repl/dist/vue-repl.js
index b839875..b670841 100644
--- a/node_modules/@vue/repl/dist/vue-repl.js
+++ b/node_modules/@vue/repl/dist/vue-repl.js
@@ -1,36 +1,22 @@
-var __defProp = Object.defineProperty;
-var __defProps = Object.defineProperties;
-var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
-var __getOwnPropSymbols = Object.getOwnPropertySymbols;
-var __hasOwnProp = Object.prototype.hasOwnProperty;
-var __propIsEnum = Object.prototype.propertyIsEnumerable;
-var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
-var __spreadValues = (a, b) => {
-  for (var prop in b || (b = {}))
-    if (__hasOwnProp.call(b, prop))
-      __defNormalProp(a, prop, b[prop]);
-  if (__getOwnPropSymbols)
-    for (var prop of __getOwnPropSymbols(b)) {
-      if (__propIsEnum.call(b, prop))
-        __defNormalProp(a, prop, b[prop]);
-    }
-  return a;
-};
-var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
-import { defineComponent, computed, ref, inject, reactive, openBlock, createElementBlock, normalizeClass, unref, createElementVNode, normalizeStyle, renderSlot, withModifiers, toDisplayString, Fragment, renderList, createCommentVNode, withDirectives, withKeys, vModelText, pushScopeId, popScopeId, onMounted, watchEffect, watch, createBlock, Transition, withCtx, createVNode, onUnmounted, vShow, version, provide, toRef } from "vue";
-import * as defaultCompiler from "vue/compiler-sfc";
-import { MagicString, babelParse, extractIdentifiers, walkIdentifiers, isStaticProperty, isInDestructureAssignment, walk, shouldTransformRef, transformRef } from "vue/compiler-sfc";
-var SplitPane_vue_vue_type_style_index_0_scoped_true_lang = "";
+import { defineComponent, computed, ref, inject, reactive, openBlock, createElementBlock, normalizeClass, unref, createElementVNode, normalizeStyle, renderSlot, withModifiers, toDisplayString, Fragment, renderList, createCommentVNode, withDirectives, withKeys, vModelText, pushScopeId, popScopeId, onMounted, watchEffect, watch, createBlock, Transition, withCtx, createVNode, onUnmounted, vShow, version, provide, toRef } from 'vue';
+import * as defaultCompiler from 'vue/compiler-sfc';
+import { MagicString, babelParse, extractIdentifiers, walkIdentifiers, isStaticProperty, isInDestructureAssignment, walk, shouldTransformRef, transformRef } from 'vue/compiler-sfc';
+
+var SplitPane_vue_vue_type_style_index_0_scoped_true_lang = '';
+
 var _export_sfc = (sfc, props) => {
+  const target = sfc.__vccOpts || sfc;
   for (const [key, val] of props) {
-    sfc[key] = val;
+    target[key] = val;
   }
-  return sfc;
+  return target;
 };
+
 const _hoisted_1$4 = ["onMousedown"];
 const _sfc_main$7 = /* @__PURE__ */ defineComponent({
+  name: "SplitPane",
   props: {
-    layout: { type: String, required: false }
+    layout: null
   },
   setup(__props) {
     const props = __props;
@@ -38,40 +24,38 @@ const _sfc_main$7 = /* @__PURE__ */ defineComponent({
     const container = ref();
     const store = inject("store");
     const showOutput = ref(store.initialShowOutput);
-    const state2 = reactive({
+    const state = reactive({
       dragging: false,
       split: 50
     });
     const boundSplit = computed(() => {
-      const { split } = state2;
+      const { split } = state;
       return split < 20 ? 20 : split > 80 ? 80 : split;
     });
     let startPosition = 0;
     let startSplit = 0;
     function dragStart(e) {
-      state2.dragging = true;
+      state.dragging = true;
       startPosition = isVertical.value ? e.pageY : e.pageX;
       startSplit = boundSplit.value;
     }
     function dragMove(e) {
-      if (state2.dragging) {
+      if (state.dragging) {
         const position = isVertical.value ? e.pageY : e.pageX;
         const totalSize = isVertical.value ? container.value.offsetHeight : container.value.offsetWidth;
         const dp = position - startPosition;
-        state2.split = startSplit + ~~(dp / totalSize * 100);
+        state.split = startSplit + ~~(dp / totalSize * 100);
       }
     }
     function dragEnd() {
-      state2.dragging = false;
+      state.dragging = false;
     }
     return (_ctx, _cache) => {
       return openBlock(), createElementBlock("div", {
-        ref: (_value, _refs) => {
-          _refs["container"] = _value;
-          container.value = _value;
-        },
+        ref_key: "container",
+        ref: container,
         class: normalizeClass(["split-pane", {
-          dragging: unref(state2).dragging,
+          dragging: state.dragging,
           "show-output": showOutput.value,
           vertical: unref(isVertical)
         }]),
@@ -104,8 +88,10 @@ const _sfc_main$7 = /* @__PURE__ */ defineComponent({
   }
 });
 var SplitPane = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-427f8a98"]]);
-var FileSelector_vue_vue_type_style_index_0_scoped_true_lang = "";
-const _withScopeId = (n) => (pushScopeId("data-v-6e00d5ce"), n = n(), popScopeId(), n);
+
+var FileSelector_vue_vue_type_style_index_0_scoped_true_lang = '';
+
+const _withScopeId = (n) => (pushScopeId("data-v-7bc917c0"), n = n(), popScopeId(), n);
 const _hoisted_1$3 = ["onClick"];
 const _hoisted_2$1 = { class: "label" };
 const _hoisted_3$1 = ["onClick"];
@@ -147,6 +133,7 @@ const _hoisted_10 = [
   _hoisted_9
 ];
 const _sfc_main$6 = /* @__PURE__ */ defineComponent({
+  name: "FileSelector",
   setup(__props) {
     const store = inject("store");
     const pending = ref(false);
@@ -155,6 +142,22 @@ const _sfc_main$6 = /* @__PURE__ */ defineComponent({
     const showImportMap = inject("import-map");
     const files = computed(() => Object.entries(store.state.files).filter(([name, file]) => name !== importMapFile && !file.hidden).map(([name]) => name));
     function startAddFile() {
+      let i = 0;
+      let name = `Comp.vue`;
+      while (true) {
+        let hasConflict = false;
+        for (const file in store.state.files) {
+          if (file === name) {
+            hasConflict = true;
+            name = `Comp${++i}.vue`;
+            break;
+          }
+        }
+        if (!hasConflict) {
+          break;
+        }
+      }
+      pendingFilename.value = name;
       pending.value = true;
     }
     function cancelAddFile() {
@@ -164,6 +167,8 @@ const _sfc_main$6 = /* @__PURE__ */ defineComponent({
       el.focus();
     }
     function doneAddFile() {
+      if (!pending.value)
+        return;
       const filename = pendingFilename.value;
       if (!/\.(vue|js|ts|css)$/.test(filename)) {
         store.state.errors = [
@@ -178,7 +183,6 @@ const _sfc_main$6 = /* @__PURE__ */ defineComponent({
       store.state.errors = [];
       cancelAddFile();
       store.addFile(filename);
-      pendingFilename.value = "Comp.vue";
     }
     const fileSel = ref(null);
     function horizontalScroll(e) {
@@ -194,10 +198,8 @@ const _sfc_main$6 = /* @__PURE__ */ defineComponent({
       return openBlock(), createElementBlock("div", {
         class: normalizeClass(["file-selector", { "has-import-map": unref(showImportMap) }]),
         onWheel: horizontalScroll,
-        ref: (_value, _refs) => {
-          _refs["fileSel"] = _value;
-          fileSel.value = _value;
-        }
+        ref_key: "fileSel",
+        ref: fileSel
       }, [
         (openBlock(true), createElementBlock(Fragment, null, renderList(unref(files), (file, i) => {
           return openBlock(), createElementBlock("div", {
@@ -240,7 +242,858 @@ const _sfc_main$6 = /* @__PURE__ */ defineComponent({
     };
   }
 });
-var FileSelector = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-6e00d5ce"]]);
+var FileSelector = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-7bc917c0"]]);
+
+// DEFLATE is a complex format; to read this code, you should probably check the RFC first:
+
+// aliases for shorter compressed code (most minifers don't do this)
+var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
+// fixed length extra bits
+var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
+// fixed distance extra bits
+// see fleb note
+var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
+// code length index map
+var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
+// get base, reverse index map from extra bits
+var freb = function (eb, start) {
+    var b = new u16(31);
+    for (var i = 0; i < 31; ++i) {
+        b[i] = start += 1 << eb[i - 1];
+    }
+    // numbers here are at max 18 bits
+    var r = new u32(b[30]);
+    for (var i = 1; i < 30; ++i) {
+        for (var j = b[i]; j < b[i + 1]; ++j) {
+            r[j] = ((j - b[i]) << 5) | i;
+        }
+    }
+    return [b, r];
+};
+var _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];
+// we can ignore the fact that the other numbers are wrong; they never happen anyway
+fl[28] = 258, revfl[258] = 28;
+var _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];
+// map of value to reverse (assuming 16 bits)
+var rev = new u16(32768);
+for (var i = 0; i < 32768; ++i) {
+    // reverse table algorithm from SO
+    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);
+    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);
+    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);
+    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;
+}
+// create huffman tree from u8 "map": index -> code length for code index
+// mb (max bits) must be at most 15
+// TODO: optimize/split up?
+var hMap = (function (cd, mb, r) {
+    var s = cd.length;
+    // index
+    var i = 0;
+    // u16 "map": index -> # of codes with bit length = index
+    var l = new u16(mb);
+    // length of cd must be 288 (total # of codes)
+    for (; i < s; ++i) {
+        if (cd[i])
+            ++l[cd[i] - 1];
+    }
+    // u16 "map": index -> minimum code for bit length = index
+    var le = new u16(mb);
+    for (i = 0; i < mb; ++i) {
+        le[i] = (le[i - 1] + l[i - 1]) << 1;
+    }
+    var co;
+    if (r) {
+        // u16 "map": index -> number of actual bits, symbol for code
+        co = new u16(1 << mb);
+        // bits to remove for reverser
+        var rvb = 15 - mb;
+        for (i = 0; i < s; ++i) {
+            // ignore 0 lengths
+            if (cd[i]) {
+                // num encoding both symbol and bits read
+                var sv = (i << 4) | cd[i];
+                // free bits
+                var r_1 = mb - cd[i];
+                // start value
+                var v = le[cd[i] - 1]++ << r_1;
+                // m is end value
+                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
+                    // every 16 bit value starting with the code yields the same result
+                    co[rev[v] >>> rvb] = sv;
+                }
+            }
+        }
+    }
+    else {
+        co = new u16(s);
+        for (i = 0; i < s; ++i) {
+            if (cd[i]) {
+                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);
+            }
+        }
+    }
+    return co;
+});
+// fixed length tree
+var flt = new u8(288);
+for (var i = 0; i < 144; ++i)
+    flt[i] = 8;
+for (var i = 144; i < 256; ++i)
+    flt[i] = 9;
+for (var i = 256; i < 280; ++i)
+    flt[i] = 7;
+for (var i = 280; i < 288; ++i)
+    flt[i] = 8;
+// fixed distance tree
+var fdt = new u8(32);
+for (var i = 0; i < 32; ++i)
+    fdt[i] = 5;
+// fixed length map
+var flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);
+// fixed distance map
+var fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
+// find max of array
+var max = function (a) {
+    var m = a[0];
+    for (var i = 1; i < a.length; ++i) {
+        if (a[i] > m)
+            m = a[i];
+    }
+    return m;
+};
+// read d, starting at bit p and mask with m
+var bits = function (d, p, m) {
+    var o = (p / 8) | 0;
+    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;
+};
+// read d, starting at bit p continuing for at least 16 bits
+var bits16 = function (d, p) {
+    var o = (p / 8) | 0;
+    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));
+};
+// get end of byte
+var shft = function (p) { return ((p + 7) / 8) | 0; };
+// typed array slice - allows garbage collector to free original reference,
+// while being more compatible than .slice
+var slc = function (v, s, e) {
+    if (s == null || s < 0)
+        s = 0;
+    if (e == null || e > v.length)
+        e = v.length;
+    // can't use .constructor in case user-supplied
+    var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);
+    n.set(v.subarray(s, e));
+    return n;
+};
+// error codes
+var ec = [
+    'unexpected EOF',
+    'invalid block type',
+    'invalid length/literal',
+    'invalid distance',
+    'stream finished',
+    'no stream handler',
+    ,
+    'no callback',
+    'invalid UTF-8 data',
+    'extra field too long',
+    'date not in range 1980-2099',
+    'filename too long',
+    'stream finishing',
+    'invalid zip data'
+    // determined by unknown compression method
+];
+var err = function (ind, msg, nt) {
+    var e = new Error(msg || ec[ind]);
+    e.code = ind;
+    if (Error.captureStackTrace)
+        Error.captureStackTrace(e, err);
+    if (!nt)
+        throw e;
+    return e;
+};
+// expands raw DEFLATE data
+var inflt = function (dat, buf, st) {
+    // source length
+    var sl = dat.length;
+    if (!sl || (st && st.f && !st.l))
+        return buf || new u8(0);
+    // have to estimate size
+    var noBuf = !buf || st;
+    // no state
+    var noSt = !st || st.i;
+    if (!st)
+        st = {};
+    // Assumes roughly 33% compression ratio average
+    if (!buf)
+        buf = new u8(sl * 3);
+    // ensure buffer can fit at least l elements
+    var cbuf = function (l) {
+        var bl = buf.length;
+        // need to increase size to fit
+        if (l > bl) {
+            // Double or set to necessary, whichever is greater
+            var nbuf = new u8(Math.max(bl * 2, l));
+            nbuf.set(buf);
+            buf = nbuf;
+        }
+    };
+    //  last chunk         bitpos           bytes
+    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
+    // total bits
+    var tbts = sl * 8;
+    do {
+        if (!lm) {
+            // BFINAL - this is only 1 when last chunk is next
+            final = bits(dat, pos, 1);
+            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
+            var type = bits(dat, pos + 1, 3);
+            pos += 3;
+            if (!type) {
+                // go to end of byte boundary
+                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;
+                if (t > sl) {
+                    if (noSt)
+                        err(0);
+                    break;
+                }
+                // ensure size
+                if (noBuf)
+                    cbuf(bt + l);
+                // Copy over uncompressed data
+                buf.set(dat.subarray(s, t), bt);
+                // Get new bitpos, update byte count
+                st.b = bt += l, st.p = pos = t * 8, st.f = final;
+                continue;
+            }
+            else if (type == 1)
+                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
+            else if (type == 2) {
+                //  literal                            lengths
+                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
+                var tl = hLit + bits(dat, pos + 5, 31) + 1;
+                pos += 14;
+                // length+distance tree
+                var ldt = new u8(tl);
+                // code length tree
+                var clt = new u8(19);
+                for (var i = 0; i < hcLen; ++i) {
+                    // use index map to get real code
+                    clt[clim[i]] = bits(dat, pos + i * 3, 7);
+                }
+                pos += hcLen * 3;
+                // code lengths bits
+                var clb = max(clt), clbmsk = (1 << clb) - 1;
+                // code lengths map
+                var clm = hMap(clt, clb, 1);
+                for (var i = 0; i < tl;) {
+                    var r = clm[bits(dat, pos, clbmsk)];
+                    // bits read
+                    pos += r & 15;
+                    // symbol
+                    var s = r >>> 4;
+                    // code length to copy
+                    if (s < 16) {
+                        ldt[i++] = s;
+                    }
+                    else {
+                        //  copy   count
+                        var c = 0, n = 0;
+                        if (s == 16)
+                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
+                        else if (s == 17)
+                            n = 3 + bits(dat, pos, 7), pos += 3;
+                        else if (s == 18)
+                            n = 11 + bits(dat, pos, 127), pos += 7;
+                        while (n--)
+                            ldt[i++] = c;
+                    }
+                }
+                //    length tree                 distance tree
+                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
+                // max length bits
+                lbt = max(lt);
+                // max dist bits
+                dbt = max(dt);
+                lm = hMap(lt, lbt, 1);
+                dm = hMap(dt, dbt, 1);
+            }
+            else
+                err(1);
+            if (pos > tbts) {
+                if (noSt)
+                    err(0);
+                break;
+            }
+        }
+        // Make sure the buffer can hold this + the largest possible addition
+        // Maximum chunk size (practically, theoretically infinite) is 2^17;
+        if (noBuf)
+            cbuf(bt + 131072);
+        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
+        var lpos = pos;
+        for (;; lpos = pos) {
+            // bits read, code
+            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
+            pos += c & 15;
+            if (pos > tbts) {
+                if (noSt)
+                    err(0);
+                break;
+            }
+            if (!c)
+                err(2);
+            if (sym < 256)
+                buf[bt++] = sym;
+            else if (sym == 256) {
+                lpos = pos, lm = null;
+                break;
+            }
+            else {
+                var add = sym - 254;
+                // no extra bits needed if less
+                if (sym > 264) {
+                    // index
+                    var i = sym - 257, b = fleb[i];
+                    add = bits(dat, pos, (1 << b) - 1) + fl[i];
+                    pos += b;
+                }
+                // dist
+                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
+                if (!d)
+                    err(3);
+                pos += d & 15;
+                var dt = fd[dsym];
+                if (dsym > 3) {
+                    var b = fdeb[dsym];
+                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;
+                }
+                if (pos > tbts) {
+                    if (noSt)
+                        err(0);
+                    break;
+                }
+                if (noBuf)
+                    cbuf(bt + 131072);
+                var end = bt + add;
+                for (; bt < end; bt += 4) {
+                    buf[bt] = buf[bt - dt];
+                    buf[bt + 1] = buf[bt + 1 - dt];
+                    buf[bt + 2] = buf[bt + 2 - dt];
+                    buf[bt + 3] = buf[bt + 3 - dt];
+                }
+                bt = end;
+            }
+        }
+        st.l = lm, st.p = lpos, st.b = bt, st.f = final;
+        if (lm)
+            final = 1, st.m = lbt, st.d = dm, st.n = dbt;
+    } while (!final);
+    return bt == buf.length ? buf : slc(buf, 0, bt);
+};
+// starting at p, write the minimum number of bits that can hold v to d
+var wbits = function (d, p, v) {
+    v <<= p & 7;
+    var o = (p / 8) | 0;
+    d[o] |= v;
+    d[o + 1] |= v >>> 8;
+};
+// starting at p, write the minimum number of bits (>8) that can hold v to d
+var wbits16 = function (d, p, v) {
+    v <<= p & 7;
+    var o = (p / 8) | 0;
+    d[o] |= v;
+    d[o + 1] |= v >>> 8;
+    d[o + 2] |= v >>> 16;
+};
+// creates code lengths from a frequency table
+var hTree = function (d, mb) {
+    // Need extra info to make a tree
+    var t = [];
+    for (var i = 0; i < d.length; ++i) {
+        if (d[i])
+            t.push({ s: i, f: d[i] });
+    }
+    var s = t.length;
+    var t2 = t.slice();
+    if (!s)
+        return [et, 0];
+    if (s == 1) {
+        var v = new u8(t[0].s + 1);
+        v[t[0].s] = 1;
+        return [v, 1];
+    }
+    t.sort(function (a, b) { return a.f - b.f; });
+    // after i2 reaches last ind, will be stopped
+    // freq must be greater than largest possible number of symbols
+    t.push({ s: -1, f: 25001 });
+    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
+    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };
+    // efficient algorithm from UZIP.js
+    // i0 is lookbehind, i2 is lookahead - after processing two low-freq
+    // symbols that combined have high freq, will start processing i2 (high-freq,
+    // non-composite) symbols instead
+    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
+    while (i1 != s - 1) {
+        l = t[t[i0].f < t[i2].f ? i0++ : i2++];
+        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
+        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };
+    }
+    var maxSym = t2[0].s;
+    for (var i = 1; i < s; ++i) {
+        if (t2[i].s > maxSym)
+            maxSym = t2[i].s;
+    }
+    // code lengths
+    var tr = new u16(maxSym + 1);
+    // max bits in tree
+    var mbt = ln(t[i1 - 1], tr, 0);
+    if (mbt > mb) {
+        // more algorithms from UZIP.js
+        // TODO: find out how this code works (debt)
+        //  ind    debt
+        var i = 0, dt = 0;
+        //    left            cost
+        var lft = mbt - mb, cst = 1 << lft;
+        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });
+        for (; i < s; ++i) {
+            var i2_1 = t2[i].s;
+            if (tr[i2_1] > mb) {
+                dt += cst - (1 << (mbt - tr[i2_1]));
+                tr[i2_1] = mb;
+            }
+            else
+                break;
+        }
+        dt >>>= lft;
+        while (dt > 0) {
+            var i2_2 = t2[i].s;
+            if (tr[i2_2] < mb)
+                dt -= 1 << (mb - tr[i2_2]++ - 1);
+            else
+                ++i;
+        }
+        for (; i >= 0 && dt; --i) {
+            var i2_3 = t2[i].s;
+            if (tr[i2_3] == mb) {
+                --tr[i2_3];
+                ++dt;
+            }
+        }
+        mbt = mb;
+    }
+    return [new u8(tr), mbt];
+};
+// get the max length and assign length codes
+var ln = function (n, l, d) {
+    return n.s == -1
+        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))
+        : (l[n.s] = d);
+};
+// length codes generation
+var lc = function (c) {
+    var s = c.length;
+    // Note that the semicolon was intentional
+    while (s && !c[--s])
+        ;
+    var cl = new u16(++s);
+    //  ind      num         streak
+    var cli = 0, cln = c[0], cls = 1;
+    var w = function (v) { cl[cli++] = v; };
+    for (var i = 1; i <= s; ++i) {
+        if (c[i] == cln && i != s)
+            ++cls;
+        else {
+            if (!cln && cls > 2) {
+                for (; cls > 138; cls -= 138)
+                    w(32754);
+                if (cls > 2) {
+                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);
+                    cls = 0;
+                }
+            }
+            else if (cls > 3) {
+                w(cln), --cls;
+                for (; cls > 6; cls -= 6)
+                    w(8304);
+                if (cls > 2)
+                    w(((cls - 3) << 5) | 8208), cls = 0;
+            }
+            while (cls--)
+                w(cln);
+            cls = 1;
+            cln = c[i];
+        }
+    }
+    return [cl.subarray(0, cli), s];
+};
+// calculate the length of output from tree, code lengths
+var clen = function (cf, cl) {
+    var l = 0;
+    for (var i = 0; i < cl.length; ++i)
+        l += cf[i] * cl[i];
+    return l;
+};
+// writes a fixed block
+// returns the new bit pos
+var wfblk = function (out, pos, dat) {
+    // no need to write 00 as type: TypedArray defaults to 0
+    var s = dat.length;
+    var o = shft(pos + 2);
+    out[o] = s & 255;
+    out[o + 1] = s >>> 8;
+    out[o + 2] = out[o] ^ 255;
+    out[o + 3] = out[o + 1] ^ 255;
+    for (var i = 0; i < s; ++i)
+        out[o + i + 4] = dat[i];
+    return (o + 4 + s) * 8;
+};
+// writes a block
+var wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
+    wbits(out, p++, final);
+    ++lf[256];
+    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];
+    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];
+    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
+    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
+    var lcfreq = new u16(19);
+    for (var i = 0; i < lclt.length; ++i)
+        lcfreq[lclt[i] & 31]++;
+    for (var i = 0; i < lcdt.length; ++i)
+        lcfreq[lcdt[i] & 31]++;
+    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
+    var nlcc = 19;
+    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
+        ;
+    var flen = (bl + 5) << 3;
+    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
+    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
+    if (flen <= ftlen && flen <= dtlen)
+        return wfblk(out, p, dat.subarray(bs, bs + bl));
+    var lm, ll, dm, dl;
+    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
+    if (dtlen < ftlen) {
+        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
+        var llm = hMap(lct, mlcb, 0);
+        wbits(out, p, nlc - 257);
+        wbits(out, p + 5, ndc - 1);
+        wbits(out, p + 10, nlcc - 4);
+        p += 14;
+        for (var i = 0; i < nlcc; ++i)
+            wbits(out, p + 3 * i, lct[clim[i]]);
+        p += 3 * nlcc;
+        var lcts = [lclt, lcdt];
+        for (var it = 0; it < 2; ++it) {
+            var clct = lcts[it];
+            for (var i = 0; i < clct.length; ++i) {
+                var len = clct[i] & 31;
+                wbits(out, p, llm[len]), p += lct[len];
+                if (len > 15)
+                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;
+            }
+        }
+    }
+    else {
+        lm = flm, ll = flt, dm = fdm, dl = fdt;
+    }
+    for (var i = 0; i < li; ++i) {
+        if (syms[i] > 255) {
+            var len = (syms[i] >>> 18) & 31;
+            wbits16(out, p, lm[len + 257]), p += ll[len + 257];
+            if (len > 7)
+                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];
+            var dst = syms[i] & 31;
+            wbits16(out, p, dm[dst]), p += dl[dst];
+            if (dst > 3)
+                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];
+        }
+        else {
+            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];
+        }
+    }
+    wbits16(out, p, lm[256]);
+    return p + ll[256];
+};
+// deflate options (nice << 13) | chain
+var deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
+// empty
+var et = /*#__PURE__*/ new u8(0);
+// compresses data into a raw DEFLATE buffer
+var dflt = function (dat, lvl, plvl, pre, post, lst) {
+    var s = dat.length;
+    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);
+    // writing to this writes to the output buffer
+    var w = o.subarray(pre, o.length - post);
+    var pos = 0;
+    if (!lvl || s < 8) {
+        for (var i = 0; i <= s; i += 65535) {
+            // end
+            var e = i + 65535;
+            if (e >= s) {
+                // write final block
+                w[pos >> 3] = lst;
+            }
+            pos = wfblk(w, pos + 1, dat.subarray(i, e));
+        }
+    }
+    else {
+        var opt = deo[lvl - 1];
+        var n = opt >>> 13, c = opt & 8191;
+        var msk_1 = (1 << plvl) - 1;
+        //    prev 2-byte val map    curr 2-byte val map
+        var prev = new u16(32768), head = new u16(msk_1 + 1);
+        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
+        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };
+        // 24576 is an arbitrary number of maximum symbols per block
+        // 424 buffer for last block
+        var syms = new u32(25000);
+        // length/literal freq   distance freq
+        var lf = new u16(288), df = new u16(32);
+        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos
+        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;
+        for (; i < s; ++i) {
+            // hash value
+            // deopt when i > s - 3 - at end, deopt acceptable
+            var hv = hsh(i);
+            // index mod 32768    previous index mod
+            var imod = i & 32767, pimod = head[hv];
+            prev[imod] = pimod;
+            head[hv] = imod;
+            // We always should modify head and prev, but only add symbols if
+            // this data is not yet processed ("wait" for wait index)
+            if (wi <= i) {
+                // bytes remaining
+                var rem = s - i;
+                if ((lc_1 > 7000 || li > 24576) && rem > 423) {
+                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
+                    li = lc_1 = eb = 0, bs = i;
+                    for (var j = 0; j < 286; ++j)
+                        lf[j] = 0;
+                    for (var j = 0; j < 30; ++j)
+                        df[j] = 0;
+                }
+                //  len    dist   chain
+                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;
+                if (rem > 2 && hv == hsh(i - dif)) {
+                    var maxn = Math.min(n, rem) - 1;
+                    var maxd = Math.min(32767, i);
+                    // max possible length
+                    // not capped at dif because decompressors implement "rolling" index population
+                    var ml = Math.min(258, rem);
+                    while (dif <= maxd && --ch_1 && imod != pimod) {
+                        if (dat[i + l] == dat[i + l - dif]) {
+                            var nl = 0;
+                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
+                                ;
+                            if (nl > l) {
+                                l = nl, d = dif;
+                                // break out early when we reach "nice" (we are satisfied enough)
+                                if (nl > maxn)
+                                    break;
+                                // now, find the rarest 2-byte sequence within this
+                                // length of literals and search for that instead.
+                                // Much faster than just using the start
+                                var mmd = Math.min(dif, nl - 2);
+                                var md = 0;
+                                for (var j = 0; j < mmd; ++j) {
+                                    var ti = (i - dif + j + 32768) & 32767;
+                                    var pti = prev[ti];
+                                    var cd = (ti - pti + 32768) & 32767;
+                                    if (cd > md)
+                                        md = cd, pimod = ti;
+                                }
+                            }
+                        }
+                        // check the previous match
+                        imod = pimod, pimod = prev[imod];
+                        dif += (imod - pimod + 32768) & 32767;
+                    }
+                }
+                // d will be nonzero only when a match was found
+                if (d) {
+                    // store both dist and len data in one Uint32
+                    // Make sure this is recognized as a len/dist with 28th bit (2^28)
+                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];
+                    var lin = revfl[l] & 31, din = revfd[d] & 31;
+                    eb += fleb[lin] + fdeb[din];
+                    ++lf[257 + lin];
+                    ++df[din];
+                    wi = i + l;
+                    ++lc_1;
+                }
+                else {
+                    syms[li++] = dat[i];
+                    ++lf[dat[i]];
+                }
+            }
+        }
+        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
+        // this is the easiest way to avoid needing to maintain state
+        if (!lst && pos & 7)
+            pos = wfblk(w, pos + 1, et);
+    }
+    return slc(o, 0, pre + shft(pos) + post);
+};
+// Alder32
+var adler = function () {
+    var a = 1, b = 0;
+    return {
+        p: function (d) {
+            // closures have awful performance
+            var n = a, m = b;
+            var l = d.length | 0;
+            for (var i = 0; i != l;) {
+                var e = Math.min(i + 2655, l);
+                for (; i < e; ++i)
+                    m += n += d[i];
+                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
+            }
+            a = n, b = m;
+        },
+        d: function () {
+            a %= 65521, b %= 65521;
+            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);
+        }
+    };
+};
+// deflate with opts
+var dopt = function (dat, opt, pre, post, st) {
+    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);
+};
+// write bytes
+var wbytes = function (d, b, v) {
+    for (; v; ++b)
+        d[b] = v, v >>>= 8;
+};
+// zlib header
+var zlh = function (c, o) {
+    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
+    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);
+};
+// zlib valid
+var zlv = function (d) {
+    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))
+        err(6, 'invalid zlib data');
+    if (d[1] & 32)
+        err(6, 'invalid zlib data: preset dictionaries not supported');
+};
+/**
+ * Compress data with Zlib
+ * @param data The data to compress
+ * @param opts The compression options
+ * @returns The zlib-compressed version of the data
+ */
+function zlibSync(data, opts) {
+    if (!opts)
+        opts = {};
+    var a = adler();
+    a.p(data);
+    var d = dopt(data, opts, 2, 4);
+    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
+}
+/**
+ * Expands Zlib data
+ * @param data The data to decompress
+ * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
+ * @returns The decompressed version of the data
+ */
+function unzlibSync(data, out) {
+    return inflt((zlv(data), data.subarray(2, -4)), out);
+}
+// text encoder
+var te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();
+// text decoder
+var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
+// text decoder stream
+var tds = 0;
+try {
+    td.decode(et, { stream: true });
+    tds = 1;
+}
+catch (e) { }
+// decode UTF8
+var dutf8 = function (d) {
+    for (var r = '', i = 0;;) {
+        var c = d[i++];
+        var eb = (c > 127) + (c > 223) + (c > 239);
+        if (i + eb > d.length)
+            return [r, slc(d, i - 1)];
+        if (!eb)
+            r += String.fromCharCode(c);
+        else if (eb == 3) {
+            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,
+                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));
+        }
+        else if (eb & 1)
+            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));
+        else
+            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));
+    }
+};
+/**
+ * Converts a string into a Uint8Array for use with compression/decompression methods
+ * @param str The string to encode
+ * @param latin1 Whether or not to interpret the data as Latin-1. This should
+ *               not need to be true unless decoding a binary string.
+ * @returns The string encoded in UTF-8/Latin-1 binary
+ */
+function strToU8(str, latin1) {
+    if (latin1) {
+        var ar_1 = new u8(str.length);
+        for (var i = 0; i < str.length; ++i)
+            ar_1[i] = str.charCodeAt(i);
+        return ar_1;
+    }
+    if (te)
+        return te.encode(str);
+    var l = str.length;
+    var ar = new u8(str.length + (str.length >> 1));
+    var ai = 0;
+    var w = function (v) { ar[ai++] = v; };
+    for (var i = 0; i < l; ++i) {
+        if (ai + 5 > ar.length) {
+            var n = new u8(ai + 8 + ((l - i) << 1));
+            n.set(ar);
+            ar = n;
+        }
+        var c = str.charCodeAt(i);
+        if (c < 128 || latin1)
+            w(c);
+        else if (c < 2048)
+            w(192 | (c >> 6)), w(128 | (c & 63));
+        else if (c > 55295 && c < 57344)
+            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),
+                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));
+        else
+            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));
+    }
+    return slc(ar, 0, ai);
+}
+/**
+ * Converts a Uint8Array to a string
+ * @param dat The data to decode to string
+ * @param latin1 Whether or not to interpret the data as Latin-1. This should
+ *               not need to be true unless encoding to binary string.
+ * @returns The original UTF-8/Latin-1 string
+ */
+function strFromU8(dat, latin1) {
+    if (latin1) {
+        var r = '';
+        for (var i = 0; i < dat.length; i += 16384)
+            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
+        return r;
+    }
+    else if (td)
+        return td.decode(dat);
+    else {
+        var _a = dutf8(dat), out = _a[0], ext = _a[1];
+        if (ext.length)
+            err(8);
+        return out;
+    }
+}
+
 function debounce(fn, n = 100) {
   let handle;
   return (...args) => {
@@ -252,15448 +1105,13581 @@ function debounce(fn, n = 100) {
   };
 }
 function utoa(data) {
-  return btoa(unescape(encodeURIComponent(data)));
+  const buffer = strToU8(data);
+  const zipped = zlibSync(buffer, { level: 9 });
+  const binary = strFromU8(zipped, true);
+  return btoa(binary);
 }
 function atou(base64) {
-  return decodeURIComponent(escape(atob(base64)));
-}
-var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
-var codemirror$1 = { exports: {} };
-(function(module, exports) {
-  (function(global2, factory) {
-    module.exports = factory();
-  })(commonjsGlobal, function() {
-    var userAgent = navigator.userAgent;
-    var platform = navigator.platform;
-    var gecko = /gecko\/\d/i.test(userAgent);
-    var ie_upto10 = /MSIE \d/.test(userAgent);
-    var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
-    var edge = /Edge\/(\d+)/.exec(userAgent);
-    var ie = ie_upto10 || ie_11up || edge;
-    var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
-    var webkit = !edge && /WebKit\//.test(userAgent);
-    var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
-    var chrome = !edge && /Chrome\//.test(userAgent);
-    var presto = /Opera\//.test(userAgent);
-    var safari = /Apple Computer/.test(navigator.vendor);
-    var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
-    var phantom = /PhantomJS/.test(userAgent);
-    var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
-    var android = /Android/.test(userAgent);
-    var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
-    var mac = ios || /Mac/.test(platform);
-    var chromeOS = /\bCrOS\b/.test(userAgent);
-    var windows = /win/i.test(platform);
-    var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
-    if (presto_version) {
-      presto_version = Number(presto_version[1]);
-    }
-    if (presto_version && presto_version >= 15) {
-      presto = false;
-      webkit = true;
-    }
-    var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
-    var captureRightClick = gecko || ie && ie_version >= 9;
-    function classTest(cls) {
-      return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
-    }
-    var rmClass = function(node, cls) {
-      var current = node.className;
-      var match2 = classTest(cls).exec(current);
-      if (match2) {
-        var after = current.slice(match2.index + match2[0].length);
-        node.className = current.slice(0, match2.index) + (after ? match2[1] + after : "");
-      }
-    };
-    function removeChildren(e) {
-      for (var count = e.childNodes.length; count > 0; --count) {
-        e.removeChild(e.firstChild);
-      }
-      return e;
+  const binary = atob(base64);
+  if (binary.startsWith("x\xDA")) {
+    const buffer = strToU8(binary, true);
+    const unzipped = unzlibSync(buffer);
+    return strFromU8(unzipped);
+  }
+  return decodeURIComponent(escape(binary));
+}
+
+var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
+
+var codemirror$1 = {exports: {}};
+
+(function (module, exports) {
+// CodeMirror, copyright (c) by Marijn Haverbeke and others
+// Distributed under an MIT license: https://codemirror.net/LICENSE
+
+// This is CodeMirror (https://codemirror.net), a code editor
+// implemented in JavaScript on top of the browser's DOM.
+//
+// You can find some technical background for some of the code below
+// at http://marijnhaverbeke.nl/blog/#cm-internals .
+
+(function (global, factory) {
+  module.exports = factory() ;
+}(commonjsGlobal, (function () {
+  // Kludges for bugs and behavior differences that can't be feature
+  // detected are enabled based on userAgent etc sniffing.
+  var userAgent = navigator.userAgent;
+  var platform = navigator.platform;
+
+  var gecko = /gecko\/\d/i.test(userAgent);
+  var ie_upto10 = /MSIE \d/.test(userAgent);
+  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
+  var edge = /Edge\/(\d+)/.exec(userAgent);
+  var ie = ie_upto10 || ie_11up || edge;
+  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
+  var webkit = !edge && /WebKit\//.test(userAgent);
+  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
+  var chrome = !edge && /Chrome\//.test(userAgent);
+  var presto = /Opera\//.test(userAgent);
+  var safari = /Apple Computer/.test(navigator.vendor);
+  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
+  var phantom = /PhantomJS/.test(userAgent);
+
+  var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
+  var android = /Android/.test(userAgent);
+  // This is woefully incomplete. Suggestions for alternative methods welcome.
+  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
+  var mac = ios || /Mac/.test(platform);
+  var chromeOS = /\bCrOS\b/.test(userAgent);
+  var windows = /win/i.test(platform);
+
+  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
+  if (presto_version) { presto_version = Number(presto_version[1]); }
+  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
+  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
+  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
+  var captureRightClick = gecko || (ie && ie_version >= 9);
+
+  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }
+
+  var rmClass = function(node, cls) {
+    var current = node.className;
+    var match = classTest(cls).exec(current);
+    if (match) {
+      var after = current.slice(match.index + match[0].length);
+      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
     }
-    function removeChildrenAndAdd(parent, e) {
-      return removeChildren(parent).appendChild(e);
+  };
+
+  function removeChildren(e) {
+    for (var count = e.childNodes.length; count > 0; --count)
+      { e.removeChild(e.firstChild); }
+    return e
+  }
+
+  function removeChildrenAndAdd(parent, e) {
+    return removeChildren(parent).appendChild(e)
+  }
+
+  function elt(tag, content, className, style) {
+    var e = document.createElement(tag);
+    if (className) { e.className = className; }
+    if (style) { e.style.cssText = style; }
+    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
+    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
+    return e
+  }
+  // wrapper for elt, which removes the elt from the accessibility tree
+  function eltP(tag, content, className, style) {
+    var e = elt(tag, content, className, style);
+    e.setAttribute("role", "presentation");
+    return e
+  }
+
+  var range;
+  if (document.createRange) { range = function(node, start, end, endNode) {
+    var r = document.createRange();
+    r.setEnd(endNode || node, end);
+    r.setStart(node, start);
+    return r
+  }; }
+  else { range = function(node, start, end) {
+    var r = document.body.createTextRange();
+    try { r.moveToElementText(node.parentNode); }
+    catch(e) { return r }
+    r.collapse(true);
+    r.moveEnd("character", end);
+    r.moveStart("character", start);
+    return r
+  }; }
+
+  function contains(parent, child) {
+    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
+      { child = child.parentNode; }
+    if (parent.contains)
+      { return parent.contains(child) }
+    do {
+      if (child.nodeType == 11) { child = child.host; }
+      if (child == parent) { return true }
+    } while (child = child.parentNode)
+  }
+
+  function activeElt() {
+    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
+    // IE < 10 will throw when accessed while the page is loading or in an iframe.
+    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
+    var activeElement;
+    try {
+      activeElement = document.activeElement;
+    } catch(e) {
+      activeElement = document.body || null;
     }
-    function elt(tag, content, className, style) {
-      var e = document.createElement(tag);
-      if (className) {
-        e.className = className;
-      }
-      if (style) {
-        e.style.cssText = style;
-      }
-      if (typeof content == "string") {
-        e.appendChild(document.createTextNode(content));
-      } else if (content) {
-        for (var i2 = 0; i2 < content.length; ++i2) {
-          e.appendChild(content[i2]);
-        }
-      }
-      return e;
+    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
+      { activeElement = activeElement.shadowRoot.activeElement; }
+    return activeElement
+  }
+
+  function addClass(node, cls) {
+    var current = node.className;
+    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
+  }
+  function joinClasses(a, b) {
+    var as = a.split(" ");
+    for (var i = 0; i < as.length; i++)
+      { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
+    return b
+  }
+
+  var selectInput = function(node) { node.select(); };
+  if (ios) // Mobile Safari apparently has a bug where select() is broken.
+    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
+  else if (ie) // Suppress mysterious IE10 errors
+    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }
+
+  function bind(f) {
+    var args = Array.prototype.slice.call(arguments, 1);
+    return function(){return f.apply(null, args)}
+  }
+
+  function copyObj(obj, target, overwrite) {
+    if (!target) { target = {}; }
+    for (var prop in obj)
+      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
+        { target[prop] = obj[prop]; } }
+    return target
+  }
+
+  // Counts the column offset in a string, taking tabs into account.
+  // Used mostly to find indentation.
+  function countColumn(string, end, tabSize, startIndex, startValue) {
+    if (end == null) {
+      end = string.search(/[^\s\u00a0]/);
+      if (end == -1) { end = string.length; }
+    }
+    for (var i = startIndex || 0, n = startValue || 0;;) {
+      var nextTab = string.indexOf("\t", i);
+      if (nextTab < 0 || nextTab >= end)
+        { return n + (end - i) }
+      n += nextTab - i;
+      n += tabSize - (n % tabSize);
+      i = nextTab + 1;
     }
-    function eltP(tag, content, className, style) {
-      var e = elt(tag, content, className, style);
-      e.setAttribute("role", "presentation");
-      return e;
+  }
+
+  var Delayed = function() {
+    this.id = null;
+    this.f = null;
+    this.time = 0;
+    this.handler = bind(this.onTimeout, this);
+  };
+  Delayed.prototype.onTimeout = function (self) {
+    self.id = 0;
+    if (self.time <= +new Date) {
+      self.f();
+    } else {
+      setTimeout(self.handler, self.time - +new Date);
     }
-    var range;
-    if (document.createRange) {
-      range = function(node, start, end, endNode) {
-        var r = document.createRange();
-        r.setEnd(endNode || node, end);
-        r.setStart(node, start);
-        return r;
-      };
+  };
+  Delayed.prototype.set = function (ms, f) {
+    this.f = f;
+    var time = +new Date + ms;
+    if (!this.id || time < this.time) {
+      clearTimeout(this.id);
+      this.id = setTimeout(this.handler, ms);
+      this.time = time;
+    }
+  };
+
+  function indexOf(array, elt) {
+    for (var i = 0; i < array.length; ++i)
+      { if (array[i] == elt) { return i } }
+    return -1
+  }
+
+  // Number of pixels added to scroller and sizer to hide scrollbar
+  var scrollerGap = 50;
+
+  // Returned or thrown by various protocols to signal 'I'm not
+  // handling this'.
+  var Pass = {toString: function(){return "CodeMirror.Pass"}};
+
+  // Reused option objects for setSelection & friends
+  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};
+
+  // The inverse of countColumn -- find the offset that corresponds to
+  // a particular column.
+  function findColumn(string, goal, tabSize) {
+    for (var pos = 0, col = 0;;) {
+      var nextTab = string.indexOf("\t", pos);
+      if (nextTab == -1) { nextTab = string.length; }
+      var skipped = nextTab - pos;
+      if (nextTab == string.length || col + skipped >= goal)
+        { return pos + Math.min(skipped, goal - col) }
+      col += nextTab - pos;
+      col += tabSize - (col % tabSize);
+      pos = nextTab + 1;
+      if (col >= goal) { return pos }
+    }
+  }
+
+  var spaceStrs = [""];
+  function spaceStr(n) {
+    while (spaceStrs.length <= n)
+      { spaceStrs.push(lst(spaceStrs) + " "); }
+    return spaceStrs[n]
+  }
+
+  function lst(arr) { return arr[arr.length-1] }
+
+  function map(array, f) {
+    var out = [];
+    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
+    return out
+  }
+
+  function insertSorted(array, value, score) {
+    var pos = 0, priority = score(value);
+    while (pos < array.length && score(array[pos]) <= priority) { pos++; }
+    array.splice(pos, 0, value);
+  }
+
+  function nothing() {}
+
+  function createObj(base, props) {
+    var inst;
+    if (Object.create) {
+      inst = Object.create(base);
     } else {
-      range = function(node, start, end) {
-        var r = document.body.createTextRange();
-        try {
-          r.moveToElementText(node.parentNode);
-        } catch (e) {
-          return r;
-        }
-        r.collapse(true);
-        r.moveEnd("character", end);
-        r.moveStart("character", start);
-        return r;
-      };
+      nothing.prototype = base;
+      inst = new nothing();
     }
-    function contains(parent, child) {
-      if (child.nodeType == 3) {
-        child = child.parentNode;
-      }
-      if (parent.contains) {
-        return parent.contains(child);
-      }
-      do {
-        if (child.nodeType == 11) {
-          child = child.host;
-        }
-        if (child == parent) {
-          return true;
-        }
-      } while (child = child.parentNode);
+    if (props) { copyObj(props, inst); }
+    return inst
+  }
+
+  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
+  function isWordCharBasic(ch) {
+    return /\w/.test(ch) || ch > "\x80" &&
+      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
+  }
+  function isWordChar(ch, helper) {
+    if (!helper) { return isWordCharBasic(ch) }
+    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
+    return helper.test(ch)
+  }
+
+  function isEmpty(obj) {
+    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
+    return true
+  }
+
+  // Extending unicode characters. A series of a non-extending char +
+  // any number of extending chars is treated as a single unit as far
+  // as editing and measuring is concerned. This is not fully correct,
+  // since some scripts/fonts/browsers also treat other configurations
+  // of code points as a group.
+  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
+  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }
+
+  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
+  function skipExtendingChars(str, pos, dir) {
+    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
+    return pos
+  }
+
+  // Returns the value from the range [`from`; `to`] that satisfies
+  // `pred` and is closest to `from`. Assumes that at least `to`
+  // satisfies `pred`. Supports `from` being greater than `to`.
+  function findFirst(pred, from, to) {
+    // At any point we are certain `to` satisfies `pred`, don't know
+    // whether `from` does.
+    var dir = from > to ? -1 : 1;
+    for (;;) {
+      if (from == to) { return from }
+      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
+      if (mid == from) { return pred(mid) ? from : to }
+      if (pred(mid)) { to = mid; }
+      else { from = mid + dir; }
     }
-    function activeElt() {
-      var activeElement;
-      try {
-        activeElement = document.activeElement;
-      } catch (e) {
-        activeElement = document.body || null;
-      }
-      while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
-        activeElement = activeElement.shadowRoot.activeElement;
+  }
+
+  // BIDI HELPERS
+
+  function iterateBidiSections(order, from, to, f) {
+    if (!order) { return f(from, to, "ltr", 0) }
+    var found = false;
+    for (var i = 0; i < order.length; ++i) {
+      var part = order[i];
+      if (part.from < to && part.to > from || from == to && part.to == from) {
+        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
+        found = true;
       }
-      return activeElement;
     }
-    function addClass(node, cls) {
-      var current = node.className;
-      if (!classTest(cls).test(current)) {
-        node.className += (current ? " " : "") + cls;
+    if (!found) { f(from, to, "ltr"); }
+  }
+
+  var bidiOther = null;
+  function getBidiPartAt(order, ch, sticky) {
+    var found;
+    bidiOther = null;
+    for (var i = 0; i < order.length; ++i) {
+      var cur = order[i];
+      if (cur.from < ch && cur.to > ch) { return i }
+      if (cur.to == ch) {
+        if (cur.from != cur.to && sticky == "before") { found = i; }
+        else { bidiOther = i; }
       }
-    }
-    function joinClasses(a, b) {
-      var as = a.split(" ");
-      for (var i2 = 0; i2 < as.length; i2++) {
-        if (as[i2] && !classTest(as[i2]).test(b)) {
-          b += " " + as[i2];
-        }
+      if (cur.from == ch) {
+        if (cur.from != cur.to && sticky != "before") { found = i; }
+        else { bidiOther = i; }
       }
-      return b;
     }
-    var selectInput = function(node) {
-      node.select();
-    };
-    if (ios) {
-      selectInput = function(node) {
-        node.selectionStart = 0;
-        node.selectionEnd = node.value.length;
-      };
-    } else if (ie) {
-      selectInput = function(node) {
-        try {
-          node.select();
-        } catch (_e) {
-        }
-      };
+    return found != null ? found : bidiOther
+  }
+
+  // Bidirectional ordering algorithm
+  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
+  // that this (partially) implements.
+
+  // One-char codes used for character types:
+  // L (L):   Left-to-Right
+  // R (R):   Right-to-Left
+  // r (AL):  Right-to-Left Arabic
+  // 1 (EN):  European Number
+  // + (ES):  European Number Separator
+  // % (ET):  European Number Terminator
+  // n (AN):  Arabic Number
+  // , (CS):  Common Number Separator
+  // m (NSM): Non-Spacing Mark
+  // b (BN):  Boundary Neutral
+  // s (B):   Paragraph Separator
+  // t (S):   Segment Separator
+  // w (WS):  Whitespace
+  // N (ON):  Other Neutrals
+
+  // Returns null if characters are ordered as they appear
+  // (left-to-right), or an array of sections ({from, to, level}
+  // objects) in the order in which they occur visually.
+  var bidiOrdering = (function() {
+    // Character types for codepoints 0 to 0xff
+    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
+    // Character types for codepoints 0x600 to 0x6f9
+    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
+    function charType(code) {
+      if (code <= 0xf7) { return lowTypes.charAt(code) }
+      else if (0x590 <= code && code <= 0x5f4) { return "R" }
+      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
+      else if (0x6ee <= code && code <= 0x8ac) { return "r" }
+      else if (0x2000 <= code && code <= 0x200b) { return "w" }
+      else if (code == 0x200c) { return "b" }
+      else { return "L" }
     }
-    function bind(f) {
-      var args = Array.prototype.slice.call(arguments, 1);
-      return function() {
-        return f.apply(null, args);
-      };
+
+    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
+    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
+
+    function BidiSpan(level, from, to) {
+      this.level = level;
+      this.from = from; this.to = to;
     }
-    function copyObj(obj, target, overwrite) {
-      if (!target) {
-        target = {};
+
+    return function(str, direction) {
+      var outerType = direction == "ltr" ? "L" : "R";
+
+      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
+      var len = str.length, types = [];
+      for (var i = 0; i < len; ++i)
+        { types.push(charType(str.charCodeAt(i))); }
+
+      // W1. Examine each non-spacing mark (NSM) in the level run, and
+      // change the type of the NSM to the type of the previous
+      // character. If the NSM is at the start of the level run, it will
+      // get the type of sor.
+      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
+        var type = types[i$1];
+        if (type == "m") { types[i$1] = prev; }
+        else { prev = type; }
       }
-      for (var prop2 in obj) {
-        if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {
-          target[prop2] = obj[prop2];
-        }
+
+      // W2. Search backwards from each instance of a European number
+      // until the first strong type (R, L, AL, or sor) is found. If an
+      // AL is found, change the type of the European number to Arabic
+      // number.
+      // W3. Change all ALs to R.
+      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
+        var type$1 = types[i$2];
+        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
+        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
       }
-      return target;
-    }
-    function countColumn(string, end, tabSize, startIndex, startValue) {
-      if (end == null) {
-        end = string.search(/[^\s\u00a0]/);
-        if (end == -1) {
-          end = string.length;
-        }
+
+      // W4. A single European separator between two European numbers
+      // changes to a European number. A single common separator between
+      // two numbers of the same type changes to that type.
+      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
+        var type$2 = types[i$3];
+        if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
+        else if (type$2 == "," && prev$1 == types[i$3+1] &&
+                 (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
+        prev$1 = type$2;
       }
-      for (var i2 = startIndex || 0, n = startValue || 0; ; ) {
-        var nextTab = string.indexOf("	", i2);
-        if (nextTab < 0 || nextTab >= end) {
-          return n + (end - i2);
+
+      // W5. A sequence of European terminators adjacent to European
+      // numbers changes to all European numbers.
+      // W6. Otherwise, separators and terminators change to Other
+      // Neutral.
+      for (var i$4 = 0; i$4 < len; ++i$4) {
+        var type$3 = types[i$4];
+        if (type$3 == ",") { types[i$4] = "N"; }
+        else if (type$3 == "%") {
+          var end = (void 0);
+          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
+          var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
+          for (var j = i$4; j < end; ++j) { types[j] = replace; }
+          i$4 = end - 1;
         }
-        n += nextTab - i2;
-        n += tabSize - n % tabSize;
-        i2 = nextTab + 1;
-      }
-    }
-    var Delayed = function() {
-      this.id = null;
-      this.f = null;
-      this.time = 0;
-      this.handler = bind(this.onTimeout, this);
-    };
-    Delayed.prototype.onTimeout = function(self2) {
-      self2.id = 0;
-      if (self2.time <= +new Date()) {
-        self2.f();
-      } else {
-        setTimeout(self2.handler, self2.time - +new Date());
       }
-    };
-    Delayed.prototype.set = function(ms, f) {
-      this.f = f;
-      var time = +new Date() + ms;
-      if (!this.id || time < this.time) {
-        clearTimeout(this.id);
-        this.id = setTimeout(this.handler, ms);
-        this.time = time;
+
+      // W7. Search backwards from each instance of a European number
+      // until the first strong type (R, L, or sor) is found. If an L is
+      // found, then change the type of the European number to L.
+      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
+        var type$4 = types[i$5];
+        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
+        else if (isStrong.test(type$4)) { cur$1 = type$4; }
       }
-    };
-    function indexOf(array, elt2) {
-      for (var i2 = 0; i2 < array.length; ++i2) {
-        if (array[i2] == elt2) {
-          return i2;
+
+      // N1. A sequence of neutrals takes the direction of the
+      // surrounding strong text if the text on both sides has the same
+      // direction. European and Arabic numbers act as if they were R in
+      // terms of their influence on neutrals. Start-of-level-run (sor)
+      // and end-of-level-run (eor) are used at level run boundaries.
+      // N2. Any remaining neutrals take the embedding direction.
+      for (var i$6 = 0; i$6 < len; ++i$6) {
+        if (isNeutral.test(types[i$6])) {
+          var end$1 = (void 0);
+          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
+          var before = (i$6 ? types[i$6-1] : outerType) == "L";
+          var after = (end$1 < len ? types[end$1] : outerType) == "L";
+          var replace$1 = before == after ? (before ? "L" : "R") : outerType;
+          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
+          i$6 = end$1 - 1;
         }
       }
-      return -1;
-    }
-    var scrollerGap = 50;
-    var Pass = { toString: function() {
-      return "CodeMirror.Pass";
-    } };
-    var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };
-    function findColumn(string, goal, tabSize) {
-      for (var pos = 0, col = 0; ; ) {
-        var nextTab = string.indexOf("	", pos);
-        if (nextTab == -1) {
-          nextTab = string.length;
+
+      // Here we depart from the documented algorithm, in order to avoid
+      // building up an actual levels array. Since there are only three
+      // levels (0, 1, 2) in an implementation that doesn't take
+      // explicit embedding into account, we can build up the order on
+      // the fly, without following the level-based algorithm.
+      var order = [], m;
+      for (var i$7 = 0; i$7 < len;) {
+        if (countsAsLeft.test(types[i$7])) {
+          var start = i$7;
+          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
+          order.push(new BidiSpan(0, start, i$7));
+        } else {
+          var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
+          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
+          for (var j$2 = pos; j$2 < i$7;) {
+            if (countsAsNum.test(types[j$2])) {
+              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }
+              var nstart = j$2;
+              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
+              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
+              at += isRTL;
+              pos = j$2;
+            } else { ++j$2; }
+          }
+          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
         }
-        var skipped = nextTab - pos;
-        if (nextTab == string.length || col + skipped >= goal) {
-          return pos + Math.min(skipped, goal - col);
+      }
+      if (direction == "ltr") {
+        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
+          order[0].from = m[0].length;
+          order.unshift(new BidiSpan(0, 0, m[0].length));
         }
-        col += nextTab - pos;
-        col += tabSize - col % tabSize;
-        pos = nextTab + 1;
-        if (col >= goal) {
-          return pos;
+        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
+          lst(order).to -= m[0].length;
+          order.push(new BidiSpan(0, len - m[0].length, len));
         }
       }
+
+      return direction == "rtl" ? order.reverse() : order
     }
-    var spaceStrs = [""];
-    function spaceStr(n) {
-      while (spaceStrs.length <= n) {
-        spaceStrs.push(lst(spaceStrs) + " ");
-      }
-      return spaceStrs[n];
-    }
-    function lst(arr) {
-      return arr[arr.length - 1];
-    }
-    function map(array, f) {
-      var out = [];
-      for (var i2 = 0; i2 < array.length; i2++) {
-        out[i2] = f(array[i2], i2);
-      }
-      return out;
+  })();
+
+  // Get the bidi ordering for the given line (and cache it). Returns
+  // false for lines that are fully left-to-right, and an array of
+  // BidiSpan objects otherwise.
+  function getOrder(line, direction) {
+    var order = line.order;
+    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
+    return order
+  }
+
+  // EVENT HANDLING
+
+  // Lightweight event framework. on/off also work on DOM nodes,
+  // registering native DOM handlers.
+
+  var noHandlers = [];
+
+  var on = function(emitter, type, f) {
+    if (emitter.addEventListener) {
+      emitter.addEventListener(type, f, false);
+    } else if (emitter.attachEvent) {
+      emitter.attachEvent("on" + type, f);
+    } else {
+      var map = emitter._handlers || (emitter._handlers = {});
+      map[type] = (map[type] || noHandlers).concat(f);
     }
-    function insertSorted(array, value, score) {
-      var pos = 0, priority = score(value);
-      while (pos < array.length && score(array[pos]) <= priority) {
-        pos++;
+  };
+
+  function getHandlers(emitter, type) {
+    return emitter._handlers && emitter._handlers[type] || noHandlers
+  }
+
+  function off(emitter, type, f) {
+    if (emitter.removeEventListener) {
+      emitter.removeEventListener(type, f, false);
+    } else if (emitter.detachEvent) {
+      emitter.detachEvent("on" + type, f);
+    } else {
+      var map = emitter._handlers, arr = map && map[type];
+      if (arr) {
+        var index = indexOf(arr, f);
+        if (index > -1)
+          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
       }
-      array.splice(pos, 0, value);
     }
-    function nothing() {
+  }
+
+  function signal(emitter, type /*, values...*/) {
+    var handlers = getHandlers(emitter, type);
+    if (!handlers.length) { return }
+    var args = Array.prototype.slice.call(arguments, 2);
+    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
+  }
+
+  // The DOM events that CodeMirror handles can be overridden by
+  // registering a (non-DOM) handler on the editor for the event name,
+  // and preventDefault-ing the event in that handler.
+  function signalDOMEvent(cm, e, override) {
+    if (typeof e == "string")
+      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
+    signal(cm, override || e.type, cm, e);
+    return e_defaultPrevented(e) || e.codemirrorIgnore
+  }
+
+  function signalCursorActivity(cm) {
+    var arr = cm._handlers && cm._handlers.cursorActivity;
+    if (!arr) { return }
+    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
+    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
+      { set.push(arr[i]); } }
+  }
+
+  function hasHandler(emitter, type) {
+    return getHandlers(emitter, type).length > 0
+  }
+
+  // Add on and off methods to a constructor's prototype, to make
+  // registering events on such objects more convenient.
+  function eventMixin(ctor) {
+    ctor.prototype.on = function(type, f) {on(this, type, f);};
+    ctor.prototype.off = function(type, f) {off(this, type, f);};
+  }
+
+  // Due to the fact that we still support jurassic IE versions, some
+  // compatibility wrappers are needed.
+
+  function e_preventDefault(e) {
+    if (e.preventDefault) { e.preventDefault(); }
+    else { e.returnValue = false; }
+  }
+  function e_stopPropagation(e) {
+    if (e.stopPropagation) { e.stopPropagation(); }
+    else { e.cancelBubble = true; }
+  }
+  function e_defaultPrevented(e) {
+    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
+  }
+  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}
+
+  function e_target(e) {return e.target || e.srcElement}
+  function e_button(e) {
+    var b = e.which;
+    if (b == null) {
+      if (e.button & 1) { b = 1; }
+      else if (e.button & 2) { b = 3; }
+      else if (e.button & 4) { b = 2; }
     }
-    function createObj(base, props) {
-      var inst;
-      if (Object.create) {
-        inst = Object.create(base);
+    if (mac && e.ctrlKey && b == 1) { b = 3; }
+    return b
+  }
+
+  // Detect drag-and-drop
+  var dragAndDrop = function() {
+    // There is *some* kind of drag-and-drop support in IE6-8, but I
+    // couldn't get it to work yet.
+    if (ie && ie_version < 9) { return false }
+    var div = elt('div');
+    return "draggable" in div || "dragDrop" in div
+  }();
+
+  var zwspSupported;
+  function zeroWidthElement(measure) {
+    if (zwspSupported == null) {
+      var test = elt("span", "\u200b");
+      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
+      if (measure.firstChild.offsetHeight != 0)
+        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
+    }
+    var node = zwspSupported ? elt("span", "\u200b") :
+      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
+    node.setAttribute("cm-text", "");
+    return node
+  }
+
+  // Feature-detect IE's crummy client rect reporting for bidi text
+  var badBidiRects;
+  function hasBadBidiRects(measure) {
+    if (badBidiRects != null) { return badBidiRects }
+    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
+    var r0 = range(txt, 0, 1).getBoundingClientRect();
+    var r1 = range(txt, 1, 2).getBoundingClientRect();
+    removeChildren(measure);
+    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
+    return badBidiRects = (r1.right - r0.right < 3)
+  }
+
+  // See if "".split is the broken IE version, if so, provide an
+  // alternative way to split lines.
+  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
+    var pos = 0, result = [], l = string.length;
+    while (pos <= l) {
+      var nl = string.indexOf("\n", pos);
+      if (nl == -1) { nl = string.length; }
+      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
+      var rt = line.indexOf("\r");
+      if (rt != -1) {
+        result.push(line.slice(0, rt));
+        pos += rt + 1;
       } else {
-        nothing.prototype = base;
-        inst = new nothing();
-      }
-      if (props) {
-        copyObj(props, inst);
-      }
-      return inst;
-    }
-    var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
-    function isWordCharBasic(ch) {
-      return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
-    }
-    function isWordChar(ch, helper) {
-      if (!helper) {
-        return isWordCharBasic(ch);
-      }
-      if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
-        return true;
+        result.push(line);
+        pos = nl + 1;
       }
-      return helper.test(ch);
     }
-    function isEmpty(obj) {
-      for (var n in obj) {
-        if (obj.hasOwnProperty(n) && obj[n]) {
-          return false;
-        }
-      }
-      return true;
+    return result
+  } : function (string) { return string.split(/\r\n?|\n/); };
+
+  var hasSelection = window.getSelection ? function (te) {
+    try { return te.selectionStart != te.selectionEnd }
+    catch(e) { return false }
+  } : function (te) {
+    var range;
+    try {range = te.ownerDocument.selection.createRange();}
+    catch(e) {}
+    if (!range || range.parentElement() != te) { return false }
+    return range.compareEndPoints("StartToEnd", range) != 0
+  };
+
+  var hasCopyEvent = (function () {
+    var e = elt("div");
+    if ("oncopy" in e) { return true }
+    e.setAttribute("oncopy", "return;");
+    return typeof e.oncopy == "function"
+  })();
+
+  var badZoomedRects = null;
+  function hasBadZoomedRects(measure) {
+    if (badZoomedRects != null) { return badZoomedRects }
+    var node = removeChildrenAndAdd(measure, elt("span", "x"));
+    var normal = node.getBoundingClientRect();
+    var fromRange = range(node, 0, 1).getBoundingClientRect();
+    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
+  }
+
+  // Known modes, by name and by MIME
+  var modes = {}, mimeModes = {};
+
+  // Extra arguments are stored as the mode's dependencies, which is
+  // used by (legacy) mechanisms like loadmode.js to automatically
+  // load a mode. (Preferred mechanism is the require/define calls.)
+  function defineMode(name, mode) {
+    if (arguments.length > 2)
+      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
+    modes[name] = mode;
+  }
+
+  function defineMIME(mime, spec) {
+    mimeModes[mime] = spec;
+  }
+
+  // Given a MIME type, a {name, ...options} config object, or a name
+  // string, return a mode config object.
+  function resolveMode(spec) {
+    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
+      spec = mimeModes[spec];
+    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
+      var found = mimeModes[spec.name];
+      if (typeof found == "string") { found = {name: found}; }
+      spec = createObj(found, spec);
+      spec.name = found.name;
+    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
+      return resolveMode("application/xml")
+    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
+      return resolveMode("application/json")
+    }
+    if (typeof spec == "string") { return {name: spec} }
+    else { return spec || {name: "null"} }
+  }
+
+  // Given a mode spec (anything that resolveMode accepts), find and
+  // initialize an actual mode object.
+  function getMode(options, spec) {
+    spec = resolveMode(spec);
+    var mfactory = modes[spec.name];
+    if (!mfactory) { return getMode(options, "text/plain") }
+    var modeObj = mfactory(options, spec);
+    if (modeExtensions.hasOwnProperty(spec.name)) {
+      var exts = modeExtensions[spec.name];
+      for (var prop in exts) {
+        if (!exts.hasOwnProperty(prop)) { continue }
+        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
+        modeObj[prop] = exts[prop];
+      }
+    }
+    modeObj.name = spec.name;
+    if (spec.helperType) { modeObj.helperType = spec.helperType; }
+    if (spec.modeProps) { for (var prop$1 in spec.modeProps)
+      { modeObj[prop$1] = spec.modeProps[prop$1]; } }
+
+    return modeObj
+  }
+
+  // This can be used to attach properties to mode objects from
+  // outside the actual mode definition.
+  var modeExtensions = {};
+  function extendMode(mode, properties) {
+    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
+    copyObj(properties, exts);
+  }
+
+  function copyState(mode, state) {
+    if (state === true) { return state }
+    if (mode.copyState) { return mode.copyState(state) }
+    var nstate = {};
+    for (var n in state) {
+      var val = state[n];
+      if (val instanceof Array) { val = val.concat([]); }
+      nstate[n] = val;
     }
-    var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
-    function isExtendingChar(ch) {
-      return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
+    return nstate
+  }
+
+  // Given a mode and a state (for that mode), find the inner mode and
+  // state at the position that the state refers to.
+  function innerMode(mode, state) {
+    var info;
+    while (mode.innerMode) {
+      info = mode.innerMode(state);
+      if (!info || info.mode == mode) { break }
+      state = info.state;
+      mode = info.mode;
+    }
+    return info || {mode: mode, state: state}
+  }
+
+  function startState(mode, a1, a2) {
+    return mode.startState ? mode.startState(a1, a2) : true
+  }
+
+  // STRING STREAM
+
+  // Fed to the mode parsers, provides helper functions to make
+  // parsers more succinct.
+
+  var StringStream = function(string, tabSize, lineOracle) {
+    this.pos = this.start = 0;
+    this.string = string;
+    this.tabSize = tabSize || 8;
+    this.lastColumnPos = this.lastColumnValue = 0;
+    this.lineStart = 0;
+    this.lineOracle = lineOracle;
+  };
+
+  StringStream.prototype.eol = function () {return this.pos >= this.string.length};
+  StringStream.prototype.sol = function () {return this.pos == this.lineStart};
+  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
+  StringStream.prototype.next = function () {
+    if (this.pos < this.string.length)
+      { return this.string.charAt(this.pos++) }
+  };
+  StringStream.prototype.eat = function (match) {
+    var ch = this.string.charAt(this.pos);
+    var ok;
+    if (typeof match == "string") { ok = ch == match; }
+    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
+    if (ok) {++this.pos; return ch}
+  };
+  StringStream.prototype.eatWhile = function (match) {
+    var start = this.pos;
+    while (this.eat(match)){}
+    return this.pos > start
+  };
+  StringStream.prototype.eatSpace = function () {
+    var start = this.pos;
+    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }
+    return this.pos > start
+  };
+  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
+  StringStream.prototype.skipTo = function (ch) {
+    var found = this.string.indexOf(ch, this.pos);
+    if (found > -1) {this.pos = found; return true}
+  };
+  StringStream.prototype.backUp = function (n) {this.pos -= n;};
+  StringStream.prototype.column = function () {
+    if (this.lastColumnPos < this.start) {
+      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
+      this.lastColumnPos = this.start;
     }
-    function skipExtendingChars(str, pos, dir) {
-      while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
-        pos += dir;
+    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
+  };
+  StringStream.prototype.indentation = function () {
+    return countColumn(this.string, null, this.tabSize) -
+      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
+  };
+  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
+    if (typeof pattern == "string") {
+      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
+      var substr = this.string.substr(this.pos, pattern.length);
+      if (cased(substr) == cased(pattern)) {
+        if (consume !== false) { this.pos += pattern.length; }
+        return true
       }
-      return pos;
+    } else {
+      var match = this.string.slice(this.pos).match(pattern);
+      if (match && match.index > 0) { return null }
+      if (match && consume !== false) { this.pos += match[0].length; }
+      return match
     }
-    function findFirst(pred, from, to) {
-      var dir = from > to ? -1 : 1;
-      for (; ; ) {
-        if (from == to) {
-          return from;
-        }
-        var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
-        if (mid == from) {
-          return pred(mid) ? from : to;
-        }
-        if (pred(mid)) {
-          to = mid;
-        } else {
-          from = mid + dir;
-        }
+  };
+  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
+  StringStream.prototype.hideFirstChars = function (n, inner) {
+    this.lineStart += n;
+    try { return inner() }
+    finally { this.lineStart -= n; }
+  };
+  StringStream.prototype.lookAhead = function (n) {
+    var oracle = this.lineOracle;
+    return oracle && oracle.lookAhead(n)
+  };
+  StringStream.prototype.baseToken = function () {
+    var oracle = this.lineOracle;
+    return oracle && oracle.baseToken(this.pos)
+  };
+
+  // Find the line object corresponding to the given line number.
+  function getLine(doc, n) {
+    n -= doc.first;
+    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
+    var chunk = doc;
+    while (!chunk.lines) {
+      for (var i = 0;; ++i) {
+        var child = chunk.children[i], sz = child.chunkSize();
+        if (n < sz) { chunk = child; break }
+        n -= sz;
       }
     }
-    function iterateBidiSections(order, from, to, f) {
-      if (!order) {
-        return f(from, to, "ltr", 0);
-      }
-      var found = false;
-      for (var i2 = 0; i2 < order.length; ++i2) {
-        var part = order[i2];
-        if (part.from < to && part.to > from || from == to && part.to == from) {
-          f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i2);
-          found = true;
-        }
-      }
-      if (!found) {
-        f(from, to, "ltr");
+    return chunk.lines[n]
+  }
+
+  // Get the part of a document between two positions, as an array of
+  // strings.
+  function getBetween(doc, start, end) {
+    var out = [], n = start.line;
+    doc.iter(start.line, end.line + 1, function (line) {
+      var text = line.text;
+      if (n == end.line) { text = text.slice(0, end.ch); }
+      if (n == start.line) { text = text.slice(start.ch); }
+      out.push(text);
+      ++n;
+    });
+    return out
+  }
+  // Get the lines between from and to, as array of strings.
+  function getLines(doc, from, to) {
+    var out = [];
+    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
+    return out
+  }
+
+  // Update the height of a line, propagating the height change
+  // upwards to parent nodes.
+  function updateLineHeight(line, height) {
+    var diff = height - line.height;
+    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
+  }
+
+  // Given a line object, find its line number by walking up through
+  // its parent links.
+  function lineNo(line) {
+    if (line.parent == null) { return null }
+    var cur = line.parent, no = indexOf(cur.lines, line);
+    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
+      for (var i = 0;; ++i) {
+        if (chunk.children[i] == cur) { break }
+        no += chunk.children[i].chunkSize();
       }
     }
-    var bidiOther = null;
-    function getBidiPartAt(order, ch, sticky) {
-      var found;
-      bidiOther = null;
-      for (var i2 = 0; i2 < order.length; ++i2) {
-        var cur = order[i2];
-        if (cur.from < ch && cur.to > ch) {
-          return i2;
-        }
-        if (cur.to == ch) {
-          if (cur.from != cur.to && sticky == "before") {
-            found = i2;
-          } else {
-            bidiOther = i2;
-          }
-        }
-        if (cur.from == ch) {
-          if (cur.from != cur.to && sticky != "before") {
-            found = i2;
-          } else {
-            bidiOther = i2;
-          }
-        }
-      }
-      return found != null ? found : bidiOther;
-    }
-    var bidiOrdering = function() {
-      var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
-      var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
-      function charType(code) {
-        if (code <= 247) {
-          return lowTypes.charAt(code);
-        } else if (1424 <= code && code <= 1524) {
-          return "R";
-        } else if (1536 <= code && code <= 1785) {
-          return arabicTypes.charAt(code - 1536);
-        } else if (1774 <= code && code <= 2220) {
-          return "r";
-        } else if (8192 <= code && code <= 8203) {
-          return "w";
-        } else if (code == 8204) {
-          return "b";
+    return no + cur.first
+  }
+
+  // Find the line at the given vertical position, using the height
+  // information in the document tree.
+  function lineAtHeight(chunk, h) {
+    var n = chunk.first;
+    outer: do {
+      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
+        var child = chunk.children[i$1], ch = child.height;
+        if (h < ch) { chunk = child; continue outer }
+        h -= ch;
+        n += child.chunkSize();
+      }
+      return n
+    } while (!chunk.lines)
+    var i = 0;
+    for (; i < chunk.lines.length; ++i) {
+      var line = chunk.lines[i], lh = line.height;
+      if (h < lh) { break }
+      h -= lh;
+    }
+    return n + i
+  }
+
+  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}
+
+  function lineNumberFor(options, i) {
+    return String(options.lineNumberFormatter(i + options.firstLineNumber))
+  }
+
+  // A Pos instance represents a position within the text.
+  function Pos(line, ch, sticky) {
+    if ( sticky === void 0 ) sticky = null;
+
+    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
+    this.line = line;
+    this.ch = ch;
+    this.sticky = sticky;
+  }
+
+  // Compare two positions, return 0 if they are the same, a negative
+  // number when a is less, and a positive number otherwise.
+  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }
+
+  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }
+
+  function copyPos(x) {return Pos(x.line, x.ch)}
+  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
+  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }
+
+  // Most of the external API clips given positions to make sure they
+  // actually exist within the document.
+  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
+  function clipPos(doc, pos) {
+    if (pos.line < doc.first) { return Pos(doc.first, 0) }
+    var last = doc.first + doc.size - 1;
+    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
+    return clipToLen(pos, getLine(doc, pos.line).text.length)
+  }
+  function clipToLen(pos, linelen) {
+    var ch = pos.ch;
+    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
+    else if (ch < 0) { return Pos(pos.line, 0) }
+    else { return pos }
+  }
+  function clipPosArray(doc, array) {
+    var out = [];
+    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
+    return out
+  }
+
+  var SavedContext = function(state, lookAhead) {
+    this.state = state;
+    this.lookAhead = lookAhead;
+  };
+
+  var Context = function(doc, state, line, lookAhead) {
+    this.state = state;
+    this.doc = doc;
+    this.line = line;
+    this.maxLookAhead = lookAhead || 0;
+    this.baseTokens = null;
+    this.baseTokenPos = 1;
+  };
+
+  Context.prototype.lookAhead = function (n) {
+    var line = this.doc.getLine(this.line + n);
+    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
+    return line
+  };
+
+  Context.prototype.baseToken = function (n) {
+    if (!this.baseTokens) { return null }
+    while (this.baseTokens[this.baseTokenPos] <= n)
+      { this.baseTokenPos += 2; }
+    var type = this.baseTokens[this.baseTokenPos + 1];
+    return {type: type && type.replace(/( |^)overlay .*/, ""),
+            size: this.baseTokens[this.baseTokenPos] - n}
+  };
+
+  Context.prototype.nextLine = function () {
+    this.line++;
+    if (this.maxLookAhead > 0) { this.maxLookAhead--; }
+  };
+
+  Context.fromSaved = function (doc, saved, line) {
+    if (saved instanceof SavedContext)
+      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
+    else
+      { return new Context(doc, copyState(doc.mode, saved), line) }
+  };
+
+  Context.prototype.save = function (copy) {
+    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
+    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
+  };
+
+
+  // Compute a style array (an array starting with a mode generation
+  // -- for invalidation -- followed by pairs of end positions and
+  // style strings), which is used to highlight the tokens on the
+  // line.
+  function highlightLine(cm, line, context, forceToEnd) {
+    // A styles array always starts with a number identifying the
+    // mode/overlays that it is based on (for easy invalidation).
+    var st = [cm.state.modeGen], lineClasses = {};
+    // Compute the base array of styles
+    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
+            lineClasses, forceToEnd);
+    var state = context.state;
+
+    // Run overlays, adjust style array.
+    var loop = function ( o ) {
+      context.baseTokens = st;
+      var overlay = cm.state.overlays[o], i = 1, at = 0;
+      context.state = true;
+      runMode(cm, line.text, overlay.mode, context, function (end, style) {
+        var start = i;
+        // Ensure there's a token end at the current position, and that i points at it
+        while (at < end) {
+          var i_end = st[i];
+          if (i_end > end)
+            { st.splice(i, 1, end, st[i+1], i_end); }
+          i += 2;
+          at = Math.min(end, i_end);
+        }
+        if (!style) { return }
+        if (overlay.opaque) {
+          st.splice(start, i - start, end, "overlay " + style);
+          i = start + 2;
         } else {
-          return "L";
-        }
-      }
-      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
-      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
-      function BidiSpan(level, from, to) {
-        this.level = level;
-        this.from = from;
-        this.to = to;
-      }
-      return function(str, direction) {
-        var outerType = direction == "ltr" ? "L" : "R";
-        if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
-          return false;
-        }
-        var len = str.length, types2 = [];
-        for (var i2 = 0; i2 < len; ++i2) {
-          types2.push(charType(str.charCodeAt(i2)));
-        }
-        for (var i$12 = 0, prev = outerType; i$12 < len; ++i$12) {
-          var type = types2[i$12];
-          if (type == "m") {
-            types2[i$12] = prev;
-          } else {
-            prev = type;
-          }
-        }
-        for (var i$22 = 0, cur = outerType; i$22 < len; ++i$22) {
-          var type$1 = types2[i$22];
-          if (type$1 == "1" && cur == "r") {
-            types2[i$22] = "n";
-          } else if (isStrong.test(type$1)) {
-            cur = type$1;
-            if (type$1 == "r") {
-              types2[i$22] = "R";
-            }
-          }
-        }
-        for (var i$3 = 1, prev$1 = types2[0]; i$3 < len - 1; ++i$3) {
-          var type$2 = types2[i$3];
-          if (type$2 == "+" && prev$1 == "1" && types2[i$3 + 1] == "1") {
-            types2[i$3] = "1";
-          } else if (type$2 == "," && prev$1 == types2[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
-            types2[i$3] = prev$1;
-          }
-          prev$1 = type$2;
-        }
-        for (var i$4 = 0; i$4 < len; ++i$4) {
-          var type$3 = types2[i$4];
-          if (type$3 == ",") {
-            types2[i$4] = "N";
-          } else if (type$3 == "%") {
-            var end = void 0;
-            for (end = i$4 + 1; end < len && types2[end] == "%"; ++end) {
-            }
-            var replace = i$4 && types2[i$4 - 1] == "!" || end < len && types2[end] == "1" ? "1" : "N";
-            for (var j = i$4; j < end; ++j) {
-              types2[j] = replace;
-            }
-            i$4 = end - 1;
-          }
-        }
-        for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
-          var type$4 = types2[i$5];
-          if (cur$1 == "L" && type$4 == "1") {
-            types2[i$5] = "L";
-          } else if (isStrong.test(type$4)) {
-            cur$1 = type$4;
-          }
-        }
-        for (var i$6 = 0; i$6 < len; ++i$6) {
-          if (isNeutral.test(types2[i$6])) {
-            var end$1 = void 0;
-            for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types2[end$1]); ++end$1) {
-            }
-            var before = (i$6 ? types2[i$6 - 1] : outerType) == "L";
-            var after = (end$1 < len ? types2[end$1] : outerType) == "L";
-            var replace$1 = before == after ? before ? "L" : "R" : outerType;
-            for (var j$1 = i$6; j$1 < end$1; ++j$1) {
-              types2[j$1] = replace$1;
-            }
-            i$6 = end$1 - 1;
-          }
-        }
-        var order = [], m;
-        for (var i$7 = 0; i$7 < len; ) {
-          if (countsAsLeft.test(types2[i$7])) {
-            var start = i$7;
-            for (++i$7; i$7 < len && countsAsLeft.test(types2[i$7]); ++i$7) {
-            }
-            order.push(new BidiSpan(0, start, i$7));
-          } else {
-            var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
-            for (++i$7; i$7 < len && types2[i$7] != "L"; ++i$7) {
-            }
-            for (var j$2 = pos; j$2 < i$7; ) {
-              if (countsAsNum.test(types2[j$2])) {
-                if (pos < j$2) {
-                  order.splice(at, 0, new BidiSpan(1, pos, j$2));
-                  at += isRTL;
-                }
-                var nstart = j$2;
-                for (++j$2; j$2 < i$7 && countsAsNum.test(types2[j$2]); ++j$2) {
-                }
-                order.splice(at, 0, new BidiSpan(2, nstart, j$2));
-                at += isRTL;
-                pos = j$2;
-              } else {
-                ++j$2;
-              }
-            }
-            if (pos < i$7) {
-              order.splice(at, 0, new BidiSpan(1, pos, i$7));
-            }
-          }
-        }
-        if (direction == "ltr") {
-          if (order[0].level == 1 && (m = str.match(/^\s+/))) {
-            order[0].from = m[0].length;
-            order.unshift(new BidiSpan(0, 0, m[0].length));
-          }
-          if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
-            lst(order).to -= m[0].length;
-            order.push(new BidiSpan(0, len - m[0].length, len));
+          for (; start < i; start += 2) {
+            var cur = st[start+1];
+            st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
           }
         }
-        return direction == "rtl" ? order.reverse() : order;
-      };
-    }();
-    function getOrder(line, direction) {
-      var order = line.order;
-      if (order == null) {
-        order = line.order = bidiOrdering(line.text, direction);
-      }
-      return order;
-    }
-    var noHandlers = [];
-    var on = function(emitter, type, f) {
-      if (emitter.addEventListener) {
-        emitter.addEventListener(type, f, false);
-      } else if (emitter.attachEvent) {
-        emitter.attachEvent("on" + type, f);
-      } else {
-        var map2 = emitter._handlers || (emitter._handlers = {});
-        map2[type] = (map2[type] || noHandlers).concat(f);
-      }
+      }, lineClasses);
+      context.state = state;
+      context.baseTokens = null;
+      context.baseTokenPos = 1;
     };
-    function getHandlers(emitter, type) {
-      return emitter._handlers && emitter._handlers[type] || noHandlers;
-    }
-    function off(emitter, type, f) {
-      if (emitter.removeEventListener) {
-        emitter.removeEventListener(type, f, false);
-      } else if (emitter.detachEvent) {
-        emitter.detachEvent("on" + type, f);
-      } else {
-        var map2 = emitter._handlers, arr = map2 && map2[type];
-        if (arr) {
-          var index = indexOf(arr, f);
-          if (index > -1) {
-            map2[type] = arr.slice(0, index).concat(arr.slice(index + 1));
-          }
-        }
-      }
+
+    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );
+
+    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
+  }
+
+  function getLineStyles(cm, line, updateFrontier) {
+    if (!line.styles || line.styles[0] != cm.state.modeGen) {
+      var context = getContextBefore(cm, lineNo(line));
+      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
+      var result = highlightLine(cm, line, context);
+      if (resetState) { context.state = resetState; }
+      line.stateAfter = context.save(!resetState);
+      line.styles = result.styles;
+      if (result.classes) { line.styleClasses = result.classes; }
+      else if (line.styleClasses) { line.styleClasses = null; }
+      if (updateFrontier === cm.doc.highlightFrontier)
+        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
+    }
+    return line.styles
+  }
+
+  function getContextBefore(cm, n, precise) {
+    var doc = cm.doc, display = cm.display;
+    if (!doc.mode.startState) { return new Context(doc, true, n) }
+    var start = findStartLine(cm, n, precise);
+    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
+    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
+
+    doc.iter(start, n, function (line) {
+      processLine(cm, line.text, context);
+      var pos = context.line;
+      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
+      context.nextLine();
+    });
+    if (precise) { doc.modeFrontier = context.line; }
+    return context
+  }
+
+  // Lightweight form of highlight -- proceed over this line and
+  // update state, but don't save a style array. Used for lines that
+  // aren't currently visible.
+  function processLine(cm, text, context, startAt) {
+    var mode = cm.doc.mode;
+    var stream = new StringStream(text, cm.options.tabSize, context);
+    stream.start = stream.pos = startAt || 0;
+    if (text == "") { callBlankLine(mode, context.state); }
+    while (!stream.eol()) {
+      readToken(mode, stream, context.state);
+      stream.start = stream.pos;
     }
-    function signal(emitter, type) {
-      var handlers = getHandlers(emitter, type);
-      if (!handlers.length) {
-        return;
-      }
-      var args = Array.prototype.slice.call(arguments, 2);
-      for (var i2 = 0; i2 < handlers.length; ++i2) {
-        handlers[i2].apply(null, args);
-      }
+  }
+
+  function callBlankLine(mode, state) {
+    if (mode.blankLine) { return mode.blankLine(state) }
+    if (!mode.innerMode) { return }
+    var inner = innerMode(mode, state);
+    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
+  }
+
+  function readToken(mode, stream, state, inner) {
+    for (var i = 0; i < 10; i++) {
+      if (inner) { inner[0] = innerMode(mode, state).mode; }
+      var style = mode.token(stream, state);
+      if (stream.pos > stream.start) { return style }
     }
-    function signalDOMEvent(cm, e, override) {
-      if (typeof e == "string") {
-        e = { type: e, preventDefault: function() {
-          this.defaultPrevented = true;
-        } };
+    throw new Error("Mode " + mode.name + " failed to advance stream.")
+  }
+
+  var Token = function(stream, type, state) {
+    this.start = stream.start; this.end = stream.pos;
+    this.string = stream.current();
+    this.type = type || null;
+    this.state = state;
+  };
+
+  // Utility for getTokenAt and getLineTokens
+  function takeToken(cm, pos, precise, asArray) {
+    var doc = cm.doc, mode = doc.mode, style;
+    pos = clipPos(doc, pos);
+    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
+    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
+    if (asArray) { tokens = []; }
+    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
+      stream.start = stream.pos;
+      style = readToken(mode, stream, context.state);
+      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
+    }
+    return asArray ? tokens : new Token(stream, style, context.state)
+  }
+
+  function extractLineClasses(type, output) {
+    if (type) { for (;;) {
+      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
+      if (!lineClass) { break }
+      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
+      var prop = lineClass[1] ? "bgClass" : "textClass";
+      if (output[prop] == null)
+        { output[prop] = lineClass[2]; }
+      else if (!(new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)")).test(output[prop]))
+        { output[prop] += " " + lineClass[2]; }
+    } }
+    return type
+  }
+
+  // Run the given mode's parser over a line, calling f for each token.
+  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
+    var flattenSpans = mode.flattenSpans;
+    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
+    var curStart = 0, curStyle = null;
+    var stream = new StringStream(text, cm.options.tabSize, context), style;
+    var inner = cm.options.addModeClass && [null];
+    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
+    while (!stream.eol()) {
+      if (stream.pos > cm.options.maxHighlightLength) {
+        flattenSpans = false;
+        if (forceToEnd) { processLine(cm, text, context, stream.pos); }
+        stream.pos = text.length;
+        style = null;
+      } else {
+        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
       }
-      signal(cm, override || e.type, cm, e);
-      return e_defaultPrevented(e) || e.codemirrorIgnore;
-    }
-    function signalCursorActivity(cm) {
-      var arr = cm._handlers && cm._handlers.cursorActivity;
-      if (!arr) {
-        return;
+      if (inner) {
+        var mName = inner[0].name;
+        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
       }
-      var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
-      for (var i2 = 0; i2 < arr.length; ++i2) {
-        if (indexOf(set, arr[i2]) == -1) {
-          set.push(arr[i2]);
+      if (!flattenSpans || curStyle != style) {
+        while (curStart < stream.start) {
+          curStart = Math.min(stream.start, curStart + 5000);
+          f(curStart, curStyle);
         }
+        curStyle = style;
       }
+      stream.start = stream.pos;
     }
-    function hasHandler(emitter, type) {
-      return getHandlers(emitter, type).length > 0;
-    }
-    function eventMixin(ctor) {
-      ctor.prototype.on = function(type, f) {
-        on(this, type, f);
-      };
-      ctor.prototype.off = function(type, f) {
-        off(this, type, f);
-      };
-    }
-    function e_preventDefault(e) {
-      if (e.preventDefault) {
-        e.preventDefault();
-      } else {
-        e.returnValue = false;
-      }
-    }
-    function e_stopPropagation(e) {
-      if (e.stopPropagation) {
-        e.stopPropagation();
-      } else {
-        e.cancelBubble = true;
-      }
+    while (curStart < stream.pos) {
+      // Webkit seems to refuse to render text nodes longer than 57444
+      // characters, and returns inaccurate measurements in nodes
+      // starting around 5000 chars.
+      var pos = Math.min(stream.pos, curStart + 5000);
+      f(pos, curStyle);
+      curStart = pos;
     }
-    function e_defaultPrevented(e) {
-      return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
+  }
+
+  // Finds the line to start with when starting a parse. Tries to
+  // find a line with a stateAfter, so that it can start with a
+  // valid state. If that fails, it returns the line with the
+  // smallest indentation, which tends to need the least context to
+  // parse correctly.
+  function findStartLine(cm, n, precise) {
+    var minindent, minline, doc = cm.doc;
+    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
+    for (var search = n; search > lim; --search) {
+      if (search <= doc.first) { return doc.first }
+      var line = getLine(doc, search - 1), after = line.stateAfter;
+      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
+        { return search }
+      var indented = countColumn(line.text, null, cm.options.tabSize);
+      if (minline == null || minindent > indented) {
+        minline = search - 1;
+        minindent = indented;
+      }
+    }
+    return minline
+  }
+
+  function retreatFrontier(doc, n) {
+    doc.modeFrontier = Math.min(doc.modeFrontier, n);
+    if (doc.highlightFrontier < n - 10) { return }
+    var start = doc.first;
+    for (var line = n - 1; line > start; line--) {
+      var saved = getLine(doc, line).stateAfter;
+      // change is on 3
+      // state on line 1 looked ahead 2 -- so saw 3
+      // test 1 + 2 < 3 should cover this
+      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
+        start = line + 1;
+        break
+      }
+    }
+    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
+  }
+
+  // Optimize some code when these features are not used.
+  var sawReadOnlySpans = false, sawCollapsedSpans = false;
+
+  function seeReadOnlySpans() {
+    sawReadOnlySpans = true;
+  }
+
+  function seeCollapsedSpans() {
+    sawCollapsedSpans = true;
+  }
+
+  // TEXTMARKER SPANS
+
+  function MarkedSpan(marker, from, to) {
+    this.marker = marker;
+    this.from = from; this.to = to;
+  }
+
+  // Search an array of spans for a span matching the given marker.
+  function getMarkedSpanFor(spans, marker) {
+    if (spans) { for (var i = 0; i < spans.length; ++i) {
+      var span = spans[i];
+      if (span.marker == marker) { return span }
+    } }
+  }
+
+  // Remove a span from an array, returning undefined if no spans are
+  // left (we don't store arrays for lines without spans).
+  function removeMarkedSpan(spans, span) {
+    var r;
+    for (var i = 0; i < spans.length; ++i)
+      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
+    return r
+  }
+
+  // Add a span to a line.
+  function addMarkedSpan(line, span, op) {
+    var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet));
+    if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {
+      line.markedSpans.push(span);
+    } else {
+      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
+      if (inThisOp) { inThisOp.add(line.markedSpans); }
     }
-    function e_stop(e) {
-      e_preventDefault(e);
-      e_stopPropagation(e);
-    }
-    function e_target(e) {
-      return e.target || e.srcElement;
-    }
-    function e_button(e) {
-      var b = e.which;
-      if (b == null) {
-        if (e.button & 1) {
-          b = 1;
-        } else if (e.button & 2) {
-          b = 3;
-        } else if (e.button & 4) {
-          b = 2;
+    span.marker.attachLine(line);
+  }
+
+  // Used for the algorithm that adjusts markers for a change in the
+  // document. These functions cut an array of spans at a given
+  // character position, returning an array of remaining chunks (or
+  // undefined if nothing remains).
+  function markedSpansBefore(old, startCh, isInsert) {
+    var nw;
+    if (old) { for (var i = 0; i < old.length; ++i) {
+      var span = old[i], marker = span.marker;
+      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
+      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
+        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
+        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
+      }
+    } }
+    return nw
+  }
+  function markedSpansAfter(old, endCh, isInsert) {
+    var nw;
+    if (old) { for (var i = 0; i < old.length; ++i) {
+      var span = old[i], marker = span.marker;
+      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
+      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
+        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
+        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
+                                              span.to == null ? null : span.to - endCh));
+      }
+    } }
+    return nw
+  }
+
+  // Given a change object, compute the new set of marker spans that
+  // cover the line in which the change took place. Removes spans
+  // entirely within the change, reconnects spans belonging to the
+  // same marker that appear on both sides of the change, and cuts off
+  // spans partially within the change. Returns an array of span
+  // arrays with one element for each line in (after) the change.
+  function stretchSpansOverChange(doc, change) {
+    if (change.full) { return null }
+    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
+    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
+    if (!oldFirst && !oldLast) { return null }
+
+    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
+    // Get the spans that 'stick out' on both sides
+    var first = markedSpansBefore(oldFirst, startCh, isInsert);
+    var last = markedSpansAfter(oldLast, endCh, isInsert);
+
+    // Next, merge those two ends
+    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
+    if (first) {
+      // Fix up .to properties of first
+      for (var i = 0; i < first.length; ++i) {
+        var span = first[i];
+        if (span.to == null) {
+          var found = getMarkedSpanFor(last, span.marker);
+          if (!found) { span.to = startCh; }
+          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
+        }
+      }
+    }
+    if (last) {
+      // Fix up .from in last (or move them into first in case of sameLine)
+      for (var i$1 = 0; i$1 < last.length; ++i$1) {
+        var span$1 = last[i$1];
+        if (span$1.to != null) { span$1.to += offset; }
+        if (span$1.from == null) {
+          var found$1 = getMarkedSpanFor(first, span$1.marker);
+          if (!found$1) {
+            span$1.from = offset;
+            if (sameLine) { (first || (first = [])).push(span$1); }
+          }
+        } else {
+          span$1.from += offset;
+          if (sameLine) { (first || (first = [])).push(span$1); }
         }
       }
-      if (mac && e.ctrlKey && b == 1) {
-        b = 3;
-      }
-      return b;
     }
-    var dragAndDrop = function() {
-      if (ie && ie_version < 9) {
-        return false;
-      }
-      var div = elt("div");
-      return "draggable" in div || "dragDrop" in div;
-    }();
-    var zwspSupported;
-    function zeroWidthElement(measure) {
-      if (zwspSupported == null) {
-        var test = elt("span", "\u200B");
-        removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
-        if (measure.firstChild.offsetHeight != 0) {
-          zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
-        }
-      }
-      var node = zwspSupported ? elt("span", "\u200B") : elt("span", "\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");
-      node.setAttribute("cm-text", "");
-      return node;
+    // Make sure we didn't create any zero-length spans
+    if (first) { first = clearEmptySpans(first); }
+    if (last && last != first) { last = clearEmptySpans(last); }
+
+    var newMarkers = [first];
+    if (!sameLine) {
+      // Fill gap with whole-line-spans
+      var gap = change.text.length - 2, gapMarkers;
+      if (gap > 0 && first)
+        { for (var i$2 = 0; i$2 < first.length; ++i$2)
+          { if (first[i$2].to == null)
+            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
+      for (var i$3 = 0; i$3 < gap; ++i$3)
+        { newMarkers.push(gapMarkers); }
+      newMarkers.push(last);
+    }
+    return newMarkers
+  }
+
+  // Remove spans that are empty and don't have a clearWhenEmpty
+  // option of false.
+  function clearEmptySpans(spans) {
+    for (var i = 0; i < spans.length; ++i) {
+      var span = spans[i];
+      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
+        { spans.splice(i--, 1); }
     }
-    var badBidiRects;
-    function hasBadBidiRects(measure) {
-      if (badBidiRects != null) {
-        return badBidiRects;
-      }
-      var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062EA"));
-      var r0 = range(txt, 0, 1).getBoundingClientRect();
-      var r1 = range(txt, 1, 2).getBoundingClientRect();
-      removeChildren(measure);
-      if (!r0 || r0.left == r0.right) {
-        return false;
-      }
-      return badBidiRects = r1.right - r0.right < 3;
+    if (!spans.length) { return null }
+    return spans
+  }
+
+  // Used to 'clip' out readOnly ranges when making a change.
+  function removeReadOnlyRanges(doc, from, to) {
+    var markers = null;
+    doc.iter(from.line, to.line + 1, function (line) {
+      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
+        var mark = line.markedSpans[i].marker;
+        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
+          { (markers || (markers = [])).push(mark); }
+      } }
+    });
+    if (!markers) { return null }
+    var parts = [{from: from, to: to}];
+    for (var i = 0; i < markers.length; ++i) {
+      var mk = markers[i], m = mk.find(0);
+      for (var j = 0; j < parts.length; ++j) {
+        var p = parts[j];
+        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
+        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
+        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
+          { newParts.push({from: p.from, to: m.from}); }
+        if (dto > 0 || !mk.inclusiveRight && !dto)
+          { newParts.push({from: m.to, to: p.to}); }
+        parts.splice.apply(parts, newParts);
+        j += newParts.length - 3;
+      }
+    }
+    return parts
+  }
+
+  // Connect or disconnect spans from a line.
+  function detachMarkedSpans(line) {
+    var spans = line.markedSpans;
+    if (!spans) { return }
+    for (var i = 0; i < spans.length; ++i)
+      { spans[i].marker.detachLine(line); }
+    line.markedSpans = null;
+  }
+  function attachMarkedSpans(line, spans) {
+    if (!spans) { return }
+    for (var i = 0; i < spans.length; ++i)
+      { spans[i].marker.attachLine(line); }
+    line.markedSpans = spans;
+  }
+
+  // Helpers used when computing which overlapping collapsed span
+  // counts as the larger one.
+  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
+  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }
+
+  // Returns a number indicating which of two overlapping collapsed
+  // spans is larger (and thus includes the other). Falls back to
+  // comparing ids when the spans cover exactly the same range.
+  function compareCollapsedMarkers(a, b) {
+    var lenDiff = a.lines.length - b.lines.length;
+    if (lenDiff != 0) { return lenDiff }
+    var aPos = a.find(), bPos = b.find();
+    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
+    if (fromCmp) { return -fromCmp }
+    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
+    if (toCmp) { return toCmp }
+    return b.id - a.id
+  }
+
+  // Find out whether a line ends or starts in a collapsed span. If
+  // so, return the marker for that span.
+  function collapsedSpanAtSide(line, start) {
+    var sps = sawCollapsedSpans && line.markedSpans, found;
+    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
+      sp = sps[i];
+      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
+          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
+        { found = sp.marker; }
+    } }
+    return found
+  }
+  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
+  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }
+
+  function collapsedSpanAround(line, ch) {
+    var sps = sawCollapsedSpans && line.markedSpans, found;
+    if (sps) { for (var i = 0; i < sps.length; ++i) {
+      var sp = sps[i];
+      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
+          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
+    } }
+    return found
+  }
+
+  // Test whether there exists a collapsed span that partially
+  // overlaps (covers the start or end, but not both) of a new span.
+  // Such overlap is not allowed.
+  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
+    var line = getLine(doc, lineNo);
+    var sps = sawCollapsedSpans && line.markedSpans;
+    if (sps) { for (var i = 0; i < sps.length; ++i) {
+      var sp = sps[i];
+      if (!sp.marker.collapsed) { continue }
+      var found = sp.marker.find(0);
+      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
+      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
+      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
+      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
+          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
+        { return true }
+    } }
+  }
+
+  // A visual line is a line as drawn on the screen. Folding, for
+  // example, can cause multiple logical lines to appear on the same
+  // visual line. This finds the start of the visual line that the
+  // given line is part of (usually that is the line itself).
+  function visualLine(line) {
+    var merged;
+    while (merged = collapsedSpanAtStart(line))
+      { line = merged.find(-1, true).line; }
+    return line
+  }
+
+  function visualLineEnd(line) {
+    var merged;
+    while (merged = collapsedSpanAtEnd(line))
+      { line = merged.find(1, true).line; }
+    return line
+  }
+
+  // Returns an array of logical lines that continue the visual line
+  // started by the argument, or undefined if there are no such lines.
+  function visualLineContinued(line) {
+    var merged, lines;
+    while (merged = collapsedSpanAtEnd(line)) {
+      line = merged.find(1, true).line
+      ;(lines || (lines = [])).push(line);
     }
-    var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function(string) {
-      var pos = 0, result = [], l = string.length;
-      while (pos <= l) {
-        var nl = string.indexOf("\n", pos);
-        if (nl == -1) {
-          nl = string.length;
-        }
-        var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
-        var rt = line.indexOf("\r");
-        if (rt != -1) {
-          result.push(line.slice(0, rt));
-          pos += rt + 1;
-        } else {
-          result.push(line);
-          pos = nl + 1;
-        }
-      }
-      return result;
-    } : function(string) {
-      return string.split(/\r\n?|\n/);
-    };
-    var hasSelection = window.getSelection ? function(te) {
-      try {
-        return te.selectionStart != te.selectionEnd;
-      } catch (e) {
-        return false;
-      }
-    } : function(te) {
-      var range2;
-      try {
-        range2 = te.ownerDocument.selection.createRange();
-      } catch (e) {
-      }
-      if (!range2 || range2.parentElement() != te) {
-        return false;
-      }
-      return range2.compareEndPoints("StartToEnd", range2) != 0;
-    };
-    var hasCopyEvent = function() {
-      var e = elt("div");
-      if ("oncopy" in e) {
-        return true;
-      }
-      e.setAttribute("oncopy", "return;");
-      return typeof e.oncopy == "function";
-    }();
-    var badZoomedRects = null;
-    function hasBadZoomedRects(measure) {
-      if (badZoomedRects != null) {
-        return badZoomedRects;
-      }
-      var node = removeChildrenAndAdd(measure, elt("span", "x"));
-      var normal = node.getBoundingClientRect();
-      var fromRange = range(node, 0, 1).getBoundingClientRect();
-      return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
-    }
-    var modes = {}, mimeModes = {};
-    function defineMode(name, mode) {
-      if (arguments.length > 2) {
-        mode.dependencies = Array.prototype.slice.call(arguments, 2);
-      }
-      modes[name] = mode;
-    }
-    function defineMIME(mime, spec) {
-      mimeModes[mime] = spec;
-    }
-    function resolveMode(spec) {
-      if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
-        spec = mimeModes[spec];
-      } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
-        var found = mimeModes[spec.name];
-        if (typeof found == "string") {
-          found = { name: found };
-        }
-        spec = createObj(found, spec);
-        spec.name = found.name;
-      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
-        return resolveMode("application/xml");
-      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
-        return resolveMode("application/json");
-      }
-      if (typeof spec == "string") {
-        return { name: spec };
-      } else {
-        return spec || { name: "null" };
-      }
+    return lines
+  }
+
+  // Get the line number of the start of the visual line that the
+  // given line number is part of.
+  function visualLineNo(doc, lineN) {
+    var line = getLine(doc, lineN), vis = visualLine(line);
+    if (line == vis) { return lineN }
+    return lineNo(vis)
+  }
+
+  // Get the line number of the start of the next visual line after
+  // the given line.
+  function visualLineEndNo(doc, lineN) {
+    if (lineN > doc.lastLine()) { return lineN }
+    var line = getLine(doc, lineN), merged;
+    if (!lineIsHidden(doc, line)) { return lineN }
+    while (merged = collapsedSpanAtEnd(line))
+      { line = merged.find(1, true).line; }
+    return lineNo(line) + 1
+  }
+
+  // Compute whether a line is hidden. Lines count as hidden when they
+  // are part of a visual line that starts with another line, or when
+  // they are entirely covered by collapsed, non-widget span.
+  function lineIsHidden(doc, line) {
+    var sps = sawCollapsedSpans && line.markedSpans;
+    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
+      sp = sps[i];
+      if (!sp.marker.collapsed) { continue }
+      if (sp.from == null) { return true }
+      if (sp.marker.widgetNode) { continue }
+      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
+        { return true }
+    } }
+  }
+  function lineIsHiddenInner(doc, line, span) {
+    if (span.to == null) {
+      var end = span.marker.find(1, true);
+      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
+    }
+    if (span.marker.inclusiveRight && span.to == line.text.length)
+      { return true }
+    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
+      sp = line.markedSpans[i];
+      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
+          (sp.to == null || sp.to != span.from) &&
+          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
+          lineIsHiddenInner(doc, line, sp)) { return true }
+    }
+  }
+
+  // Find the height above the given line.
+  function heightAtLine(lineObj) {
+    lineObj = visualLine(lineObj);
+
+    var h = 0, chunk = lineObj.parent;
+    for (var i = 0; i < chunk.lines.length; ++i) {
+      var line = chunk.lines[i];
+      if (line == lineObj) { break }
+      else { h += line.height; }
     }
-    function getMode(options, spec) {
-      spec = resolveMode(spec);
-      var mfactory = modes[spec.name];
-      if (!mfactory) {
-        return getMode(options, "text/plain");
+    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
+      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
+        var cur = p.children[i$1];
+        if (cur == chunk) { break }
+        else { h += cur.height; }
       }
-      var modeObj = mfactory(options, spec);
-      if (modeExtensions.hasOwnProperty(spec.name)) {
-        var exts = modeExtensions[spec.name];
-        for (var prop2 in exts) {
-          if (!exts.hasOwnProperty(prop2)) {
-            continue;
-          }
-          if (modeObj.hasOwnProperty(prop2)) {
-            modeObj["_" + prop2] = modeObj[prop2];
-          }
-          modeObj[prop2] = exts[prop2];
-        }
+    }
+    return h
+  }
+
+  // Compute the character length of a line, taking into account
+  // collapsed ranges (see markText) that might hide parts, and join
+  // other lines onto it.
+  function lineLength(line) {
+    if (line.height == 0) { return 0 }
+    var len = line.text.length, merged, cur = line;
+    while (merged = collapsedSpanAtStart(cur)) {
+      var found = merged.find(0, true);
+      cur = found.from.line;
+      len += found.from.ch - found.to.ch;
+    }
+    cur = line;
+    while (merged = collapsedSpanAtEnd(cur)) {
+      var found$1 = merged.find(0, true);
+      len -= cur.text.length - found$1.from.ch;
+      cur = found$1.to.line;
+      len += cur.text.length - found$1.to.ch;
+    }
+    return len
+  }
+
+  // Find the longest line in the document.
+  function findMaxLine(cm) {
+    var d = cm.display, doc = cm.doc;
+    d.maxLine = getLine(doc, doc.first);
+    d.maxLineLength = lineLength(d.maxLine);
+    d.maxLineChanged = true;
+    doc.iter(function (line) {
+      var len = lineLength(line);
+      if (len > d.maxLineLength) {
+        d.maxLineLength = len;
+        d.maxLine = line;
       }
-      modeObj.name = spec.name;
-      if (spec.helperType) {
-        modeObj.helperType = spec.helperType;
+    });
+  }
+
+  // LINE DATA STRUCTURE
+
+  // Line objects. These hold state related to a line, including
+  // highlighting info (the styles array).
+  var Line = function(text, markedSpans, estimateHeight) {
+    this.text = text;
+    attachMarkedSpans(this, markedSpans);
+    this.height = estimateHeight ? estimateHeight(this) : 1;
+  };
+
+  Line.prototype.lineNo = function () { return lineNo(this) };
+  eventMixin(Line);
+
+  // Change the content (text, markers) of a line. Automatically
+  // invalidates cached information and tries to re-estimate the
+  // line's height.
+  function updateLine(line, text, markedSpans, estimateHeight) {
+    line.text = text;
+    if (line.stateAfter) { line.stateAfter = null; }
+    if (line.styles) { line.styles = null; }
+    if (line.order != null) { line.order = null; }
+    detachMarkedSpans(line);
+    attachMarkedSpans(line, markedSpans);
+    var estHeight = estimateHeight ? estimateHeight(line) : 1;
+    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
+  }
+
+  // Detach a line from the document tree and its markers.
+  function cleanUpLine(line) {
+    line.parent = null;
+    detachMarkedSpans(line);
+  }
+
+  // Convert a style as returned by a mode (either null, or a string
+  // containing one or more styles) to a CSS style. This is cached,
+  // and also looks for line-wide styles.
+  var styleToClassCache = {}, styleToClassCacheWithMode = {};
+  function interpretTokenStyle(style, options) {
+    if (!style || /^\s*$/.test(style)) { return null }
+    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
+    return cache[style] ||
+      (cache[style] = style.replace(/\S+/g, "cm-$&"))
+  }
+
+  // Render the DOM representation of the text of a line. Also builds
+  // up a 'line map', which points at the DOM nodes that represent
+  // specific stretches of text, and is used by the measuring code.
+  // The returned object contains the DOM node, this map, and
+  // information about line-wide styles that were set by the mode.
+  function buildLineContent(cm, lineView) {
+    // The padding-right forces the element to have a 'border', which
+    // is needed on Webkit to be able to get line-level bounding
+    // rectangles for it (in measureChar).
+    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
+    var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
+                   col: 0, pos: 0, cm: cm,
+                   trailingSpace: false,
+                   splitSpaces: cm.getOption("lineWrapping")};
+    lineView.measure = {};
+
+    // Iterate over the logical lines that make up this visual line.
+    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
+      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
+      builder.pos = 0;
+      builder.addToken = buildToken;
+      // Optionally wire in some hacks into the token-rendering
+      // algorithm, to deal with browser quirks.
+      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
+        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
+      builder.map = [];
+      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
+      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
+      if (line.styleClasses) {
+        if (line.styleClasses.bgClass)
+          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
+        if (line.styleClasses.textClass)
+          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
       }
-      if (spec.modeProps) {
-        for (var prop$1 in spec.modeProps) {
-          modeObj[prop$1] = spec.modeProps[prop$1];
-        }
+
+      // Ensure at least a single node is present, for measuring.
+      if (builder.map.length == 0)
+        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }
+
+      // Store the map and a cache object for the current logical line
+      if (i == 0) {
+        lineView.measure.map = builder.map;
+        lineView.measure.cache = {};
+      } else {
+  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
+        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
       }
-      return modeObj;
     }
-    var modeExtensions = {};
-    function extendMode(mode, properties) {
-      var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
-      copyObj(properties, exts);
+
+    // See issue #2901
+    if (webkit) {
+      var last = builder.content.lastChild;
+      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
+        { builder.content.className = "cm-tab-wrap-hack"; }
     }
-    function copyState(mode, state2) {
-      if (state2 === true) {
-        return state2;
-      }
-      if (mode.copyState) {
-        return mode.copyState(state2);
-      }
-      var nstate = {};
-      for (var n in state2) {
-        var val = state2[n];
-        if (val instanceof Array) {
-          val = val.concat([]);
+
+    signal(cm, "renderLine", cm, lineView.line, builder.pre);
+    if (builder.pre.className)
+      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }
+
+    return builder
+  }
+
+  function defaultSpecialCharPlaceholder(ch) {
+    var token = elt("span", "\u2022", "cm-invalidchar");
+    token.title = "\\u" + ch.charCodeAt(0).toString(16);
+    token.setAttribute("aria-label", token.title);
+    return token
+  }
+
+  // Build up the DOM representation for a single token, and add it to
+  // the line map. Takes care to render special characters separately.
+  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
+    if (!text) { return }
+    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
+    var special = builder.cm.state.specialChars, mustWrap = false;
+    var content;
+    if (!special.test(text)) {
+      builder.col += text.length;
+      content = document.createTextNode(displayText);
+      builder.map.push(builder.pos, builder.pos + text.length, content);
+      if (ie && ie_version < 9) { mustWrap = true; }
+      builder.pos += text.length;
+    } else {
+      content = document.createDocumentFragment();
+      var pos = 0;
+      while (true) {
+        special.lastIndex = pos;
+        var m = special.exec(text);
+        var skipped = m ? m.index - pos : text.length - pos;
+        if (skipped) {
+          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
+          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
+          else { content.appendChild(txt); }
+          builder.map.push(builder.pos, builder.pos + skipped, txt);
+          builder.col += skipped;
+          builder.pos += skipped;
+        }
+        if (!m) { break }
+        pos += skipped + 1;
+        var txt$1 = (void 0);
+        if (m[0] == "\t") {
+          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
+          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
+          txt$1.setAttribute("role", "presentation");
+          txt$1.setAttribute("cm-text", "\t");
+          builder.col += tabWidth;
+        } else if (m[0] == "\r" || m[0] == "\n") {
+          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
+          txt$1.setAttribute("cm-text", m[0]);
+          builder.col += 1;
+        } else {
+          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
+          txt$1.setAttribute("cm-text", m[0]);
+          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
+          else { content.appendChild(txt$1); }
+          builder.col += 1;
         }
-        nstate[n] = val;
+        builder.map.push(builder.pos, builder.pos + 1, txt$1);
+        builder.pos++;
       }
-      return nstate;
     }
-    function innerMode(mode, state2) {
-      var info;
-      while (mode.innerMode) {
-        info = mode.innerMode(state2);
-        if (!info || info.mode == mode) {
-          break;
-        }
-        state2 = info.state;
-        mode = info.mode;
+    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
+    if (style || startStyle || endStyle || mustWrap || css || attributes) {
+      var fullStyle = style || "";
+      if (startStyle) { fullStyle += startStyle; }
+      if (endStyle) { fullStyle += endStyle; }
+      var token = elt("span", [content], fullStyle, css);
+      if (attributes) {
+        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
+          { token.setAttribute(attr, attributes[attr]); } }
       }
-      return info || { mode, state: state2 };
-    }
-    function startState(mode, a1, a2) {
-      return mode.startState ? mode.startState(a1, a2) : true;
+      return builder.content.appendChild(token)
     }
-    var StringStream = function(string, tabSize, lineOracle) {
-      this.pos = this.start = 0;
-      this.string = string;
-      this.tabSize = tabSize || 8;
-      this.lastColumnPos = this.lastColumnValue = 0;
-      this.lineStart = 0;
-      this.lineOracle = lineOracle;
-    };
-    StringStream.prototype.eol = function() {
-      return this.pos >= this.string.length;
-    };
-    StringStream.prototype.sol = function() {
-      return this.pos == this.lineStart;
-    };
-    StringStream.prototype.peek = function() {
-      return this.string.charAt(this.pos) || void 0;
-    };
-    StringStream.prototype.next = function() {
-      if (this.pos < this.string.length) {
-        return this.string.charAt(this.pos++);
-      }
-    };
-    StringStream.prototype.eat = function(match2) {
-      var ch = this.string.charAt(this.pos);
-      var ok;
-      if (typeof match2 == "string") {
-        ok = ch == match2;
-      } else {
-        ok = ch && (match2.test ? match2.test(ch) : match2(ch));
-      }
-      if (ok) {
-        ++this.pos;
-        return ch;
-      }
-    };
-    StringStream.prototype.eatWhile = function(match2) {
-      var start = this.pos;
-      while (this.eat(match2)) {
-      }
-      return this.pos > start;
-    };
-    StringStream.prototype.eatSpace = function() {
-      var start = this.pos;
-      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
-        ++this.pos;
-      }
-      return this.pos > start;
-    };
-    StringStream.prototype.skipToEnd = function() {
-      this.pos = this.string.length;
-    };
-    StringStream.prototype.skipTo = function(ch) {
-      var found = this.string.indexOf(ch, this.pos);
-      if (found > -1) {
-        this.pos = found;
-        return true;
-      }
-    };
-    StringStream.prototype.backUp = function(n) {
-      this.pos -= n;
-    };
-    StringStream.prototype.column = function() {
-      if (this.lastColumnPos < this.start) {
-        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
-        this.lastColumnPos = this.start;
-      }
-      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
-    };
-    StringStream.prototype.indentation = function() {
-      return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
-    };
-    StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
-      if (typeof pattern == "string") {
-        var cased = function(str) {
-          return caseInsensitive ? str.toLowerCase() : str;
-        };
-        var substr = this.string.substr(this.pos, pattern.length);
-        if (cased(substr) == cased(pattern)) {
-          if (consume !== false) {
-            this.pos += pattern.length;
-          }
-          return true;
-        }
-      } else {
-        var match2 = this.string.slice(this.pos).match(pattern);
-        if (match2 && match2.index > 0) {
-          return null;
-        }
-        if (match2 && consume !== false) {
-          this.pos += match2[0].length;
-        }
-        return match2;
-      }
-    };
-    StringStream.prototype.current = function() {
-      return this.string.slice(this.start, this.pos);
-    };
-    StringStream.prototype.hideFirstChars = function(n, inner) {
-      this.lineStart += n;
-      try {
-        return inner();
-      } finally {
-        this.lineStart -= n;
-      }
-    };
-    StringStream.prototype.lookAhead = function(n) {
-      var oracle = this.lineOracle;
-      return oracle && oracle.lookAhead(n);
-    };
-    StringStream.prototype.baseToken = function() {
-      var oracle = this.lineOracle;
-      return oracle && oracle.baseToken(this.pos);
-    };
-    function getLine(doc, n) {
-      n -= doc.first;
-      if (n < 0 || n >= doc.size) {
-        throw new Error("There is no line " + (n + doc.first) + " in the document.");
-      }
-      var chunk = doc;
-      while (!chunk.lines) {
-        for (var i2 = 0; ; ++i2) {
-          var child = chunk.children[i2], sz = child.chunkSize();
-          if (n < sz) {
-            chunk = child;
-            break;
-          }
-          n -= sz;
-        }
+    builder.content.appendChild(content);
+  }
+
+  // Change some spaces to NBSP to prevent the browser from collapsing
+  // trailing spaces at the end of a line when rendering text (issue #1362).
+  function splitSpaces(text, trailingBefore) {
+    if (text.length > 1 && !/  /.test(text)) { return text }
+    var spaceBefore = trailingBefore, result = "";
+    for (var i = 0; i < text.length; i++) {
+      var ch = text.charAt(i);
+      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
+        { ch = "\u00a0"; }
+      result += ch;
+      spaceBefore = ch == " ";
+    }
+    return result
+  }
+
+  // Work around nonsense dimensions being reported for stretches of
+  // right-to-left text.
+  function buildTokenBadBidi(inner, order) {
+    return function (builder, text, style, startStyle, endStyle, css, attributes) {
+      style = style ? style + " cm-force-border" : "cm-force-border";
+      var start = builder.pos, end = start + text.length;
+      for (;;) {
+        // Find the part that overlaps with the start of this text
+        var part = (void 0);
+        for (var i = 0; i < order.length; i++) {
+          part = order[i];
+          if (part.to > start && part.from <= start) { break }
+        }
+        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
+        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
+        startStyle = null;
+        text = text.slice(part.to - start);
+        start = part.to;
       }
-      return chunk.lines[n];
     }
-    function getBetween(doc, start, end) {
-      var out = [], n = start.line;
-      doc.iter(start.line, end.line + 1, function(line) {
-        var text = line.text;
-        if (n == end.line) {
-          text = text.slice(0, end.ch);
-        }
-        if (n == start.line) {
-          text = text.slice(start.ch);
-        }
-        out.push(text);
-        ++n;
-      });
-      return out;
+  }
+
+  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
+    var widget = !ignoreWidget && marker.widgetNode;
+    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
+    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
+      if (!widget)
+        { widget = builder.content.appendChild(document.createElement("span")); }
+      widget.setAttribute("cm-marker", marker.id);
     }
-    function getLines(doc, from, to) {
-      var out = [];
-      doc.iter(from, to, function(line) {
-        out.push(line.text);
-      });
-      return out;
+    if (widget) {
+      builder.cm.display.input.setUneditable(widget);
+      builder.content.appendChild(widget);
     }
-    function updateLineHeight(line, height) {
-      var diff = height - line.height;
-      if (diff) {
-        for (var n = line; n; n = n.parent) {
-          n.height += diff;
-        }
-      }
+    builder.pos += size;
+    builder.trailingSpace = false;
+  }
+
+  // Outputs a number of spans to make up a line, taking highlighting
+  // and marked text into account.
+  function insertLineContent(line, builder, styles) {
+    var spans = line.markedSpans, allText = line.text, at = 0;
+    if (!spans) {
+      for (var i$1 = 1; i$1 < styles.length; i$1+=2)
+        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
+      return
     }
-    function lineNo(line) {
-      if (line.parent == null) {
-        return null;
-      }
-      var cur = line.parent, no = indexOf(cur.lines, line);
-      for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
-        for (var i2 = 0; ; ++i2) {
-          if (chunk.children[i2] == cur) {
-            break;
+
+    var len = allText.length, pos = 0, i = 1, text = "", style, css;
+    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
+    for (;;) {
+      if (nextChange == pos) { // Update current marker set
+        spanStyle = spanEndStyle = spanStartStyle = css = "";
+        attributes = null;
+        collapsed = null; nextChange = Infinity;
+        var foundBookmarks = [], endStyles = (void 0);
+        for (var j = 0; j < spans.length; ++j) {
+          var sp = spans[j], m = sp.marker;
+          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
+            foundBookmarks.push(m);
+          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
+            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
+              nextChange = sp.to;
+              spanEndStyle = "";
+            }
+            if (m.className) { spanStyle += " " + m.className; }
+            if (m.css) { css = (css ? css + ";" : "") + m.css; }
+            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
+            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
+            // support for the old title property
+            // https://github.com/codemirror/CodeMirror/pull/5673
+            if (m.title) { (attributes || (attributes = {})).title = m.title; }
+            if (m.attributes) {
+              for (var attr in m.attributes)
+                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
+            }
+            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
+              { collapsed = sp; }
+          } else if (sp.from > pos && nextChange > sp.from) {
+            nextChange = sp.from;
           }
-          no += chunk.children[i2].chunkSize();
+        }
+        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
+          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }
+
+        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
+          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
+        if (collapsed && (collapsed.from || 0) == pos) {
+          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
+                             collapsed.marker, collapsed.from == null);
+          if (collapsed.to == null) { return }
+          if (collapsed.to == pos) { collapsed = false; }
         }
       }
-      return no + cur.first;
-    }
-    function lineAtHeight(chunk, h) {
-      var n = chunk.first;
-      outer:
-        do {
-          for (var i$12 = 0; i$12 < chunk.children.length; ++i$12) {
-            var child = chunk.children[i$12], ch = child.height;
-            if (h < ch) {
-              chunk = child;
-              continue outer;
-            }
-            h -= ch;
-            n += child.chunkSize();
+      if (pos >= len) { break }
+
+      var upto = Math.min(len, nextChange);
+      while (true) {
+        if (text) {
+          var end = pos + text.length;
+          if (!collapsed) {
+            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
+            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
+                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
           }
-          return n;
-        } while (!chunk.lines);
-      var i2 = 0;
-      for (; i2 < chunk.lines.length; ++i2) {
-        var line = chunk.lines[i2], lh = line.height;
-        if (h < lh) {
-          break;
+          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
+          pos = end;
+          spanStartStyle = "";
         }
-        h -= lh;
+        text = allText.slice(at, at = styles[i++]);
+        style = interpretTokenStyle(styles[i++], builder.cm.options);
       }
-      return n + i2;
     }
-    function isLine(doc, l) {
-      return l >= doc.first && l < doc.first + doc.size;
+  }
+
+
+  // These objects are used to represent the visible (currently drawn)
+  // part of the document. A LineView may correspond to multiple
+  // logical lines, if those are connected by collapsed ranges.
+  function LineView(doc, line, lineN) {
+    // The starting line
+    this.line = line;
+    // Continuing lines, if any
+    this.rest = visualLineContinued(line);
+    // Number of logical lines in this visual line
+    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
+    this.node = this.text = null;
+    this.hidden = lineIsHidden(doc, line);
+  }
+
+  // Create a range of LineView objects for the given lines.
+  function buildViewArray(cm, from, to) {
+    var array = [], nextPos;
+    for (var pos = from; pos < to; pos = nextPos) {
+      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
+      nextPos = pos + view.size;
+      array.push(view);
     }
-    function lineNumberFor(options, i2) {
-      return String(options.lineNumberFormatter(i2 + options.firstLineNumber));
+    return array
+  }
+
+  var operationGroup = null;
+
+  function pushOperation(op) {
+    if (operationGroup) {
+      operationGroup.ops.push(op);
+    } else {
+      op.ownsGroup = operationGroup = {
+        ops: [op],
+        delayedCallbacks: []
+      };
     }
-    function Pos(line, ch, sticky) {
-      if (sticky === void 0)
-        sticky = null;
-      if (!(this instanceof Pos)) {
-        return new Pos(line, ch, sticky);
+  }
+
+  function fireCallbacksForOps(group) {
+    // Calls delayed callbacks and cursorActivity handlers until no
+    // new ones appear
+    var callbacks = group.delayedCallbacks, i = 0;
+    do {
+      for (; i < callbacks.length; i++)
+        { callbacks[i].call(null); }
+      for (var j = 0; j < group.ops.length; j++) {
+        var op = group.ops[j];
+        if (op.cursorActivityHandlers)
+          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
+            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
       }
-      this.line = line;
-      this.ch = ch;
-      this.sticky = sticky;
+    } while (i < callbacks.length)
+  }
+
+  function finishOperation(op, endCb) {
+    var group = op.ownsGroup;
+    if (!group) { return }
+
+    try { fireCallbacksForOps(group); }
+    finally {
+      operationGroup = null;
+      endCb(group);
     }
-    function cmp(a, b) {
-      return a.line - b.line || a.ch - b.ch;
+  }
+
+  var orphanDelayedCallbacks = null;
+
+  // Often, we want to signal events at a point where we are in the
+  // middle of some work, but don't want the handler to start calling
+  // other methods on the editor, which might be in an inconsistent
+  // state or simply not expect any other events to happen.
+  // signalLater looks whether there are any handlers, and schedules
+  // them to be executed when the last operation ends, or, if no
+  // operation is active, when a timeout fires.
+  function signalLater(emitter, type /*, values...*/) {
+    var arr = getHandlers(emitter, type);
+    if (!arr.length) { return }
+    var args = Array.prototype.slice.call(arguments, 2), list;
+    if (operationGroup) {
+      list = operationGroup.delayedCallbacks;
+    } else if (orphanDelayedCallbacks) {
+      list = orphanDelayedCallbacks;
+    } else {
+      list = orphanDelayedCallbacks = [];
+      setTimeout(fireOrphanDelayed, 0);
     }
-    function equalCursorPos(a, b) {
-      return a.sticky == b.sticky && cmp(a, b) == 0;
+    var loop = function ( i ) {
+      list.push(function () { return arr[i].apply(null, args); });
+    };
+
+    for (var i = 0; i < arr.length; ++i)
+      loop( i );
+  }
+
+  function fireOrphanDelayed() {
+    var delayed = orphanDelayedCallbacks;
+    orphanDelayedCallbacks = null;
+    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
+  }
+
+  // When an aspect of a line changes, a string is added to
+  // lineView.changes. This updates the relevant part of the line's
+  // DOM structure.
+  function updateLineForChanges(cm, lineView, lineN, dims) {
+    for (var j = 0; j < lineView.changes.length; j++) {
+      var type = lineView.changes[j];
+      if (type == "text") { updateLineText(cm, lineView); }
+      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
+      else if (type == "class") { updateLineClasses(cm, lineView); }
+      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
+    }
+    lineView.changes = null;
+  }
+
+  // Lines with gutter elements, widgets or a background class need to
+  // be wrapped, and have the extra elements added to the wrapper div
+  function ensureLineWrapped(lineView) {
+    if (lineView.node == lineView.text) {
+      lineView.node = elt("div", null, null, "position: relative");
+      if (lineView.text.parentNode)
+        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
+      lineView.node.appendChild(lineView.text);
+      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
+    }
+    return lineView.node
+  }
+
+  function updateLineBackground(cm, lineView) {
+    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
+    if (cls) { cls += " CodeMirror-linebackground"; }
+    if (lineView.background) {
+      if (cls) { lineView.background.className = cls; }
+      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
+    } else if (cls) {
+      var wrap = ensureLineWrapped(lineView);
+      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
+      cm.display.input.setUneditable(lineView.background);
     }
-    function copyPos(x) {
-      return Pos(x.line, x.ch);
+  }
+
+  // Wrapper around buildLineContent which will reuse the structure
+  // in display.externalMeasured when possible.
+  function getLineContent(cm, lineView) {
+    var ext = cm.display.externalMeasured;
+    if (ext && ext.line == lineView.line) {
+      cm.display.externalMeasured = null;
+      lineView.measure = ext.measure;
+      return ext.built
     }
-    function maxPos(a, b) {
-      return cmp(a, b) < 0 ? b : a;
+    return buildLineContent(cm, lineView)
+  }
+
+  // Redraw the line's text. Interacts with the background and text
+  // classes because the mode may output tokens that influence these
+  // classes.
+  function updateLineText(cm, lineView) {
+    var cls = lineView.text.className;
+    var built = getLineContent(cm, lineView);
+    if (lineView.text == lineView.node) { lineView.node = built.pre; }
+    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
+    lineView.text = built.pre;
+    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
+      lineView.bgClass = built.bgClass;
+      lineView.textClass = built.textClass;
+      updateLineClasses(cm, lineView);
+    } else if (cls) {
+      lineView.text.className = cls;
     }
-    function minPos(a, b) {
-      return cmp(a, b) < 0 ? a : b;
+  }
+
+  function updateLineClasses(cm, lineView) {
+    updateLineBackground(cm, lineView);
+    if (lineView.line.wrapClass)
+      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
+    else if (lineView.node != lineView.text)
+      { lineView.node.className = ""; }
+    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
+    lineView.text.className = textClass || "";
+  }
+
+  function updateLineGutter(cm, lineView, lineN, dims) {
+    if (lineView.gutter) {
+      lineView.node.removeChild(lineView.gutter);
+      lineView.gutter = null;
     }
-    function clipLine(doc, n) {
-      return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
+    if (lineView.gutterBackground) {
+      lineView.node.removeChild(lineView.gutterBackground);
+      lineView.gutterBackground = null;
     }
-    function clipPos(doc, pos) {
-      if (pos.line < doc.first) {
-        return Pos(doc.first, 0);
-      }
-      var last = doc.first + doc.size - 1;
-      if (pos.line > last) {
-        return Pos(last, getLine(doc, last).text.length);
-      }
-      return clipToLen(pos, getLine(doc, pos.line).text.length);
+    if (lineView.line.gutterClass) {
+      var wrap = ensureLineWrapped(lineView);
+      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
+                                      ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
+      cm.display.input.setUneditable(lineView.gutterBackground);
+      wrap.insertBefore(lineView.gutterBackground, lineView.text);
+    }
+    var markers = lineView.line.gutterMarkers;
+    if (cm.options.lineNumbers || markers) {
+      var wrap$1 = ensureLineWrapped(lineView);
+      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
+      gutterWrap.setAttribute("aria-hidden", "true");
+      cm.display.input.setUneditable(gutterWrap);
+      wrap$1.insertBefore(gutterWrap, lineView.text);
+      if (lineView.line.gutterClass)
+        { gutterWrap.className += " " + lineView.line.gutterClass; }
+      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
+        { lineView.lineNumber = gutterWrap.appendChild(
+          elt("div", lineNumberFor(cm.options, lineN),
+              "CodeMirror-linenumber CodeMirror-gutter-elt",
+              ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
+      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
+        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
+        if (found)
+          { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
+                                     ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
+      } }
     }
-    function clipToLen(pos, linelen) {
-      var ch = pos.ch;
-      if (ch == null || ch > linelen) {
-        return Pos(pos.line, linelen);
-      } else if (ch < 0) {
-        return Pos(pos.line, 0);
-      } else {
-        return pos;
-      }
+  }
+
+  function updateLineWidgets(cm, lineView, dims) {
+    if (lineView.alignable) { lineView.alignable = null; }
+    var isWidget = classTest("CodeMirror-linewidget");
+    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
+      next = node.nextSibling;
+      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }
     }
-    function clipPosArray(doc, array) {
-      var out = [];
-      for (var i2 = 0; i2 < array.length; i2++) {
-        out[i2] = clipPos(doc, array[i2]);
-      }
-      return out;
+    insertLineWidgets(cm, lineView, dims);
+  }
+
+  // Build a line's DOM representation from scratch
+  function buildLineElement(cm, lineView, lineN, dims) {
+    var built = getLineContent(cm, lineView);
+    lineView.text = lineView.node = built.pre;
+    if (built.bgClass) { lineView.bgClass = built.bgClass; }
+    if (built.textClass) { lineView.textClass = built.textClass; }
+
+    updateLineClasses(cm, lineView);
+    updateLineGutter(cm, lineView, lineN, dims);
+    insertLineWidgets(cm, lineView, dims);
+    return lineView.node
+  }
+
+  // A lineView may contain multiple logical lines (when merged by
+  // collapsed spans). The widgets for all of them need to be drawn.
+  function insertLineWidgets(cm, lineView, dims) {
+    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
+    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
+      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
+  }
+
+  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
+    if (!line.widgets) { return }
+    var wrap = ensureLineWrapped(lineView);
+    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
+      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
+      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
+      positionLineWidget(widget, node, lineView, dims);
+      cm.display.input.setUneditable(node);
+      if (allowAbove && widget.above)
+        { wrap.insertBefore(node, lineView.gutter || lineView.text); }
+      else
+        { wrap.appendChild(node); }
+      signalLater(widget, "redraw");
     }
-    var SavedContext = function(state2, lookAhead) {
-      this.state = state2;
-      this.lookAhead = lookAhead;
-    };
-    var Context = function(doc, state2, line, lookAhead) {
-      this.state = state2;
-      this.doc = doc;
-      this.line = line;
-      this.maxLookAhead = lookAhead || 0;
-      this.baseTokens = null;
-      this.baseTokenPos = 1;
-    };
-    Context.prototype.lookAhead = function(n) {
-      var line = this.doc.getLine(this.line + n);
-      if (line != null && n > this.maxLookAhead) {
-        this.maxLookAhead = n;
-      }
-      return line;
-    };
-    Context.prototype.baseToken = function(n) {
-      if (!this.baseTokens) {
-        return null;
-      }
-      while (this.baseTokens[this.baseTokenPos] <= n) {
-        this.baseTokenPos += 2;
-      }
-      var type = this.baseTokens[this.baseTokenPos + 1];
-      return {
-        type: type && type.replace(/( |^)overlay .*/, ""),
-        size: this.baseTokens[this.baseTokenPos] - n
-      };
-    };
-    Context.prototype.nextLine = function() {
-      this.line++;
-      if (this.maxLookAhead > 0) {
-        this.maxLookAhead--;
-      }
-    };
-    Context.fromSaved = function(doc, saved, line) {
-      if (saved instanceof SavedContext) {
-        return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
-      } else {
-        return new Context(doc, copyState(doc.mode, saved), line);
-      }
-    };
-    Context.prototype.save = function(copy) {
-      var state2 = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
-      return this.maxLookAhead > 0 ? new SavedContext(state2, this.maxLookAhead) : state2;
-    };
-    function highlightLine(cm, line, context, forceToEnd) {
-      var st = [cm.state.modeGen], lineClasses = {};
-      runMode(cm, line.text, cm.doc.mode, context, function(end, style) {
-        return st.push(end, style);
-      }, lineClasses, forceToEnd);
-      var state2 = context.state;
-      var loop = function(o2) {
-        context.baseTokens = st;
-        var overlay = cm.state.overlays[o2], i2 = 1, at = 0;
-        context.state = true;
-        runMode(cm, line.text, overlay.mode, context, function(end, style) {
-          var start = i2;
-          while (at < end) {
-            var i_end = st[i2];
-            if (i_end > end) {
-              st.splice(i2, 1, end, st[i2 + 1], i_end);
-            }
-            i2 += 2;
-            at = Math.min(end, i_end);
-          }
-          if (!style) {
-            return;
-          }
-          if (overlay.opaque) {
-            st.splice(start, i2 - start, end, "overlay " + style);
-            i2 = start + 2;
-          } else {
-            for (; start < i2; start += 2) {
-              var cur = st[start + 1];
-              st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
-            }
-          }
-        }, lineClasses);
-        context.state = state2;
-        context.baseTokens = null;
-        context.baseTokenPos = 1;
-      };
-      for (var o = 0; o < cm.state.overlays.length; ++o)
-        loop(o);
-      return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
-    }
-    function getLineStyles(cm, line, updateFrontier) {
-      if (!line.styles || line.styles[0] != cm.state.modeGen) {
-        var context = getContextBefore(cm, lineNo(line));
-        var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
-        var result = highlightLine(cm, line, context);
-        if (resetState) {
-          context.state = resetState;
-        }
-        line.stateAfter = context.save(!resetState);
-        line.styles = result.styles;
-        if (result.classes) {
-          line.styleClasses = result.classes;
-        } else if (line.styleClasses) {
-          line.styleClasses = null;
-        }
-        if (updateFrontier === cm.doc.highlightFrontier) {
-          cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
-        }
+  }
+
+  function positionLineWidget(widget, node, lineView, dims) {
+    if (widget.noHScroll) {
+  (lineView.alignable || (lineView.alignable = [])).push(node);
+      var width = dims.wrapperWidth;
+      node.style.left = dims.fixedPos + "px";
+      if (!widget.coverGutter) {
+        width -= dims.gutterTotalWidth;
+        node.style.paddingLeft = dims.gutterTotalWidth + "px";
       }
-      return line.styles;
+      node.style.width = width + "px";
     }
-    function getContextBefore(cm, n, precise) {
-      var doc = cm.doc, display = cm.display;
-      if (!doc.mode.startState) {
-        return new Context(doc, true, n);
-      }
-      var start = findStartLine(cm, n, precise);
-      var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
-      var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
-      doc.iter(start, n, function(line) {
-        processLine(cm, line.text, context);
-        var pos = context.line;
-        line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
-        context.nextLine();
-      });
-      if (precise) {
-        doc.modeFrontier = context.line;
-      }
-      return context;
+    if (widget.coverGutter) {
+      node.style.zIndex = 5;
+      node.style.position = "relative";
+      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
     }
-    function processLine(cm, text, context, startAt) {
-      var mode = cm.doc.mode;
-      var stream = new StringStream(text, cm.options.tabSize, context);
-      stream.start = stream.pos = startAt || 0;
-      if (text == "") {
-        callBlankLine(mode, context.state);
-      }
-      while (!stream.eol()) {
-        readToken2(mode, stream, context.state);
-        stream.start = stream.pos;
-      }
+  }
+
+  function widgetHeight(widget) {
+    if (widget.height != null) { return widget.height }
+    var cm = widget.doc.cm;
+    if (!cm) { return 0 }
+    if (!contains(document.body, widget.node)) {
+      var parentStyle = "position: relative;";
+      if (widget.coverGutter)
+        { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
+      if (widget.noHScroll)
+        { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
+      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
+    }
+    return widget.height = widget.node.parentNode.offsetHeight
+  }
+
+  // Return true when the given mouse event happened in a widget
+  function eventInWidget(display, e) {
+    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
+      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
+          (n.parentNode == display.sizer && n != display.mover))
+        { return true }
     }
-    function callBlankLine(mode, state2) {
-      if (mode.blankLine) {
-        return mode.blankLine(state2);
-      }
-      if (!mode.innerMode) {
-        return;
-      }
-      var inner = innerMode(mode, state2);
-      if (inner.mode.blankLine) {
-        return inner.mode.blankLine(inner.state);
-      }
+  }
+
+  // POSITION MEASUREMENT
+
+  function paddingTop(display) {return display.lineSpace.offsetTop}
+  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
+  function paddingH(display) {
+    if (display.cachedPaddingH) { return display.cachedPaddingH }
+    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
+    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
+    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
+    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
+    return data
+  }
+
+  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
+  function displayWidth(cm) {
+    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
+  }
+  function displayHeight(cm) {
+    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
+  }
+
+  // Ensure the lineView.wrapping.heights array is populated. This is
+  // an array of bottom offsets for the lines that make up a drawn
+  // line. When lineWrapping is on, there might be more than one
+  // height.
+  function ensureLineHeights(cm, lineView, rect) {
+    var wrapping = cm.options.lineWrapping;
+    var curWidth = wrapping && displayWidth(cm);
+    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
+      var heights = lineView.measure.heights = [];
+      if (wrapping) {
+        lineView.measure.width = curWidth;
+        var rects = lineView.text.firstChild.getClientRects();
+        for (var i = 0; i < rects.length - 1; i++) {
+          var cur = rects[i], next = rects[i + 1];
+          if (Math.abs(cur.bottom - next.bottom) > 2)
+            { heights.push((cur.bottom + next.top) / 2 - rect.top); }
+        }
+      }
+      heights.push(rect.bottom - rect.top);
     }
-    function readToken2(mode, stream, state2, inner) {
-      for (var i2 = 0; i2 < 10; i2++) {
-        if (inner) {
-          inner[0] = innerMode(mode, state2).mode;
-        }
-        var style = mode.token(stream, state2);
-        if (stream.pos > stream.start) {
-          return style;
-        }
-      }
-      throw new Error("Mode " + mode.name + " failed to advance stream.");
+  }
+
+  // Find a line map (mapping character offsets to text nodes) and a
+  // measurement cache for the given line number. (A line view might
+  // contain multiple lines when collapsed ranges are present.)
+  function mapFromLineView(lineView, line, lineN) {
+    if (lineView.line == line)
+      { return {map: lineView.measure.map, cache: lineView.measure.cache} }
+    if (lineView.rest) {
+      for (var i = 0; i < lineView.rest.length; i++)
+        { if (lineView.rest[i] == line)
+          { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
+      for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
+        { if (lineNo(lineView.rest[i$1]) > lineN)
+          { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
     }
-    var Token2 = function(stream, type, state2) {
-      this.start = stream.start;
-      this.end = stream.pos;
-      this.string = stream.current();
-      this.type = type || null;
-      this.state = state2;
-    };
-    function takeToken(cm, pos, precise, asArray) {
-      var doc = cm.doc, mode = doc.mode, style;
-      pos = clipPos(doc, pos);
-      var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
-      var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
-      if (asArray) {
-        tokens = [];
-      }
-      while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
-        stream.start = stream.pos;
-        style = readToken2(mode, stream, context.state);
-        if (asArray) {
-          tokens.push(new Token2(stream, style, copyState(doc.mode, context.state)));
-        }
-      }
-      return asArray ? tokens : new Token2(stream, style, context.state);
+  }
+
+  // Render a line into the hidden node display.externalMeasured. Used
+  // when measurement is needed for a line that's not in the viewport.
+  function updateExternalMeasurement(cm, line) {
+    line = visualLine(line);
+    var lineN = lineNo(line);
+    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
+    view.lineN = lineN;
+    var built = view.built = buildLineContent(cm, view);
+    view.text = built.pre;
+    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
+    return view
+  }
+
+  // Get a {top, bottom, left, right} box (in line-local coordinates)
+  // for a given character.
+  function measureChar(cm, line, ch, bias) {
+    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
+  }
+
+  // Find a line view that corresponds to the given line number.
+  function findViewForLine(cm, lineN) {
+    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
+      { return cm.display.view[findViewIndex(cm, lineN)] }
+    var ext = cm.display.externalMeasured;
+    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
+      { return ext }
+  }
+
+  // Measurement can be split in two steps, the set-up work that
+  // applies to the whole line, and the measurement of the actual
+  // character. Functions like coordsChar, that need to do a lot of
+  // measurements in a row, can thus ensure that the set-up work is
+  // only done once.
+  function prepareMeasureForLine(cm, line) {
+    var lineN = lineNo(line);
+    var view = findViewForLine(cm, lineN);
+    if (view && !view.text) {
+      view = null;
+    } else if (view && view.changes) {
+      updateLineForChanges(cm, view, lineN, getDimensions(cm));
+      cm.curOp.forceUpdate = true;
+    }
+    if (!view)
+      { view = updateExternalMeasurement(cm, line); }
+
+    var info = mapFromLineView(view, line, lineN);
+    return {
+      line: line, view: view, rect: null,
+      map: info.map, cache: info.cache, before: info.before,
+      hasHeights: false
     }
-    function extractLineClasses(type, output) {
-      if (type) {
-        for (; ; ) {
-          var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
-          if (!lineClass) {
-            break;
-          }
-          type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
-          var prop2 = lineClass[1] ? "bgClass" : "textClass";
-          if (output[prop2] == null) {
-            output[prop2] = lineClass[2];
-          } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop2])) {
-            output[prop2] += " " + lineClass[2];
-          }
-        }
+  }
+
+  // Given a prepared measurement object, measures the position of an
+  // actual character (or fetches it from the cache).
+  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
+    if (prepared.before) { ch = -1; }
+    var key = ch + (bias || ""), found;
+    if (prepared.cache.hasOwnProperty(key)) {
+      found = prepared.cache[key];
+    } else {
+      if (!prepared.rect)
+        { prepared.rect = prepared.view.text.getBoundingClientRect(); }
+      if (!prepared.hasHeights) {
+        ensureLineHeights(cm, prepared.view, prepared.rect);
+        prepared.hasHeights = true;
       }
-      return type;
+      found = measureCharInner(cm, prepared, ch, bias);
+      if (!found.bogus) { prepared.cache[key] = found; }
     }
-    function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
-      var flattenSpans = mode.flattenSpans;
-      if (flattenSpans == null) {
-        flattenSpans = cm.options.flattenSpans;
-      }
-      var curStart = 0, curStyle = null;
-      var stream = new StringStream(text, cm.options.tabSize, context), style;
-      var inner = cm.options.addModeClass && [null];
-      if (text == "") {
-        extractLineClasses(callBlankLine(mode, context.state), lineClasses);
-      }
-      while (!stream.eol()) {
-        if (stream.pos > cm.options.maxHighlightLength) {
-          flattenSpans = false;
-          if (forceToEnd) {
-            processLine(cm, text, context, stream.pos);
-          }
-          stream.pos = text.length;
-          style = null;
-        } else {
-          style = extractLineClasses(readToken2(mode, stream, context.state, inner), lineClasses);
-        }
-        if (inner) {
-          var mName = inner[0].name;
-          if (mName) {
-            style = "m-" + (style ? mName + " " + style : mName);
-          }
-        }
-        if (!flattenSpans || curStyle != style) {
-          while (curStart < stream.start) {
-            curStart = Math.min(stream.start, curStart + 5e3);
-            f(curStart, curStyle);
-          }
-          curStyle = style;
-        }
-        stream.start = stream.pos;
-      }
-      while (curStart < stream.pos) {
-        var pos = Math.min(stream.pos, curStart + 5e3);
-        f(pos, curStyle);
-        curStart = pos;
+    return {left: found.left, right: found.right,
+            top: varHeight ? found.rtop : found.top,
+            bottom: varHeight ? found.rbottom : found.bottom}
+  }
+
+  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};
+
+  function nodeAndOffsetInLineMap(map, ch, bias) {
+    var node, start, end, collapse, mStart, mEnd;
+    // First, search the line map for the text node corresponding to,
+    // or closest to, the target character.
+    for (var i = 0; i < map.length; i += 3) {
+      mStart = map[i];
+      mEnd = map[i + 1];
+      if (ch < mStart) {
+        start = 0; end = 1;
+        collapse = "left";
+      } else if (ch < mEnd) {
+        start = ch - mStart;
+        end = start + 1;
+      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
+        end = mEnd - mStart;
+        start = end - 1;
+        if (ch >= mEnd) { collapse = "right"; }
+      }
+      if (start != null) {
+        node = map[i + 2];
+        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
+          { collapse = bias; }
+        if (bias == "left" && start == 0)
+          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
+            node = map[(i -= 3) + 2];
+            collapse = "left";
+          } }
+        if (bias == "right" && start == mEnd - mStart)
+          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
+            node = map[(i += 3) + 2];
+            collapse = "right";
+          } }
+        break
       }
     }
-    function findStartLine(cm, n, precise) {
-      var minindent, minline, doc = cm.doc;
-      var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100);
-      for (var search = n; search > lim; --search) {
-        if (search <= doc.first) {
-          return doc.first;
-        }
-        var line = getLine(doc, search - 1), after = line.stateAfter;
-        if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
-          return search;
-        }
-        var indented = countColumn(line.text, null, cm.options.tabSize);
-        if (minline == null || minindent > indented) {
-          minline = search - 1;
-          minindent = indented;
-        }
-      }
-      return minline;
+    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
+  }
+
+  function getUsefulRect(rects, bias) {
+    var rect = nullRect;
+    if (bias == "left") { for (var i = 0; i < rects.length; i++) {
+      if ((rect = rects[i]).left != rect.right) { break }
+    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
+      if ((rect = rects[i$1]).left != rect.right) { break }
+    } }
+    return rect
+  }
+
+  function measureCharInner(cm, prepared, ch, bias) {
+    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
+    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;
+
+    var rect;
+    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
+      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
+        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
+        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
+        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
+          { rect = node.parentNode.getBoundingClientRect(); }
+        else
+          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
+        if (rect.left || rect.right || start == 0) { break }
+        end = start;
+        start = start - 1;
+        collapse = "right";
+      }
+      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
+    } else { // If it is a widget, simply get the box for the whole widget.
+      if (start > 0) { collapse = bias = "right"; }
+      var rects;
+      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
+        { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
+      else
+        { rect = node.getBoundingClientRect(); }
     }
-    function retreatFrontier(doc, n) {
-      doc.modeFrontier = Math.min(doc.modeFrontier, n);
-      if (doc.highlightFrontier < n - 10) {
-        return;
-      }
-      var start = doc.first;
-      for (var line = n - 1; line > start; line--) {
-        var saved = getLine(doc, line).stateAfter;
-        if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
-          start = line + 1;
-          break;
-        }
-      }
-      doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
+    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
+      var rSpan = node.parentNode.getClientRects()[0];
+      if (rSpan)
+        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
+      else
+        { rect = nullRect; }
+    }
+
+    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
+    var mid = (rtop + rbot) / 2;
+    var heights = prepared.view.measure.heights;
+    var i = 0;
+    for (; i < heights.length - 1; i++)
+      { if (mid < heights[i]) { break } }
+    var top = i ? heights[i - 1] : 0, bot = heights[i];
+    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
+                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
+                  top: top, bottom: bot};
+    if (!rect.left && !rect.right) { result.bogus = true; }
+    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }
+
+    return result
+  }
+
+  // Work around problem with bounding client rects on ranges being
+  // returned incorrectly when zoomed on IE10 and below.
+  function maybeUpdateRectForZooming(measure, rect) {
+    if (!window.screen || screen.logicalXDPI == null ||
+        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
+      { return rect }
+    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
+    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
+    return {left: rect.left * scaleX, right: rect.right * scaleX,
+            top: rect.top * scaleY, bottom: rect.bottom * scaleY}
+  }
+
+  function clearLineMeasurementCacheFor(lineView) {
+    if (lineView.measure) {
+      lineView.measure.cache = {};
+      lineView.measure.heights = null;
+      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
+        { lineView.measure.caches[i] = {}; } }
+    }
+  }
+
+  function clearLineMeasurementCache(cm) {
+    cm.display.externalMeasure = null;
+    removeChildren(cm.display.lineMeasure);
+    for (var i = 0; i < cm.display.view.length; i++)
+      { clearLineMeasurementCacheFor(cm.display.view[i]); }
+  }
+
+  function clearCaches(cm) {
+    clearLineMeasurementCache(cm);
+    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
+    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
+    cm.display.lineNumChars = null;
+  }
+
+  function pageScrollX() {
+    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
+    // which causes page_Offset and bounding client rects to use
+    // different reference viewports and invalidate our calculations.
+    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
+    return window.pageXOffset || (document.documentElement || document.body).scrollLeft
+  }
+  function pageScrollY() {
+    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
+    return window.pageYOffset || (document.documentElement || document.body).scrollTop
+  }
+
+  function widgetTopHeight(lineObj) {
+    var ref = visualLine(lineObj);
+    var widgets = ref.widgets;
+    var height = 0;
+    if (widgets) { for (var i = 0; i < widgets.length; ++i) { if (widgets[i].above)
+      { height += widgetHeight(widgets[i]); } } }
+    return height
+  }
+
+  // Converts a {top, bottom, left, right} box from line-local
+  // coordinates into another coordinate system. Context may be one of
+  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
+  // or "page".
+  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
+    if (!includeWidgets) {
+      var height = widgetTopHeight(lineObj);
+      rect.top += height; rect.bottom += height;
+    }
+    if (context == "line") { return rect }
+    if (!context) { context = "local"; }
+    var yOff = heightAtLine(lineObj);
+    if (context == "local") { yOff += paddingTop(cm.display); }
+    else { yOff -= cm.display.viewOffset; }
+    if (context == "page" || context == "window") {
+      var lOff = cm.display.lineSpace.getBoundingClientRect();
+      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
+      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
+      rect.left += xOff; rect.right += xOff;
+    }
+    rect.top += yOff; rect.bottom += yOff;
+    return rect
+  }
+
+  // Coverts a box from "div" coords to another coordinate system.
+  // Context may be "window", "page", "div", or "local"./null.
+  function fromCoordSystem(cm, coords, context) {
+    if (context == "div") { return coords }
+    var left = coords.left, top = coords.top;
+    // First move into "page" coordinate system
+    if (context == "page") {
+      left -= pageScrollX();
+      top -= pageScrollY();
+    } else if (context == "local" || !context) {
+      var localBox = cm.display.sizer.getBoundingClientRect();
+      left += localBox.left;
+      top += localBox.top;
     }
-    var sawReadOnlySpans = false, sawCollapsedSpans = false;
-    function seeReadOnlySpans() {
-      sawReadOnlySpans = true;
+
+    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
+    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
+  }
+
+  function charCoords(cm, pos, context, lineObj, bias) {
+    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
+    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
+  }
+
+  // Returns a box for a given cursor position, which may have an
+  // 'other' property containing the position of the secondary cursor
+  // on a bidi boundary.
+  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
+  // and after `char - 1` in writing order of `char - 1`
+  // A cursor Pos(line, char, "after") is on the same visual line as `char`
+  // and before `char` in writing order of `char`
+  // Examples (upper-case letters are RTL, lower-case are LTR):
+  //     Pos(0, 1, ...)
+  //     before   after
+  // ab     a|b     a|b
+  // aB     a|B     aB|
+  // Ab     |Ab     A|b
+  // AB     B|A     B|A
+  // Every position after the last character on a line is considered to stick
+  // to the last character on the line.
+  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
+    lineObj = lineObj || getLine(cm.doc, pos.line);
+    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
+    function get(ch, right) {
+      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
+      if (right) { m.left = m.right; } else { m.right = m.left; }
+      return intoCoordSystem(cm, lineObj, m, context)
+    }
+    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
+    if (ch >= lineObj.text.length) {
+      ch = lineObj.text.length;
+      sticky = "before";
+    } else if (ch <= 0) {
+      ch = 0;
+      sticky = "after";
+    }
+    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }
+
+    function getBidi(ch, partPos, invert) {
+      var part = order[partPos], right = part.level == 1;
+      return get(invert ? ch - 1 : ch, right != invert)
     }
-    function seeCollapsedSpans() {
-      sawCollapsedSpans = true;
+    var partPos = getBidiPartAt(order, ch, sticky);
+    var other = bidiOther;
+    var val = getBidi(ch, partPos, sticky == "before");
+    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
+    return val
+  }
+
+  // Used to cheaply estimate the coordinates for a position. Used for
+  // intermediate scroll updates.
+  function estimateCoords(cm, pos) {
+    var left = 0;
+    pos = clipPos(cm.doc, pos);
+    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
+    var lineObj = getLine(cm.doc, pos.line);
+    var top = heightAtLine(lineObj) + paddingTop(cm.display);
+    return {left: left, right: left, top: top, bottom: top + lineObj.height}
+  }
+
+  // Positions returned by coordsChar contain some extra information.
+  // xRel is the relative x position of the input coordinates compared
+  // to the found position (so xRel > 0 means the coordinates are to
+  // the right of the character position, for example). When outside
+  // is true, that means the coordinates lie outside the line's
+  // vertical range.
+  function PosWithInfo(line, ch, sticky, outside, xRel) {
+    var pos = Pos(line, ch, sticky);
+    pos.xRel = xRel;
+    if (outside) { pos.outside = outside; }
+    return pos
+  }
+
+  // Compute the character position closest to the given coordinates.
+  // Input must be lineSpace-local ("div" coordinate system).
+  function coordsChar(cm, x, y) {
+    var doc = cm.doc;
+    y += cm.display.viewOffset;
+    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }
+    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
+    if (lineN > last)
+      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }
+    if (x < 0) { x = 0; }
+
+    var lineObj = getLine(doc, lineN);
+    for (;;) {
+      var found = coordsCharInner(cm, lineObj, lineN, x, y);
+      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
+      if (!collapsed) { return found }
+      var rangeEnd = collapsed.find(1);
+      if (rangeEnd.line == lineN) { return rangeEnd }
+      lineObj = getLine(doc, lineN = rangeEnd.line);
     }
-    function MarkedSpan(marker, from, to) {
-      this.marker = marker;
-      this.from = from;
-      this.to = to;
+  }
+
+  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
+    y -= widgetTopHeight(lineObj);
+    var end = lineObj.text.length;
+    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
+    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
+    return {begin: begin, end: end}
+  }
+
+  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
+    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
+    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
+    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
+  }
+
+  // Returns true if the given side of a box is after the given
+  // coordinates, in top-to-bottom, left-to-right order.
+  function boxIsAfter(box, x, y, left) {
+    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
+  }
+
+  function coordsCharInner(cm, lineObj, lineNo, x, y) {
+    // Move y into line-local coordinate space
+    y -= heightAtLine(lineObj);
+    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
+    // When directly calling `measureCharPrepared`, we have to adjust
+    // for the widgets at this line.
+    var widgetHeight = widgetTopHeight(lineObj);
+    var begin = 0, end = lineObj.text.length, ltr = true;
+
+    var order = getOrder(lineObj, cm.doc.direction);
+    // If the line isn't plain left-to-right text, first figure out
+    // which bidi section the coordinates fall into.
+    if (order) {
+      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
+                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);
+      ltr = part.level != 1;
+      // The awkward -1 offsets are needed because findFirst (called
+      // on these below) will treat its first bound as inclusive,
+      // second as exclusive, but we want to actually address the
+      // characters in the part's range
+      begin = ltr ? part.from : part.to - 1;
+      end = ltr ? part.to : part.from - 1;
     }
-    function getMarkedSpanFor(spans, marker) {
-      if (spans) {
-        for (var i2 = 0; i2 < spans.length; ++i2) {
-          var span = spans[i2];
-          if (span.marker == marker) {
-            return span;
-          }
-        }
-      }
+
+    // A binary search to find the first character whose bounding box
+    // starts after the coordinates. If we run across any whose box wrap
+    // the coordinates, store that.
+    var chAround = null, boxAround = null;
+    var ch = findFirst(function (ch) {
+      var box = measureCharPrepared(cm, preparedMeasure, ch);
+      box.top += widgetHeight; box.bottom += widgetHeight;
+      if (!boxIsAfter(box, x, y, false)) { return false }
+      if (box.top <= y && box.left <= x) {
+        chAround = ch;
+        boxAround = box;
+      }
+      return true
+    }, begin, end);
+
+    var baseX, sticky, outside = false;
+    // If a box around the coordinates was found, use that
+    if (boxAround) {
+      // Distinguish coordinates nearer to the left or right side of the box
+      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
+      ch = chAround + (atStart ? 0 : 1);
+      sticky = atStart ? "after" : "before";
+      baseX = atLeft ? boxAround.left : boxAround.right;
+    } else {
+      // (Adjust for extended bound, if necessary.)
+      if (!ltr && (ch == end || ch == begin)) { ch++; }
+      // To determine which side to associate with, get the box to the
+      // left of the character and compare it's vertical position to the
+      // coordinates
+      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
+        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?
+        "after" : "before";
+      // Now get accurate coordinates for this place, in order to get a
+      // base X position
+      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);
+      baseX = coords.left;
+      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
     }
-    function removeMarkedSpan(spans, span) {
-      var r;
-      for (var i2 = 0; i2 < spans.length; ++i2) {
-        if (spans[i2] != span) {
-          (r || (r = [])).push(spans[i2]);
-        }
+
+    ch = skipExtendingChars(lineObj.text, ch, 1);
+    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)
+  }
+
+  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
+    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
+    // situation, we can take this ordering to correspond to the visual
+    // ordering. This finds the first part whose end is after the given
+    // coordinates.
+    var index = findFirst(function (i) {
+      var part = order[i], ltr = part.level != 1;
+      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"),
+                                     "line", lineObj, preparedMeasure), x, y, true)
+    }, 0, order.length - 1);
+    var part = order[index];
+    // If this isn't the first part, the part's start is also after
+    // the coordinates, and the coordinates aren't on the same line as
+    // that start, move one part back.
+    if (index > 0) {
+      var ltr = part.level != 1;
+      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"),
+                               "line", lineObj, preparedMeasure);
+      if (boxIsAfter(start, x, y, true) && start.top > y)
+        { part = order[index - 1]; }
+    }
+    return part
+  }
+
+  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
+    // In a wrapped line, rtl text on wrapping boundaries can do things
+    // that don't correspond to the ordering in our `order` array at
+    // all, so a binary search doesn't work, and we want to return a
+    // part that only spans one line so that the binary search in
+    // coordsCharInner is safe. As such, we first find the extent of the
+    // wrapped line, and then do a flat search in which we discard any
+    // spans that aren't on the line.
+    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
+    var begin = ref.begin;
+    var end = ref.end;
+    if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
+    var part = null, closestDist = null;
+    for (var i = 0; i < order.length; i++) {
+      var p = order[i];
+      if (p.from >= end || p.to <= begin) { continue }
+      var ltr = p.level != 1;
+      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
+      // Weigh against spans ending before this, so that they are only
+      // picked if nothing ends after
+      var dist = endX < x ? x - endX + 1e9 : endX - x;
+      if (!part || closestDist > dist) {
+        part = p;
+        closestDist = dist;
+      }
+    }
+    if (!part) { part = order[order.length - 1]; }
+    // Clip the part to the wrapped line.
+    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
+    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
+    return part
+  }
+
+  var measureText;
+  // Compute the default text height.
+  function textHeight(display) {
+    if (display.cachedTextHeight != null) { return display.cachedTextHeight }
+    if (measureText == null) {
+      measureText = elt("pre", null, "CodeMirror-line-like");
+      // Measure a bunch of lines, for browsers that compute
+      // fractional heights.
+      for (var i = 0; i < 49; ++i) {
+        measureText.appendChild(document.createTextNode("x"));
+        measureText.appendChild(elt("br"));
       }
-      return r;
+      measureText.appendChild(document.createTextNode("x"));
+    }
+    removeChildrenAndAdd(display.measure, measureText);
+    var height = measureText.offsetHeight / 50;
+    if (height > 3) { display.cachedTextHeight = height; }
+    removeChildren(display.measure);
+    return height || 1
+  }
+
+  // Compute the default character width.
+  function charWidth(display) {
+    if (display.cachedCharWidth != null) { return display.cachedCharWidth }
+    var anchor = elt("span", "xxxxxxxxxx");
+    var pre = elt("pre", [anchor], "CodeMirror-line-like");
+    removeChildrenAndAdd(display.measure, pre);
+    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
+    if (width > 2) { display.cachedCharWidth = width; }
+    return width || 10
+  }
+
+  // Do a bulk-read of the DOM positions and sizes needed to draw the
+  // view, so that we don't interleave reading and writing to the DOM.
+  function getDimensions(cm) {
+    var d = cm.display, left = {}, width = {};
+    var gutterLeft = d.gutters.clientLeft;
+    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
+      var id = cm.display.gutterSpecs[i].className;
+      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
+      width[id] = n.clientWidth;
+    }
+    return {fixedPos: compensateForHScroll(d),
+            gutterTotalWidth: d.gutters.offsetWidth,
+            gutterLeft: left,
+            gutterWidth: width,
+            wrapperWidth: d.wrapper.clientWidth}
+  }
+
+  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
+  // but using getBoundingClientRect to get a sub-pixel-accurate
+  // result.
+  function compensateForHScroll(display) {
+    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
+  }
+
+  // Returns a function that estimates the height of a line, to use as
+  // first approximation until the line becomes visible (and is thus
+  // properly measurable).
+  function estimateHeight(cm) {
+    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
+    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
+    return function (line) {
+      if (lineIsHidden(cm.doc, line)) { return 0 }
+
+      var widgetsHeight = 0;
+      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
+        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
+      } }
+
+      if (wrapping)
+        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
+      else
+        { return widgetsHeight + th }
+    }
+  }
+
+  function estimateLineHeights(cm) {
+    var doc = cm.doc, est = estimateHeight(cm);
+    doc.iter(function (line) {
+      var estHeight = est(line);
+      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
+    });
+  }
+
+  // Given a mouse event, find the corresponding position. If liberal
+  // is false, it checks whether a gutter or scrollbar was clicked,
+  // and returns null if it was. forRect is used by rectangular
+  // selections, and tries to estimate a character position even for
+  // coordinates beyond the right of the text.
+  function posFromMouse(cm, e, liberal, forRect) {
+    var display = cm.display;
+    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }
+
+    var x, y, space = display.lineSpace.getBoundingClientRect();
+    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
+    try { x = e.clientX - space.left; y = e.clientY - space.top; }
+    catch (e$1) { return null }
+    var coords = coordsChar(cm, x, y), line;
+    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
+      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
+      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
+    }
+    return coords
+  }
+
+  // Find the view element corresponding to a given line. Return null
+  // when the line isn't visible.
+  function findViewIndex(cm, n) {
+    if (n >= cm.display.viewTo) { return null }
+    n -= cm.display.viewFrom;
+    if (n < 0) { return null }
+    var view = cm.display.view;
+    for (var i = 0; i < view.length; i++) {
+      n -= view[i].size;
+      if (n < 0) { return i }
     }
-    function addMarkedSpan(line, span, op) {
-      var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet()));
-      if (inThisOp && inThisOp.has(line.markedSpans)) {
-        line.markedSpans.push(span);
+  }
+
+  // Updates the display.view data structure for a given change to the
+  // document. From and to are in pre-change coordinates. Lendiff is
+  // the amount of lines added or subtracted by the change. This is
+  // used for changes that span multiple lines, or change the way
+  // lines are divided into visual lines. regLineChange (below)
+  // registers single-line changes.
+  function regChange(cm, from, to, lendiff) {
+    if (from == null) { from = cm.doc.first; }
+    if (to == null) { to = cm.doc.first + cm.doc.size; }
+    if (!lendiff) { lendiff = 0; }
+
+    var display = cm.display;
+    if (lendiff && to < display.viewTo &&
+        (display.updateLineNumbers == null || display.updateLineNumbers > from))
+      { display.updateLineNumbers = from; }
+
+    cm.curOp.viewChanged = true;
+
+    if (from >= display.viewTo) { // Change after
+      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
+        { resetView(cm); }
+    } else if (to <= display.viewFrom) { // Change before
+      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
+        resetView(cm);
       } else {
-        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
-        if (inThisOp) {
-          inThisOp.add(line.markedSpans);
-        }
-      }
-      span.marker.attachLine(line);
-    }
-    function markedSpansBefore(old, startCh, isInsert) {
-      var nw;
-      if (old) {
-        for (var i2 = 0; i2 < old.length; ++i2) {
-          var span = old[i2], marker = span.marker;
-          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
-          if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
-            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
-            (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
-          }
-        }
-      }
-      return nw;
-    }
-    function markedSpansAfter(old, endCh, isInsert) {
-      var nw;
-      if (old) {
-        for (var i2 = 0; i2 < old.length; ++i2) {
-          var span = old[i2], marker = span.marker;
-          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
-          if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
-            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
-            (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
-          }
-        }
-      }
-      return nw;
-    }
-    function stretchSpansOverChange(doc, change) {
-      if (change.full) {
-        return null;
-      }
-      var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
-      var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
-      if (!oldFirst && !oldLast) {
-        return null;
-      }
-      var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
-      var first = markedSpansBefore(oldFirst, startCh, isInsert);
-      var last = markedSpansAfter(oldLast, endCh, isInsert);
-      var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
-      if (first) {
-        for (var i2 = 0; i2 < first.length; ++i2) {
-          var span = first[i2];
-          if (span.to == null) {
-            var found = getMarkedSpanFor(last, span.marker);
-            if (!found) {
-              span.to = startCh;
-            } else if (sameLine) {
-              span.to = found.to == null ? null : found.to + offset;
-            }
-          }
-        }
-      }
-      if (last) {
-        for (var i$12 = 0; i$12 < last.length; ++i$12) {
-          var span$1 = last[i$12];
-          if (span$1.to != null) {
-            span$1.to += offset;
-          }
-          if (span$1.from == null) {
-            var found$1 = getMarkedSpanFor(first, span$1.marker);
-            if (!found$1) {
-              span$1.from = offset;
-              if (sameLine) {
-                (first || (first = [])).push(span$1);
-              }
-            }
-          } else {
-            span$1.from += offset;
-            if (sameLine) {
-              (first || (first = [])).push(span$1);
-            }
-          }
-        }
-      }
-      if (first) {
-        first = clearEmptySpans(first);
+        display.viewFrom += lendiff;
+        display.viewTo += lendiff;
+      }
+    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
+      resetView(cm);
+    } else if (from <= display.viewFrom) { // Top overlap
+      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
+      if (cut) {
+        display.view = display.view.slice(cut.index);
+        display.viewFrom = cut.lineN;
+        display.viewTo += lendiff;
+      } else {
+        resetView(cm);
       }
-      if (last && last != first) {
-        last = clearEmptySpans(last);
+    } else if (to >= display.viewTo) { // Bottom overlap
+      var cut$1 = viewCuttingPoint(cm, from, from, -1);
+      if (cut$1) {
+        display.view = display.view.slice(0, cut$1.index);
+        display.viewTo = cut$1.lineN;
+      } else {
+        resetView(cm);
       }
-      var newMarkers = [first];
-      if (!sameLine) {
-        var gap = change.text.length - 2, gapMarkers;
-        if (gap > 0 && first) {
-          for (var i$22 = 0; i$22 < first.length; ++i$22) {
-            if (first[i$22].to == null) {
-              (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$22].marker, null, null));
-            }
-          }
-        }
-        for (var i$3 = 0; i$3 < gap; ++i$3) {
-          newMarkers.push(gapMarkers);
-        }
-        newMarkers.push(last);
+    } else { // Gap in the middle
+      var cutTop = viewCuttingPoint(cm, from, from, -1);
+      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
+      if (cutTop && cutBot) {
+        display.view = display.view.slice(0, cutTop.index)
+          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
+          .concat(display.view.slice(cutBot.index));
+        display.viewTo += lendiff;
+      } else {
+        resetView(cm);
       }
-      return newMarkers;
     }
-    function clearEmptySpans(spans) {
-      for (var i2 = 0; i2 < spans.length; ++i2) {
-        var span = spans[i2];
-        if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
-          spans.splice(i2--, 1);
-        }
-      }
-      if (!spans.length) {
-        return null;
-      }
-      return spans;
+
+    var ext = display.externalMeasured;
+    if (ext) {
+      if (to < ext.lineN)
+        { ext.lineN += lendiff; }
+      else if (from < ext.lineN + ext.size)
+        { display.externalMeasured = null; }
     }
-    function removeReadOnlyRanges(doc, from, to) {
-      var markers = null;
-      doc.iter(from.line, to.line + 1, function(line) {
-        if (line.markedSpans) {
-          for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {
-            var mark = line.markedSpans[i3].marker;
-            if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
-              (markers || (markers = [])).push(mark);
-            }
-          }
-        }
-      });
-      if (!markers) {
-        return null;
-      }
-      var parts = [{ from, to }];
-      for (var i2 = 0; i2 < markers.length; ++i2) {
-        var mk = markers[i2], m = mk.find(0);
-        for (var j = 0; j < parts.length; ++j) {
-          var p = parts[j];
-          if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
-            continue;
-          }
-          var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
-          if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
-            newParts.push({ from: p.from, to: m.from });
-          }
-          if (dto > 0 || !mk.inclusiveRight && !dto) {
-            newParts.push({ from: m.to, to: p.to });
-          }
-          parts.splice.apply(parts, newParts);
-          j += newParts.length - 3;
-        }
+  }
+
+  // Register a change to a single line. Type must be one of "text",
+  // "gutter", "class", "widget"
+  function regLineChange(cm, line, type) {
+    cm.curOp.viewChanged = true;
+    var display = cm.display, ext = cm.display.externalMeasured;
+    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
+      { display.externalMeasured = null; }
+
+    if (line < display.viewFrom || line >= display.viewTo) { return }
+    var lineView = display.view[findViewIndex(cm, line)];
+    if (lineView.node == null) { return }
+    var arr = lineView.changes || (lineView.changes = []);
+    if (indexOf(arr, type) == -1) { arr.push(type); }
+  }
+
+  // Clear the view.
+  function resetView(cm) {
+    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
+    cm.display.view = [];
+    cm.display.viewOffset = 0;
+  }
+
+  function viewCuttingPoint(cm, oldN, newN, dir) {
+    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
+    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
+      { return {index: index, lineN: newN} }
+    var n = cm.display.viewFrom;
+    for (var i = 0; i < index; i++)
+      { n += view[i].size; }
+    if (n != oldN) {
+      if (dir > 0) {
+        if (index == view.length - 1) { return null }
+        diff = (n + view[index].size) - oldN;
+        index++;
+      } else {
+        diff = n - oldN;
       }
-      return parts;
+      oldN += diff; newN += diff;
     }
-    function detachMarkedSpans(line) {
-      var spans = line.markedSpans;
-      if (!spans) {
-        return;
-      }
-      for (var i2 = 0; i2 < spans.length; ++i2) {
-        spans[i2].marker.detachLine(line);
-      }
-      line.markedSpans = null;
+    while (visualLineNo(cm.doc, newN) != newN) {
+      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
+      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
+      index += dir;
     }
-    function attachMarkedSpans(line, spans) {
-      if (!spans) {
-        return;
-      }
-      for (var i2 = 0; i2 < spans.length; ++i2) {
-        spans[i2].marker.attachLine(line);
-      }
-      line.markedSpans = spans;
+    return {index: index, lineN: newN}
+  }
+
+  // Force the view to cover a given range, adding empty view element
+  // or clipping off existing ones as needed.
+  function adjustView(cm, from, to) {
+    var display = cm.display, view = display.view;
+    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
+      display.view = buildViewArray(cm, from, to);
+      display.viewFrom = from;
+    } else {
+      if (display.viewFrom > from)
+        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
+      else if (display.viewFrom < from)
+        { display.view = display.view.slice(findViewIndex(cm, from)); }
+      display.viewFrom = from;
+      if (display.viewTo < to)
+        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
+      else if (display.viewTo > to)
+        { display.view = display.view.slice(0, findViewIndex(cm, to)); }
+    }
+    display.viewTo = to;
+  }
+
+  // Count the number of lines in the view whose DOM representation is
+  // out of date (or nonexistent).
+  function countDirtyView(cm) {
+    var view = cm.display.view, dirty = 0;
+    for (var i = 0; i < view.length; i++) {
+      var lineView = view[i];
+      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
     }
-    function extraLeft(marker) {
-      return marker.inclusiveLeft ? -1 : 0;
+    return dirty
+  }
+
+  function updateSelection(cm) {
+    cm.display.input.showSelection(cm.display.input.prepareSelection());
+  }
+
+  function prepareSelection(cm, primary) {
+    if ( primary === void 0 ) primary = true;
+
+    var doc = cm.doc, result = {};
+    var curFragment = result.cursors = document.createDocumentFragment();
+    var selFragment = result.selection = document.createDocumentFragment();
+
+    var customCursor = cm.options.$customCursor;
+    if (customCursor) { primary = true; }
+    for (var i = 0; i < doc.sel.ranges.length; i++) {
+      if (!primary && i == doc.sel.primIndex) { continue }
+      var range = doc.sel.ranges[i];
+      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }
+      var collapsed = range.empty();
+      if (customCursor) {
+        var head = customCursor(cm, range);
+        if (head) { drawSelectionCursor(cm, head, curFragment); }
+      } else if (collapsed || cm.options.showCursorWhenSelecting) {
+        drawSelectionCursor(cm, range.head, curFragment);
+      }
+      if (!collapsed)
+        { drawSelectionRange(cm, range, selFragment); }
+    }
+    return result
+  }
+
+  // Draws a cursor for the given range
+  function drawSelectionCursor(cm, head, output) {
+    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
+
+    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
+    cursor.style.left = pos.left + "px";
+    cursor.style.top = pos.top + "px";
+    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
+
+    if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
+      var charPos = charCoords(cm, head, "div", null, null);
+      var width = charPos.right - charPos.left;
+      cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";
     }
-    function extraRight(marker) {
-      return marker.inclusiveRight ? 1 : 0;
+
+    if (pos.other) {
+      // Secondary cursor, shown when on a 'jump' in bi-directional text
+      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
+      otherCursor.style.display = "";
+      otherCursor.style.left = pos.other.left + "px";
+      otherCursor.style.top = pos.other.top + "px";
+      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
     }
-    function compareCollapsedMarkers(a, b) {
-      var lenDiff = a.lines.length - b.lines.length;
-      if (lenDiff != 0) {
-        return lenDiff;
-      }
-      var aPos = a.find(), bPos = b.find();
-      var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
-      if (fromCmp) {
-        return -fromCmp;
+  }
+
+  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }
+
+  // Draws the given range as a highlighted selection
+  function drawSelectionRange(cm, range, output) {
+    var display = cm.display, doc = cm.doc;
+    var fragment = document.createDocumentFragment();
+    var padding = paddingH(cm.display), leftSide = padding.left;
+    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
+    var docLTR = doc.direction == "ltr";
+
+    function add(left, top, width, bottom) {
+      if (top < 0) { top = 0; }
+      top = Math.round(top);
+      bottom = Math.round(bottom);
+      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
+    }
+
+    function drawForLine(line, fromArg, toArg) {
+      var lineObj = getLine(doc, line);
+      var lineLen = lineObj.text.length;
+      var start, end;
+      function coords(ch, bias) {
+        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
       }
-      var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
-      if (toCmp) {
-        return toCmp;
+
+      function wrapX(pos, dir, side) {
+        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
+        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
+        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
+        return coords(ch, prop)[prop]
       }
-      return b.id - a.id;
-    }
-    function collapsedSpanAtSide(line, start) {
-      var sps = sawCollapsedSpans && line.markedSpans, found;
-      if (sps) {
-        for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
-          sp = sps[i2];
-          if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
-            found = sp.marker;
+
+      var order = getOrder(lineObj, doc.direction);
+      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
+        var ltr = dir == "ltr";
+        var fromPos = coords(from, ltr ? "left" : "right");
+        var toPos = coords(to - 1, ltr ? "right" : "left");
+
+        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
+        var first = i == 0, last = !order || i == order.length - 1;
+        if (toPos.top - fromPos.top <= 3) { // Single line
+          var openLeft = (docLTR ? openStart : openEnd) && first;
+          var openRight = (docLTR ? openEnd : openStart) && last;
+          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
+          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
+          add(left, fromPos.top, right - left, fromPos.bottom);
+        } else { // Multiple lines
+          var topLeft, topRight, botLeft, botRight;
+          if (ltr) {
+            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
+            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
+            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
+            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
+          } else {
+            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
+            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
+            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
+            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
           }
+          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
+          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
+          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
+        }
+
+        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
+        if (cmpCoords(toPos, start) < 0) { start = toPos; }
+        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
+        if (cmpCoords(toPos, end) < 0) { end = toPos; }
+      });
+      return {start: start, end: end}
+    }
+
+    var sFrom = range.from(), sTo = range.to();
+    if (sFrom.line == sTo.line) {
+      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
+    } else {
+      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
+      var singleVLine = visualLine(fromLine) == visualLine(toLine);
+      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
+      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
+      if (singleVLine) {
+        if (leftEnd.top < rightStart.top - 2) {
+          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
+          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
+        } else {
+          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
         }
       }
-      return found;
+      if (leftEnd.bottom < rightStart.top)
+        { add(leftSide, leftEnd.bottom, null, rightStart.top); }
     }
-    function collapsedSpanAtStart(line) {
-      return collapsedSpanAtSide(line, true);
-    }
-    function collapsedSpanAtEnd(line) {
-      return collapsedSpanAtSide(line, false);
-    }
-    function collapsedSpanAround(line, ch) {
-      var sps = sawCollapsedSpans && line.markedSpans, found;
-      if (sps) {
-        for (var i2 = 0; i2 < sps.length; ++i2) {
-          var sp = sps[i2];
-          if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
-            found = sp.marker;
-          }
-        }
-      }
-      return found;
+
+    output.appendChild(fragment);
+  }
+
+  // Cursor-blinking
+  function restartBlink(cm) {
+    if (!cm.state.focused) { return }
+    var display = cm.display;
+    clearInterval(display.blinker);
+    var on = true;
+    display.cursorDiv.style.visibility = "";
+    if (cm.options.cursorBlinkRate > 0)
+      { display.blinker = setInterval(function () {
+        if (!cm.hasFocus()) { onBlur(cm); }
+        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
+      }, cm.options.cursorBlinkRate); }
+    else if (cm.options.cursorBlinkRate < 0)
+      { display.cursorDiv.style.visibility = "hidden"; }
+  }
+
+  function ensureFocus(cm) {
+    if (!cm.hasFocus()) {
+      cm.display.input.focus();
+      if (!cm.state.focused) { onFocus(cm); }
     }
-    function conflictingCollapsedRange(doc, lineNo2, from, to, marker) {
-      var line = getLine(doc, lineNo2);
-      var sps = sawCollapsedSpans && line.markedSpans;
-      if (sps) {
-        for (var i2 = 0; i2 < sps.length; ++i2) {
-          var sp = sps[i2];
-          if (!sp.marker.collapsed) {
-            continue;
-          }
-          var found = sp.marker.find(0);
-          var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
-          var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
-          if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
-            continue;
-          }
-          if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
-            return true;
-          }
-        }
+  }
+
+  function delayBlurEvent(cm) {
+    cm.state.delayingBlurEvent = true;
+    setTimeout(function () { if (cm.state.delayingBlurEvent) {
+      cm.state.delayingBlurEvent = false;
+      if (cm.state.focused) { onBlur(cm); }
+    } }, 100);
+  }
+
+  function onFocus(cm, e) {
+    if (cm.state.delayingBlurEvent && !cm.state.draggingText) { cm.state.delayingBlurEvent = false; }
+
+    if (cm.options.readOnly == "nocursor") { return }
+    if (!cm.state.focused) {
+      signal(cm, "focus", cm, e);
+      cm.state.focused = true;
+      addClass(cm.display.wrapper, "CodeMirror-focused");
+      // This test prevents this from firing when a context
+      // menu is closed (since the input reset would kill the
+      // select-all detection hack)
+      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
+        cm.display.input.reset();
+        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
       }
+      cm.display.input.receivedFocus();
     }
-    function visualLine(line) {
-      var merged;
-      while (merged = collapsedSpanAtStart(line)) {
-        line = merged.find(-1, true).line;
-      }
-      return line;
+    restartBlink(cm);
+  }
+  function onBlur(cm, e) {
+    if (cm.state.delayingBlurEvent) { return }
+
+    if (cm.state.focused) {
+      signal(cm, "blur", cm, e);
+      cm.state.focused = false;
+      rmClass(cm.display.wrapper, "CodeMirror-focused");
     }
-    function visualLineEnd(line) {
-      var merged;
-      while (merged = collapsedSpanAtEnd(line)) {
-        line = merged.find(1, true).line;
+    clearInterval(cm.display.blinker);
+    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
+  }
+
+  // Read the actual heights of the rendered lines, and update their
+  // stored heights to match.
+  function updateHeightsInViewport(cm) {
+    var display = cm.display;
+    var prevBottom = display.lineDiv.offsetTop;
+    var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
+    var oldHeight = display.lineDiv.getBoundingClientRect().top;
+    var mustScroll = 0;
+    for (var i = 0; i < display.view.length; i++) {
+      var cur = display.view[i], wrapping = cm.options.lineWrapping;
+      var height = (void 0), width = 0;
+      if (cur.hidden) { continue }
+      oldHeight += cur.line.height;
+      if (ie && ie_version < 8) {
+        var bot = cur.node.offsetTop + cur.node.offsetHeight;
+        height = bot - prevBottom;
+        prevBottom = bot;
+      } else {
+        var box = cur.node.getBoundingClientRect();
+        height = box.bottom - box.top;
+        // Check that lines don't extend past the right of the current
+        // editor width
+        if (!wrapping && cur.text.firstChild)
+          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
       }
-      return line;
-    }
-    function visualLineContinued(line) {
-      var merged, lines;
-      while (merged = collapsedSpanAtEnd(line)) {
-        line = merged.find(1, true).line;
-        (lines || (lines = [])).push(line);
+      var diff = cur.line.height - height;
+      if (diff > .005 || diff < -.005) {
+        if (oldHeight < viewTop) { mustScroll -= diff; }
+        updateLineHeight(cur.line, height);
+        updateWidgetHeight(cur.line);
+        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
+          { updateWidgetHeight(cur.rest[j]); } }
       }
-      return lines;
-    }
-    function visualLineNo(doc, lineN) {
-      var line = getLine(doc, lineN), vis = visualLine(line);
-      if (line == vis) {
-        return lineN;
+      if (width > cm.display.sizerWidth) {
+        var chWidth = Math.ceil(width / charWidth(cm.display));
+        if (chWidth > cm.display.maxLineLength) {
+          cm.display.maxLineLength = chWidth;
+          cm.display.maxLine = cur.line;
+          cm.display.maxLineChanged = true;
+        }
       }
-      return lineNo(vis);
     }
-    function visualLineEndNo(doc, lineN) {
-      if (lineN > doc.lastLine()) {
-        return lineN;
-      }
-      var line = getLine(doc, lineN), merged;
-      if (!lineIsHidden(doc, line)) {
-        return lineN;
-      }
-      while (merged = collapsedSpanAtEnd(line)) {
-        line = merged.find(1, true).line;
+    if (Math.abs(mustScroll) > 2) { display.scroller.scrollTop += mustScroll; }
+  }
+
+  // Read and store the height of line widgets associated with the
+  // given line.
+  function updateWidgetHeight(line) {
+    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
+      var w = line.widgets[i], parent = w.node.parentNode;
+      if (parent) { w.height = parent.offsetHeight; }
+    } }
+  }
+
+  // Compute the lines that are visible in a given viewport (defaults
+  // the the current scroll position). viewport may contain top,
+  // height, and ensure (see op.scrollToPos) properties.
+  function visibleLines(display, doc, viewport) {
+    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
+    top = Math.floor(top - paddingTop(display));
+    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
+
+    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
+    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
+    // forces those lines into the viewport (if possible).
+    if (viewport && viewport.ensure) {
+      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
+      if (ensureFrom < from) {
+        from = ensureFrom;
+        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
+      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
+        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
+        to = ensureTo;
       }
-      return lineNo(line) + 1;
     }
-    function lineIsHidden(doc, line) {
-      var sps = sawCollapsedSpans && line.markedSpans;
-      if (sps) {
-        for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
-          sp = sps[i2];
-          if (!sp.marker.collapsed) {
-            continue;
-          }
-          if (sp.from == null) {
-            return true;
-          }
-          if (sp.marker.widgetNode) {
-            continue;
-          }
-          if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
-            return true;
-          }
-        }
-      }
+    return {from: from, to: Math.max(to, from + 1)}
+  }
+
+  // SCROLLING THINGS INTO VIEW
+
+  // If an editor sits on the top or bottom of the window, partially
+  // scrolled out of view, this ensures that the cursor is visible.
+  function maybeScrollWindow(cm, rect) {
+    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }
+
+    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
+    if (rect.top + box.top < 0) { doScroll = true; }
+    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
+    if (doScroll != null && !phantom) {
+      var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
+      cm.display.lineSpace.appendChild(scrollNode);
+      scrollNode.scrollIntoView(doScroll);
+      cm.display.lineSpace.removeChild(scrollNode);
     }
-    function lineIsHiddenInner(doc, line, span) {
-      if (span.to == null) {
-        var end = span.marker.find(1, true);
-        return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
-      }
-      if (span.marker.inclusiveRight && span.to == line.text.length) {
-        return true;
+  }
+
+  // Scroll a given position into view (immediately), verifying that
+  // it actually became visible (as line heights are accurately
+  // measured, the position of something may 'drift' during drawing).
+  function scrollPosIntoView(cm, pos, end, margin) {
+    if (margin == null) { margin = 0; }
+    var rect;
+    if (!cm.options.lineWrapping && pos == end) {
+      // Set pos and end to the cursor positions around the character pos sticks to
+      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
+      // If pos == Pos(_, 0, "before"), pos and end are unchanged
+      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
+      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
+    }
+    for (var limit = 0; limit < 5; limit++) {
+      var changed = false;
+      var coords = cursorCoords(cm, pos);
+      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
+      rect = {left: Math.min(coords.left, endCoords.left),
+              top: Math.min(coords.top, endCoords.top) - margin,
+              right: Math.max(coords.left, endCoords.left),
+              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
+      var scrollPos = calculateScrollPos(cm, rect);
+      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
+      if (scrollPos.scrollTop != null) {
+        updateScrollTop(cm, scrollPos.scrollTop);
+        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
       }
-      for (var sp = void 0, i2 = 0; i2 < line.markedSpans.length; ++i2) {
-        sp = line.markedSpans[i2];
-        if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
-          return true;
-        }
+      if (scrollPos.scrollLeft != null) {
+        setScrollLeft(cm, scrollPos.scrollLeft);
+        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
       }
+      if (!changed) { break }
     }
-    function heightAtLine(lineObj) {
-      lineObj = visualLine(lineObj);
-      var h = 0, chunk = lineObj.parent;
-      for (var i2 = 0; i2 < chunk.lines.length; ++i2) {
-        var line = chunk.lines[i2];
-        if (line == lineObj) {
-          break;
-        } else {
-          h += line.height;
-        }
-      }
-      for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
-        for (var i$12 = 0; i$12 < p.children.length; ++i$12) {
-          var cur = p.children[i$12];
-          if (cur == chunk) {
-            break;
-          } else {
-            h += cur.height;
-          }
-        }
-      }
-      return h;
-    }
-    function lineLength(line) {
-      if (line.height == 0) {
-        return 0;
-      }
-      var len = line.text.length, merged, cur = line;
-      while (merged = collapsedSpanAtStart(cur)) {
-        var found = merged.find(0, true);
-        cur = found.from.line;
-        len += found.from.ch - found.to.ch;
-      }
-      cur = line;
-      while (merged = collapsedSpanAtEnd(cur)) {
-        var found$1 = merged.find(0, true);
-        len -= cur.text.length - found$1.from.ch;
-        cur = found$1.to.line;
-        len += cur.text.length - found$1.to.ch;
-      }
-      return len;
-    }
-    function findMaxLine(cm) {
-      var d = cm.display, doc = cm.doc;
-      d.maxLine = getLine(doc, doc.first);
-      d.maxLineLength = lineLength(d.maxLine);
-      d.maxLineChanged = true;
-      doc.iter(function(line) {
-        var len = lineLength(line);
-        if (len > d.maxLineLength) {
-          d.maxLineLength = len;
-          d.maxLine = line;
-        }
-      });
+    return rect
+  }
+
+  // Scroll a given set of coordinates into view (immediately).
+  function scrollIntoView(cm, rect) {
+    var scrollPos = calculateScrollPos(cm, rect);
+    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
+    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
+  }
+
+  // Calculate a new scroll position needed to scroll the given
+  // rectangle into view. Returns an object with scrollTop and
+  // scrollLeft properties. When these are undefined, the
+  // vertical/horizontal position does not need to be adjusted.
+  function calculateScrollPos(cm, rect) {
+    var display = cm.display, snapMargin = textHeight(cm.display);
+    if (rect.top < 0) { rect.top = 0; }
+    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
+    var screen = displayHeight(cm), result = {};
+    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
+    var docBottom = cm.doc.height + paddingVert(display);
+    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
+    if (rect.top < screentop) {
+      result.scrollTop = atTop ? 0 : rect.top;
+    } else if (rect.bottom > screentop + screen) {
+      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
+      if (newTop != screentop) { result.scrollTop = newTop; }
     }
-    var Line = function(text, markedSpans, estimateHeight2) {
-      this.text = text;
-      attachMarkedSpans(this, markedSpans);
-      this.height = estimateHeight2 ? estimateHeight2(this) : 1;
-    };
-    Line.prototype.lineNo = function() {
-      return lineNo(this);
-    };
-    eventMixin(Line);
-    function updateLine(line, text, markedSpans, estimateHeight2) {
-      line.text = text;
-      if (line.stateAfter) {
-        line.stateAfter = null;
-      }
-      if (line.styles) {
-        line.styles = null;
-      }
-      if (line.order != null) {
-        line.order = null;
-      }
-      detachMarkedSpans(line);
-      attachMarkedSpans(line, markedSpans);
-      var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;
-      if (estHeight != line.height) {
-        updateLineHeight(line, estHeight);
-      }
-    }
-    function cleanUpLine(line) {
-      line.parent = null;
-      detachMarkedSpans(line);
-    }
-    var styleToClassCache = {}, styleToClassCacheWithMode = {};
-    function interpretTokenStyle(style, options) {
-      if (!style || /^\s*$/.test(style)) {
-        return null;
-      }
-      var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
-      return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
-    }
-    function buildLineContent(cm, lineView) {
-      var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
-      var builder = {
-        pre: eltP("pre", [content], "CodeMirror-line"),
-        content,
-        col: 0,
-        pos: 0,
-        cm,
-        trailingSpace: false,
-        splitSpaces: cm.getOption("lineWrapping")
-      };
-      lineView.measure = {};
-      for (var i2 = 0; i2 <= (lineView.rest ? lineView.rest.length : 0); i2++) {
-        var line = i2 ? lineView.rest[i2 - 1] : lineView.line, order = void 0;
-        builder.pos = 0;
-        builder.addToken = buildToken;
-        if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
-          builder.addToken = buildTokenBadBidi(builder.addToken, order);
-        }
-        builder.map = [];
-        var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
-        insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
-        if (line.styleClasses) {
-          if (line.styleClasses.bgClass) {
-            builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
-          }
-          if (line.styleClasses.textClass) {
-            builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
-          }
-        }
-        if (builder.map.length == 0) {
-          builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
-        }
-        if (i2 == 0) {
-          lineView.measure.map = builder.map;
-          lineView.measure.cache = {};
-        } else {
-          (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
-          (lineView.measure.caches || (lineView.measure.caches = [])).push({});
-        }
-      }
-      if (webkit) {
-        var last = builder.content.lastChild;
-        if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
-          builder.content.className = "cm-tab-wrap-hack";
-        }
-      }
-      signal(cm, "renderLine", cm, lineView.line, builder.pre);
-      if (builder.pre.className) {
-        builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
-      }
-      return builder;
+
+    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
+    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
+    var screenw = displayWidth(cm) - display.gutters.offsetWidth;
+    var tooWide = rect.right - rect.left > screenw;
+    if (tooWide) { rect.right = rect.left + screenw; }
+    if (rect.left < 10)
+      { result.scrollLeft = 0; }
+    else if (rect.left < screenleft)
+      { result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10)); }
+    else if (rect.right > screenw + screenleft - 3)
+      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
+    return result
+  }
+
+  // Store a relative adjustment to the scroll position in the current
+  // operation (to be applied when the operation finishes).
+  function addToScrollTop(cm, top) {
+    if (top == null) { return }
+    resolveScrollToPos(cm);
+    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
+  }
+
+  // Make sure that at the end of the operation the current cursor is
+  // shown.
+  function ensureCursorVisible(cm) {
+    resolveScrollToPos(cm);
+    var cur = cm.getCursor();
+    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
+  }
+
+  function scrollToCoords(cm, x, y) {
+    if (x != null || y != null) { resolveScrollToPos(cm); }
+    if (x != null) { cm.curOp.scrollLeft = x; }
+    if (y != null) { cm.curOp.scrollTop = y; }
+  }
+
+  function scrollToRange(cm, range) {
+    resolveScrollToPos(cm);
+    cm.curOp.scrollToPos = range;
+  }
+
+  // When an operation has its scrollToPos property set, and another
+  // scroll action is applied before the end of the operation, this
+  // 'simulates' scrolling that position into view in a cheap way, so
+  // that the effect of intermediate scroll commands is not ignored.
+  function resolveScrollToPos(cm) {
+    var range = cm.curOp.scrollToPos;
+    if (range) {
+      cm.curOp.scrollToPos = null;
+      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
+      scrollToCoordsRange(cm, from, to, range.margin);
     }
-    function defaultSpecialCharPlaceholder(ch) {
-      var token = elt("span", "\u2022", "cm-invalidchar");
-      token.title = "\\u" + ch.charCodeAt(0).toString(16);
-      token.setAttribute("aria-label", token.title);
-      return token;
+  }
+
+  function scrollToCoordsRange(cm, from, to, margin) {
+    var sPos = calculateScrollPos(cm, {
+      left: Math.min(from.left, to.left),
+      top: Math.min(from.top, to.top) - margin,
+      right: Math.max(from.right, to.right),
+      bottom: Math.max(from.bottom, to.bottom) + margin
+    });
+    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
+  }
+
+  // Sync the scrollable area and scrollbars, ensure the viewport
+  // covers the visible area.
+  function updateScrollTop(cm, val) {
+    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
+    if (!gecko) { updateDisplaySimple(cm, {top: val}); }
+    setScrollTop(cm, val, true);
+    if (gecko) { updateDisplaySimple(cm); }
+    startWorker(cm, 100);
+  }
+
+  function setScrollTop(cm, val, forceScroll) {
+    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
+    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
+    cm.doc.scrollTop = val;
+    cm.display.scrollbars.setScrollTop(val);
+    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
+  }
+
+  // Sync scroller and scrollbar, ensure the gutter elements are
+  // aligned.
+  function setScrollLeft(cm, val, isScroller, forceScroll) {
+    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
+    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
+    cm.doc.scrollLeft = val;
+    alignHorizontally(cm);
+    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
+    cm.display.scrollbars.setScrollLeft(val);
+  }
+
+  // SCROLLBARS
+
+  // Prepare DOM reads needed to update the scrollbars. Done in one
+  // shot to minimize update/measure roundtrips.
+  function measureForScrollbars(cm) {
+    var d = cm.display, gutterW = d.gutters.offsetWidth;
+    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
+    return {
+      clientHeight: d.scroller.clientHeight,
+      viewHeight: d.wrapper.clientHeight,
+      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
+      viewWidth: d.wrapper.clientWidth,
+      barLeft: cm.options.fixedGutter ? gutterW : 0,
+      docHeight: docH,
+      scrollHeight: docH + scrollGap(cm) + d.barHeight,
+      nativeBarWidth: d.nativeBarWidth,
+      gutterWidth: gutterW
     }
-    function buildToken(builder, text, style, startStyle, endStyle, css2, attributes) {
-      if (!text) {
-        return;
-      }
-      var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
-      var special = builder.cm.state.specialChars, mustWrap = false;
-      var content;
-      if (!special.test(text)) {
-        builder.col += text.length;
-        content = document.createTextNode(displayText);
-        builder.map.push(builder.pos, builder.pos + text.length, content);
-        if (ie && ie_version < 9) {
-          mustWrap = true;
-        }
-        builder.pos += text.length;
-      } else {
-        content = document.createDocumentFragment();
-        var pos = 0;
-        while (true) {
-          special.lastIndex = pos;
-          var m = special.exec(text);
-          var skipped = m ? m.index - pos : text.length - pos;
-          if (skipped) {
-            var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
-            if (ie && ie_version < 9) {
-              content.appendChild(elt("span", [txt]));
-            } else {
-              content.appendChild(txt);
-            }
-            builder.map.push(builder.pos, builder.pos + skipped, txt);
-            builder.col += skipped;
-            builder.pos += skipped;
-          }
-          if (!m) {
-            break;
-          }
-          pos += skipped + 1;
-          var txt$1 = void 0;
-          if (m[0] == "	") {
-            var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
-            txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
-            txt$1.setAttribute("role", "presentation");
-            txt$1.setAttribute("cm-text", "	");
-            builder.col += tabWidth;
-          } else if (m[0] == "\r" || m[0] == "\n") {
-            txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
-            txt$1.setAttribute("cm-text", m[0]);
-            builder.col += 1;
-          } else {
-            txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
-            txt$1.setAttribute("cm-text", m[0]);
-            if (ie && ie_version < 9) {
-              content.appendChild(elt("span", [txt$1]));
-            } else {
-              content.appendChild(txt$1);
-            }
-            builder.col += 1;
-          }
-          builder.map.push(builder.pos, builder.pos + 1, txt$1);
-          builder.pos++;
-        }
-      }
-      builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
-      if (style || startStyle || endStyle || mustWrap || css2 || attributes) {
-        var fullStyle = style || "";
-        if (startStyle) {
-          fullStyle += startStyle;
-        }
-        if (endStyle) {
-          fullStyle += endStyle;
-        }
-        var token = elt("span", [content], fullStyle, css2);
-        if (attributes) {
-          for (var attr in attributes) {
-            if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
-              token.setAttribute(attr, attributes[attr]);
-            }
-          }
-        }
-        return builder.content.appendChild(token);
-      }
-      builder.content.appendChild(content);
+  }
+
+  var NativeScrollbars = function(place, scroll, cm) {
+    this.cm = cm;
+    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
+    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
+    vert.tabIndex = horiz.tabIndex = -1;
+    place(vert); place(horiz);
+
+    on(vert, "scroll", function () {
+      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
+    });
+    on(horiz, "scroll", function () {
+      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
+    });
+
+    this.checkedZeroWidth = false;
+    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
+    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
+  };
+
+  NativeScrollbars.prototype.update = function (measure) {
+    var needsH = measure.scrollWidth > measure.clientWidth + 1;
+    var needsV = measure.scrollHeight > measure.clientHeight + 1;
+    var sWidth = measure.nativeBarWidth;
+
+    if (needsV) {
+      this.vert.style.display = "block";
+      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
+      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
+      // A bug in IE8 can cause this value to be negative, so guard it.
+      this.vert.firstChild.style.height =
+        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
+    } else {
+      this.vert.scrollTop = 0;
+      this.vert.style.display = "";
+      this.vert.firstChild.style.height = "0";
     }
-    function splitSpaces(text, trailingBefore) {
-      if (text.length > 1 && !/  /.test(text)) {
-        return text;
-      }
-      var spaceBefore = trailingBefore, result = "";
-      for (var i2 = 0; i2 < text.length; i2++) {
-        var ch = text.charAt(i2);
-        if (ch == " " && spaceBefore && (i2 == text.length - 1 || text.charCodeAt(i2 + 1) == 32)) {
-          ch = "\xA0";
-        }
-        result += ch;
-        spaceBefore = ch == " ";
-      }
-      return result;
-    }
-    function buildTokenBadBidi(inner, order) {
-      return function(builder, text, style, startStyle, endStyle, css2, attributes) {
-        style = style ? style + " cm-force-border" : "cm-force-border";
-        var start = builder.pos, end = start + text.length;
-        for (; ; ) {
-          var part = void 0;
-          for (var i2 = 0; i2 < order.length; i2++) {
-            part = order[i2];
-            if (part.to > start && part.from <= start) {
-              break;
-            }
-          }
-          if (part.to >= end) {
-            return inner(builder, text, style, startStyle, endStyle, css2, attributes);
-          }
-          inner(builder, text.slice(0, part.to - start), style, startStyle, null, css2, attributes);
-          startStyle = null;
-          text = text.slice(part.to - start);
-          start = part.to;
-        }
-      };
+
+    if (needsH) {
+      this.horiz.style.display = "block";
+      this.horiz.style.right = needsV ? sWidth + "px" : "0";
+      this.horiz.style.left = measure.barLeft + "px";
+      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
+      this.horiz.firstChild.style.width =
+        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
+    } else {
+      this.horiz.style.display = "";
+      this.horiz.firstChild.style.width = "0";
     }
-    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
-      var widget = !ignoreWidget && marker.widgetNode;
-      if (widget) {
-        builder.map.push(builder.pos, builder.pos + size, widget);
-      }
-      if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
-        if (!widget) {
-          widget = builder.content.appendChild(document.createElement("span"));
-        }
-        widget.setAttribute("cm-marker", marker.id);
-      }
-      if (widget) {
-        builder.cm.display.input.setUneditable(widget);
-        builder.content.appendChild(widget);
-      }
-      builder.pos += size;
-      builder.trailingSpace = false;
+
+    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
+      if (sWidth == 0) { this.zeroWidthHack(); }
+      this.checkedZeroWidth = true;
     }
-    function insertLineContent(line, builder, styles) {
-      var spans = line.markedSpans, allText = line.text, at = 0;
-      if (!spans) {
-        for (var i$12 = 1; i$12 < styles.length; i$12 += 2) {
-          builder.addToken(builder, allText.slice(at, at = styles[i$12]), interpretTokenStyle(styles[i$12 + 1], builder.cm.options));
-        }
-        return;
-      }
-      var len = allText.length, pos = 0, i2 = 1, text = "", style, css2;
-      var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
-      for (; ; ) {
-        if (nextChange == pos) {
-          spanStyle = spanEndStyle = spanStartStyle = css2 = "";
-          attributes = null;
-          collapsed = null;
-          nextChange = Infinity;
-          var foundBookmarks = [], endStyles = void 0;
-          for (var j = 0; j < spans.length; ++j) {
-            var sp = spans[j], m = sp.marker;
-            if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
-              foundBookmarks.push(m);
-            } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
-              if (sp.to != null && sp.to != pos && nextChange > sp.to) {
-                nextChange = sp.to;
-                spanEndStyle = "";
-              }
-              if (m.className) {
-                spanStyle += " " + m.className;
-              }
-              if (m.css) {
-                css2 = (css2 ? css2 + ";" : "") + m.css;
-              }
-              if (m.startStyle && sp.from == pos) {
-                spanStartStyle += " " + m.startStyle;
-              }
-              if (m.endStyle && sp.to == nextChange) {
-                (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
-              }
-              if (m.title) {
-                (attributes || (attributes = {})).title = m.title;
-              }
-              if (m.attributes) {
-                for (var attr in m.attributes) {
-                  (attributes || (attributes = {}))[attr] = m.attributes[attr];
-                }
-              }
-              if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
-                collapsed = sp;
-              }
-            } else if (sp.from > pos && nextChange > sp.from) {
-              nextChange = sp.from;
-            }
-          }
-          if (endStyles) {
-            for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
-              if (endStyles[j$1 + 1] == nextChange) {
-                spanEndStyle += " " + endStyles[j$1];
-              }
-            }
-          }
-          if (!collapsed || collapsed.from == pos) {
-            for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
-              buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
-            }
-          }
-          if (collapsed && (collapsed.from || 0) == pos) {
-            buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
-            if (collapsed.to == null) {
-              return;
-            }
-            if (collapsed.to == pos) {
-              collapsed = false;
-            }
-          }
-        }
-        if (pos >= len) {
-          break;
-        }
-        var upto = Math.min(len, nextChange);
-        while (true) {
-          if (text) {
-            var end = pos + text.length;
-            if (!collapsed) {
-              var tokenText = end > upto ? text.slice(0, upto - pos) : text;
-              builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css2, attributes);
-            }
-            if (end >= upto) {
-              text = text.slice(upto - pos);
-              pos = upto;
-              break;
-            }
-            pos = end;
-            spanStartStyle = "";
-          }
-          text = allText.slice(at, at = styles[i2++]);
-          style = interpretTokenStyle(styles[i2++], builder.cm.options);
-        }
-      }
+
+    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
+  };
+
+  NativeScrollbars.prototype.setScrollLeft = function (pos) {
+    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
+    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
+  };
+
+  NativeScrollbars.prototype.setScrollTop = function (pos) {
+    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
+    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
+  };
+
+  NativeScrollbars.prototype.zeroWidthHack = function () {
+    var w = mac && !mac_geMountainLion ? "12px" : "18px";
+    this.horiz.style.height = this.vert.style.width = w;
+    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
+    this.disableHoriz = new Delayed;
+    this.disableVert = new Delayed;
+  };
+
+  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
+    bar.style.pointerEvents = "auto";
+    function maybeDisable() {
+      // To find out whether the scrollbar is still visible, we
+      // check whether the element under the pixel in the bottom
+      // right corner of the scrollbar box is the scrollbar box
+      // itself (when the bar is still visible) or its filler child
+      // (when the bar is hidden). If it is still visible, we keep
+      // it enabled, if it's hidden, we disable pointer events.
+      var box = bar.getBoundingClientRect();
+      var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
+          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
+      if (elt != bar) { bar.style.pointerEvents = "none"; }
+      else { delay.set(1000, maybeDisable); }
+    }
+    delay.set(1000, maybeDisable);
+  };
+
+  NativeScrollbars.prototype.clear = function () {
+    var parent = this.horiz.parentNode;
+    parent.removeChild(this.horiz);
+    parent.removeChild(this.vert);
+  };
+
+  var NullScrollbars = function () {};
+
+  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
+  NullScrollbars.prototype.setScrollLeft = function () {};
+  NullScrollbars.prototype.setScrollTop = function () {};
+  NullScrollbars.prototype.clear = function () {};
+
+  function updateScrollbars(cm, measure) {
+    if (!measure) { measure = measureForScrollbars(cm); }
+    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
+    updateScrollbarsInner(cm, measure);
+    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
+      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
+        { updateHeightsInViewport(cm); }
+      updateScrollbarsInner(cm, measureForScrollbars(cm));
+      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
     }
-    function LineView(doc, line, lineN) {
-      this.line = line;
-      this.rest = visualLineContinued(line);
-      this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
-      this.node = this.text = null;
-      this.hidden = lineIsHidden(doc, line);
+  }
+
+  // Re-synchronize the fake scrollbars with the actual size of the
+  // content.
+  function updateScrollbarsInner(cm, measure) {
+    var d = cm.display;
+    var sizes = d.scrollbars.update(measure);
+
+    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
+    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
+    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
+
+    if (sizes.right && sizes.bottom) {
+      d.scrollbarFiller.style.display = "block";
+      d.scrollbarFiller.style.height = sizes.bottom + "px";
+      d.scrollbarFiller.style.width = sizes.right + "px";
+    } else { d.scrollbarFiller.style.display = ""; }
+    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
+      d.gutterFiller.style.display = "block";
+      d.gutterFiller.style.height = sizes.bottom + "px";
+      d.gutterFiller.style.width = measure.gutterWidth + "px";
+    } else { d.gutterFiller.style.display = ""; }
+  }
+
+  var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};
+
+  function initScrollbars(cm) {
+    if (cm.display.scrollbars) {
+      cm.display.scrollbars.clear();
+      if (cm.display.scrollbars.addClass)
+        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
     }
-    function buildViewArray(cm, from, to) {
-      var array = [], nextPos;
-      for (var pos = from; pos < to; pos = nextPos) {
-        var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
-        nextPos = pos + view.size;
-        array.push(view);
-      }
-      return array;
+
+    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
+      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
+      // Prevent clicks in the scrollbars from killing focus
+      on(node, "mousedown", function () {
+        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
+      });
+      node.setAttribute("cm-not-content", "true");
+    }, function (pos, axis) {
+      if (axis == "horizontal") { setScrollLeft(cm, pos); }
+      else { updateScrollTop(cm, pos); }
+    }, cm);
+    if (cm.display.scrollbars.addClass)
+      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
+  }
+
+  // Operations are used to wrap a series of changes to the editor
+  // state in such a way that each change won't have to update the
+  // cursor and display (which would be awkward, slow, and
+  // error-prone). Instead, display updates are batched and then all
+  // combined and executed at once.
+
+  var nextOpId = 0;
+  // Start a new operation.
+  function startOperation(cm) {
+    cm.curOp = {
+      cm: cm,
+      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
+      startHeight: cm.doc.height, // Used to detect need to update scrollbar
+      forceUpdate: false,      // Used to force a redraw
+      updateInput: 0,       // Whether to reset the input textarea
+      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
+      changeObjs: null,        // Accumulated changes, for firing change events
+      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
+      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
+      selectionChanged: false, // Whether the selection needs to be redrawn
+      updateMaxLine: false,    // Set when the widest line needs to be determined anew
+      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
+      scrollToPos: null,       // Used to scroll to a specific position
+      focus: false,
+      id: ++nextOpId,          // Unique ID
+      markArrays: null         // Used by addMarkedSpan
+    };
+    pushOperation(cm.curOp);
+  }
+
+  // Finish an operation, updating the display and signalling delayed events
+  function endOperation(cm) {
+    var op = cm.curOp;
+    if (op) { finishOperation(op, function (group) {
+      for (var i = 0; i < group.ops.length; i++)
+        { group.ops[i].cm.curOp = null; }
+      endOperations(group);
+    }); }
+  }
+
+  // The DOM updates done when an operation finishes are batched so
+  // that the minimum number of relayouts are required.
+  function endOperations(group) {
+    var ops = group.ops;
+    for (var i = 0; i < ops.length; i++) // Read DOM
+      { endOperation_R1(ops[i]); }
+    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
+      { endOperation_W1(ops[i$1]); }
+    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
+      { endOperation_R2(ops[i$2]); }
+    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
+      { endOperation_W2(ops[i$3]); }
+    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
+      { endOperation_finish(ops[i$4]); }
+  }
+
+  function endOperation_R1(op) {
+    var cm = op.cm, display = cm.display;
+    maybeClipScrollbars(cm);
+    if (op.updateMaxLine) { findMaxLine(cm); }
+
+    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
+      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
+                         op.scrollToPos.to.line >= display.viewTo) ||
+      display.maxLineChanged && cm.options.lineWrapping;
+    op.update = op.mustUpdate &&
+      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
+  }
+
+  function endOperation_W1(op) {
+    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
+  }
+
+  function endOperation_R2(op) {
+    var cm = op.cm, display = cm.display;
+    if (op.updatedDisplay) { updateHeightsInViewport(cm); }
+
+    op.barMeasure = measureForScrollbars(cm);
+
+    // If the max line changed since it was last measured, measure it,
+    // and ensure the document's width matches it.
+    // updateDisplay_W2 will use these properties to do the actual resizing
+    if (display.maxLineChanged && !cm.options.lineWrapping) {
+      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
+      cm.display.sizerWidth = op.adjustWidthTo;
+      op.barMeasure.scrollWidth =
+        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
+      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
     }
-    var operationGroup = null;
-    function pushOperation(op) {
-      if (operationGroup) {
-        operationGroup.ops.push(op);
-      } else {
-        op.ownsGroup = operationGroup = {
-          ops: [op],
-          delayedCallbacks: []
-        };
-      }
+
+    if (op.updatedDisplay || op.selectionChanged)
+      { op.preparedSelection = display.input.prepareSelection(); }
+  }
+
+  function endOperation_W2(op) {
+    var cm = op.cm;
+
+    if (op.adjustWidthTo != null) {
+      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
+      if (op.maxScrollLeft < cm.doc.scrollLeft)
+        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
+      cm.display.maxLineChanged = false;
     }
-    function fireCallbacksForOps(group) {
-      var callbacks = group.delayedCallbacks, i2 = 0;
-      do {
-        for (; i2 < callbacks.length; i2++) {
-          callbacks[i2].call(null);
-        }
-        for (var j = 0; j < group.ops.length; j++) {
-          var op = group.ops[j];
-          if (op.cursorActivityHandlers) {
-            while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
-              op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
-            }
-          }
-        }
-      } while (i2 < callbacks.length);
+
+    var takeFocus = op.focus && op.focus == activeElt();
+    if (op.preparedSelection)
+      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
+    if (op.updatedDisplay || op.startHeight != cm.doc.height)
+      { updateScrollbars(cm, op.barMeasure); }
+    if (op.updatedDisplay)
+      { setDocumentHeight(cm, op.barMeasure); }
+
+    if (op.selectionChanged) { restartBlink(cm); }
+
+    if (cm.state.focused && op.updateInput)
+      { cm.display.input.reset(op.typing); }
+    if (takeFocus) { ensureFocus(op.cm); }
+  }
+
+  function endOperation_finish(op) {
+    var cm = op.cm, display = cm.display, doc = cm.doc;
+
+    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }
+
+    // Abort mouse wheel delta measurement, when scrolling explicitly
+    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
+      { display.wheelStartX = display.wheelStartY = null; }
+
+    // Propagate the scroll position to the actual DOM scroller
+    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }
+
+    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
+    // If we need to scroll a specific position into view, do so.
+    if (op.scrollToPos) {
+      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
+                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
+      maybeScrollWindow(cm, rect);
     }
-    function finishOperation(op, endCb) {
-      var group = op.ownsGroup;
-      if (!group) {
-        return;
-      }
-      try {
-        fireCallbacksForOps(group);
-      } finally {
-        operationGroup = null;
-        endCb(group);
-      }
+
+    // Fire events for markers that are hidden/unidden by editing or
+    // undoing
+    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
+    if (hidden) { for (var i = 0; i < hidden.length; ++i)
+      { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
+    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
+      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }
+
+    if (display.wrapper.offsetHeight)
+      { doc.scrollTop = cm.display.scroller.scrollTop; }
+
+    // Fire change events, and delayed event handlers
+    if (op.changeObjs)
+      { signal(cm, "changes", cm, op.changeObjs); }
+    if (op.update)
+      { op.update.finish(); }
+  }
+
+  // Run the given function in an operation
+  function runInOp(cm, f) {
+    if (cm.curOp) { return f() }
+    startOperation(cm);
+    try { return f() }
+    finally { endOperation(cm); }
+  }
+  // Wraps a function in an operation. Returns the wrapped function.
+  function operation(cm, f) {
+    return function() {
+      if (cm.curOp) { return f.apply(cm, arguments) }
+      startOperation(cm);
+      try { return f.apply(cm, arguments) }
+      finally { endOperation(cm); }
     }
-    var orphanDelayedCallbacks = null;
-    function signalLater(emitter, type) {
-      var arr = getHandlers(emitter, type);
-      if (!arr.length) {
-        return;
-      }
-      var args = Array.prototype.slice.call(arguments, 2), list;
-      if (operationGroup) {
-        list = operationGroup.delayedCallbacks;
-      } else if (orphanDelayedCallbacks) {
-        list = orphanDelayedCallbacks;
-      } else {
-        list = orphanDelayedCallbacks = [];
-        setTimeout(fireOrphanDelayed, 0);
-      }
-      var loop = function(i3) {
-        list.push(function() {
-          return arr[i3].apply(null, args);
-        });
-      };
-      for (var i2 = 0; i2 < arr.length; ++i2)
-        loop(i2);
-    }
-    function fireOrphanDelayed() {
-      var delayed = orphanDelayedCallbacks;
-      orphanDelayedCallbacks = null;
-      for (var i2 = 0; i2 < delayed.length; ++i2) {
-        delayed[i2]();
-      }
-    }
-    function updateLineForChanges(cm, lineView, lineN, dims) {
-      for (var j = 0; j < lineView.changes.length; j++) {
-        var type = lineView.changes[j];
-        if (type == "text") {
-          updateLineText(cm, lineView);
-        } else if (type == "gutter") {
-          updateLineGutter(cm, lineView, lineN, dims);
-        } else if (type == "class") {
-          updateLineClasses(cm, lineView);
-        } else if (type == "widget") {
-          updateLineWidgets(cm, lineView, dims);
-        }
-      }
-      lineView.changes = null;
+  }
+  // Used to add methods to editor and doc instances, wrapping them in
+  // operations.
+  function methodOp(f) {
+    return function() {
+      if (this.curOp) { return f.apply(this, arguments) }
+      startOperation(this);
+      try { return f.apply(this, arguments) }
+      finally { endOperation(this); }
     }
-    function ensureLineWrapped(lineView) {
-      if (lineView.node == lineView.text) {
-        lineView.node = elt("div", null, null, "position: relative");
-        if (lineView.text.parentNode) {
-          lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
-        }
-        lineView.node.appendChild(lineView.text);
-        if (ie && ie_version < 8) {
-          lineView.node.style.zIndex = 2;
-        }
-      }
-      return lineView.node;
+  }
+  function docMethodOp(f) {
+    return function() {
+      var cm = this.cm;
+      if (!cm || cm.curOp) { return f.apply(this, arguments) }
+      startOperation(cm);
+      try { return f.apply(this, arguments) }
+      finally { endOperation(cm); }
     }
-    function updateLineBackground(cm, lineView) {
-      var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
-      if (cls) {
-        cls += " CodeMirror-linebackground";
+  }
+
+  // HIGHLIGHT WORKER
+
+  function startWorker(cm, time) {
+    if (cm.doc.highlightFrontier < cm.display.viewTo)
+      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
+  }
+
+  function highlightWorker(cm) {
+    var doc = cm.doc;
+    if (doc.highlightFrontier >= cm.display.viewTo) { return }
+    var end = +new Date + cm.options.workTime;
+    var context = getContextBefore(cm, doc.highlightFrontier);
+    var changedLines = [];
+
+    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
+      if (context.line >= cm.display.viewFrom) { // Visible
+        var oldStyles = line.styles;
+        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
+        var highlighted = highlightLine(cm, line, context, true);
+        if (resetState) { context.state = resetState; }
+        line.styles = highlighted.styles;
+        var oldCls = line.styleClasses, newCls = highlighted.classes;
+        if (newCls) { line.styleClasses = newCls; }
+        else if (oldCls) { line.styleClasses = null; }
+        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
+          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
+        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
+        if (ischange) { changedLines.push(context.line); }
+        line.stateAfter = context.save();
+        context.nextLine();
+      } else {
+        if (line.text.length <= cm.options.maxHighlightLength)
+          { processLine(cm, line.text, context); }
+        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
+        context.nextLine();
       }
-      if (lineView.background) {
-        if (cls) {
-          lineView.background.className = cls;
-        } else {
-          lineView.background.parentNode.removeChild(lineView.background);
-          lineView.background = null;
-        }
-      } else if (cls) {
-        var wrap = ensureLineWrapped(lineView);
-        lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
-        cm.display.input.setUneditable(lineView.background);
-      }
-    }
-    function getLineContent(cm, lineView) {
-      var ext = cm.display.externalMeasured;
-      if (ext && ext.line == lineView.line) {
-        cm.display.externalMeasured = null;
-        lineView.measure = ext.measure;
-        return ext.built;
-      }
-      return buildLineContent(cm, lineView);
-    }
-    function updateLineText(cm, lineView) {
-      var cls = lineView.text.className;
-      var built = getLineContent(cm, lineView);
-      if (lineView.text == lineView.node) {
-        lineView.node = built.pre;
-      }
-      lineView.text.parentNode.replaceChild(built.pre, lineView.text);
-      lineView.text = built.pre;
-      if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
-        lineView.bgClass = built.bgClass;
-        lineView.textClass = built.textClass;
-        updateLineClasses(cm, lineView);
-      } else if (cls) {
-        lineView.text.className = cls;
-      }
-    }
-    function updateLineClasses(cm, lineView) {
-      updateLineBackground(cm, lineView);
-      if (lineView.line.wrapClass) {
-        ensureLineWrapped(lineView).className = lineView.line.wrapClass;
-      } else if (lineView.node != lineView.text) {
-        lineView.node.className = "";
-      }
-      var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
-      lineView.text.className = textClass || "";
-    }
-    function updateLineGutter(cm, lineView, lineN, dims) {
-      if (lineView.gutter) {
-        lineView.node.removeChild(lineView.gutter);
-        lineView.gutter = null;
-      }
-      if (lineView.gutterBackground) {
-        lineView.node.removeChild(lineView.gutterBackground);
-        lineView.gutterBackground = null;
-      }
-      if (lineView.line.gutterClass) {
-        var wrap = ensureLineWrapped(lineView);
-        lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
-        cm.display.input.setUneditable(lineView.gutterBackground);
-        wrap.insertBefore(lineView.gutterBackground, lineView.text);
-      }
-      var markers = lineView.line.gutterMarkers;
-      if (cm.options.lineNumbers || markers) {
-        var wrap$1 = ensureLineWrapped(lineView);
-        var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
-        gutterWrap.setAttribute("aria-hidden", "true");
-        cm.display.input.setUneditable(gutterWrap);
-        wrap$1.insertBefore(gutterWrap, lineView.text);
-        if (lineView.line.gutterClass) {
-          gutterWrap.className += " " + lineView.line.gutterClass;
-        }
-        if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
-          lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
-        }
-        if (markers) {
-          for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
-            var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
-            if (found) {
-              gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
-            }
-          }
-        }
+      if (+new Date > end) {
+        startWorker(cm, cm.options.workDelay);
+        return true
       }
+    });
+    doc.highlightFrontier = context.line;
+    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
+    if (changedLines.length) { runInOp(cm, function () {
+      for (var i = 0; i < changedLines.length; i++)
+        { regLineChange(cm, changedLines[i], "text"); }
+    }); }
+  }
+
+  // DISPLAY DRAWING
+
+  var DisplayUpdate = function(cm, viewport, force) {
+    var display = cm.display;
+
+    this.viewport = viewport;
+    // Store some values that we'll need later (but don't want to force a relayout for)
+    this.visible = visibleLines(display, cm.doc, viewport);
+    this.editorIsHidden = !display.wrapper.offsetWidth;
+    this.wrapperHeight = display.wrapper.clientHeight;
+    this.wrapperWidth = display.wrapper.clientWidth;
+    this.oldDisplayWidth = displayWidth(cm);
+    this.force = force;
+    this.dims = getDimensions(cm);
+    this.events = [];
+  };
+
+  DisplayUpdate.prototype.signal = function (emitter, type) {
+    if (hasHandler(emitter, type))
+      { this.events.push(arguments); }
+  };
+  DisplayUpdate.prototype.finish = function () {
+    for (var i = 0; i < this.events.length; i++)
+      { signal.apply(null, this.events[i]); }
+  };
+
+  function maybeClipScrollbars(cm) {
+    var display = cm.display;
+    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
+      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
+      display.heightForcer.style.height = scrollGap(cm) + "px";
+      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
+      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
+      display.scrollbarsClipped = true;
     }
-    function updateLineWidgets(cm, lineView, dims) {
-      if (lineView.alignable) {
-        lineView.alignable = null;
-      }
-      var isWidget = classTest("CodeMirror-linewidget");
-      for (var node = lineView.node.firstChild, next2 = void 0; node; node = next2) {
-        next2 = node.nextSibling;
-        if (isWidget.test(node.className)) {
-          lineView.node.removeChild(node);
-        }
-      }
-      insertLineWidgets(cm, lineView, dims);
+  }
+
+  function selectionSnapshot(cm) {
+    if (cm.hasFocus()) { return null }
+    var active = activeElt();
+    if (!active || !contains(cm.display.lineDiv, active)) { return null }
+    var result = {activeElt: active};
+    if (window.getSelection) {
+      var sel = window.getSelection();
+      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
+        result.anchorNode = sel.anchorNode;
+        result.anchorOffset = sel.anchorOffset;
+        result.focusNode = sel.focusNode;
+        result.focusOffset = sel.focusOffset;
+      }
+    }
+    return result
+  }
+
+  function restoreSelection(snapshot) {
+    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
+    snapshot.activeElt.focus();
+    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&
+        snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
+      var sel = window.getSelection(), range = document.createRange();
+      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
+      range.collapse(false);
+      sel.removeAllRanges();
+      sel.addRange(range);
+      sel.extend(snapshot.focusNode, snapshot.focusOffset);
     }
-    function buildLineElement(cm, lineView, lineN, dims) {
-      var built = getLineContent(cm, lineView);
-      lineView.text = lineView.node = built.pre;
-      if (built.bgClass) {
-        lineView.bgClass = built.bgClass;
-      }
-      if (built.textClass) {
-        lineView.textClass = built.textClass;
-      }
-      updateLineClasses(cm, lineView);
-      updateLineGutter(cm, lineView, lineN, dims);
-      insertLineWidgets(cm, lineView, dims);
-      return lineView.node;
-    }
-    function insertLineWidgets(cm, lineView, dims) {
-      insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
-      if (lineView.rest) {
-        for (var i2 = 0; i2 < lineView.rest.length; i2++) {
-          insertLineWidgetsFor(cm, lineView.rest[i2], lineView, dims, false);
-        }
-      }
+  }
+
+  // Does the actual updating of the line display. Bails out
+  // (returning false) when there is nothing to be done and forced is
+  // false.
+  function updateDisplayIfNeeded(cm, update) {
+    var display = cm.display, doc = cm.doc;
+
+    if (update.editorIsHidden) {
+      resetView(cm);
+      return false
     }
-    function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
-      if (!line.widgets) {
-        return;
-      }
-      var wrap = ensureLineWrapped(lineView);
-      for (var i2 = 0, ws = line.widgets; i2 < ws.length; ++i2) {
-        var widget = ws[i2], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
-        if (!widget.handleMouseEvents) {
-          node.setAttribute("cm-ignore-events", "true");
-        }
-        positionLineWidget(widget, node, lineView, dims);
-        cm.display.input.setUneditable(node);
-        if (allowAbove && widget.above) {
-          wrap.insertBefore(node, lineView.gutter || lineView.text);
-        } else {
-          wrap.appendChild(node);
-        }
-        signalLater(widget, "redraw");
-      }
+
+    // Bail out if the visible area is already rendered and nothing changed.
+    if (!update.force &&
+        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
+        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
+        display.renderedView == display.view && countDirtyView(cm) == 0)
+      { return false }
+
+    if (maybeUpdateLineNumberWidth(cm)) {
+      resetView(cm);
+      update.dims = getDimensions(cm);
     }
-    function positionLineWidget(widget, node, lineView, dims) {
-      if (widget.noHScroll) {
-        (lineView.alignable || (lineView.alignable = [])).push(node);
-        var width = dims.wrapperWidth;
-        node.style.left = dims.fixedPos + "px";
-        if (!widget.coverGutter) {
-          width -= dims.gutterTotalWidth;
-          node.style.paddingLeft = dims.gutterTotalWidth + "px";
-        }
-        node.style.width = width + "px";
-      }
-      if (widget.coverGutter) {
-        node.style.zIndex = 5;
-        node.style.position = "relative";
-        if (!widget.noHScroll) {
-          node.style.marginLeft = -dims.gutterTotalWidth + "px";
-        }
-      }
+
+    // Compute a suitable new viewport (from & to)
+    var end = doc.first + doc.size;
+    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
+    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
+    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
+    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
+    if (sawCollapsedSpans) {
+      from = visualLineNo(cm.doc, from);
+      to = visualLineEndNo(cm.doc, to);
     }
-    function widgetHeight(widget) {
-      if (widget.height != null) {
-        return widget.height;
-      }
-      var cm = widget.doc.cm;
-      if (!cm) {
-        return 0;
-      }
-      if (!contains(document.body, widget.node)) {
-        var parentStyle = "position: relative;";
-        if (widget.coverGutter) {
-          parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
-        }
-        if (widget.noHScroll) {
-          parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
-        }
-        removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
-      }
-      return widget.height = widget.node.parentNode.offsetHeight;
+
+    var different = from != display.viewFrom || to != display.viewTo ||
+      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
+    adjustView(cm, from, to);
+
+    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
+    // Position the mover div to align with the current scroll position
+    cm.display.mover.style.top = display.viewOffset + "px";
+
+    var toUpdate = countDirtyView(cm);
+    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
+        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
+      { return false }
+
+    // For big changes, we hide the enclosing element during the
+    // update, since that speeds up the operations on most browsers.
+    var selSnapshot = selectionSnapshot(cm);
+    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
+    patchDisplay(cm, display.updateLineNumbers, update.dims);
+    if (toUpdate > 4) { display.lineDiv.style.display = ""; }
+    display.renderedView = display.view;
+    // There might have been a widget with a focused element that got
+    // hidden or updated, if so re-focus it.
+    restoreSelection(selSnapshot);
+
+    // Prevent selection and cursors from interfering with the scroll
+    // width and height.
+    removeChildren(display.cursorDiv);
+    removeChildren(display.selectionDiv);
+    display.gutters.style.height = display.sizer.style.minHeight = 0;
+
+    if (different) {
+      display.lastWrapHeight = update.wrapperHeight;
+      display.lastWrapWidth = update.wrapperWidth;
+      startWorker(cm, 400);
     }
-    function eventInWidget(display, e) {
-      for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
-        if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
-          return true;
-        }
-      }
+
+    display.updateLineNumbers = null;
+
+    return true
+  }
+
+  function postUpdateDisplay(cm, update) {
+    var viewport = update.viewport;
+
+    for (var first = true;; first = false) {
+      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
+        // Clip forced viewport to actual scrollable area.
+        if (viewport && viewport.top != null)
+          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
+        // Updated line heights might result in the drawn area not
+        // actually covering the viewport. Keep looping until it does.
+        update.visible = visibleLines(cm.display, cm.doc, viewport);
+        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
+          { break }
+      } else if (first) {
+        update.visible = visibleLines(cm.display, cm.doc, viewport);
+      }
+      if (!updateDisplayIfNeeded(cm, update)) { break }
+      updateHeightsInViewport(cm);
+      var barMeasure = measureForScrollbars(cm);
+      updateSelection(cm);
+      updateScrollbars(cm, barMeasure);
+      setDocumentHeight(cm, barMeasure);
+      update.force = false;
     }
-    function paddingTop(display) {
-      return display.lineSpace.offsetTop;
+
+    update.signal(cm, "update", cm);
+    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
+      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
+      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
     }
-    function paddingVert(display) {
-      return display.mover.offsetHeight - display.lineSpace.offsetHeight;
+  }
+
+  function updateDisplaySimple(cm, viewport) {
+    var update = new DisplayUpdate(cm, viewport);
+    if (updateDisplayIfNeeded(cm, update)) {
+      updateHeightsInViewport(cm);
+      postUpdateDisplay(cm, update);
+      var barMeasure = measureForScrollbars(cm);
+      updateSelection(cm);
+      updateScrollbars(cm, barMeasure);
+      setDocumentHeight(cm, barMeasure);
+      update.finish();
     }
-    function paddingH(display) {
-      if (display.cachedPaddingH) {
-        return display.cachedPaddingH;
-      }
-      var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
-      var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
-      var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
-      if (!isNaN(data.left) && !isNaN(data.right)) {
-        display.cachedPaddingH = data;
-      }
-      return data;
+  }
+
+  // Sync the actual display DOM structure with display.view, removing
+  // nodes for lines that are no longer in view, and creating the ones
+  // that are not there yet, and updating the ones that are out of
+  // date.
+  function patchDisplay(cm, updateNumbersFrom, dims) {
+    var display = cm.display, lineNumbers = cm.options.lineNumbers;
+    var container = display.lineDiv, cur = container.firstChild;
+
+    function rm(node) {
+      var next = node.nextSibling;
+      // Works around a throw-scroll bug in OS X Webkit
+      if (webkit && mac && cm.display.currentWheelTarget == node)
+        { node.style.display = "none"; }
+      else
+        { node.parentNode.removeChild(node); }
+      return next
     }
-    function scrollGap(cm) {
-      return scrollerGap - cm.display.nativeBarWidth;
+
+    var view = display.view, lineN = display.viewFrom;
+    // Loop over the elements in the view, syncing cur (the DOM nodes
+    // in display.lineDiv) with the view as we go.
+    for (var i = 0; i < view.length; i++) {
+      var lineView = view[i];
+      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
+        var node = buildLineElement(cm, lineView, lineN, dims);
+        container.insertBefore(node, cur);
+      } else { // Already drawn
+        while (cur != lineView.node) { cur = rm(cur); }
+        var updateNumber = lineNumbers && updateNumbersFrom != null &&
+          updateNumbersFrom <= lineN && lineView.lineNumber;
+        if (lineView.changes) {
+          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
+          updateLineForChanges(cm, lineView, lineN, dims);
+        }
+        if (updateNumber) {
+          removeChildren(lineView.lineNumber);
+          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
+        }
+        cur = lineView.node.nextSibling;
+      }
+      lineN += lineView.size;
+    }
+    while (cur) { cur = rm(cur); }
+  }
+
+  function updateGutterSpace(display) {
+    var width = display.gutters.offsetWidth;
+    display.sizer.style.marginLeft = width + "px";
+    // Send an event to consumers responding to changes in gutter width.
+    signalLater(display, "gutterChanged", display);
+  }
+
+  function setDocumentHeight(cm, measure) {
+    cm.display.sizer.style.minHeight = measure.docHeight + "px";
+    cm.display.heightForcer.style.top = measure.docHeight + "px";
+    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
+  }
+
+  // Re-align line numbers and gutter marks to compensate for
+  // horizontal scrolling.
+  function alignHorizontally(cm) {
+    var display = cm.display, view = display.view;
+    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
+    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
+    var gutterW = display.gutters.offsetWidth, left = comp + "px";
+    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
+      if (cm.options.fixedGutter) {
+        if (view[i].gutter)
+          { view[i].gutter.style.left = left; }
+        if (view[i].gutterBackground)
+          { view[i].gutterBackground.style.left = left; }
+      }
+      var align = view[i].alignable;
+      if (align) { for (var j = 0; j < align.length; j++)
+        { align[j].style.left = left; } }
+    } }
+    if (cm.options.fixedGutter)
+      { display.gutters.style.left = (comp + gutterW) + "px"; }
+  }
+
+  // Used to ensure that the line number gutter is still the right
+  // size for the current document size. Returns true when an update
+  // is needed.
+  function maybeUpdateLineNumberWidth(cm) {
+    if (!cm.options.lineNumbers) { return false }
+    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
+    if (last.length != display.lineNumChars) {
+      var test = display.measure.appendChild(elt("div", [elt("div", last)],
+                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
+      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
+      display.lineGutter.style.width = "";
+      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
+      display.lineNumWidth = display.lineNumInnerWidth + padding;
+      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
+      display.lineGutter.style.width = display.lineNumWidth + "px";
+      updateGutterSpace(cm.display);
+      return true
+    }
+    return false
+  }
+
+  function getGutters(gutters, lineNumbers) {
+    var result = [], sawLineNumbers = false;
+    for (var i = 0; i < gutters.length; i++) {
+      var name = gutters[i], style = null;
+      if (typeof name != "string") { style = name.style; name = name.className; }
+      if (name == "CodeMirror-linenumbers") {
+        if (!lineNumbers) { continue }
+        else { sawLineNumbers = true; }
+      }
+      result.push({className: name, style: style});
     }
-    function displayWidth(cm) {
-      return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
+    if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }
+    return result
+  }
+
+  // Rebuild the gutter elements, ensure the margin to the left of the
+  // code matches their width.
+  function renderGutters(display) {
+    var gutters = display.gutters, specs = display.gutterSpecs;
+    removeChildren(gutters);
+    display.lineGutter = null;
+    for (var i = 0; i < specs.length; ++i) {
+      var ref = specs[i];
+      var className = ref.className;
+      var style = ref.style;
+      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
+      if (style) { gElt.style.cssText = style; }
+      if (className == "CodeMirror-linenumbers") {
+        display.lineGutter = gElt;
+        gElt.style.width = (display.lineNumWidth || 1) + "px";
+      }
+    }
+    gutters.style.display = specs.length ? "" : "none";
+    updateGutterSpace(display);
+  }
+
+  function updateGutters(cm) {
+    renderGutters(cm.display);
+    regChange(cm);
+    alignHorizontally(cm);
+  }
+
+  // The display handles the DOM integration, both for input reading
+  // and content drawing. It holds references to DOM nodes and
+  // display-related state.
+
+  function Display(place, doc, input, options) {
+    var d = this;
+    this.input = input;
+
+    // Covers bottom-right square when both scrollbars are present.
+    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
+    d.scrollbarFiller.setAttribute("cm-not-content", "true");
+    // Covers bottom of gutter when coverGutterNextToScrollbar is on
+    // and h scrollbar is present.
+    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
+    d.gutterFiller.setAttribute("cm-not-content", "true");
+    // Will contain the actual code, positioned to cover the viewport.
+    d.lineDiv = eltP("div", null, "CodeMirror-code");
+    // Elements are added to these to represent selection and cursors.
+    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
+    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
+    // A visibility: hidden element used to find the size of things.
+    d.measure = elt("div", null, "CodeMirror-measure");
+    // When lines outside of the viewport are measured, they are drawn in this.
+    d.lineMeasure = elt("div", null, "CodeMirror-measure");
+    // Wraps everything that needs to exist inside the vertically-padded coordinate system
+    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
+                      null, "position: relative; outline: none");
+    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
+    // Moved around its parent to cover visible view.
+    d.mover = elt("div", [lines], null, "position: relative");
+    // Set to the height of the document, allowing scrolling.
+    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
+    d.sizerWidth = null;
+    // Behavior of elts with overflow: auto and padding is
+    // inconsistent across browsers. This is used to ensure the
+    // scrollable area is big enough.
+    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
+    // Will contain the gutters, if any.
+    d.gutters = elt("div", null, "CodeMirror-gutters");
+    d.lineGutter = null;
+    // Actual scrollable element.
+    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
+    d.scroller.setAttribute("tabIndex", "-1");
+    // The element in which the editor lives.
+    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
+
+    // This attribute is respected by automatic translation systems such as Google Translate,
+    // and may also be respected by tools used by human translators.
+    d.wrapper.setAttribute('translate', 'no');
+
+    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
+    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
+    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }
+
+    if (place) {
+      if (place.appendChild) { place.appendChild(d.wrapper); }
+      else { place(d.wrapper); }
     }
-    function displayHeight(cm) {
-      return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
+
+    // Current rendered range (may be bigger than the view window).
+    d.viewFrom = d.viewTo = doc.first;
+    d.reportedViewFrom = d.reportedViewTo = doc.first;
+    // Information about the rendered lines.
+    d.view = [];
+    d.renderedView = null;
+    // Holds info about a single rendered line when it was rendered
+    // for measurement, while not in view.
+    d.externalMeasured = null;
+    // Empty space (in pixels) above the view
+    d.viewOffset = 0;
+    d.lastWrapHeight = d.lastWrapWidth = 0;
+    d.updateLineNumbers = null;
+
+    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
+    d.scrollbarsClipped = false;
+
+    // Used to only resize the line number gutter when necessary (when
+    // the amount of lines crosses a boundary that makes its width change)
+    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
+    // Set to true when a non-horizontal-scrolling line widget is
+    // added. As an optimization, line widget aligning is skipped when
+    // this is false.
+    d.alignWidgets = false;
+
+    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
+
+    // Tracks the maximum line length so that the horizontal scrollbar
+    // can be kept static when scrolling.
+    d.maxLine = null;
+    d.maxLineLength = 0;
+    d.maxLineChanged = false;
+
+    // Used for measuring wheel scrolling granularity
+    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
+
+    // True when shift is held down.
+    d.shift = false;
+
+    // Used to track whether anything happened since the context menu
+    // was opened.
+    d.selForContextMenu = null;
+
+    d.activeTouch = null;
+
+    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
+    renderGutters(d);
+
+    input.init(d);
+  }
+
+  // Since the delta values reported on mouse wheel events are
+  // unstandardized between browsers and even browser versions, and
+  // generally horribly unpredictable, this code starts by measuring
+  // the scroll effect that the first few mouse wheel events have,
+  // and, from that, detects the way it can convert deltas to pixel
+  // offsets afterwards.
+  //
+  // The reason we want to know the amount a wheel event will scroll
+  // is that it gives us a chance to update the display before the
+  // actual scrolling happens, reducing flickering.
+
+  var wheelSamples = 0, wheelPixelsPerUnit = null;
+  // Fill in a browser-detected starting value on browsers where we
+  // know one. These don't have to be accurate -- the result of them
+  // being wrong would just be a slight flicker on the first wheel
+  // scroll (if it is large enough).
+  if (ie) { wheelPixelsPerUnit = -.53; }
+  else if (gecko) { wheelPixelsPerUnit = 15; }
+  else if (chrome) { wheelPixelsPerUnit = -.7; }
+  else if (safari) { wheelPixelsPerUnit = -1/3; }
+
+  function wheelEventDelta(e) {
+    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
+    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
+    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
+    else if (dy == null) { dy = e.wheelDelta; }
+    return {x: dx, y: dy}
+  }
+  function wheelEventPixels(e) {
+    var delta = wheelEventDelta(e);
+    delta.x *= wheelPixelsPerUnit;
+    delta.y *= wheelPixelsPerUnit;
+    return delta
+  }
+
+  function onScrollWheel(cm, e) {
+    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
+    var pixelsPerUnit = wheelPixelsPerUnit;
+    if (e.deltaMode === 0) {
+      dx = e.deltaX;
+      dy = e.deltaY;
+      pixelsPerUnit = 1;
     }
-    function ensureLineHeights(cm, lineView, rect) {
-      var wrapping = cm.options.lineWrapping;
-      var curWidth = wrapping && displayWidth(cm);
-      if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
-        var heights = lineView.measure.heights = [];
-        if (wrapping) {
-          lineView.measure.width = curWidth;
-          var rects = lineView.text.firstChild.getClientRects();
-          for (var i2 = 0; i2 < rects.length - 1; i2++) {
-            var cur = rects[i2], next2 = rects[i2 + 1];
-            if (Math.abs(cur.bottom - next2.bottom) > 2) {
-              heights.push((cur.bottom + next2.top) / 2 - rect.top);
-            }
+
+    var display = cm.display, scroll = display.scroller;
+    // Quit if there's nothing to scroll here
+    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
+    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
+    if (!(dx && canScrollX || dy && canScrollY)) { return }
+
+    // Webkit browsers on OS X abort momentum scrolls when the target
+    // of the scroll event is removed from the scrollable element.
+    // This hack (see related code in patchDisplay) makes sure the
+    // element is kept around.
+    if (dy && mac && webkit) {
+      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
+        for (var i = 0; i < view.length; i++) {
+          if (view[i].node == cur) {
+            cm.display.currentWheelTarget = cur;
+            break outer
           }
         }
-        heights.push(rect.bottom - rect.top);
       }
     }
-    function mapFromLineView(lineView, line, lineN) {
-      if (lineView.line == line) {
-        return { map: lineView.measure.map, cache: lineView.measure.cache };
-      }
-      for (var i2 = 0; i2 < lineView.rest.length; i2++) {
-        if (lineView.rest[i2] == line) {
-          return { map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2] };
-        }
-      }
-      for (var i$12 = 0; i$12 < lineView.rest.length; i$12++) {
-        if (lineNo(lineView.rest[i$12]) > lineN) {
-          return { map: lineView.measure.maps[i$12], cache: lineView.measure.caches[i$12], before: true };
-        }
-      }
-    }
-    function updateExternalMeasurement(cm, line) {
-      line = visualLine(line);
-      var lineN = lineNo(line);
-      var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
-      view.lineN = lineN;
-      var built = view.built = buildLineContent(cm, view);
-      view.text = built.pre;
-      removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
-      return view;
-    }
-    function measureChar(cm, line, ch, bias) {
-      return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
-    }
-    function findViewForLine(cm, lineN) {
-      if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
-        return cm.display.view[findViewIndex(cm, lineN)];
-      }
-      var ext = cm.display.externalMeasured;
-      if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
-        return ext;
-      }
+
+    // On some browsers, horizontal scrolling will cause redraws to
+    // happen before the gutter has been realigned, causing it to
+    // wriggle around in a most unseemly way. When we have an
+    // estimated pixels/delta value, we just handle horizontal
+    // scrolling entirely here. It'll be slightly off from native, but
+    // better than glitching out.
+    if (dx && !gecko && !presto && pixelsPerUnit != null) {
+      if (dy && canScrollY)
+        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit)); }
+      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
+      // Only prevent default scrolling if vertical scrolling is
+      // actually possible. Otherwise, it causes vertical scroll
+      // jitter on OSX trackpads when deltaX is small and deltaY
+      // is large (issue #3579)
+      if (!dy || (dy && canScrollY))
+        { e_preventDefault(e); }
+      display.wheelStartX = null; // Abort measurement, if in progress
+      return
     }
-    function prepareMeasureForLine(cm, line) {
-      var lineN = lineNo(line);
-      var view = findViewForLine(cm, lineN);
-      if (view && !view.text) {
-        view = null;
-      } else if (view && view.changes) {
-        updateLineForChanges(cm, view, lineN, getDimensions(cm));
-        cm.curOp.forceUpdate = true;
-      }
-      if (!view) {
-        view = updateExternalMeasurement(cm, line);
-      }
-      var info = mapFromLineView(view, line, lineN);
-      return {
-        line,
-        view,
-        rect: null,
-        map: info.map,
-        cache: info.cache,
-        before: info.before,
-        hasHeights: false
-      };
+
+    // 'Project' the visible viewport to cover the area that is being
+    // scrolled into view (if we know enough to estimate it).
+    if (dy && pixelsPerUnit != null) {
+      var pixels = dy * pixelsPerUnit;
+      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
+      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
+      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
+      updateDisplaySimple(cm, {top: top, bottom: bot});
     }
-    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
-      if (prepared.before) {
-        ch = -1;
-      }
-      var key = ch + (bias || ""), found;
-      if (prepared.cache.hasOwnProperty(key)) {
-        found = prepared.cache[key];
+
+    if (wheelSamples < 20 && e.deltaMode !== 0) {
+      if (display.wheelStartX == null) {
+        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
+        display.wheelDX = dx; display.wheelDY = dy;
+        setTimeout(function () {
+          if (display.wheelStartX == null) { return }
+          var movedX = scroll.scrollLeft - display.wheelStartX;
+          var movedY = scroll.scrollTop - display.wheelStartY;
+          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
+            (movedX && display.wheelDX && movedX / display.wheelDX);
+          display.wheelStartX = display.wheelStartY = null;
+          if (!sample) { return }
+          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
+          ++wheelSamples;
+        }, 200);
       } else {
-        if (!prepared.rect) {
-          prepared.rect = prepared.view.text.getBoundingClientRect();
-        }
-        if (!prepared.hasHeights) {
-          ensureLineHeights(cm, prepared.view, prepared.rect);
-          prepared.hasHeights = true;
-        }
-        found = measureCharInner(cm, prepared, ch, bias);
-        if (!found.bogus) {
-          prepared.cache[key] = found;
-        }
+        display.wheelDX += dx; display.wheelDY += dy;
       }
-      return {
-        left: found.left,
-        right: found.right,
-        top: varHeight ? found.rtop : found.top,
-        bottom: varHeight ? found.rbottom : found.bottom
-      };
     }
-    var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
-    function nodeAndOffsetInLineMap(map2, ch, bias) {
-      var node, start, end, collapse, mStart, mEnd;
-      for (var i2 = 0; i2 < map2.length; i2 += 3) {
-        mStart = map2[i2];
-        mEnd = map2[i2 + 1];
-        if (ch < mStart) {
-          start = 0;
-          end = 1;
-          collapse = "left";
-        } else if (ch < mEnd) {
-          start = ch - mStart;
-          end = start + 1;
-        } else if (i2 == map2.length - 3 || ch == mEnd && map2[i2 + 3] > ch) {
-          end = mEnd - mStart;
-          start = end - 1;
-          if (ch >= mEnd) {
-            collapse = "right";
-          }
-        }
-        if (start != null) {
-          node = map2[i2 + 2];
-          if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
-            collapse = bias;
-          }
-          if (bias == "left" && start == 0) {
-            while (i2 && map2[i2 - 2] == map2[i2 - 3] && map2[i2 - 1].insertLeft) {
-              node = map2[(i2 -= 3) + 2];
-              collapse = "left";
-            }
-          }
-          if (bias == "right" && start == mEnd - mStart) {
-            while (i2 < map2.length - 3 && map2[i2 + 3] == map2[i2 + 4] && !map2[i2 + 5].insertLeft) {
-              node = map2[(i2 += 3) + 2];
-              collapse = "right";
-            }
-          }
-          break;
-        }
-      }
-      return { node, start, end, collapse, coverStart: mStart, coverEnd: mEnd };
+  }
+
+  // Selection objects are immutable. A new one is created every time
+  // the selection changes. A selection is one or more non-overlapping
+  // (and non-touching) ranges, sorted, and an integer that indicates
+  // which one is the primary selection (the one that's scrolled into
+  // view, that getCursor returns, etc).
+  var Selection = function(ranges, primIndex) {
+    this.ranges = ranges;
+    this.primIndex = primIndex;
+  };
+
+  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };
+
+  Selection.prototype.equals = function (other) {
+    if (other == this) { return true }
+    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
+    for (var i = 0; i < this.ranges.length; i++) {
+      var here = this.ranges[i], there = other.ranges[i];
+      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
+    }
+    return true
+  };
+
+  Selection.prototype.deepCopy = function () {
+    var out = [];
+    for (var i = 0; i < this.ranges.length; i++)
+      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }
+    return new Selection(out, this.primIndex)
+  };
+
+  Selection.prototype.somethingSelected = function () {
+    for (var i = 0; i < this.ranges.length; i++)
+      { if (!this.ranges[i].empty()) { return true } }
+    return false
+  };
+
+  Selection.prototype.contains = function (pos, end) {
+    if (!end) { end = pos; }
+    for (var i = 0; i < this.ranges.length; i++) {
+      var range = this.ranges[i];
+      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
+        { return i }
+    }
+    return -1
+  };
+
+  var Range = function(anchor, head) {
+    this.anchor = anchor; this.head = head;
+  };
+
+  Range.prototype.from = function () { return minPos(this.anchor, this.head) };
+  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
+  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };
+
+  // Take an unsorted, potentially overlapping set of ranges, and
+  // build a selection out of it. 'Consumes' ranges array (modifying
+  // it).
+  function normalizeSelection(cm, ranges, primIndex) {
+    var mayTouch = cm && cm.options.selectionsMayTouch;
+    var prim = ranges[primIndex];
+    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
+    primIndex = indexOf(ranges, prim);
+    for (var i = 1; i < ranges.length; i++) {
+      var cur = ranges[i], prev = ranges[i - 1];
+      var diff = cmp(prev.to(), cur.from());
+      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
+        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
+        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
+        if (i <= primIndex) { --primIndex; }
+        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
+      }
+    }
+    return new Selection(ranges, primIndex)
+  }
+
+  function simpleSelection(anchor, head) {
+    return new Selection([new Range(anchor, head || anchor)], 0)
+  }
+
+  // Compute the position of the end of a change (its 'to' property
+  // refers to the pre-change end).
+  function changeEnd(change) {
+    if (!change.text) { return change.to }
+    return Pos(change.from.line + change.text.length - 1,
+               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
+  }
+
+  // Adjust a position to refer to the post-change position of the
+  // same text, or the end of the change if the change covers it.
+  function adjustForChange(pos, change) {
+    if (cmp(pos, change.from) < 0) { return pos }
+    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }
+
+    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
+    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
+    return Pos(line, ch)
+  }
+
+  function computeSelAfterChange(doc, change) {
+    var out = [];
+    for (var i = 0; i < doc.sel.ranges.length; i++) {
+      var range = doc.sel.ranges[i];
+      out.push(new Range(adjustForChange(range.anchor, change),
+                         adjustForChange(range.head, change)));
     }
-    function getUsefulRect(rects, bias) {
-      var rect = nullRect;
-      if (bias == "left") {
-        for (var i2 = 0; i2 < rects.length; i2++) {
-          if ((rect = rects[i2]).left != rect.right) {
-            break;
-          }
-        }
+    return normalizeSelection(doc.cm, out, doc.sel.primIndex)
+  }
+
+  function offsetPos(pos, old, nw) {
+    if (pos.line == old.line)
+      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
+    else
+      { return Pos(nw.line + (pos.line - old.line), pos.ch) }
+  }
+
+  // Used by replaceSelections to allow moving the selection to the
+  // start or around the replaced test. Hint may be "start" or "around".
+  function computeReplacedSel(doc, changes, hint) {
+    var out = [];
+    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
+    for (var i = 0; i < changes.length; i++) {
+      var change = changes[i];
+      var from = offsetPos(change.from, oldPrev, newPrev);
+      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
+      oldPrev = change.to;
+      newPrev = to;
+      if (hint == "around") {
+        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
+        out[i] = new Range(inv ? to : from, inv ? from : to);
       } else {
-        for (var i$12 = rects.length - 1; i$12 >= 0; i$12--) {
-          if ((rect = rects[i$12]).left != rect.right) {
-            break;
-          }
-        }
+        out[i] = new Range(from, from);
       }
-      return rect;
     }
-    function measureCharInner(cm, prepared, ch, bias) {
-      var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
-      var node = place.node, start = place.start, end = place.end, collapse = place.collapse;
-      var rect;
-      if (node.nodeType == 3) {
-        for (var i$12 = 0; i$12 < 4; i$12++) {
-          while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
-            --start;
-          }
-          while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
-            ++end;
-          }
-          if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
-            rect = node.parentNode.getBoundingClientRect();
-          } else {
-            rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
-          }
-          if (rect.left || rect.right || start == 0) {
-            break;
-          }
-          end = start;
-          start = start - 1;
-          collapse = "right";
-        }
-        if (ie && ie_version < 11) {
-          rect = maybeUpdateRectForZooming(cm.display.measure, rect);
-        }
-      } else {
-        if (start > 0) {
-          collapse = bias = "right";
-        }
-        var rects;
-        if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
-          rect = rects[bias == "right" ? rects.length - 1 : 0];
-        } else {
-          rect = node.getBoundingClientRect();
-        }
-      }
-      if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
-        var rSpan = node.parentNode.getClientRects()[0];
-        if (rSpan) {
-          rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
-        } else {
-          rect = nullRect;
-        }
-      }
-      var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
-      var mid = (rtop + rbot) / 2;
-      var heights = prepared.view.measure.heights;
-      var i2 = 0;
-      for (; i2 < heights.length - 1; i2++) {
-        if (mid < heights[i2]) {
-          break;
-        }
-      }
-      var top = i2 ? heights[i2 - 1] : 0, bot = heights[i2];
-      var result = {
-        left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
-        right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
-        top,
-        bottom: bot
-      };
-      if (!rect.left && !rect.right) {
-        result.bogus = true;
-      }
-      if (!cm.options.singleCursorHeightPerLine) {
-        result.rtop = rtop;
-        result.rbottom = rbot;
-      }
-      return result;
+    return new Selection(out, doc.sel.primIndex)
+  }
+
+  // Used to get the editor into a consistent state again when options change.
+
+  function loadMode(cm) {
+    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
+    resetModeState(cm);
+  }
+
+  function resetModeState(cm) {
+    cm.doc.iter(function (line) {
+      if (line.stateAfter) { line.stateAfter = null; }
+      if (line.styles) { line.styles = null; }
+    });
+    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
+    startWorker(cm, 100);
+    cm.state.modeGen++;
+    if (cm.curOp) { regChange(cm); }
+  }
+
+  // DOCUMENT DATA STRUCTURE
+
+  // By default, updates that start and end at the beginning of a line
+  // are treated specially, in order to make the association of line
+  // widgets and marker elements with the text behave more intuitive.
+  function isWholeLineUpdate(doc, change) {
+    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
+      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
+  }
+
+  // Perform a change on the document data structure.
+  function updateDoc(doc, change, markedSpans, estimateHeight) {
+    function spansFor(n) {return markedSpans ? markedSpans[n] : null}
+    function update(line, text, spans) {
+      updateLine(line, text, spans, estimateHeight);
+      signalLater(line, "change", line, change);
+    }
+    function linesFor(start, end) {
+      var result = [];
+      for (var i = start; i < end; ++i)
+        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }
+      return result
     }
-    function maybeUpdateRectForZooming(measure, rect) {
-      if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
-        return rect;
+
+    var from = change.from, to = change.to, text = change.text;
+    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
+    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
+
+    // Adjust the line structure
+    if (change.full) {
+      doc.insert(0, linesFor(0, text.length));
+      doc.remove(text.length, doc.size - text.length);
+    } else if (isWholeLineUpdate(doc, change)) {
+      // This is a whole-line replace. Treated specially to make
+      // sure line objects move the way they are supposed to.
+      var added = linesFor(0, text.length - 1);
+      update(lastLine, lastLine.text, lastSpans);
+      if (nlines) { doc.remove(from.line, nlines); }
+      if (added.length) { doc.insert(from.line, added); }
+    } else if (firstLine == lastLine) {
+      if (text.length == 1) {
+        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
+      } else {
+        var added$1 = linesFor(1, text.length - 1);
+        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
+        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
+        doc.insert(from.line + 1, added$1);
       }
-      var scaleX = screen.logicalXDPI / screen.deviceXDPI;
-      var scaleY = screen.logicalYDPI / screen.deviceYDPI;
-      return {
-        left: rect.left * scaleX,
-        right: rect.right * scaleX,
-        top: rect.top * scaleY,
-        bottom: rect.bottom * scaleY
-      };
+    } else if (text.length == 1) {
+      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
+      doc.remove(from.line + 1, nlines);
+    } else {
+      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
+      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
+      var added$2 = linesFor(1, text.length - 1);
+      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
+      doc.insert(from.line + 1, added$2);
     }
-    function clearLineMeasurementCacheFor(lineView) {
-      if (lineView.measure) {
-        lineView.measure.cache = {};
-        lineView.measure.heights = null;
-        if (lineView.rest) {
-          for (var i2 = 0; i2 < lineView.rest.length; i2++) {
-            lineView.measure.caches[i2] = {};
-          }
-        }
-      }
+
+    signalLater(doc, "change", doc, change);
+  }
+
+  // Call f for all linked documents.
+  function linkedDocs(doc, f, sharedHistOnly) {
+    function propagate(doc, skip, sharedHist) {
+      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
+        var rel = doc.linked[i];
+        if (rel.doc == skip) { continue }
+        var shared = sharedHist && rel.sharedHist;
+        if (sharedHistOnly && !shared) { continue }
+        f(rel.doc, shared);
+        propagate(rel.doc, doc, shared);
+      } }
+    }
+    propagate(doc, null, true);
+  }
+
+  // Attach a document to an editor.
+  function attachDoc(cm, doc) {
+    if (doc.cm) { throw new Error("This document is already in use.") }
+    cm.doc = doc;
+    doc.cm = cm;
+    estimateLineHeights(cm);
+    loadMode(cm);
+    setDirectionClass(cm);
+    cm.options.direction = doc.direction;
+    if (!cm.options.lineWrapping) { findMaxLine(cm); }
+    cm.options.mode = doc.modeOption;
+    regChange(cm);
+  }
+
+  function setDirectionClass(cm) {
+  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
+  }
+
+  function directionChanged(cm) {
+    runInOp(cm, function () {
+      setDirectionClass(cm);
+      regChange(cm);
+    });
+  }
+
+  function History(prev) {
+    // Arrays of change events and selections. Doing something adds an
+    // event to done and clears undo. Undoing moves events from done
+    // to undone, redoing moves them in the other direction.
+    this.done = []; this.undone = [];
+    this.undoDepth = prev ? prev.undoDepth : Infinity;
+    // Used to track when changes can be merged into a single undo
+    // event
+    this.lastModTime = this.lastSelTime = 0;
+    this.lastOp = this.lastSelOp = null;
+    this.lastOrigin = this.lastSelOrigin = null;
+    // Used by the isClean() method
+    this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
+  }
+
+  // Create a history change event from an updateDoc-style change
+  // object.
+  function historyChangeFromChange(doc, change) {
+    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
+    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
+    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
+    return histChange
+  }
+
+  // Pop all selection events off the end of a history array. Stop at
+  // a change event.
+  function clearSelectionEvents(array) {
+    while (array.length) {
+      var last = lst(array);
+      if (last.ranges) { array.pop(); }
+      else { break }
     }
-    function clearLineMeasurementCache(cm) {
-      cm.display.externalMeasure = null;
-      removeChildren(cm.display.lineMeasure);
-      for (var i2 = 0; i2 < cm.display.view.length; i2++) {
-        clearLineMeasurementCacheFor(cm.display.view[i2]);
-      }
+  }
+
+  // Find the top change event in the history. Pop off selection
+  // events that are in the way.
+  function lastChangeEvent(hist, force) {
+    if (force) {
+      clearSelectionEvents(hist.done);
+      return lst(hist.done)
+    } else if (hist.done.length && !lst(hist.done).ranges) {
+      return lst(hist.done)
+    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
+      hist.done.pop();
+      return lst(hist.done)
     }
-    function clearCaches(cm) {
-      clearLineMeasurementCache(cm);
-      cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
-      if (!cm.options.lineWrapping) {
-        cm.display.maxLineChanged = true;
+  }
+
+  // Register a change in the history. Merges changes that are within
+  // a single operation, or are close together with an origin that
+  // allows merging (starting with "+") into a single event.
+  function addChangeToHistory(doc, change, selAfter, opId) {
+    var hist = doc.history;
+    hist.undone.length = 0;
+    var time = +new Date, cur;
+    var last;
+
+    if ((hist.lastOp == opId ||
+         hist.lastOrigin == change.origin && change.origin &&
+         ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
+          change.origin.charAt(0) == "*")) &&
+        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
+      // Merge this change into the last event
+      last = lst(cur.changes);
+      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
+        // Optimized case for simple insertion -- don't want to add
+        // new changesets for every character typed
+        last.to = changeEnd(change);
+      } else {
+        // Add new sub-event
+        cur.changes.push(historyChangeFromChange(doc, change));
       }
-      cm.display.lineNumChars = null;
+    } else {
+      // Can not be merged, start a new event.
+      var before = lst(hist.done);
+      if (!before || !before.ranges)
+        { pushSelectionToHistory(doc.sel, hist.done); }
+      cur = {changes: [historyChangeFromChange(doc, change)],
+             generation: hist.generation};
+      hist.done.push(cur);
+      while (hist.done.length > hist.undoDepth) {
+        hist.done.shift();
+        if (!hist.done[0].ranges) { hist.done.shift(); }
+      }
+    }
+    hist.done.push(selAfter);
+    hist.generation = ++hist.maxGeneration;
+    hist.lastModTime = hist.lastSelTime = time;
+    hist.lastOp = hist.lastSelOp = opId;
+    hist.lastOrigin = hist.lastSelOrigin = change.origin;
+
+    if (!last) { signal(doc, "historyAdded"); }
+  }
+
+  function selectionEventCanBeMerged(doc, origin, prev, sel) {
+    var ch = origin.charAt(0);
+    return ch == "*" ||
+      ch == "+" &&
+      prev.ranges.length == sel.ranges.length &&
+      prev.somethingSelected() == sel.somethingSelected() &&
+      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
+  }
+
+  // Called whenever the selection changes, sets the new selection as
+  // the pending selection in the history, and pushes the old pending
+  // selection into the 'done' array when it was significantly
+  // different (in number of selected ranges, emptiness, or time).
+  function addSelectionToHistory(doc, sel, opId, options) {
+    var hist = doc.history, origin = options && options.origin;
+
+    // A new event is started when the previous origin does not match
+    // the current, or the origins don't allow matching. Origins
+    // starting with * are always merged, those starting with + are
+    // merged when similar and close together in time.
+    if (opId == hist.lastSelOp ||
+        (origin && hist.lastSelOrigin == origin &&
+         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
+          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
+      { hist.done[hist.done.length - 1] = sel; }
+    else
+      { pushSelectionToHistory(sel, hist.done); }
+
+    hist.lastSelTime = +new Date;
+    hist.lastSelOrigin = origin;
+    hist.lastSelOp = opId;
+    if (options && options.clearRedo !== false)
+      { clearSelectionEvents(hist.undone); }
+  }
+
+  function pushSelectionToHistory(sel, dest) {
+    var top = lst(dest);
+    if (!(top && top.ranges && top.equals(sel)))
+      { dest.push(sel); }
+  }
+
+  // Used to store marked span information in the history.
+  function attachLocalSpans(doc, change, from, to) {
+    var existing = change["spans_" + doc.id], n = 0;
+    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
+      if (line.markedSpans)
+        { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
+      ++n;
+    });
+  }
+
+  // When un/re-doing restores text containing marked spans, those
+  // that have been explicitly cleared should not be restored.
+  function removeClearedSpans(spans) {
+    if (!spans) { return null }
+    var out;
+    for (var i = 0; i < spans.length; ++i) {
+      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
+      else if (out) { out.push(spans[i]); }
     }
-    function pageScrollX() {
-      if (chrome && android) {
-        return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
+    return !out ? spans : out.length ? out : null
+  }
+
+  // Retrieve and filter the old marked spans stored in a change event.
+  function getOldSpans(doc, change) {
+    var found = change["spans_" + doc.id];
+    if (!found) { return null }
+    var nw = [];
+    for (var i = 0; i < change.text.length; ++i)
+      { nw.push(removeClearedSpans(found[i])); }
+    return nw
+  }
+
+  // Used for un/re-doing changes from the history. Combines the
+  // result of computing the existing spans with the set of spans that
+  // existed in the history (so that deleting around a span and then
+  // undoing brings back the span).
+  function mergeOldSpans(doc, change) {
+    var old = getOldSpans(doc, change);
+    var stretched = stretchSpansOverChange(doc, change);
+    if (!old) { return stretched }
+    if (!stretched) { return old }
+
+    for (var i = 0; i < old.length; ++i) {
+      var oldCur = old[i], stretchCur = stretched[i];
+      if (oldCur && stretchCur) {
+        spans: for (var j = 0; j < stretchCur.length; ++j) {
+          var span = stretchCur[j];
+          for (var k = 0; k < oldCur.length; ++k)
+            { if (oldCur[k].marker == span.marker) { continue spans } }
+          oldCur.push(span);
+        }
+      } else if (stretchCur) {
+        old[i] = stretchCur;
       }
-      return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
     }
-    function pageScrollY() {
-      if (chrome && android) {
-        return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
-      }
-      return window.pageYOffset || (document.documentElement || document.body).scrollTop;
+    return old
+  }
+
+  // Used both to provide a JSON-safe object in .getHistory, and, when
+  // detaching a document, to split the history in two
+  function copyHistoryArray(events, newGroup, instantiateSel) {
+    var copy = [];
+    for (var i = 0; i < events.length; ++i) {
+      var event = events[i];
+      if (event.ranges) {
+        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
+        continue
+      }
+      var changes = event.changes, newChanges = [];
+      copy.push({changes: newChanges});
+      for (var j = 0; j < changes.length; ++j) {
+        var change = changes[j], m = (void 0);
+        newChanges.push({from: change.from, to: change.to, text: change.text});
+        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
+          if (indexOf(newGroup, Number(m[1])) > -1) {
+            lst(newChanges)[prop] = change[prop];
+            delete change[prop];
+          }
+        } } }
+      }
+    }
+    return copy
+  }
+
+  // The 'scroll' parameter given to many of these indicated whether
+  // the new cursor position should be scrolled into view after
+  // modifying the selection.
+
+  // If shift is held or the extend flag is set, extends a range to
+  // include a given position (and optionally a second position).
+  // Otherwise, simply returns the range between the given positions.
+  // Used for cursor motion and such.
+  function extendRange(range, head, other, extend) {
+    if (extend) {
+      var anchor = range.anchor;
+      if (other) {
+        var posBefore = cmp(head, anchor) < 0;
+        if (posBefore != (cmp(other, anchor) < 0)) {
+          anchor = head;
+          head = other;
+        } else if (posBefore != (cmp(head, other) < 0)) {
+          head = other;
+        }
+      }
+      return new Range(anchor, head)
+    } else {
+      return new Range(other || head, head)
     }
-    function widgetTopHeight(lineObj) {
-      var height = 0;
-      if (lineObj.widgets) {
-        for (var i2 = 0; i2 < lineObj.widgets.length; ++i2) {
-          if (lineObj.widgets[i2].above) {
-            height += widgetHeight(lineObj.widgets[i2]);
-          }
-        }
-      }
-      return height;
+  }
+
+  // Extend the primary selection range, discard the rest.
+  function extendSelection(doc, head, other, options, extend) {
+    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
+    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
+  }
+
+  // Extend all selections (pos is an array of selections with length
+  // equal the number of selections)
+  function extendSelections(doc, heads, options) {
+    var out = [];
+    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
+    for (var i = 0; i < doc.sel.ranges.length; i++)
+      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
+    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
+    setSelection(doc, newSel, options);
+  }
+
+  // Updates a single range in the selection.
+  function replaceOneSelection(doc, i, range, options) {
+    var ranges = doc.sel.ranges.slice(0);
+    ranges[i] = range;
+    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
+  }
+
+  // Reset the selection to a single range.
+  function setSimpleSelection(doc, anchor, head, options) {
+    setSelection(doc, simpleSelection(anchor, head), options);
+  }
+
+  // Give beforeSelectionChange handlers a change to influence a
+  // selection update.
+  function filterSelectionChange(doc, sel, options) {
+    var obj = {
+      ranges: sel.ranges,
+      update: function(ranges) {
+        this.ranges = [];
+        for (var i = 0; i < ranges.length; i++)
+          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
+                                     clipPos(doc, ranges[i].head)); }
+      },
+      origin: options && options.origin
+    };
+    signal(doc, "beforeSelectionChange", doc, obj);
+    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
+    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
+    else { return sel }
+  }
+
+  function setSelectionReplaceHistory(doc, sel, options) {
+    var done = doc.history.done, last = lst(done);
+    if (last && last.ranges) {
+      done[done.length - 1] = sel;
+      setSelectionNoUndo(doc, sel, options);
+    } else {
+      setSelection(doc, sel, options);
     }
-    function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
-      if (!includeWidgets) {
-        var height = widgetTopHeight(lineObj);
-        rect.top += height;
-        rect.bottom += height;
-      }
-      if (context == "line") {
-        return rect;
-      }
-      if (!context) {
-        context = "local";
-      }
-      var yOff = heightAtLine(lineObj);
-      if (context == "local") {
-        yOff += paddingTop(cm.display);
-      } else {
-        yOff -= cm.display.viewOffset;
-      }
-      if (context == "page" || context == "window") {
-        var lOff = cm.display.lineSpace.getBoundingClientRect();
-        yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
-        var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
-        rect.left += xOff;
-        rect.right += xOff;
-      }
-      rect.top += yOff;
-      rect.bottom += yOff;
-      return rect;
-    }
-    function fromCoordSystem(cm, coords, context) {
-      if (context == "div") {
-        return coords;
-      }
-      var left = coords.left, top = coords.top;
-      if (context == "page") {
-        left -= pageScrollX();
-        top -= pageScrollY();
-      } else if (context == "local" || !context) {
-        var localBox = cm.display.sizer.getBoundingClientRect();
-        left += localBox.left;
-        top += localBox.top;
-      }
-      var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
-      return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top };
-    }
-    function charCoords(cm, pos, context, lineObj, bias) {
-      if (!lineObj) {
-        lineObj = getLine(cm.doc, pos.line);
-      }
-      return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
-    }
-    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
-      lineObj = lineObj || getLine(cm.doc, pos.line);
-      if (!preparedMeasure) {
-        preparedMeasure = prepareMeasureForLine(cm, lineObj);
-      }
-      function get(ch2, right) {
-        var m = measureCharPrepared(cm, preparedMeasure, ch2, right ? "right" : "left", varHeight);
-        if (right) {
-          m.left = m.right;
-        } else {
-          m.right = m.left;
-        }
-        return intoCoordSystem(cm, lineObj, m, context);
-      }
-      var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
-      if (ch >= lineObj.text.length) {
-        ch = lineObj.text.length;
-        sticky = "before";
-      } else if (ch <= 0) {
-        ch = 0;
-        sticky = "after";
-      }
-      if (!order) {
-        return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
-      }
-      function getBidi(ch2, partPos2, invert) {
-        var part = order[partPos2], right = part.level == 1;
-        return get(invert ? ch2 - 1 : ch2, right != invert);
-      }
-      var partPos = getBidiPartAt(order, ch, sticky);
-      var other = bidiOther;
-      var val = getBidi(ch, partPos, sticky == "before");
-      if (other != null) {
-        val.other = getBidi(ch, other, sticky != "before");
-      }
-      return val;
-    }
-    function estimateCoords(cm, pos) {
-      var left = 0;
-      pos = clipPos(cm.doc, pos);
-      if (!cm.options.lineWrapping) {
-        left = charWidth(cm.display) * pos.ch;
-      }
-      var lineObj = getLine(cm.doc, pos.line);
-      var top = heightAtLine(lineObj) + paddingTop(cm.display);
-      return { left, right: left, top, bottom: top + lineObj.height };
-    }
-    function PosWithInfo(line, ch, sticky, outside, xRel) {
-      var pos = Pos(line, ch, sticky);
-      pos.xRel = xRel;
-      if (outside) {
-        pos.outside = outside;
-      }
-      return pos;
-    }
-    function coordsChar(cm, x, y) {
-      var doc = cm.doc;
-      y += cm.display.viewOffset;
-      if (y < 0) {
-        return PosWithInfo(doc.first, 0, null, -1, -1);
-      }
-      var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
-      if (lineN > last) {
-        return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);
-      }
-      if (x < 0) {
-        x = 0;
-      }
-      var lineObj = getLine(doc, lineN);
-      for (; ; ) {
-        var found = coordsCharInner(cm, lineObj, lineN, x, y);
-        var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
-        if (!collapsed) {
-          return found;
-        }
-        var rangeEnd = collapsed.find(1);
-        if (rangeEnd.line == lineN) {
-          return rangeEnd;
-        }
-        lineObj = getLine(doc, lineN = rangeEnd.line);
-      }
-    }
-    function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
-      y -= widgetTopHeight(lineObj);
-      var end = lineObj.text.length;
-      var begin = findFirst(function(ch) {
-        return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
-      }, end, 0);
-      end = findFirst(function(ch) {
-        return measureCharPrepared(cm, preparedMeasure, ch).top > y;
-      }, begin, end);
-      return { begin, end };
-    }
-    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
-      if (!preparedMeasure) {
-        preparedMeasure = prepareMeasureForLine(cm, lineObj);
-      }
-      var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
-      return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
-    }
-    function boxIsAfter(box, x, y, left) {
-      return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
-    }
-    function coordsCharInner(cm, lineObj, lineNo2, x, y) {
-      y -= heightAtLine(lineObj);
-      var preparedMeasure = prepareMeasureForLine(cm, lineObj);
-      var widgetHeight2 = widgetTopHeight(lineObj);
-      var begin = 0, end = lineObj.text.length, ltr = true;
-      var order = getOrder(lineObj, cm.doc.direction);
-      if (order) {
-        var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order, x, y);
-        ltr = part.level != 1;
-        begin = ltr ? part.from : part.to - 1;
-        end = ltr ? part.to : part.from - 1;
-      }
-      var chAround = null, boxAround = null;
-      var ch = findFirst(function(ch2) {
-        var box = measureCharPrepared(cm, preparedMeasure, ch2);
-        box.top += widgetHeight2;
-        box.bottom += widgetHeight2;
-        if (!boxIsAfter(box, x, y, false)) {
-          return false;
-        }
-        if (box.top <= y && box.left <= x) {
-          chAround = ch2;
-          boxAround = box;
-        }
-        return true;
-      }, begin, end);
-      var baseX, sticky, outside = false;
-      if (boxAround) {
-        var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
-        ch = chAround + (atStart ? 0 : 1);
-        sticky = atStart ? "after" : "before";
-        baseX = atLeft ? boxAround.left : boxAround.right;
-      } else {
-        if (!ltr && (ch == end || ch == begin)) {
-          ch++;
-        }
-        sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y == ltr ? "after" : "before";
-        var coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);
-        baseX = coords.left;
-        outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
-      }
-      ch = skipExtendingChars(lineObj.text, ch, 1);
-      return PosWithInfo(lineNo2, ch, sticky, outside, x - baseX);
-    }
-    function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order, x, y) {
-      var index = findFirst(function(i2) {
-        var part2 = order[i2], ltr2 = part2.level != 1;
-        return boxIsAfter(cursorCoords(cm, Pos(lineNo2, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
-      }, 0, order.length - 1);
-      var part = order[index];
-      if (index > 0) {
-        var ltr = part.level != 1;
-        var start = cursorCoords(cm, Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
-        if (boxIsAfter(start, x, y, true) && start.top > y) {
-          part = order[index - 1];
-        }
-      }
-      return part;
+  }
+
+  // Set a new selection.
+  function setSelection(doc, sel, options) {
+    setSelectionNoUndo(doc, sel, options);
+    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
+  }
+
+  function setSelectionNoUndo(doc, sel, options) {
+    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
+      { sel = filterSelectionChange(doc, sel, options); }
+
+    var bias = options && options.bias ||
+      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
+    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
+
+    if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor")
+      { ensureCursorVisible(doc.cm); }
+  }
+
+  function setSelectionInner(doc, sel) {
+    if (sel.equals(doc.sel)) { return }
+
+    doc.sel = sel;
+
+    if (doc.cm) {
+      doc.cm.curOp.updateInput = 1;
+      doc.cm.curOp.selectionChanged = true;
+      signalCursorActivity(doc.cm);
     }
-    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
-      var ref2 = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
-      var begin = ref2.begin;
-      var end = ref2.end;
-      if (/\s/.test(lineObj.text.charAt(end - 1))) {
-        end--;
-      }
-      var part = null, closestDist = null;
-      for (var i2 = 0; i2 < order.length; i2++) {
-        var p = order[i2];
-        if (p.from >= end || p.to <= begin) {
-          continue;
+    signalLater(doc, "cursorActivity", doc);
+  }
+
+  // Verify that the selection does not partially select any atomic
+  // marked ranges.
+  function reCheckSelection(doc) {
+    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
+  }
+
+  // Return a selection that does not partially select any atomic
+  // ranges.
+  function skipAtomicInSelection(doc, sel, bias, mayClear) {
+    var out;
+    for (var i = 0; i < sel.ranges.length; i++) {
+      var range = sel.ranges[i];
+      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
+      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
+      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
+      if (out || newAnchor != range.anchor || newHead != range.head) {
+        if (!out) { out = sel.ranges.slice(0, i); }
+        out[i] = new Range(newAnchor, newHead);
+      }
+    }
+    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
+  }
+
+  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
+    var line = getLine(doc, pos.line);
+    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
+      var sp = line.markedSpans[i], m = sp.marker;
+
+      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
+      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
+      // is with selectLeft/Right
+      var preventCursorLeft = ("selectLeft" in m) ? !m.selectLeft : m.inclusiveLeft;
+      var preventCursorRight = ("selectRight" in m) ? !m.selectRight : m.inclusiveRight;
+
+      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
+          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
+        if (mayClear) {
+          signal(m, "beforeCursorEnter");
+          if (m.explicitlyCleared) {
+            if (!line.markedSpans) { break }
+            else {--i; continue}
+          }
         }
-        var ltr = p.level != 1;
-        var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
-        var dist2 = endX < x ? x - endX + 1e9 : endX - x;
-        if (!part || closestDist > dist2) {
-          part = p;
-          closestDist = dist2;
+        if (!m.atomic) { continue }
+
+        if (oldPos) {
+          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
+          if (dir < 0 ? preventCursorRight : preventCursorLeft)
+            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
+          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
+            { return skipAtomicInner(doc, near, pos, dir, mayClear) }
         }
+
+        var far = m.find(dir < 0 ? -1 : 1);
+        if (dir < 0 ? preventCursorLeft : preventCursorRight)
+          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
+        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
       }
-      if (!part) {
-        part = order[order.length - 1];
-      }
-      if (part.from < begin) {
-        part = { from: begin, to: part.to, level: part.level };
-      }
-      if (part.to > end) {
-        part = { from: part.from, to: end, level: part.level };
+    } }
+    return pos
+  }
+
+  // Ensure a given position is not inside an atomic range.
+  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
+    var dir = bias || 1;
+    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
+        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
+        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
+        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
+    if (!found) {
+      doc.cantEdit = true;
+      return Pos(doc.first, 0)
+    }
+    return found
+  }
+
+  function movePos(doc, pos, dir, line) {
+    if (dir < 0 && pos.ch == 0) {
+      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
+      else { return null }
+    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
+      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
+      else { return null }
+    } else {
+      return new Pos(pos.line, pos.ch + dir)
+    }
+  }
+
+  function selectAll(cm) {
+    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
+  }
+
+  // UPDATING
+
+  // Allow "beforeChange" event handlers to influence a change
+  function filterChange(doc, change, update) {
+    var obj = {
+      canceled: false,
+      from: change.from,
+      to: change.to,
+      text: change.text,
+      origin: change.origin,
+      cancel: function () { return obj.canceled = true; }
+    };
+    if (update) { obj.update = function (from, to, text, origin) {
+      if (from) { obj.from = clipPos(doc, from); }
+      if (to) { obj.to = clipPos(doc, to); }
+      if (text) { obj.text = text; }
+      if (origin !== undefined) { obj.origin = origin; }
+    }; }
+    signal(doc, "beforeChange", doc, obj);
+    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }
+
+    if (obj.canceled) {
+      if (doc.cm) { doc.cm.curOp.updateInput = 2; }
+      return null
+    }
+    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
+  }
+
+  // Apply a change to a document, and add it to the document's
+  // history, and propagating it to all linked documents.
+  function makeChange(doc, change, ignoreReadOnly) {
+    if (doc.cm) {
+      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
+      if (doc.cm.state.suppressEdits) { return }
+    }
+
+    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
+      change = filterChange(doc, change, true);
+      if (!change) { return }
+    }
+
+    // Possibly split or suppress the update based on the presence
+    // of read-only spans in its range.
+    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
+    if (split) {
+      for (var i = split.length - 1; i >= 0; --i)
+        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
+    } else {
+      makeChangeInner(doc, change);
+    }
+  }
+
+  function makeChangeInner(doc, change) {
+    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
+    var selAfter = computeSelAfterChange(doc, change);
+    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
+
+    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
+    var rebased = [];
+
+    linkedDocs(doc, function (doc, sharedHist) {
+      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
+        rebaseHist(doc.history, change);
+        rebased.push(doc.history);
       }
-      return part;
+      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
+    });
+  }
+
+  // Revert a change stored in a document's history.
+  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
+    var suppress = doc.cm && doc.cm.state.suppressEdits;
+    if (suppress && !allowSelectionOnly) { return }
+
+    var hist = doc.history, event, selAfter = doc.sel;
+    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;
+
+    // Verify that there is a useable event (so that ctrl-z won't
+    // needlessly clear selection events)
+    var i = 0;
+    for (; i < source.length; i++) {
+      event = source[i];
+      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
+        { break }
+    }
+    if (i == source.length) { return }
+    hist.lastOrigin = hist.lastSelOrigin = null;
+
+    for (;;) {
+      event = source.pop();
+      if (event.ranges) {
+        pushSelectionToHistory(event, dest);
+        if (allowSelectionOnly && !event.equals(doc.sel)) {
+          setSelection(doc, event, {clearRedo: false});
+          return
+        }
+        selAfter = event;
+      } else if (suppress) {
+        source.push(event);
+        return
+      } else { break }
     }
-    var measureText;
-    function textHeight(display) {
-      if (display.cachedTextHeight != null) {
-        return display.cachedTextHeight;
+
+    // Build up a reverse change object to add to the opposite history
+    // stack (redo when undoing, and vice versa).
+    var antiChanges = [];
+    pushSelectionToHistory(selAfter, dest);
+    dest.push({changes: antiChanges, generation: hist.generation});
+    hist.generation = event.generation || ++hist.maxGeneration;
+
+    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
+
+    var loop = function ( i ) {
+      var change = event.changes[i];
+      change.origin = type;
+      if (filter && !filterChange(doc, change, false)) {
+        source.length = 0;
+        return {}
       }
-      if (measureText == null) {
-        measureText = elt("pre", null, "CodeMirror-line-like");
-        for (var i2 = 0; i2 < 49; ++i2) {
-          measureText.appendChild(document.createTextNode("x"));
-          measureText.appendChild(elt("br"));
+
+      antiChanges.push(historyChangeFromChange(doc, change));
+
+      var after = i ? computeSelAfterChange(doc, change) : lst(source);
+      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
+      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
+      var rebased = [];
+
+      // Propagate to the linked documents
+      linkedDocs(doc, function (doc, sharedHist) {
+        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
+          rebaseHist(doc.history, change);
+          rebased.push(doc.history);
         }
-        measureText.appendChild(document.createTextNode("x"));
-      }
-      removeChildrenAndAdd(display.measure, measureText);
-      var height = measureText.offsetHeight / 50;
-      if (height > 3) {
-        display.cachedTextHeight = height;
-      }
-      removeChildren(display.measure);
-      return height || 1;
+        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
+      });
+    };
+
+    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
+      var returned = loop( i$1 );
+
+      if ( returned ) return returned.v;
     }
-    function charWidth(display) {
-      if (display.cachedCharWidth != null) {
-        return display.cachedCharWidth;
-      }
-      var anchor = elt("span", "xxxxxxxxxx");
-      var pre = elt("pre", [anchor], "CodeMirror-line-like");
-      removeChildrenAndAdd(display.measure, pre);
-      var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
-      if (width > 2) {
-        display.cachedCharWidth = width;
-      }
-      return width || 10;
+  }
+
+  // Sub-views need their line numbers shifted when text is added
+  // above or below them in the parent document.
+  function shiftDoc(doc, distance) {
+    if (distance == 0) { return }
+    doc.first += distance;
+    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
+      Pos(range.anchor.line + distance, range.anchor.ch),
+      Pos(range.head.line + distance, range.head.ch)
+    ); }), doc.sel.primIndex);
+    if (doc.cm) {
+      regChange(doc.cm, doc.first, doc.first - distance, distance);
+      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
+        { regLineChange(doc.cm, l, "gutter"); }
     }
-    function getDimensions(cm) {
-      var d = cm.display, left = {}, width = {};
-      var gutterLeft = d.gutters.clientLeft;
-      for (var n = d.gutters.firstChild, i2 = 0; n; n = n.nextSibling, ++i2) {
-        var id = cm.display.gutterSpecs[i2].className;
-        left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
-        width[id] = n.clientWidth;
-      }
-      return {
-        fixedPos: compensateForHScroll(d),
-        gutterTotalWidth: d.gutters.offsetWidth,
-        gutterLeft: left,
-        gutterWidth: width,
-        wrapperWidth: d.wrapper.clientWidth
-      };
+  }
+
+  // More lower-level change function, handling only a single document
+  // (not linked ones).
+  function makeChangeSingleDoc(doc, change, selAfter, spans) {
+    if (doc.cm && !doc.cm.curOp)
+      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }
+
+    if (change.to.line < doc.first) {
+      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
+      return
     }
-    function compensateForHScroll(display) {
-      return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
+    if (change.from.line > doc.lastLine()) { return }
+
+    // Clip the change to the size of this doc
+    if (change.from.line < doc.first) {
+      var shift = change.text.length - 1 - (doc.first - change.from.line);
+      shiftDoc(doc, shift);
+      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
+                text: [lst(change.text)], origin: change.origin};
+    }
+    var last = doc.lastLine();
+    if (change.to.line > last) {
+      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
+                text: [change.text[0]], origin: change.origin};
     }
-    function estimateHeight(cm) {
-      var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
-      var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
-      return function(line) {
-        if (lineIsHidden(cm.doc, line)) {
-          return 0;
-        }
-        var widgetsHeight = 0;
-        if (line.widgets) {
-          for (var i2 = 0; i2 < line.widgets.length; i2++) {
-            if (line.widgets[i2].height) {
-              widgetsHeight += line.widgets[i2].height;
-            }
-          }
-        }
-        if (wrapping) {
-          return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
-        } else {
-          return widgetsHeight + th;
+
+    change.removed = getBetween(doc, change.from, change.to);
+
+    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
+    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
+    else { updateDoc(doc, change, spans); }
+    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
+
+    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))
+      { doc.cantEdit = false; }
+  }
+
+  // Handle the interaction of a change to a document with the editor
+  // that this document is part of.
+  function makeChangeSingleDocInEditor(cm, change, spans) {
+    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
+
+    var recomputeMaxLength = false, checkWidthStart = from.line;
+    if (!cm.options.lineWrapping) {
+      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
+      doc.iter(checkWidthStart, to.line + 1, function (line) {
+        if (line == display.maxLine) {
+          recomputeMaxLength = true;
+          return true
         }
-      };
+      });
     }
-    function estimateLineHeights(cm) {
-      var doc = cm.doc, est = estimateHeight(cm);
-      doc.iter(function(line) {
-        var estHeight = est(line);
-        if (estHeight != line.height) {
-          updateLineHeight(line, estHeight);
+
+    if (doc.sel.contains(change.from, change.to) > -1)
+      { signalCursorActivity(cm); }
+
+    updateDoc(doc, change, spans, estimateHeight(cm));
+
+    if (!cm.options.lineWrapping) {
+      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
+        var len = lineLength(line);
+        if (len > display.maxLineLength) {
+          display.maxLine = line;
+          display.maxLineLength = len;
+          display.maxLineChanged = true;
+          recomputeMaxLength = false;
         }
       });
+      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
     }
-    function posFromMouse(cm, e, liberal, forRect) {
-      var display = cm.display;
-      if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
-        return null;
-      }
-      var x, y, space = display.lineSpace.getBoundingClientRect();
-      try {
-        x = e.clientX - space.left;
-        y = e.clientY - space.top;
-      } catch (e$1) {
-        return null;
-      }
-      var coords = coordsChar(cm, x, y), line;
-      if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
-        var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
-        coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
-      }
-      return coords;
-    }
-    function findViewIndex(cm, n) {
-      if (n >= cm.display.viewTo) {
-        return null;
-      }
-      n -= cm.display.viewFrom;
-      if (n < 0) {
-        return null;
-      }
-      var view = cm.display.view;
-      for (var i2 = 0; i2 < view.length; i2++) {
-        n -= view[i2].size;
-        if (n < 0) {
-          return i2;
-        }
-      }
+
+    retreatFrontier(doc, from.line);
+    startWorker(cm, 400);
+
+    var lendiff = change.text.length - (to.line - from.line) - 1;
+    // Remember that these lines changed, for updating the display
+    if (change.full)
+      { regChange(cm); }
+    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
+      { regLineChange(cm, from.line, "text"); }
+    else
+      { regChange(cm, from.line, to.line + 1, lendiff); }
+
+    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
+    if (changeHandler || changesHandler) {
+      var obj = {
+        from: from, to: to,
+        text: change.text,
+        removed: change.removed,
+        origin: change.origin
+      };
+      if (changeHandler) { signalLater(cm, "change", cm, obj); }
+      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
     }
-    function regChange(cm, from, to, lendiff) {
-      if (from == null) {
-        from = cm.doc.first;
-      }
-      if (to == null) {
-        to = cm.doc.first + cm.doc.size;
-      }
-      if (!lendiff) {
-        lendiff = 0;
-      }
-      var display = cm.display;
-      if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
-        display.updateLineNumbers = from;
+    cm.display.selForContextMenu = null;
+  }
+
+  function replaceRange(doc, code, from, to, origin) {
+    var assign;
+
+    if (!to) { to = from; }
+    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
+    if (typeof code == "string") { code = doc.splitLines(code); }
+    makeChange(doc, {from: from, to: to, text: code, origin: origin});
+  }
+
+  // Rebasing/resetting history to deal with externally-sourced changes
+
+  function rebaseHistSelSingle(pos, from, to, diff) {
+    if (to < pos.line) {
+      pos.line += diff;
+    } else if (from < pos.line) {
+      pos.line = from;
+      pos.ch = 0;
+    }
+  }
+
+  // Tries to rebase an array of history events given a change in the
+  // document. If the change touches the same lines as the event, the
+  // event, and everything 'behind' it, is discarded. If the change is
+  // before the event, the event's positions are updated. Uses a
+  // copy-on-write scheme for the positions, to avoid having to
+  // reallocate them all on every rebase, but also avoid problems with
+  // shared position objects being unsafely updated.
+  function rebaseHistArray(array, from, to, diff) {
+    for (var i = 0; i < array.length; ++i) {
+      var sub = array[i], ok = true;
+      if (sub.ranges) {
+        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
+        for (var j = 0; j < sub.ranges.length; j++) {
+          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
+          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
+        }
+        continue
+      }
+      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
+        var cur = sub.changes[j$1];
+        if (to < cur.from.line) {
+          cur.from = Pos(cur.from.line + diff, cur.from.ch);
+          cur.to = Pos(cur.to.line + diff, cur.to.ch);
+        } else if (from <= cur.to.line) {
+          ok = false;
+          break
+        }
+      }
+      if (!ok) {
+        array.splice(0, i + 1);
+        i = 0;
       }
-      cm.curOp.viewChanged = true;
-      if (from >= display.viewTo) {
-        if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
-          resetView(cm);
-        }
-      } else if (to <= display.viewFrom) {
-        if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
-          resetView(cm);
-        } else {
-          display.viewFrom += lendiff;
-          display.viewTo += lendiff;
-        }
-      } else if (from <= display.viewFrom && to >= display.viewTo) {
-        resetView(cm);
-      } else if (from <= display.viewFrom) {
-        var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
-        if (cut) {
-          display.view = display.view.slice(cut.index);
-          display.viewFrom = cut.lineN;
-          display.viewTo += lendiff;
-        } else {
-          resetView(cm);
-        }
-      } else if (to >= display.viewTo) {
-        var cut$1 = viewCuttingPoint(cm, from, from, -1);
-        if (cut$1) {
-          display.view = display.view.slice(0, cut$1.index);
-          display.viewTo = cut$1.lineN;
-        } else {
-          resetView(cm);
-        }
-      } else {
-        var cutTop = viewCuttingPoint(cm, from, from, -1);
-        var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
-        if (cutTop && cutBot) {
-          display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
-          display.viewTo += lendiff;
-        } else {
-          resetView(cm);
+    }
+  }
+
+  function rebaseHist(hist, change) {
+    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
+    rebaseHistArray(hist.done, from, to, diff);
+    rebaseHistArray(hist.undone, from, to, diff);
+  }
+
+  // Utility for applying a change to a line by handle or number,
+  // returning the number and optionally registering the line as
+  // changed.
+  function changeLine(doc, handle, changeType, op) {
+    var no = handle, line = handle;
+    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
+    else { no = lineNo(handle); }
+    if (no == null) { return null }
+    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
+    return line
+  }
+
+  // The document is represented as a BTree consisting of leaves, with
+  // chunk of lines in them, and branches, with up to ten leaves or
+  // other branch nodes below them. The top node is always a branch
+  // node, and is the document object itself (meaning it has
+  // additional methods and properties).
+  //
+  // All nodes have parent links. The tree is used both to go from
+  // line numbers to line objects, and to go from objects to numbers.
+  // It also indexes by height, and is used to convert between height
+  // and line object, and to find the total height of the document.
+  //
+  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html
+
+  function LeafChunk(lines) {
+    this.lines = lines;
+    this.parent = null;
+    var height = 0;
+    for (var i = 0; i < lines.length; ++i) {
+      lines[i].parent = this;
+      height += lines[i].height;
+    }
+    this.height = height;
+  }
+
+  LeafChunk.prototype = {
+    chunkSize: function() { return this.lines.length },
+
+    // Remove the n lines at offset 'at'.
+    removeInner: function(at, n) {
+      for (var i = at, e = at + n; i < e; ++i) {
+        var line = this.lines[i];
+        this.height -= line.height;
+        cleanUpLine(line);
+        signalLater(line, "delete");
+      }
+      this.lines.splice(at, n);
+    },
+
+    // Helper used to collapse a small branch into a single leaf.
+    collapse: function(lines) {
+      lines.push.apply(lines, this.lines);
+    },
+
+    // Insert the given array of lines at offset 'at', count them as
+    // having the given height.
+    insertInner: function(at, lines, height) {
+      this.height += height;
+      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
+      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }
+    },
+
+    // Used to iterate over a part of the tree.
+    iterN: function(at, n, op) {
+      for (var e = at + n; at < e; ++at)
+        { if (op(this.lines[at])) { return true } }
+    }
+  };
+
+  function BranchChunk(children) {
+    this.children = children;
+    var size = 0, height = 0;
+    for (var i = 0; i < children.length; ++i) {
+      var ch = children[i];
+      size += ch.chunkSize(); height += ch.height;
+      ch.parent = this;
+    }
+    this.size = size;
+    this.height = height;
+    this.parent = null;
+  }
+
+  BranchChunk.prototype = {
+    chunkSize: function() { return this.size },
+
+    removeInner: function(at, n) {
+      this.size -= n;
+      for (var i = 0; i < this.children.length; ++i) {
+        var child = this.children[i], sz = child.chunkSize();
+        if (at < sz) {
+          var rm = Math.min(n, sz - at), oldHeight = child.height;
+          child.removeInner(at, rm);
+          this.height -= oldHeight - child.height;
+          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
+          if ((n -= rm) == 0) { break }
+          at = 0;
+        } else { at -= sz; }
+      }
+      // If the result is smaller than 25 lines, ensure that it is a
+      // single leaf node.
+      if (this.size - n < 25 &&
+          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
+        var lines = [];
+        this.collapse(lines);
+        this.children = [new LeafChunk(lines)];
+        this.children[0].parent = this;
+      }
+    },
+
+    collapse: function(lines) {
+      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }
+    },
+
+    insertInner: function(at, lines, height) {
+      this.size += lines.length;
+      this.height += height;
+      for (var i = 0; i < this.children.length; ++i) {
+        var child = this.children[i], sz = child.chunkSize();
+        if (at <= sz) {
+          child.insertInner(at, lines, height);
+          if (child.lines && child.lines.length > 50) {
+            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
+            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
+            var remaining = child.lines.length % 25 + 25;
+            for (var pos = remaining; pos < child.lines.length;) {
+              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
+              child.height -= leaf.height;
+              this.children.splice(++i, 0, leaf);
+              leaf.parent = this;
+            }
+            child.lines = child.lines.slice(0, remaining);
+            this.maybeSpill();
+          }
+          break
         }
+        at -= sz;
       }
-      var ext = display.externalMeasured;
-      if (ext) {
-        if (to < ext.lineN) {
-          ext.lineN += lendiff;
-        } else if (from < ext.lineN + ext.size) {
-          display.externalMeasured = null;
-        }
+    },
+
+    // When a node has grown, check whether it should be split.
+    maybeSpill: function() {
+      if (this.children.length <= 10) { return }
+      var me = this;
+      do {
+        var spilled = me.children.splice(me.children.length - 5, 5);
+        var sibling = new BranchChunk(spilled);
+        if (!me.parent) { // Become the parent node
+          var copy = new BranchChunk(me.children);
+          copy.parent = me;
+          me.children = [copy, sibling];
+          me = copy;
+       } else {
+          me.size -= sibling.size;
+          me.height -= sibling.height;
+          var myIndex = indexOf(me.parent.children, me);
+          me.parent.children.splice(myIndex + 1, 0, sibling);
+        }
+        sibling.parent = me.parent;
+      } while (me.children.length > 10)
+      me.parent.maybeSpill();
+    },
+
+    iterN: function(at, n, op) {
+      for (var i = 0; i < this.children.length; ++i) {
+        var child = this.children[i], sz = child.chunkSize();
+        if (at < sz) {
+          var used = Math.min(n, sz - at);
+          if (child.iterN(at, used, op)) { return true }
+          if ((n -= used) == 0) { break }
+          at = 0;
+        } else { at -= sz; }
       }
     }
-    function regLineChange(cm, line, type) {
-      cm.curOp.viewChanged = true;
-      var display = cm.display, ext = cm.display.externalMeasured;
-      if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
-        display.externalMeasured = null;
-      }
-      if (line < display.viewFrom || line >= display.viewTo) {
-        return;
-      }
-      var lineView = display.view[findViewIndex(cm, line)];
-      if (lineView.node == null) {
-        return;
-      }
-      var arr = lineView.changes || (lineView.changes = []);
-      if (indexOf(arr, type) == -1) {
-        arr.push(type);
-      }
+  };
+
+  // Line widgets are block elements displayed above or below a line.
+
+  var LineWidget = function(doc, node, options) {
+    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
+      { this[opt] = options[opt]; } } }
+    this.doc = doc;
+    this.node = node;
+  };
+
+  LineWidget.prototype.clear = function () {
+    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
+    if (no == null || !ws) { return }
+    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }
+    if (!ws.length) { line.widgets = null; }
+    var height = widgetHeight(this);
+    updateLineHeight(line, Math.max(0, line.height - height));
+    if (cm) {
+      runInOp(cm, function () {
+        adjustScrollWhenAboveVisible(cm, line, -height);
+        regLineChange(cm, no, "widget");
+      });
+      signalLater(cm, "lineWidgetCleared", cm, this, no);
     }
-    function resetView(cm) {
-      cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
-      cm.display.view = [];
-      cm.display.viewOffset = 0;
+  };
+
+  LineWidget.prototype.changed = function () {
+      var this$1$1 = this;
+
+    var oldH = this.height, cm = this.doc.cm, line = this.line;
+    this.height = null;
+    var diff = widgetHeight(this) - oldH;
+    if (!diff) { return }
+    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
+    if (cm) {
+      runInOp(cm, function () {
+        cm.curOp.forceUpdate = true;
+        adjustScrollWhenAboveVisible(cm, line, diff);
+        signalLater(cm, "lineWidgetChanged", cm, this$1$1, lineNo(line));
+      });
     }
-    function viewCuttingPoint(cm, oldN, newN, dir) {
-      var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
-      if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
-        return { index, lineN: newN };
-      }
-      var n = cm.display.viewFrom;
-      for (var i2 = 0; i2 < index; i2++) {
-        n += view[i2].size;
-      }
-      if (n != oldN) {
-        if (dir > 0) {
-          if (index == view.length - 1) {
-            return null;
-          }
-          diff = n + view[index].size - oldN;
-          index++;
-        } else {
-          diff = n - oldN;
-        }
-        oldN += diff;
-        newN += diff;
+  };
+  eventMixin(LineWidget);
+
+  function adjustScrollWhenAboveVisible(cm, line, diff) {
+    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
+      { addToScrollTop(cm, diff); }
+  }
+
+  function addLineWidget(doc, handle, node, options) {
+    var widget = new LineWidget(doc, node, options);
+    var cm = doc.cm;
+    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
+    changeLine(doc, handle, "widget", function (line) {
+      var widgets = line.widgets || (line.widgets = []);
+      if (widget.insertAt == null) { widgets.push(widget); }
+      else { widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget); }
+      widget.line = line;
+      if (cm && !lineIsHidden(doc, line)) {
+        var aboveVisible = heightAtLine(line) < doc.scrollTop;
+        updateLineHeight(line, line.height + widgetHeight(widget));
+        if (aboveVisible) { addToScrollTop(cm, widget.height); }
+        cm.curOp.forceUpdate = true;
       }
-      while (visualLineNo(cm.doc, newN) != newN) {
-        if (index == (dir < 0 ? 0 : view.length - 1)) {
-          return null;
-        }
-        newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
-        index += dir;
+      return true
+    });
+    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
+    return widget
+  }
+
+  // TEXTMARKERS
+
+  // Created with markText and setBookmark methods. A TextMarker is a
+  // handle that can be used to clear or find a marked position in the
+  // document. Line objects hold arrays (markedSpans) containing
+  // {from, to, marker} object pointing to such marker objects, and
+  // indicating that such a marker is present on that line. Multiple
+  // lines may point to the same marker when it spans across lines.
+  // The spans will have null for their from/to properties when the
+  // marker continues beyond the start/end of the line. Markers have
+  // links back to the lines they currently touch.
+
+  // Collapsed markers have unique ids, in order to be able to order
+  // them, which is needed for uniquely determining an outer marker
+  // when they overlap (they may nest, but not partially overlap).
+  var nextMarkerId = 0;
+
+  var TextMarker = function(doc, type) {
+    this.lines = [];
+    this.type = type;
+    this.doc = doc;
+    this.id = ++nextMarkerId;
+  };
+
+  // Clear the marker.
+  TextMarker.prototype.clear = function () {
+    if (this.explicitlyCleared) { return }
+    var cm = this.doc.cm, withOp = cm && !cm.curOp;
+    if (withOp) { startOperation(cm); }
+    if (hasHandler(this, "clear")) {
+      var found = this.find();
+      if (found) { signalLater(this, "clear", found.from, found.to); }
+    }
+    var min = null, max = null;
+    for (var i = 0; i < this.lines.length; ++i) {
+      var line = this.lines[i];
+      var span = getMarkedSpanFor(line.markedSpans, this);
+      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), "text"); }
+      else if (cm) {
+        if (span.to != null) { max = lineNo(line); }
+        if (span.from != null) { min = lineNo(line); }
+      }
+      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
+      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
+        { updateLineHeight(line, textHeight(cm.display)); }
+    }
+    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
+      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);
+      if (len > cm.display.maxLineLength) {
+        cm.display.maxLine = visual;
+        cm.display.maxLineLength = len;
+        cm.display.maxLineChanged = true;
       }
-      return { index, lineN: newN };
+    } }
+
+    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
+    this.lines.length = 0;
+    this.explicitlyCleared = true;
+    if (this.atomic && this.doc.cantEdit) {
+      this.doc.cantEdit = false;
+      if (cm) { reCheckSelection(cm.doc); }
+    }
+    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
+    if (withOp) { endOperation(cm); }
+    if (this.parent) { this.parent.clear(); }
+  };
+
+  // Find the position of the marker in the document. Returns a {from,
+  // to} object by default. Side can be passed to get a specific side
+  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
+  // Pos objects returned contain a line object, rather than a line
+  // number (used to prevent looking up the same line twice).
+  TextMarker.prototype.find = function (side, lineObj) {
+    if (side == null && this.type == "bookmark") { side = 1; }
+    var from, to;
+    for (var i = 0; i < this.lines.length; ++i) {
+      var line = this.lines[i];
+      var span = getMarkedSpanFor(line.markedSpans, this);
+      if (span.from != null) {
+        from = Pos(lineObj ? line : lineNo(line), span.from);
+        if (side == -1) { return from }
+      }
+      if (span.to != null) {
+        to = Pos(lineObj ? line : lineNo(line), span.to);
+        if (side == 1) { return to }
+      }
+    }
+    return from && {from: from, to: to}
+  };
+
+  // Signals that the marker's widget changed, and surrounding layout
+  // should be recomputed.
+  TextMarker.prototype.changed = function () {
+      var this$1$1 = this;
+
+    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
+    if (!pos || !cm) { return }
+    runInOp(cm, function () {
+      var line = pos.line, lineN = lineNo(pos.line);
+      var view = findViewForLine(cm, lineN);
+      if (view) {
+        clearLineMeasurementCacheFor(view);
+        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
+      }
+      cm.curOp.updateMaxLine = true;
+      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
+        var oldHeight = widget.height;
+        widget.height = null;
+        var dHeight = widgetHeight(widget) - oldHeight;
+        if (dHeight)
+          { updateLineHeight(line, line.height + dHeight); }
+      }
+      signalLater(cm, "markerChanged", cm, this$1$1);
+    });
+  };
+
+  TextMarker.prototype.attachLine = function (line) {
+    if (!this.lines.length && this.doc.cm) {
+      var op = this.doc.cm.curOp;
+      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
+        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
     }
-    function adjustView(cm, from, to) {
-      var display = cm.display, view = display.view;
-      if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
-        display.view = buildViewArray(cm, from, to);
-        display.viewFrom = from;
-      } else {
-        if (display.viewFrom > from) {
-          display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
-        } else if (display.viewFrom < from) {
-          display.view = display.view.slice(findViewIndex(cm, from));
-        }
-        display.viewFrom = from;
-        if (display.viewTo < to) {
-          display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
-        } else if (display.viewTo > to) {
-          display.view = display.view.slice(0, findViewIndex(cm, to));
-        }
-      }
-      display.viewTo = to;
+    this.lines.push(line);
+  };
+
+  TextMarker.prototype.detachLine = function (line) {
+    this.lines.splice(indexOf(this.lines, line), 1);
+    if (!this.lines.length && this.doc.cm) {
+      var op = this.doc.cm.curOp
+      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
     }
-    function countDirtyView(cm) {
-      var view = cm.display.view, dirty = 0;
-      for (var i2 = 0; i2 < view.length; i2++) {
-        var lineView = view[i2];
-        if (!lineView.hidden && (!lineView.node || lineView.changes)) {
-          ++dirty;
-        }
-      }
-      return dirty;
+  };
+  eventMixin(TextMarker);
+
+  // Create a marker, wire it up to the right lines, and
+  function markText(doc, from, to, options, type) {
+    // Shared markers (across linked documents) are handled separately
+    // (markTextShared will call out to this again, once per
+    // document).
+    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
+    // Ensure we are in an operation.
+    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }
+
+    var marker = new TextMarker(doc, type), diff = cmp(from, to);
+    if (options) { copyObj(options, marker, false); }
+    // Don't connect empty markers unless clearWhenEmpty is false
+    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
+      { return marker }
+    if (marker.replacedWith) {
+      // Showing up as a widget implies collapsed (widget replaces text)
+      marker.collapsed = true;
+      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
+      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
+      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
+    }
+    if (marker.collapsed) {
+      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
+          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
+        { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
+      seeCollapsedSpans();
     }
-    function updateSelection(cm) {
-      cm.display.input.showSelection(cm.display.input.prepareSelection());
+
+    if (marker.addToHistory)
+      { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }
+
+    var curLine = from.line, cm = doc.cm, updateMaxLine;
+    doc.iter(curLine, to.line + 1, function (line) {
+      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
+        { updateMaxLine = true; }
+      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
+      addMarkedSpan(line, new MarkedSpan(marker,
+                                         curLine == from.line ? from.ch : null,
+                                         curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);
+      ++curLine;
+    });
+    // lineIsHidden depends on the presence of the spans, so needs a second pass
+    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
+      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
+    }); }
+
+    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }
+
+    if (marker.readOnly) {
+      seeReadOnlySpans();
+      if (doc.history.done.length || doc.history.undone.length)
+        { doc.clearHistory(); }
+    }
+    if (marker.collapsed) {
+      marker.id = ++nextMarkerId;
+      marker.atomic = true;
+    }
+    if (cm) {
+      // Sync editor state
+      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
+      if (marker.collapsed)
+        { regChange(cm, from.line, to.line + 1); }
+      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
+               marker.attributes || marker.title)
+        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
+      if (marker.atomic) { reCheckSelection(cm.doc); }
+      signalLater(cm, "markerAdded", cm, marker);
+    }
+    return marker
+  }
+
+  // SHARED TEXTMARKERS
+
+  // A shared marker spans multiple linked documents. It is
+  // implemented as a meta-marker-object controlling multiple normal
+  // markers.
+  var SharedTextMarker = function(markers, primary) {
+    this.markers = markers;
+    this.primary = primary;
+    for (var i = 0; i < markers.length; ++i)
+      { markers[i].parent = this; }
+  };
+
+  SharedTextMarker.prototype.clear = function () {
+    if (this.explicitlyCleared) { return }
+    this.explicitlyCleared = true;
+    for (var i = 0; i < this.markers.length; ++i)
+      { this.markers[i].clear(); }
+    signalLater(this, "clear");
+  };
+
+  SharedTextMarker.prototype.find = function (side, lineObj) {
+    return this.primary.find(side, lineObj)
+  };
+  eventMixin(SharedTextMarker);
+
+  function markTextShared(doc, from, to, options, type) {
+    options = copyObj(options);
+    options.shared = false;
+    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
+    var widget = options.widgetNode;
+    linkedDocs(doc, function (doc) {
+      if (widget) { options.widgetNode = widget.cloneNode(true); }
+      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
+      for (var i = 0; i < doc.linked.length; ++i)
+        { if (doc.linked[i].isParent) { return } }
+      primary = lst(markers);
+    });
+    return new SharedTextMarker(markers, primary)
+  }
+
+  function findSharedMarkers(doc) {
+    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
+  }
+
+  function copySharedMarkers(doc, markers) {
+    for (var i = 0; i < markers.length; i++) {
+      var marker = markers[i], pos = marker.find();
+      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
+      if (cmp(mFrom, mTo)) {
+        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
+        marker.markers.push(subMark);
+        subMark.parent = marker;
+      }
     }
-    function prepareSelection(cm, primary) {
-      if (primary === void 0)
-        primary = true;
-      var doc = cm.doc, result = {};
-      var curFragment = result.cursors = document.createDocumentFragment();
-      var selFragment = result.selection = document.createDocumentFragment();
-      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
-        if (!primary && i2 == doc.sel.primIndex) {
-          continue;
-        }
-        var range2 = doc.sel.ranges[i2];
-        if (range2.from().line >= cm.display.viewTo || range2.to().line < cm.display.viewFrom) {
-          continue;
-        }
-        var collapsed = range2.empty();
-        if (collapsed || cm.options.showCursorWhenSelecting) {
-          drawSelectionCursor(cm, range2.head, curFragment);
-        }
-        if (!collapsed) {
-          drawSelectionRange(cm, range2, selFragment);
+  }
+
+  function detachSharedMarkers(markers) {
+    var loop = function ( i ) {
+      var marker = markers[i], linked = [marker.primary.doc];
+      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
+      for (var j = 0; j < marker.markers.length; j++) {
+        var subMarker = marker.markers[j];
+        if (indexOf(linked, subMarker.doc) == -1) {
+          subMarker.parent = null;
+          marker.markers.splice(j--, 1);
         }
       }
-      return result;
-    }
-    function drawSelectionCursor(cm, head, output) {
-      var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
-      var cursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor"));
-      cursor.style.left = pos.left + "px";
-      cursor.style.top = pos.top + "px";
-      cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
-      if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
-        var charPos = charCoords(cm, head, "div", null, null);
-        if (charPos.right - charPos.left > 0) {
-          cursor.style.width = charPos.right - charPos.left + "px";
+    };
+
+    for (var i = 0; i < markers.length; i++) loop( i );
+  }
+
+  var nextDocId = 0;
+  var Doc = function(text, mode, firstLine, lineSep, direction) {
+    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
+    if (firstLine == null) { firstLine = 0; }
+
+    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
+    this.first = firstLine;
+    this.scrollTop = this.scrollLeft = 0;
+    this.cantEdit = false;
+    this.cleanGeneration = 1;
+    this.modeFrontier = this.highlightFrontier = firstLine;
+    var start = Pos(firstLine, 0);
+    this.sel = simpleSelection(start);
+    this.history = new History(null);
+    this.id = ++nextDocId;
+    this.modeOption = mode;
+    this.lineSep = lineSep;
+    this.direction = (direction == "rtl") ? "rtl" : "ltr";
+    this.extend = false;
+
+    if (typeof text == "string") { text = this.splitLines(text); }
+    updateDoc(this, {from: start, to: start, text: text});
+    setSelection(this, simpleSelection(start), sel_dontScroll);
+  };
+
+  Doc.prototype = createObj(BranchChunk.prototype, {
+    constructor: Doc,
+    // Iterate over the document. Supports two forms -- with only one
+    // argument, it calls that for each line in the document. With
+    // three, it iterates over the range given by the first two (with
+    // the second being non-inclusive).
+    iter: function(from, to, op) {
+      if (op) { this.iterN(from - this.first, to - from, op); }
+      else { this.iterN(this.first, this.first + this.size, from); }
+    },
+
+    // Non-public interface for adding and removing lines.
+    insert: function(at, lines) {
+      var height = 0;
+      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
+      this.insertInner(at - this.first, lines, height);
+    },
+    remove: function(at, n) { this.removeInner(at - this.first, n); },
+
+    // From here, the methods are part of the public interface. Most
+    // are also available from CodeMirror (editor) instances.
+
+    getValue: function(lineSep) {
+      var lines = getLines(this, this.first, this.first + this.size);
+      if (lineSep === false) { return lines }
+      return lines.join(lineSep || this.lineSeparator())
+    },
+    setValue: docMethodOp(function(code) {
+      var top = Pos(this.first, 0), last = this.first + this.size - 1;
+      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
+                        text: this.splitLines(code), origin: "setValue", full: true}, true);
+      if (this.cm) { scrollToCoords(this.cm, 0, 0); }
+      setSelection(this, simpleSelection(top), sel_dontScroll);
+    }),
+    replaceRange: function(code, from, to, origin) {
+      from = clipPos(this, from);
+      to = to ? clipPos(this, to) : from;
+      replaceRange(this, code, from, to, origin);
+    },
+    getRange: function(from, to, lineSep) {
+      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
+      if (lineSep === false) { return lines }
+      if (lineSep === '') { return lines.join('') }
+      return lines.join(lineSep || this.lineSeparator())
+    },
+
+    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},
+
+    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
+    getLineNumber: function(line) {return lineNo(line)},
+
+    getLineHandleVisualStart: function(line) {
+      if (typeof line == "number") { line = getLine(this, line); }
+      return visualLine(line)
+    },
+
+    lineCount: function() {return this.size},
+    firstLine: function() {return this.first},
+    lastLine: function() {return this.first + this.size - 1},
+
+    clipPos: function(pos) {return clipPos(this, pos)},
+
+    getCursor: function(start) {
+      var range = this.sel.primary(), pos;
+      if (start == null || start == "head") { pos = range.head; }
+      else if (start == "anchor") { pos = range.anchor; }
+      else if (start == "end" || start == "to" || start === false) { pos = range.to(); }
+      else { pos = range.from(); }
+      return pos
+    },
+    listSelections: function() { return this.sel.ranges },
+    somethingSelected: function() {return this.sel.somethingSelected()},
+
+    setCursor: docMethodOp(function(line, ch, options) {
+      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
+    }),
+    setSelection: docMethodOp(function(anchor, head, options) {
+      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
+    }),
+    extendSelection: docMethodOp(function(head, other, options) {
+      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
+    }),
+    extendSelections: docMethodOp(function(heads, options) {
+      extendSelections(this, clipPosArray(this, heads), options);
+    }),
+    extendSelectionsBy: docMethodOp(function(f, options) {
+      var heads = map(this.sel.ranges, f);
+      extendSelections(this, clipPosArray(this, heads), options);
+    }),
+    setSelections: docMethodOp(function(ranges, primary, options) {
+      if (!ranges.length) { return }
+      var out = [];
+      for (var i = 0; i < ranges.length; i++)
+        { out[i] = new Range(clipPos(this, ranges[i].anchor),
+                           clipPos(this, ranges[i].head || ranges[i].anchor)); }
+      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
+      setSelection(this, normalizeSelection(this.cm, out, primary), options);
+    }),
+    addSelection: docMethodOp(function(anchor, head, options) {
+      var ranges = this.sel.ranges.slice(0);
+      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
+      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
+    }),
+
+    getSelection: function(lineSep) {
+      var ranges = this.sel.ranges, lines;
+      for (var i = 0; i < ranges.length; i++) {
+        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
+        lines = lines ? lines.concat(sel) : sel;
+      }
+      if (lineSep === false) { return lines }
+      else { return lines.join(lineSep || this.lineSeparator()) }
+    },
+    getSelections: function(lineSep) {
+      var parts = [], ranges = this.sel.ranges;
+      for (var i = 0; i < ranges.length; i++) {
+        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
+        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }
+        parts[i] = sel;
+      }
+      return parts
+    },
+    replaceSelection: function(code, collapse, origin) {
+      var dup = [];
+      for (var i = 0; i < this.sel.ranges.length; i++)
+        { dup[i] = code; }
+      this.replaceSelections(dup, collapse, origin || "+input");
+    },
+    replaceSelections: docMethodOp(function(code, collapse, origin) {
+      var changes = [], sel = this.sel;
+      for (var i = 0; i < sel.ranges.length; i++) {
+        var range = sel.ranges[i];
+        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
+      }
+      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
+      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
+        { makeChange(this, changes[i$1]); }
+      if (newSel) { setSelectionReplaceHistory(this, newSel); }
+      else if (this.cm) { ensureCursorVisible(this.cm); }
+    }),
+    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
+    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
+    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
+    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),
+
+    setExtending: function(val) {this.extend = val;},
+    getExtending: function() {return this.extend},
+
+    historySize: function() {
+      var hist = this.history, done = 0, undone = 0;
+      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
+      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
+      return {undo: done, redo: undone}
+    },
+    clearHistory: function() {
+      var this$1$1 = this;
+
+      this.history = new History(this.history);
+      linkedDocs(this, function (doc) { return doc.history = this$1$1.history; }, true);
+    },
+
+    markClean: function() {
+      this.cleanGeneration = this.changeGeneration(true);
+    },
+    changeGeneration: function(forceSplit) {
+      if (forceSplit)
+        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
+      return this.history.generation
+    },
+    isClean: function (gen) {
+      return this.history.generation == (gen || this.cleanGeneration)
+    },
+
+    getHistory: function() {
+      return {done: copyHistoryArray(this.history.done),
+              undone: copyHistoryArray(this.history.undone)}
+    },
+    setHistory: function(histData) {
+      var hist = this.history = new History(this.history);
+      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
+      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
+    },
+
+    setGutterMarker: docMethodOp(function(line, gutterID, value) {
+      return changeLine(this, line, "gutter", function (line) {
+        var markers = line.gutterMarkers || (line.gutterMarkers = {});
+        markers[gutterID] = value;
+        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
+        return true
+      })
+    }),
+
+    clearGutter: docMethodOp(function(gutterID) {
+      var this$1$1 = this;
+
+      this.iter(function (line) {
+        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
+          changeLine(this$1$1, line, "gutter", function () {
+            line.gutterMarkers[gutterID] = null;
+            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
+            return true
+          });
         }
+      });
+    }),
+
+    lineInfo: function(line) {
+      var n;
+      if (typeof line == "number") {
+        if (!isLine(this, line)) { return null }
+        n = line;
+        line = getLine(this, line);
+        if (!line) { return null }
+      } else {
+        n = lineNo(line);
+        if (n == null) { return null }
       }
-      if (pos.other) {
-        var otherCursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
-        otherCursor.style.display = "";
-        otherCursor.style.left = pos.other.left + "px";
-        otherCursor.style.top = pos.other.top + "px";
-        otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
-      }
-    }
-    function cmpCoords(a, b) {
-      return a.top - b.top || a.left - b.left;
-    }
-    function drawSelectionRange(cm, range2, output) {
-      var display = cm.display, doc = cm.doc;
-      var fragment = document.createDocumentFragment();
-      var padding = paddingH(cm.display), leftSide = padding.left;
-      var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
-      var docLTR = doc.direction == "ltr";
-      function add(left, top, width, bottom) {
-        if (top < 0) {
-          top = 0;
-        }
-        top = Math.round(top);
-        bottom = Math.round(bottom);
-        fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
-      }
-      function drawForLine(line, fromArg, toArg) {
-        var lineObj = getLine(doc, line);
-        var lineLen = lineObj.text.length;
-        var start, end;
-        function coords(ch, bias) {
-          return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
-        }
-        function wrapX(pos, dir, side) {
-          var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
-          var prop2 = dir == "ltr" == (side == "after") ? "left" : "right";
-          var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
-          return coords(ch, prop2)[prop2];
+      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
+              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
+              widgets: line.widgets}
+    },
+
+    addLineClass: docMethodOp(function(handle, where, cls) {
+      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
+        var prop = where == "text" ? "textClass"
+                 : where == "background" ? "bgClass"
+                 : where == "gutter" ? "gutterClass" : "wrapClass";
+        if (!line[prop]) { line[prop] = cls; }
+        else if (classTest(cls).test(line[prop])) { return false }
+        else { line[prop] += " " + cls; }
+        return true
+      })
+    }),
+    removeLineClass: docMethodOp(function(handle, where, cls) {
+      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
+        var prop = where == "text" ? "textClass"
+                 : where == "background" ? "bgClass"
+                 : where == "gutter" ? "gutterClass" : "wrapClass";
+        var cur = line[prop];
+        if (!cur) { return false }
+        else if (cls == null) { line[prop] = null; }
+        else {
+          var found = cur.match(classTest(cls));
+          if (!found) { return false }
+          var end = found.index + found[0].length;
+          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
+        }
+        return true
+      })
+    }),
+
+    addLineWidget: docMethodOp(function(handle, node, options) {
+      return addLineWidget(this, handle, node, options)
+    }),
+    removeLineWidget: function(widget) { widget.clear(); },
+
+    markText: function(from, to, options) {
+      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
+    },
+    setBookmark: function(pos, options) {
+      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
+                      insertLeft: options && options.insertLeft,
+                      clearWhenEmpty: false, shared: options && options.shared,
+                      handleMouseEvents: options && options.handleMouseEvents};
+      pos = clipPos(this, pos);
+      return markText(this, pos, pos, realOpts, "bookmark")
+    },
+    findMarksAt: function(pos) {
+      pos = clipPos(this, pos);
+      var markers = [], spans = getLine(this, pos.line).markedSpans;
+      if (spans) { for (var i = 0; i < spans.length; ++i) {
+        var span = spans[i];
+        if ((span.from == null || span.from <= pos.ch) &&
+            (span.to == null || span.to >= pos.ch))
+          { markers.push(span.marker.parent || span.marker); }
+      } }
+      return markers
+    },
+    findMarks: function(from, to, filter) {
+      from = clipPos(this, from); to = clipPos(this, to);
+      var found = [], lineNo = from.line;
+      this.iter(from.line, to.line + 1, function (line) {
+        var spans = line.markedSpans;
+        if (spans) { for (var i = 0; i < spans.length; i++) {
+          var span = spans[i];
+          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
+                span.from == null && lineNo != from.line ||
+                span.from != null && lineNo == to.line && span.from >= to.ch) &&
+              (!filter || filter(span.marker)))
+            { found.push(span.marker.parent || span.marker); }
+        } }
+        ++lineNo;
+      });
+      return found
+    },
+    getAllMarks: function() {
+      var markers = [];
+      this.iter(function (line) {
+        var sps = line.markedSpans;
+        if (sps) { for (var i = 0; i < sps.length; ++i)
+          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
+      });
+      return markers
+    },
+
+    posFromIndex: function(off) {
+      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
+      this.iter(function (line) {
+        var sz = line.text.length + sepSize;
+        if (sz > off) { ch = off; return true }
+        off -= sz;
+        ++lineNo;
+      });
+      return clipPos(this, Pos(lineNo, ch))
+    },
+    indexFromPos: function (coords) {
+      coords = clipPos(this, coords);
+      var index = coords.ch;
+      if (coords.line < this.first || coords.ch < 0) { return 0 }
+      var sepSize = this.lineSeparator().length;
+      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
+        index += line.text.length + sepSize;
+      });
+      return index
+    },
+
+    copy: function(copyHistory) {
+      var doc = new Doc(getLines(this, this.first, this.first + this.size),
+                        this.modeOption, this.first, this.lineSep, this.direction);
+      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
+      doc.sel = this.sel;
+      doc.extend = false;
+      if (copyHistory) {
+        doc.history.undoDepth = this.history.undoDepth;
+        doc.setHistory(this.getHistory());
+      }
+      return doc
+    },
+
+    linkedDoc: function(options) {
+      if (!options) { options = {}; }
+      var from = this.first, to = this.first + this.size;
+      if (options.from != null && options.from > from) { from = options.from; }
+      if (options.to != null && options.to < to) { to = options.to; }
+      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
+      if (options.sharedHist) { copy.history = this.history
+      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
+      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
+      copySharedMarkers(copy, findSharedMarkers(this));
+      return copy
+    },
+    unlinkDoc: function(other) {
+      if (other instanceof CodeMirror) { other = other.doc; }
+      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
+        var link = this.linked[i];
+        if (link.doc != other) { continue }
+        this.linked.splice(i, 1);
+        other.unlinkDoc(this);
+        detachSharedMarkers(findSharedMarkers(this));
+        break
+      } }
+      // If the histories were shared, split them again
+      if (other.history == this.history) {
+        var splitIds = [other.id];
+        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
+        other.history = new History(null);
+        other.history.done = copyHistoryArray(this.history.done, splitIds);
+        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
+      }
+    },
+    iterLinkedDocs: function(f) {linkedDocs(this, f);},
+
+    getMode: function() {return this.mode},
+    getEditor: function() {return this.cm},
+
+    splitLines: function(str) {
+      if (this.lineSep) { return str.split(this.lineSep) }
+      return splitLinesAuto(str)
+    },
+    lineSeparator: function() { return this.lineSep || "\n" },
+
+    setDirection: docMethodOp(function (dir) {
+      if (dir != "rtl") { dir = "ltr"; }
+      if (dir == this.direction) { return }
+      this.direction = dir;
+      this.iter(function (line) { return line.order = null; });
+      if (this.cm) { directionChanged(this.cm); }
+    })
+  });
+
+  // Public alias.
+  Doc.prototype.eachLine = Doc.prototype.iter;
+
+  // Kludge to work around strange IE behavior where it'll sometimes
+  // re-fire a series of drag-related events right after the drop (#1551)
+  var lastDrop = 0;
+
+  function onDrop(e) {
+    var cm = this;
+    clearDragCursor(cm);
+    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
+      { return }
+    e_preventDefault(e);
+    if (ie) { lastDrop = +new Date; }
+    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
+    if (!pos || cm.isReadOnly()) { return }
+    // Might be a file drop, in which case we simply extract the text
+    // and insert it.
+    if (files && files.length && window.FileReader && window.File) {
+      var n = files.length, text = Array(n), read = 0;
+      var markAsReadAndPasteIfAllFilesAreRead = function () {
+        if (++read == n) {
+          operation(cm, function () {
+            pos = clipPos(cm.doc, pos);
+            var change = {from: pos, to: pos,
+                          text: cm.doc.splitLines(
+                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),
+                          origin: "paste"};
+            makeChange(cm.doc, change);
+            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
+          })();
         }
-        var order = getOrder(lineObj, doc.direction);
-        iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i2) {
-          var ltr = dir == "ltr";
-          var fromPos = coords(from, ltr ? "left" : "right");
-          var toPos = coords(to - 1, ltr ? "right" : "left");
-          var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
-          var first = i2 == 0, last = !order || i2 == order.length - 1;
-          if (toPos.top - fromPos.top <= 3) {
-            var openLeft = (docLTR ? openStart : openEnd) && first;
-            var openRight = (docLTR ? openEnd : openStart) && last;
-            var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
-            var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
-            add(left, fromPos.top, right - left, fromPos.bottom);
-          } else {
-            var topLeft, topRight, botLeft, botRight;
-            if (ltr) {
-              topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
-              topRight = docLTR ? rightSide : wrapX(from, dir, "before");
-              botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
-              botRight = docLTR && openEnd && last ? rightSide : toPos.right;
-            } else {
-              topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
-              topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
-              botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
-              botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
-            }
-            add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
-            if (fromPos.bottom < toPos.top) {
-              add(leftSide, fromPos.bottom, null, toPos.top);
-            }
-            add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
-          }
-          if (!start || cmpCoords(fromPos, start) < 0) {
-            start = fromPos;
-          }
-          if (cmpCoords(toPos, start) < 0) {
-            start = toPos;
-          }
-          if (!end || cmpCoords(fromPos, end) < 0) {
-            end = fromPos;
-          }
-          if (cmpCoords(toPos, end) < 0) {
-            end = toPos;
+      };
+      var readTextFromFile = function (file, i) {
+        if (cm.options.allowDropFileTypes &&
+            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
+          markAsReadAndPasteIfAllFilesAreRead();
+          return
+        }
+        var reader = new FileReader;
+        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };
+        reader.onload = function () {
+          var content = reader.result;
+          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
+            markAsReadAndPasteIfAllFilesAreRead();
+            return
           }
-        });
-        return { start, end };
+          text[i] = content;
+          markAsReadAndPasteIfAllFilesAreRead();
+        };
+        reader.readAsText(file);
+      };
+      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }
+    } else { // Normal drop
+      // Don't do a replace if the drop happened inside of the selected text.
+      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
+        cm.state.draggingText(e);
+        // Ensure the editor is re-focused
+        setTimeout(function () { return cm.display.input.focus(); }, 20);
+        return
       }
-      var sFrom = range2.from(), sTo = range2.to();
-      if (sFrom.line == sTo.line) {
-        drawForLine(sFrom.line, sFrom.ch, sTo.ch);
-      } else {
-        var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
-        var singleVLine = visualLine(fromLine) == visualLine(toLine);
-        var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
-        var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
-        if (singleVLine) {
-          if (leftEnd.top < rightStart.top - 2) {
-            add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
-            add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
-          } else {
-            add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
-          }
-        }
-        if (leftEnd.bottom < rightStart.top) {
-          add(leftSide, leftEnd.bottom, null, rightStart.top);
+      try {
+        var text$1 = e.dataTransfer.getData("Text");
+        if (text$1) {
+          var selected;
+          if (cm.state.draggingText && !cm.state.draggingText.copy)
+            { selected = cm.listSelections(); }
+          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
+          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
+            { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
+          cm.replaceSelection(text$1, "around", "paste");
+          cm.display.input.focus();
         }
       }
-      output.appendChild(fragment);
+      catch(e$1){}
     }
-    function restartBlink(cm) {
-      if (!cm.state.focused) {
-        return;
-      }
-      var display = cm.display;
-      clearInterval(display.blinker);
-      var on2 = true;
-      display.cursorDiv.style.visibility = "";
-      if (cm.options.cursorBlinkRate > 0) {
-        display.blinker = setInterval(function() {
-          if (!cm.hasFocus()) {
-            onBlur(cm);
-          }
-          display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";
-        }, cm.options.cursorBlinkRate);
-      } else if (cm.options.cursorBlinkRate < 0) {
-        display.cursorDiv.style.visibility = "hidden";
+  }
+
+  function onDragStart(cm, e) {
+    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
+    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }
+
+    e.dataTransfer.setData("Text", cm.getSelection());
+    e.dataTransfer.effectAllowed = "copyMove";
+
+    // Use dummy image instead of default browsers image.
+    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
+    if (e.dataTransfer.setDragImage && !safari) {
+      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
+      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
+      if (presto) {
+        img.width = img.height = 1;
+        cm.display.wrapper.appendChild(img);
+        // Force a relayout, or Opera won't use our image for some obscure reason
+        img._top = img.offsetTop;
       }
+      e.dataTransfer.setDragImage(img, 0, 0);
+      if (presto) { img.parentNode.removeChild(img); }
     }
-    function ensureFocus(cm) {
-      if (!cm.hasFocus()) {
-        cm.display.input.focus();
-        if (!cm.state.focused) {
-          onFocus(cm);
-        }
-      }
+  }
+
+  function onDragOver(cm, e) {
+    var pos = posFromMouse(cm, e);
+    if (!pos) { return }
+    var frag = document.createDocumentFragment();
+    drawSelectionCursor(cm, pos, frag);
+    if (!cm.display.dragCursor) {
+      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
+      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
     }
-    function delayBlurEvent(cm) {
-      cm.state.delayingBlurEvent = true;
-      setTimeout(function() {
-        if (cm.state.delayingBlurEvent) {
-          cm.state.delayingBlurEvent = false;
-          if (cm.state.focused) {
-            onBlur(cm);
-          }
-        }
-      }, 100);
+    removeChildrenAndAdd(cm.display.dragCursor, frag);
+  }
+
+  function clearDragCursor(cm) {
+    if (cm.display.dragCursor) {
+      cm.display.lineSpace.removeChild(cm.display.dragCursor);
+      cm.display.dragCursor = null;
     }
-    function onFocus(cm, e) {
-      if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
-        cm.state.delayingBlurEvent = false;
-      }
-      if (cm.options.readOnly == "nocursor") {
-        return;
-      }
-      if (!cm.state.focused) {
-        signal(cm, "focus", cm, e);
-        cm.state.focused = true;
-        addClass(cm.display.wrapper, "CodeMirror-focused");
-        if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
-          cm.display.input.reset();
-          if (webkit) {
-            setTimeout(function() {
-              return cm.display.input.reset(true);
-            }, 20);
-          }
-        }
-        cm.display.input.receivedFocus();
-      }
-      restartBlink(cm);
+  }
+
+  // These must be handled carefully, because naively registering a
+  // handler for each editor will cause the editors to never be
+  // garbage collected.
+
+  function forEachCodeMirror(f) {
+    if (!document.getElementsByClassName) { return }
+    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
+    for (var i = 0; i < byClass.length; i++) {
+      var cm = byClass[i].CodeMirror;
+      if (cm) { editors.push(cm); }
     }
-    function onBlur(cm, e) {
-      if (cm.state.delayingBlurEvent) {
-        return;
-      }
-      if (cm.state.focused) {
-        signal(cm, "blur", cm, e);
-        cm.state.focused = false;
-        rmClass(cm.display.wrapper, "CodeMirror-focused");
-      }
-      clearInterval(cm.display.blinker);
-      setTimeout(function() {
-        if (!cm.state.focused) {
-          cm.display.shift = false;
-        }
-      }, 150);
-    }
-    function updateHeightsInViewport(cm) {
-      var display = cm.display;
-      var prevBottom = display.lineDiv.offsetTop;
-      var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
-      var oldHeight = display.lineDiv.getBoundingClientRect().top;
-      var mustScroll = 0;
-      for (var i2 = 0; i2 < display.view.length; i2++) {
-        var cur = display.view[i2], wrapping = cm.options.lineWrapping;
-        var height = void 0, width = 0;
-        if (cur.hidden) {
-          continue;
-        }
-        oldHeight += cur.line.height;
-        if (ie && ie_version < 8) {
-          var bot = cur.node.offsetTop + cur.node.offsetHeight;
-          height = bot - prevBottom;
-          prevBottom = bot;
+    if (editors.length) { editors[0].operation(function () {
+      for (var i = 0; i < editors.length; i++) { f(editors[i]); }
+    }); }
+  }
+
+  var globalsRegistered = false;
+  function ensureGlobalHandlers() {
+    if (globalsRegistered) { return }
+    registerGlobalHandlers();
+    globalsRegistered = true;
+  }
+  function registerGlobalHandlers() {
+    // When the window resizes, we need to refresh active editors.
+    var resizeTimer;
+    on(window, "resize", function () {
+      if (resizeTimer == null) { resizeTimer = setTimeout(function () {
+        resizeTimer = null;
+        forEachCodeMirror(onResize);
+      }, 100); }
+    });
+    // When the window loses focus, we want to show the editor as blurred
+    on(window, "blur", function () { return forEachCodeMirror(onBlur); });
+  }
+  // Called when the window resizes
+  function onResize(cm) {
+    var d = cm.display;
+    // Might be a text scaling operation, clear size caches.
+    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
+    d.scrollbarsClipped = false;
+    cm.setSize();
+  }
+
+  var keyNames = {
+    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
+    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
+    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
+    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
+    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
+    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
+    221: "]", 222: "'", 224: "Mod", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
+    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
+  };
+
+  // Number keys
+  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
+  // Alphabetic keys
+  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
+  // Function keys
+  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }
+
+  var keyMap = {};
+
+  keyMap.basic = {
+    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
+    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
+    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
+    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
+    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
+    "Esc": "singleSelection"
+  };
+  // Note that the save and find-related commands aren't defined by
+  // default. User code or addons can define them. Unknown commands
+  // are simply ignored.
+  keyMap.pcDefault = {
+    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
+    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
+    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
+    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
+    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
+    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
+    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
+    "fallthrough": "basic"
+  };
+  // Very basic readline/emacs-style bindings, which are standard on Mac.
+  keyMap.emacsy = {
+    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
+    "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd", "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp",
+    "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine",
+    "Ctrl-T": "transposeChars", "Ctrl-O": "openLine"
+  };
+  keyMap.macDefault = {
+    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
+    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
+    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
+    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
+    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
+    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
+    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
+    "fallthrough": ["basic", "emacsy"]
+  };
+  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
+
+  // KEYMAP DISPATCH
+
+  function normalizeKeyName(name) {
+    var parts = name.split(/-(?!$)/);
+    name = parts[parts.length - 1];
+    var alt, ctrl, shift, cmd;
+    for (var i = 0; i < parts.length - 1; i++) {
+      var mod = parts[i];
+      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
+      else if (/^a(lt)?$/i.test(mod)) { alt = true; }
+      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
+      else if (/^s(hift)?$/i.test(mod)) { shift = true; }
+      else { throw new Error("Unrecognized modifier name: " + mod) }
+    }
+    if (alt) { name = "Alt-" + name; }
+    if (ctrl) { name = "Ctrl-" + name; }
+    if (cmd) { name = "Cmd-" + name; }
+    if (shift) { name = "Shift-" + name; }
+    return name
+  }
+
+  // This is a kludge to keep keymaps mostly working as raw objects
+  // (backwards compatibility) while at the same time support features
+  // like normalization and multi-stroke key bindings. It compiles a
+  // new normalized keymap, and then updates the old object to reflect
+  // this.
+  function normalizeKeyMap(keymap) {
+    var copy = {};
+    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
+      var value = keymap[keyname];
+      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
+      if (value == "...") { delete keymap[keyname]; continue }
+
+      var keys = map(keyname.split(" "), normalizeKeyName);
+      for (var i = 0; i < keys.length; i++) {
+        var val = (void 0), name = (void 0);
+        if (i == keys.length - 1) {
+          name = keys.join(" ");
+          val = value;
         } else {
-          var box = cur.node.getBoundingClientRect();
-          height = box.bottom - box.top;
-          if (!wrapping && cur.text.firstChild) {
-            width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
-          }
-        }
-        var diff = cur.line.height - height;
-        if (diff > 5e-3 || diff < -5e-3) {
-          if (oldHeight < viewTop) {
-            mustScroll -= diff;
-          }
-          updateLineHeight(cur.line, height);
-          updateWidgetHeight(cur.line);
-          if (cur.rest) {
-            for (var j = 0; j < cur.rest.length; j++) {
-              updateWidgetHeight(cur.rest[j]);
-            }
-          }
-        }
-        if (width > cm.display.sizerWidth) {
-          var chWidth = Math.ceil(width / charWidth(cm.display));
-          if (chWidth > cm.display.maxLineLength) {
-            cm.display.maxLineLength = chWidth;
-            cm.display.maxLine = cur.line;
-            cm.display.maxLineChanged = true;
-          }
+          name = keys.slice(0, i + 1).join(" ");
+          val = "...";
         }
+        var prev = copy[name];
+        if (!prev) { copy[name] = val; }
+        else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
       }
-      if (Math.abs(mustScroll) > 2) {
-        display.scroller.scrollTop += mustScroll;
+      delete keymap[keyname];
+    } }
+    for (var prop in copy) { keymap[prop] = copy[prop]; }
+    return keymap
+  }
+
+  function lookupKey(key, map, handle, context) {
+    map = getKeyMap(map);
+    var found = map.call ? map.call(key, context) : map[key];
+    if (found === false) { return "nothing" }
+    if (found === "...") { return "multi" }
+    if (found != null && handle(found)) { return "handled" }
+
+    if (map.fallthrough) {
+      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
+        { return lookupKey(key, map.fallthrough, handle, context) }
+      for (var i = 0; i < map.fallthrough.length; i++) {
+        var result = lookupKey(key, map.fallthrough[i], handle, context);
+        if (result) { return result }
       }
     }
-    function updateWidgetHeight(line) {
-      if (line.widgets) {
-        for (var i2 = 0; i2 < line.widgets.length; ++i2) {
-          var w = line.widgets[i2], parent = w.node.parentNode;
-          if (parent) {
-            w.height = parent.offsetHeight;
-          }
-        }
-      }
+  }
+
+  // Modifier key presses don't count as 'real' key presses for the
+  // purpose of keymap fallthrough.
+  function isModifierKey(value) {
+    var name = typeof value == "string" ? value : keyNames[value.keyCode];
+    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
+  }
+
+  function addModifierNames(name, event, noShift) {
+    var base = name;
+    if (event.altKey && base != "Alt") { name = "Alt-" + name; }
+    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
+    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") { name = "Cmd-" + name; }
+    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
+    return name
+  }
+
+  // Look up the name of a key as indicated by an event object.
+  function keyName(event, noShift) {
+    if (presto && event.keyCode == 34 && event["char"]) { return false }
+    var name = keyNames[event.keyCode];
+    if (name == null || event.altGraphKey) { return false }
+    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
+    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
+    if (event.keyCode == 3 && event.code) { name = event.code; }
+    return addModifierNames(name, event, noShift)
+  }
+
+  function getKeyMap(val) {
+    return typeof val == "string" ? keyMap[val] : val
+  }
+
+  // Helper for deleting text near the selection(s), used to implement
+  // backspace, delete, and similar functionality.
+  function deleteNearSelection(cm, compute) {
+    var ranges = cm.doc.sel.ranges, kill = [];
+    // Build up a set of ranges to kill first, merging overlapping
+    // ranges.
+    for (var i = 0; i < ranges.length; i++) {
+      var toKill = compute(ranges[i]);
+      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
+        var replaced = kill.pop();
+        if (cmp(replaced.from, toKill.from) < 0) {
+          toKill.from = replaced.from;
+          break
+        }
+      }
+      kill.push(toKill);
+    }
+    // Next, remove those actual ranges.
+    runInOp(cm, function () {
+      for (var i = kill.length - 1; i >= 0; i--)
+        { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
+      ensureCursorVisible(cm);
+    });
+  }
+
+  function moveCharLogically(line, ch, dir) {
+    var target = skipExtendingChars(line.text, ch + dir, dir);
+    return target < 0 || target > line.text.length ? null : target
+  }
+
+  function moveLogically(line, start, dir) {
+    var ch = moveCharLogically(line, start.ch, dir);
+    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
+  }
+
+  function endOfLine(visually, cm, lineObj, lineNo, dir) {
+    if (visually) {
+      if (cm.doc.direction == "rtl") { dir = -dir; }
+      var order = getOrder(lineObj, cm.doc.direction);
+      if (order) {
+        var part = dir < 0 ? lst(order) : order[0];
+        var moveInStorageOrder = (dir < 0) == (part.level == 1);
+        var sticky = moveInStorageOrder ? "after" : "before";
+        var ch;
+        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
+        // it could be that the last bidi part is not on the last visual line,
+        // since visual lines contain content order-consecutive chunks.
+        // Thus, in rtl, we are looking for the first (content-order) character
+        // in the rtl chunk that is on the last line (that is, the same line
+        // as the last (content-order) character).
+        if (part.level > 0 || cm.doc.direction == "rtl") {
+          var prep = prepareMeasureForLine(cm, lineObj);
+          ch = dir < 0 ? lineObj.text.length - 1 : 0;
+          var targetTop = measureCharPrepared(cm, prep, ch).top;
+          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
+          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
+        } else { ch = dir < 0 ? part.to : part.from; }
+        return new Pos(lineNo, ch, sticky)
+      }
+    }
+    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
+  }
+
+  function moveVisually(cm, line, start, dir) {
+    var bidi = getOrder(line, cm.doc.direction);
+    if (!bidi) { return moveLogically(line, start, dir) }
+    if (start.ch >= line.text.length) {
+      start.ch = line.text.length;
+      start.sticky = "before";
+    } else if (start.ch <= 0) {
+      start.ch = 0;
+      start.sticky = "after";
+    }
+    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
+    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
+      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
+      // nothing interesting happens.
+      return moveLogically(line, start, dir)
     }
-    function visibleLines(display, doc, viewport) {
-      var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
-      top = Math.floor(top - paddingTop(display));
-      var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
-      var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
-      if (viewport && viewport.ensure) {
-        var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
-        if (ensureFrom < from) {
-          from = ensureFrom;
-          to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
-        } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
-          from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
-          to = ensureTo;
-        }
-      }
-      return { from, to: Math.max(to, from + 1) };
-    }
-    function maybeScrollWindow(cm, rect) {
-      if (signalDOMEvent(cm, "scrollCursorIntoView")) {
-        return;
-      }
-      var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
-      if (rect.top + box.top < 0) {
-        doScroll = true;
-      } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
-        doScroll = false;
-      }
-      if (doScroll != null && !phantom) {
-        var scrollNode = elt("div", "\u200B", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
-        cm.display.lineSpace.appendChild(scrollNode);
-        scrollNode.scrollIntoView(doScroll);
-        cm.display.lineSpace.removeChild(scrollNode);
-      }
-    }
-    function scrollPosIntoView(cm, pos, end, margin) {
-      if (margin == null) {
-        margin = 0;
-      }
-      var rect;
-      if (!cm.options.lineWrapping && pos == end) {
-        end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
-        pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
-      }
-      for (var limit = 0; limit < 5; limit++) {
-        var changed = false;
-        var coords = cursorCoords(cm, pos);
-        var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
-        rect = {
-          left: Math.min(coords.left, endCoords.left),
-          top: Math.min(coords.top, endCoords.top) - margin,
-          right: Math.max(coords.left, endCoords.left),
-          bottom: Math.max(coords.bottom, endCoords.bottom) + margin
-        };
-        var scrollPos = calculateScrollPos(cm, rect);
-        var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
-        if (scrollPos.scrollTop != null) {
-          updateScrollTop(cm, scrollPos.scrollTop);
-          if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
-            changed = true;
-          }
-        }
-        if (scrollPos.scrollLeft != null) {
-          setScrollLeft(cm, scrollPos.scrollLeft);
-          if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
-            changed = true;
-          }
-        }
-        if (!changed) {
-          break;
-        }
+
+    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
+    var prep;
+    var getWrappedLineExtent = function (ch) {
+      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
+      prep = prep || prepareMeasureForLine(cm, line);
+      return wrappedLineExtentChar(cm, line, prep, ch)
+    };
+    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);
+
+    if (cm.doc.direction == "rtl" || part.level == 1) {
+      var moveInStorageOrder = (part.level == 1) == (dir < 0);
+      var ch = mv(start, moveInStorageOrder ? 1 : -1);
+      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
+        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
+        var sticky = moveInStorageOrder ? "before" : "after";
+        return new Pos(start.line, ch, sticky)
       }
-      return rect;
     }
-    function scrollIntoView(cm, rect) {
-      var scrollPos = calculateScrollPos(cm, rect);
-      if (scrollPos.scrollTop != null) {
-        updateScrollTop(cm, scrollPos.scrollTop);
-      }
-      if (scrollPos.scrollLeft != null) {
-        setScrollLeft(cm, scrollPos.scrollLeft);
+
+    // Case 3: Could not move within this bidi part in this visual line, so leave
+    // the current bidi part
+
+    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
+      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
+        ? new Pos(start.line, mv(ch, 1), "before")
+        : new Pos(start.line, ch, "after"); };
+
+      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
+        var part = bidi[partPos];
+        var moveInStorageOrder = (dir > 0) == (part.level != 1);
+        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
+        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
+        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
+        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
       }
+    };
+
+    // Case 3a: Look for other bidi parts on the same visual line
+    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
+    if (res) { return res }
+
+    // Case 3b: Look for other bidi parts on the next visual line
+    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
+    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
+      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
+      if (res) { return res }
     }
-    function calculateScrollPos(cm, rect) {
-      var display = cm.display, snapMargin = textHeight(cm.display);
-      if (rect.top < 0) {
-        rect.top = 0;
-      }
-      var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
-      var screen2 = displayHeight(cm), result = {};
-      if (rect.bottom - rect.top > screen2) {
-        rect.bottom = rect.top + screen2;
-      }
-      var docBottom = cm.doc.height + paddingVert(display);
-      var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
-      if (rect.top < screentop) {
-        result.scrollTop = atTop ? 0 : rect.top;
-      } else if (rect.bottom > screentop + screen2) {
-        var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);
-        if (newTop != screentop) {
-          result.scrollTop = newTop;
+
+    // Case 4: Nowhere to move
+    return null
+  }
+
+  // Commands are parameter-less actions that can be performed on an
+  // editor, mostly used for keybindings.
+  var commands = {
+    selectAll: selectAll,
+    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
+    killLine: function (cm) { return deleteNearSelection(cm, function (range) {
+      if (range.empty()) {
+        var len = getLine(cm.doc, range.head.line).text.length;
+        if (range.head.ch == len && range.head.line < cm.lastLine())
+          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
+        else
+          { return {from: range.head, to: Pos(range.head.line, len)} }
+      } else {
+        return {from: range.from(), to: range.to()}
+      }
+    }); },
+    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
+      from: Pos(range.from().line, 0),
+      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
+    }); }); },
+    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
+      from: Pos(range.from().line, 0), to: range.from()
+    }); }); },
+    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
+      var top = cm.charCoords(range.head, "div").top + 5;
+      var leftPos = cm.coordsChar({left: 0, top: top}, "div");
+      return {from: leftPos, to: range.from()}
+    }); },
+    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
+      var top = cm.charCoords(range.head, "div").top + 5;
+      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
+      return {from: range.from(), to: rightPos }
+    }); },
+    undo: function (cm) { return cm.undo(); },
+    redo: function (cm) { return cm.redo(); },
+    undoSelection: function (cm) { return cm.undoSelection(); },
+    redoSelection: function (cm) { return cm.redoSelection(); },
+    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
+    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
+    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
+      {origin: "+move", bias: 1}
+    ); },
+    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
+      {origin: "+move", bias: 1}
+    ); },
+    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
+      {origin: "+move", bias: -1}
+    ); },
+    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
+      var top = cm.cursorCoords(range.head, "div").top + 5;
+      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
+    }, sel_move); },
+    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
+      var top = cm.cursorCoords(range.head, "div").top + 5;
+      return cm.coordsChar({left: 0, top: top}, "div")
+    }, sel_move); },
+    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
+      var top = cm.cursorCoords(range.head, "div").top + 5;
+      var pos = cm.coordsChar({left: 0, top: top}, "div");
+      if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
+      return pos
+    }, sel_move); },
+    goLineUp: function (cm) { return cm.moveV(-1, "line"); },
+    goLineDown: function (cm) { return cm.moveV(1, "line"); },
+    goPageUp: function (cm) { return cm.moveV(-1, "page"); },
+    goPageDown: function (cm) { return cm.moveV(1, "page"); },
+    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
+    goCharRight: function (cm) { return cm.moveH(1, "char"); },
+    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
+    goColumnRight: function (cm) { return cm.moveH(1, "column"); },
+    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
+    goGroupRight: function (cm) { return cm.moveH(1, "group"); },
+    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
+    goWordRight: function (cm) { return cm.moveH(1, "word"); },
+    delCharBefore: function (cm) { return cm.deleteH(-1, "codepoint"); },
+    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
+    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
+    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
+    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
+    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
+    indentAuto: function (cm) { return cm.indentSelection("smart"); },
+    indentMore: function (cm) { return cm.indentSelection("add"); },
+    indentLess: function (cm) { return cm.indentSelection("subtract"); },
+    insertTab: function (cm) { return cm.replaceSelection("\t"); },
+    insertSoftTab: function (cm) {
+      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
+      for (var i = 0; i < ranges.length; i++) {
+        var pos = ranges[i].from();
+        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
+        spaces.push(spaceStr(tabSize - col % tabSize));
+      }
+      cm.replaceSelections(spaces);
+    },
+    defaultTab: function (cm) {
+      if (cm.somethingSelected()) { cm.indentSelection("add"); }
+      else { cm.execCommand("insertTab"); }
+    },
+    // Swap the two chars left and right of each selection's head.
+    // Move cursor behind the two swapped characters afterwards.
+    //
+    // Doesn't consider line feeds a character.
+    // Doesn't scan more than one line above to find a character.
+    // Doesn't do anything on an empty line.
+    // Doesn't do anything with non-empty selections.
+    transposeChars: function (cm) { return runInOp(cm, function () {
+      var ranges = cm.listSelections(), newSel = [];
+      for (var i = 0; i < ranges.length; i++) {
+        if (!ranges[i].empty()) { continue }
+        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
+        if (line) {
+          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
+          if (cur.ch > 0) {
+            cur = new Pos(cur.line, cur.ch + 1);
+            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
+                            Pos(cur.line, cur.ch - 2), cur, "+transpose");
+          } else if (cur.line > cm.doc.first) {
+            var prev = getLine(cm.doc, cur.line - 1).text;
+            if (prev) {
+              cur = new Pos(cur.line, 1);
+              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
+                              prev.charAt(prev.length - 1),
+                              Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
+            }
+          }
         }
+        newSel.push(new Range(cur, cur));
       }
-      var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
-      var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
-      var screenw = displayWidth(cm) - display.gutters.offsetWidth;
-      var tooWide = rect.right - rect.left > screenw;
-      if (tooWide) {
-        rect.right = rect.left + screenw;
-      }
-      if (rect.left < 10) {
-        result.scrollLeft = 0;
-      } else if (rect.left < screenleft) {
-        result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
-      } else if (rect.right > screenw + screenleft - 3) {
-        result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
-      }
-      return result;
+      cm.setSelections(newSel);
+    }); },
+    newlineAndIndent: function (cm) { return runInOp(cm, function () {
+      var sels = cm.listSelections();
+      for (var i = sels.length - 1; i >= 0; i--)
+        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
+      sels = cm.listSelections();
+      for (var i$1 = 0; i$1 < sels.length; i$1++)
+        { cm.indentLine(sels[i$1].from().line, null, true); }
+      ensureCursorVisible(cm);
+    }); },
+    openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
+    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
+  };
+
+
+  function lineStart(cm, lineN) {
+    var line = getLine(cm.doc, lineN);
+    var visual = visualLine(line);
+    if (visual != line) { lineN = lineNo(visual); }
+    return endOfLine(true, cm, visual, lineN, 1)
+  }
+  function lineEnd(cm, lineN) {
+    var line = getLine(cm.doc, lineN);
+    var visual = visualLineEnd(line);
+    if (visual != line) { lineN = lineNo(visual); }
+    return endOfLine(true, cm, line, lineN, -1)
+  }
+  function lineStartSmart(cm, pos) {
+    var start = lineStart(cm, pos.line);
+    var line = getLine(cm.doc, start.line);
+    var order = getOrder(line, cm.doc.direction);
+    if (!order || order[0].level == 0) {
+      var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
+      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
+      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
+    }
+    return start
+  }
+
+  // Run a handler that was bound to a key.
+  function doHandleBinding(cm, bound, dropShift) {
+    if (typeof bound == "string") {
+      bound = commands[bound];
+      if (!bound) { return false }
+    }
+    // Ensure previous input has been read, so that the handler sees a
+    // consistent view of the document
+    cm.display.input.ensurePolled();
+    var prevShift = cm.display.shift, done = false;
+    try {
+      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
+      if (dropShift) { cm.display.shift = false; }
+      done = bound(cm) != Pass;
+    } finally {
+      cm.display.shift = prevShift;
+      cm.state.suppressEdits = false;
     }
-    function addToScrollTop(cm, top) {
-      if (top == null) {
-        return;
-      }
-      resolveScrollToPos(cm);
-      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
+    return done
+  }
+
+  function lookupKeyForEditor(cm, name, handle) {
+    for (var i = 0; i < cm.state.keyMaps.length; i++) {
+      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
+      if (result) { return result }
     }
-    function ensureCursorVisible(cm) {
-      resolveScrollToPos(cm);
-      var cur = cm.getCursor();
-      cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
+    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
+      || lookupKey(name, cm.options.keyMap, handle, cm)
+  }
+
+  // Note that, despite the name, this function is also used to check
+  // for bound mouse clicks.
+
+  var stopSeq = new Delayed;
+
+  function dispatchKey(cm, name, e, handle) {
+    var seq = cm.state.keySeq;
+    if (seq) {
+      if (isModifierKey(name)) { return "handled" }
+      if (/\'$/.test(name))
+        { cm.state.keySeq = null; }
+      else
+        { stopSeq.set(50, function () {
+          if (cm.state.keySeq == seq) {
+            cm.state.keySeq = null;
+            cm.display.input.reset();
+          }
+        }); }
+      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
     }
-    function scrollToCoords(cm, x, y) {
-      if (x != null || y != null) {
-        resolveScrollToPos(cm);
-      }
-      if (x != null) {
-        cm.curOp.scrollLeft = x;
-      }
-      if (y != null) {
-        cm.curOp.scrollTop = y;
-      }
+    return dispatchKeyInner(cm, name, e, handle)
+  }
+
+  function dispatchKeyInner(cm, name, e, handle) {
+    var result = lookupKeyForEditor(cm, name, handle);
+
+    if (result == "multi")
+      { cm.state.keySeq = name; }
+    if (result == "handled")
+      { signalLater(cm, "keyHandled", cm, name, e); }
+
+    if (result == "handled" || result == "multi") {
+      e_preventDefault(e);
+      restartBlink(cm);
     }
-    function scrollToRange(cm, range2) {
-      resolveScrollToPos(cm);
-      cm.curOp.scrollToPos = range2;
+
+    return !!result
+  }
+
+  // Handle a key from the keydown event.
+  function handleKeyBinding(cm, e) {
+    var name = keyName(e, true);
+    if (!name) { return false }
+
+    if (e.shiftKey && !cm.state.keySeq) {
+      // First try to resolve full name (including 'Shift-'). Failing
+      // that, see if there is a cursor-motion command (starting with
+      // 'go') bound to the keyname without 'Shift-'.
+      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
+          || dispatchKey(cm, name, e, function (b) {
+               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
+                 { return doHandleBinding(cm, b) }
+             })
+    } else {
+      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
     }
-    function resolveScrollToPos(cm) {
-      var range2 = cm.curOp.scrollToPos;
-      if (range2) {
-        cm.curOp.scrollToPos = null;
-        var from = estimateCoords(cm, range2.from), to = estimateCoords(cm, range2.to);
-        scrollToCoordsRange(cm, from, to, range2.margin);
+  }
+
+  // Handle a key from the keypress event
+  function handleCharBinding(cm, e, ch) {
+    return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
+  }
+
+  var lastStoppedKey = null;
+  function onKeyDown(e) {
+    var cm = this;
+    if (e.target && e.target != cm.display.input.getField()) { return }
+    cm.curOp.focus = activeElt();
+    if (signalDOMEvent(cm, e)) { return }
+    // IE does strange things with escape.
+    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
+    var code = e.keyCode;
+    cm.display.shift = code == 16 || e.shiftKey;
+    var handled = handleKeyBinding(cm, e);
+    if (presto) {
+      lastStoppedKey = handled ? code : null;
+      // Opera has no cut event... we try to at least catch the key combo
+      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
+        { cm.replaceSelection("", null, "cut"); }
+    }
+    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)
+      { document.execCommand("cut"); }
+
+    // Turn mouse into crosshair when Alt is held on Mac.
+    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
+      { showCrossHair(cm); }
+  }
+
+  function showCrossHair(cm) {
+    var lineDiv = cm.display.lineDiv;
+    addClass(lineDiv, "CodeMirror-crosshair");
+
+    function up(e) {
+      if (e.keyCode == 18 || !e.altKey) {
+        rmClass(lineDiv, "CodeMirror-crosshair");
+        off(document, "keyup", up);
+        off(document, "mouseover", up);
       }
     }
-    function scrollToCoordsRange(cm, from, to, margin) {
-      var sPos = calculateScrollPos(cm, {
-        left: Math.min(from.left, to.left),
-        top: Math.min(from.top, to.top) - margin,
-        right: Math.max(from.right, to.right),
-        bottom: Math.max(from.bottom, to.bottom) + margin
-      });
-      scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
+    on(document, "keyup", up);
+    on(document, "mouseover", up);
+  }
+
+  function onKeyUp(e) {
+    if (e.keyCode == 16) { this.doc.sel.shift = false; }
+    signalDOMEvent(this, e);
+  }
+
+  function onKeyPress(e) {
+    var cm = this;
+    if (e.target && e.target != cm.display.input.getField()) { return }
+    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
+    var keyCode = e.keyCode, charCode = e.charCode;
+    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
+    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
+    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
+    // Some browsers fire keypress events for backspace
+    if (ch == "\x08") { return }
+    if (handleCharBinding(cm, e, ch)) { return }
+    cm.display.input.onKeyPress(e);
+  }
+
+  var DOUBLECLICK_DELAY = 400;
+
+  var PastClick = function(time, pos, button) {
+    this.time = time;
+    this.pos = pos;
+    this.button = button;
+  };
+
+  PastClick.prototype.compare = function (time, pos, button) {
+    return this.time + DOUBLECLICK_DELAY > time &&
+      cmp(pos, this.pos) == 0 && button == this.button
+  };
+
+  var lastClick, lastDoubleClick;
+  function clickRepeat(pos, button) {
+    var now = +new Date;
+    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
+      lastClick = lastDoubleClick = null;
+      return "triple"
+    } else if (lastClick && lastClick.compare(now, pos, button)) {
+      lastDoubleClick = new PastClick(now, pos, button);
+      lastClick = null;
+      return "double"
+    } else {
+      lastClick = new PastClick(now, pos, button);
+      lastDoubleClick = null;
+      return "single"
     }
-    function updateScrollTop(cm, val) {
-      if (Math.abs(cm.doc.scrollTop - val) < 2) {
-        return;
-      }
-      if (!gecko) {
-        updateDisplaySimple(cm, { top: val });
-      }
-      setScrollTop(cm, val, true);
-      if (gecko) {
-        updateDisplaySimple(cm);
-      }
-      startWorker(cm, 100);
+  }
+
+  // A mouse down can be a single click, double click, triple click,
+  // start of selection drag, start of text drag, new cursor
+  // (ctrl-click), rectangle drag (alt-drag), or xwin
+  // middle-click-paste. Or it might be a click on something we should
+  // not interfere with, such as a scrollbar or widget.
+  function onMouseDown(e) {
+    var cm = this, display = cm.display;
+    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
+    display.input.ensurePolled();
+    display.shift = e.shiftKey;
+
+    if (eventInWidget(display, e)) {
+      if (!webkit) {
+        // Briefly turn off draggability, to allow widgets to do
+        // normal dragging things.
+        display.scroller.draggable = false;
+        setTimeout(function () { return display.scroller.draggable = true; }, 100);
+      }
+      return
+    }
+    if (clickInGutter(cm, e)) { return }
+    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
+    window.focus();
+
+    // #3261: make sure, that we're not starting a second selection
+    if (button == 1 && cm.state.selectingText)
+      { cm.state.selectingText(e); }
+
+    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }
+
+    if (button == 1) {
+      if (pos) { leftButtonDown(cm, pos, repeat, e); }
+      else if (e_target(e) == display.scroller) { e_preventDefault(e); }
+    } else if (button == 2) {
+      if (pos) { extendSelection(cm.doc, pos); }
+      setTimeout(function () { return display.input.focus(); }, 20);
+    } else if (button == 3) {
+      if (captureRightClick) { cm.display.input.onContextMenu(e); }
+      else { delayBlurEvent(cm); }
     }
-    function setScrollTop(cm, val, forceScroll) {
-      val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
-      if (cm.display.scroller.scrollTop == val && !forceScroll) {
-        return;
+  }
+
+  function handleMappedButton(cm, button, pos, repeat, event) {
+    var name = "Click";
+    if (repeat == "double") { name = "Double" + name; }
+    else if (repeat == "triple") { name = "Triple" + name; }
+    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
+
+    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
+      if (typeof bound == "string") { bound = commands[bound]; }
+      if (!bound) { return false }
+      var done = false;
+      try {
+        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
+        done = bound(cm, pos) != Pass;
+      } finally {
+        cm.state.suppressEdits = false;
       }
-      cm.doc.scrollTop = val;
-      cm.display.scrollbars.setScrollTop(val);
-      if (cm.display.scroller.scrollTop != val) {
-        cm.display.scroller.scrollTop = val;
+      return done
+    })
+  }
+
+  function configureMouse(cm, repeat, event) {
+    var option = cm.getOption("configureMouse");
+    var value = option ? option(cm, repeat, event) : {};
+    if (value.unit == null) {
+      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
+      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
+    }
+    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
+    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
+    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
+    return value
+  }
+
+  function leftButtonDown(cm, pos, repeat, event) {
+    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
+    else { cm.curOp.focus = activeElt(); }
+
+    var behavior = configureMouse(cm, repeat, event);
+
+    var sel = cm.doc.sel, contained;
+    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
+        repeat == "single" && (contained = sel.contains(pos)) > -1 &&
+        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
+        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
+      { leftButtonStartDrag(cm, event, pos, behavior); }
+    else
+      { leftButtonSelect(cm, event, pos, behavior); }
+  }
+
+  // Start a text drag. When it ends, see if any dragging actually
+  // happen, and treat as a click if it didn't.
+  function leftButtonStartDrag(cm, event, pos, behavior) {
+    var display = cm.display, moved = false;
+    var dragEnd = operation(cm, function (e) {
+      if (webkit) { display.scroller.draggable = false; }
+      cm.state.draggingText = false;
+      if (cm.state.delayingBlurEvent) {
+        if (cm.hasFocus()) { cm.state.delayingBlurEvent = false; }
+        else { delayBlurEvent(cm); }
+      }
+      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
+      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
+      off(display.scroller, "dragstart", dragStart);
+      off(display.scroller, "drop", dragEnd);
+      if (!moved) {
+        e_preventDefault(e);
+        if (!behavior.addNew)
+          { extendSelection(cm.doc, pos, null, null, behavior.extend); }
+        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
+        if ((webkit && !safari) || ie && ie_version == 9)
+          { setTimeout(function () {display.wrapper.ownerDocument.body.focus({preventScroll: true}); display.input.focus();}, 20); }
+        else
+          { display.input.focus(); }
       }
+    });
+    var mouseMove = function(e2) {
+      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
+    };
+    var dragStart = function () { return moved = true; };
+    // Let the drag handler handle this.
+    if (webkit) { display.scroller.draggable = true; }
+    cm.state.draggingText = dragEnd;
+    dragEnd.copy = !behavior.moveOnDrag;
+    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
+    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
+    on(display.scroller, "dragstart", dragStart);
+    on(display.scroller, "drop", dragEnd);
+
+    cm.state.delayingBlurEvent = true;
+    setTimeout(function () { return display.input.focus(); }, 20);
+    // IE's approach to draggable
+    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
+  }
+
+  function rangeForUnit(cm, pos, unit) {
+    if (unit == "char") { return new Range(pos, pos) }
+    if (unit == "word") { return cm.findWordAt(pos) }
+    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
+    var result = unit(cm, pos);
+    return new Range(result.from, result.to)
+  }
+
+  // Normal selection, as opposed to text dragging.
+  function leftButtonSelect(cm, event, start, behavior) {
+    if (ie) { delayBlurEvent(cm); }
+    var display = cm.display, doc = cm.doc;
+    e_preventDefault(event);
+
+    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
+    if (behavior.addNew && !behavior.extend) {
+      ourIndex = doc.sel.contains(start);
+      if (ourIndex > -1)
+        { ourRange = ranges[ourIndex]; }
+      else
+        { ourRange = new Range(start, start); }
+    } else {
+      ourRange = doc.sel.primary();
+      ourIndex = doc.sel.primIndex;
     }
-    function setScrollLeft(cm, val, isScroller, forceScroll) {
-      val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
-      if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
-        return;
-      }
-      cm.doc.scrollLeft = val;
-      alignHorizontally(cm);
-      if (cm.display.scroller.scrollLeft != val) {
-        cm.display.scroller.scrollLeft = val;
-      }
-      cm.display.scrollbars.setScrollLeft(val);
+
+    if (behavior.unit == "rectangle") {
+      if (!behavior.addNew) { ourRange = new Range(start, start); }
+      start = posFromMouse(cm, event, true, true);
+      ourIndex = -1;
+    } else {
+      var range = rangeForUnit(cm, start, behavior.unit);
+      if (behavior.extend)
+        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }
+      else
+        { ourRange = range; }
     }
-    function measureForScrollbars(cm) {
-      var d = cm.display, gutterW = d.gutters.offsetWidth;
-      var docH = Math.round(cm.doc.height + paddingVert(cm.display));
-      return {
-        clientHeight: d.scroller.clientHeight,
-        viewHeight: d.wrapper.clientHeight,
-        scrollWidth: d.scroller.scrollWidth,
-        clientWidth: d.scroller.clientWidth,
-        viewWidth: d.wrapper.clientWidth,
-        barLeft: cm.options.fixedGutter ? gutterW : 0,
-        docHeight: docH,
-        scrollHeight: docH + scrollGap(cm) + d.barHeight,
-        nativeBarWidth: d.nativeBarWidth,
-        gutterWidth: gutterW
-      };
+
+    if (!behavior.addNew) {
+      ourIndex = 0;
+      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
+      startSel = doc.sel;
+    } else if (ourIndex == -1) {
+      ourIndex = ranges.length;
+      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
+                   {scroll: false, origin: "*mouse"});
+    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
+      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
+                   {scroll: false, origin: "*mouse"});
+      startSel = doc.sel;
+    } else {
+      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
     }
-    var NativeScrollbars = function(place, scroll, cm) {
-      this.cm = cm;
-      var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
-      var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
-      vert.tabIndex = horiz.tabIndex = -1;
-      place(vert);
-      place(horiz);
-      on(vert, "scroll", function() {
-        if (vert.clientHeight) {
-          scroll(vert.scrollTop, "vertical");
-        }
-      });
-      on(horiz, "scroll", function() {
-        if (horiz.clientWidth) {
-          scroll(horiz.scrollLeft, "horizontal");
-        }
-      });
-      this.checkedZeroWidth = false;
-      if (ie && ie_version < 8) {
-        this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
-      }
-    };
-    NativeScrollbars.prototype.update = function(measure) {
-      var needsH = measure.scrollWidth > measure.clientWidth + 1;
-      var needsV = measure.scrollHeight > measure.clientHeight + 1;
-      var sWidth = measure.nativeBarWidth;
-      if (needsV) {
-        this.vert.style.display = "block";
-        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
-        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
-        this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
-      } else {
-        this.vert.style.display = "";
-        this.vert.firstChild.style.height = "0";
-      }
-      if (needsH) {
-        this.horiz.style.display = "block";
-        this.horiz.style.right = needsV ? sWidth + "px" : "0";
-        this.horiz.style.left = measure.barLeft + "px";
-        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
-        this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
+
+    var lastPos = start;
+    function extendTo(pos) {
+      if (cmp(lastPos, pos) == 0) { return }
+      lastPos = pos;
+
+      if (behavior.unit == "rectangle") {
+        var ranges = [], tabSize = cm.options.tabSize;
+        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
+        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
+        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
+        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
+             line <= end; line++) {
+          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
+          if (left == right)
+            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
+          else if (text.length > leftPos)
+            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
+        }
+        if (!ranges.length) { ranges.push(new Range(start, start)); }
+        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
+                     {origin: "*mouse", scroll: false});
+        cm.scrollIntoView(pos);
       } else {
-        this.horiz.style.display = "";
-        this.horiz.firstChild.style.width = "0";
-      }
-      if (!this.checkedZeroWidth && measure.clientHeight > 0) {
-        if (sWidth == 0) {
-          this.zeroWidthHack();
-        }
-        this.checkedZeroWidth = true;
-      }
-      return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
-    };
-    NativeScrollbars.prototype.setScrollLeft = function(pos) {
-      if (this.horiz.scrollLeft != pos) {
-        this.horiz.scrollLeft = pos;
-      }
-      if (this.disableHoriz) {
-        this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
-      }
-    };
-    NativeScrollbars.prototype.setScrollTop = function(pos) {
-      if (this.vert.scrollTop != pos) {
-        this.vert.scrollTop = pos;
-      }
-      if (this.disableVert) {
-        this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
-      }
-    };
-    NativeScrollbars.prototype.zeroWidthHack = function() {
-      var w = mac && !mac_geMountainLion ? "12px" : "18px";
-      this.horiz.style.height = this.vert.style.width = w;
-      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
-      this.disableHoriz = new Delayed();
-      this.disableVert = new Delayed();
-    };
-    NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {
-      bar.style.pointerEvents = "auto";
-      function maybeDisable() {
-        var box = bar.getBoundingClientRect();
-        var elt2 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
-        if (elt2 != bar) {
-          bar.style.pointerEvents = "none";
+        var oldRange = ourRange;
+        var range = rangeForUnit(cm, pos, behavior.unit);
+        var anchor = oldRange.anchor, head;
+        if (cmp(range.anchor, anchor) > 0) {
+          head = range.head;
+          anchor = minPos(oldRange.from(), range.anchor);
         } else {
-          delay.set(1e3, maybeDisable);
+          head = range.anchor;
+          anchor = maxPos(oldRange.to(), range.head);
         }
-      }
-      delay.set(1e3, maybeDisable);
-    };
-    NativeScrollbars.prototype.clear = function() {
-      var parent = this.horiz.parentNode;
-      parent.removeChild(this.horiz);
-      parent.removeChild(this.vert);
-    };
-    var NullScrollbars = function() {
-    };
-    NullScrollbars.prototype.update = function() {
-      return { bottom: 0, right: 0 };
-    };
-    NullScrollbars.prototype.setScrollLeft = function() {
-    };
-    NullScrollbars.prototype.setScrollTop = function() {
-    };
-    NullScrollbars.prototype.clear = function() {
-    };
-    function updateScrollbars(cm, measure) {
-      if (!measure) {
-        measure = measureForScrollbars(cm);
-      }
-      var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
-      updateScrollbarsInner(cm, measure);
-      for (var i2 = 0; i2 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i2++) {
-        if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
-          updateHeightsInViewport(cm);
-        }
-        updateScrollbarsInner(cm, measureForScrollbars(cm));
-        startWidth = cm.display.barWidth;
-        startHeight = cm.display.barHeight;
-      }
-    }
-    function updateScrollbarsInner(cm, measure) {
-      var d = cm.display;
-      var sizes = d.scrollbars.update(measure);
-      d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
-      d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
-      d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
-      if (sizes.right && sizes.bottom) {
-        d.scrollbarFiller.style.display = "block";
-        d.scrollbarFiller.style.height = sizes.bottom + "px";
-        d.scrollbarFiller.style.width = sizes.right + "px";
-      } else {
-        d.scrollbarFiller.style.display = "";
-      }
-      if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
-        d.gutterFiller.style.display = "block";
-        d.gutterFiller.style.height = sizes.bottom + "px";
-        d.gutterFiller.style.width = measure.gutterWidth + "px";
-      } else {
-        d.gutterFiller.style.display = "";
+        var ranges$1 = startSel.ranges.slice(0);
+        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
+        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
       }
     }
-    var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };
-    function initScrollbars(cm) {
-      if (cm.display.scrollbars) {
-        cm.display.scrollbars.clear();
-        if (cm.display.scrollbars.addClass) {
-          rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
-        }
-      }
-      cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
-        cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
-        on(node, "mousedown", function() {
-          if (cm.state.focused) {
-            setTimeout(function() {
-              return cm.display.input.focus();
-            }, 0);
-          }
-        });
-        node.setAttribute("cm-not-content", "true");
-      }, function(pos, axis) {
-        if (axis == "horizontal") {
-          setScrollLeft(cm, pos);
-        } else {
-          updateScrollTop(cm, pos);
-        }
-      }, cm);
-      if (cm.display.scrollbars.addClass) {
-        addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
-      }
-    }
-    var nextOpId = 0;
-    function startOperation(cm) {
-      cm.curOp = {
-        cm,
-        viewChanged: false,
-        startHeight: cm.doc.height,
-        forceUpdate: false,
-        updateInput: 0,
-        typing: false,
-        changeObjs: null,
-        cursorActivityHandlers: null,
-        cursorActivityCalled: 0,
-        selectionChanged: false,
-        updateMaxLine: false,
-        scrollLeft: null,
-        scrollTop: null,
-        scrollToPos: null,
-        focus: false,
-        id: ++nextOpId,
-        markArrays: null
-      };
-      pushOperation(cm.curOp);
-    }
-    function endOperation(cm) {
-      var op = cm.curOp;
-      if (op) {
-        finishOperation(op, function(group) {
-          for (var i2 = 0; i2 < group.ops.length; i2++) {
-            group.ops[i2].cm.curOp = null;
-          }
-          endOperations(group);
-        });
+
+    var editorSize = display.wrapper.getBoundingClientRect();
+    // Used to ensure timeout re-tries don't fire when another extend
+    // happened in the meantime (clearTimeout isn't reliable -- at
+    // least on Chrome, the timeouts still happen even when cleared,
+    // if the clear happens after their scheduled firing time).
+    var counter = 0;
+
+    function extend(e) {
+      var curCount = ++counter;
+      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
+      if (!cur) { return }
+      if (cmp(cur, lastPos) != 0) {
+        cm.curOp.focus = activeElt();
+        extendTo(cur);
+        var visible = visibleLines(display, doc);
+        if (cur.line >= visible.to || cur.line < visible.from)
+          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
+      } else {
+        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
+        if (outside) { setTimeout(operation(cm, function () {
+          if (counter != curCount) { return }
+          display.scroller.scrollTop += outside;
+          extend(e);
+        }), 50); }
       }
     }
-    function endOperations(group) {
-      var ops = group.ops;
-      for (var i2 = 0; i2 < ops.length; i2++) {
-        endOperation_R1(ops[i2]);
-      }
-      for (var i$12 = 0; i$12 < ops.length; i$12++) {
-        endOperation_W1(ops[i$12]);
-      }
-      for (var i$22 = 0; i$22 < ops.length; i$22++) {
-        endOperation_R2(ops[i$22]);
-      }
-      for (var i$3 = 0; i$3 < ops.length; i$3++) {
-        endOperation_W2(ops[i$3]);
-      }
-      for (var i$4 = 0; i$4 < ops.length; i$4++) {
-        endOperation_finish(ops[i$4]);
+
+    function done(e) {
+      cm.state.selectingText = false;
+      counter = Infinity;
+      // If e is null or undefined we interpret this as someone trying
+      // to explicitly cancel the selection rather than the user
+      // letting go of the mouse button.
+      if (e) {
+        e_preventDefault(e);
+        display.input.focus();
       }
+      off(display.wrapper.ownerDocument, "mousemove", move);
+      off(display.wrapper.ownerDocument, "mouseup", up);
+      doc.history.lastSelOrigin = null;
     }
-    function endOperation_R1(op) {
-      var cm = op.cm, display = cm.display;
-      maybeClipScrollbars(cm);
-      if (op.updateMaxLine) {
-        findMaxLine(cm);
-      }
-      op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
-      op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
+
+    var move = operation(cm, function (e) {
+      if (e.buttons === 0 || !e_button(e)) { done(e); }
+      else { extend(e); }
+    });
+    var up = operation(cm, done);
+    cm.state.selectingText = up;
+    on(display.wrapper.ownerDocument, "mousemove", move);
+    on(display.wrapper.ownerDocument, "mouseup", up);
+  }
+
+  // Used when mouse-selecting to adjust the anchor to the proper side
+  // of a bidi jump depending on the visual position of the head.
+  function bidiSimplify(cm, range) {
+    var anchor = range.anchor;
+    var head = range.head;
+    var anchorLine = getLine(cm.doc, anchor.line);
+    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }
+    var order = getOrder(anchorLine);
+    if (!order) { return range }
+    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
+    if (part.from != anchor.ch && part.to != anchor.ch) { return range }
+    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
+    if (boundary == 0 || boundary == order.length) { return range }
+
+    // Compute the relative visual position of the head compared to the
+    // anchor (<0 is to the left, >0 to the right)
+    var leftSide;
+    if (head.line != anchor.line) {
+      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
+    } else {
+      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
+      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
+      if (headIndex == boundary - 1 || headIndex == boundary)
+        { leftSide = dir < 0; }
+      else
+        { leftSide = dir > 0; }
     }
-    function endOperation_W1(op) {
-      op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
+
+    var usePart = order[boundary + (leftSide ? -1 : 0)];
+    var from = leftSide == (usePart.level == 1);
+    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
+    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)
+  }
+
+
+  // Determines whether an event happened in the gutter, and fires the
+  // handlers for the corresponding event.
+  function gutterEvent(cm, e, type, prevent) {
+    var mX, mY;
+    if (e.touches) {
+      mX = e.touches[0].clientX;
+      mY = e.touches[0].clientY;
+    } else {
+      try { mX = e.clientX; mY = e.clientY; }
+      catch(e$1) { return false }
     }
-    function endOperation_R2(op) {
-      var cm = op.cm, display = cm.display;
-      if (op.updatedDisplay) {
-        updateHeightsInViewport(cm);
-      }
-      op.barMeasure = measureForScrollbars(cm);
-      if (display.maxLineChanged && !cm.options.lineWrapping) {
-        op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
-        cm.display.sizerWidth = op.adjustWidthTo;
-        op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
-        op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
-      }
-      if (op.updatedDisplay || op.selectionChanged) {
-        op.preparedSelection = display.input.prepareSelection();
+    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
+    if (prevent) { e_preventDefault(e); }
+
+    var display = cm.display;
+    var lineBox = display.lineDiv.getBoundingClientRect();
+
+    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
+    mY -= lineBox.top - display.viewOffset;
+
+    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
+      var g = display.gutters.childNodes[i];
+      if (g && g.getBoundingClientRect().right >= mX) {
+        var line = lineAtHeight(cm.doc, mY);
+        var gutter = cm.display.gutterSpecs[i];
+        signal(cm, type, cm, line, gutter.className, e);
+        return e_defaultPrevented(e)
       }
     }
-    function endOperation_W2(op) {
-      var cm = op.cm;
-      if (op.adjustWidthTo != null) {
-        cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
-        if (op.maxScrollLeft < cm.doc.scrollLeft) {
-          setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
-        }
-        cm.display.maxLineChanged = false;
-      }
-      var takeFocus = op.focus && op.focus == activeElt();
-      if (op.preparedSelection) {
-        cm.display.input.showSelection(op.preparedSelection, takeFocus);
-      }
-      if (op.updatedDisplay || op.startHeight != cm.doc.height) {
-        updateScrollbars(cm, op.barMeasure);
-      }
-      if (op.updatedDisplay) {
-        setDocumentHeight(cm, op.barMeasure);
-      }
-      if (op.selectionChanged) {
-        restartBlink(cm);
-      }
-      if (cm.state.focused && op.updateInput) {
-        cm.display.input.reset(op.typing);
-      }
-      if (takeFocus) {
-        ensureFocus(op.cm);
-      }
+  }
+
+  function clickInGutter(cm, e) {
+    return gutterEvent(cm, e, "gutterClick", true)
+  }
+
+  // CONTEXT MENU HANDLING
+
+  // To make the context menu work, we need to briefly unhide the
+  // textarea (making it as unobtrusive as possible) to let the
+  // right-click take effect on it.
+  function onContextMenu(cm, e) {
+    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
+    if (signalDOMEvent(cm, e, "contextmenu")) { return }
+    if (!captureRightClick) { cm.display.input.onContextMenu(e); }
+  }
+
+  function contextMenuInGutter(cm, e) {
+    if (!hasHandler(cm, "gutterContextMenu")) { return false }
+    return gutterEvent(cm, e, "gutterContextMenu", false)
+  }
+
+  function themeChanged(cm) {
+    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
+      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
+    clearCaches(cm);
+  }
+
+  var Init = {toString: function(){return "CodeMirror.Init"}};
+
+  var defaults = {};
+  var optionHandlers = {};
+
+  function defineOptions(CodeMirror) {
+    var optionHandlers = CodeMirror.optionHandlers;
+
+    function option(name, deflt, handle, notOnInit) {
+      CodeMirror.defaults[name] = deflt;
+      if (handle) { optionHandlers[name] =
+        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
     }
-    function endOperation_finish(op) {
-      var cm = op.cm, display = cm.display, doc = cm.doc;
-      if (op.updatedDisplay) {
-        postUpdateDisplay(cm, op.update);
-      }
-      if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
-        display.wheelStartX = display.wheelStartY = null;
-      }
-      if (op.scrollTop != null) {
-        setScrollTop(cm, op.scrollTop, op.forceScroll);
-      }
-      if (op.scrollLeft != null) {
-        setScrollLeft(cm, op.scrollLeft, true, true);
-      }
-      if (op.scrollToPos) {
-        var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
-        maybeScrollWindow(cm, rect);
+
+    CodeMirror.defineOption = option;
+
+    // Passed to option handlers when there is no old value.
+    CodeMirror.Init = Init;
+
+    // These two are, on init, called from the constructor because they
+    // have to be initialized before the editor can start at all.
+    option("value", "", function (cm, val) { return cm.setValue(val); }, true);
+    option("mode", null, function (cm, val) {
+      cm.doc.modeOption = val;
+      loadMode(cm);
+    }, true);
+
+    option("indentUnit", 2, loadMode, true);
+    option("indentWithTabs", false);
+    option("smartIndent", true);
+    option("tabSize", 4, function (cm) {
+      resetModeState(cm);
+      clearCaches(cm);
+      regChange(cm);
+    }, true);
+
+    option("lineSeparator", null, function (cm, val) {
+      cm.doc.lineSep = val;
+      if (!val) { return }
+      var newBreaks = [], lineNo = cm.doc.first;
+      cm.doc.iter(function (line) {
+        for (var pos = 0;;) {
+          var found = line.text.indexOf(val, pos);
+          if (found == -1) { break }
+          pos = found + val.length;
+          newBreaks.push(Pos(lineNo, found));
+        }
+        lineNo++;
+      });
+      for (var i = newBreaks.length - 1; i >= 0; i--)
+        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
+    });
+    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
+      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
+      if (old != Init) { cm.refresh(); }
+    });
+    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
+    option("electricChars", true);
+    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
+      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
+    }, true);
+    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
+    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
+    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
+    option("rtlMoveVisually", !windows);
+    option("wholeLineUpdateBefore", true);
+
+    option("theme", "default", function (cm) {
+      themeChanged(cm);
+      updateGutters(cm);
+    }, true);
+    option("keyMap", "default", function (cm, val, old) {
+      var next = getKeyMap(val);
+      var prev = old != Init && getKeyMap(old);
+      if (prev && prev.detach) { prev.detach(cm, next); }
+      if (next.attach) { next.attach(cm, prev || null); }
+    });
+    option("extraKeys", null);
+    option("configureMouse", null);
+
+    option("lineWrapping", false, wrappingChanged, true);
+    option("gutters", [], function (cm, val) {
+      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
+      updateGutters(cm);
+    }, true);
+    option("fixedGutter", true, function (cm, val) {
+      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
+      cm.refresh();
+    }, true);
+    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
+    option("scrollbarStyle", "native", function (cm) {
+      initScrollbars(cm);
+      updateScrollbars(cm);
+      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
+      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
+    }, true);
+    option("lineNumbers", false, function (cm, val) {
+      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
+      updateGutters(cm);
+    }, true);
+    option("firstLineNumber", 1, updateGutters, true);
+    option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
+    option("showCursorWhenSelecting", false, updateSelection, true);
+
+    option("resetSelectionOnContextMenu", true);
+    option("lineWiseCopyCut", true);
+    option("pasteLinesPerSelection", true);
+    option("selectionsMayTouch", false);
+
+    option("readOnly", false, function (cm, val) {
+      if (val == "nocursor") {
+        onBlur(cm);
+        cm.display.input.blur();
       }
-      var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
-      if (hidden) {
-        for (var i2 = 0; i2 < hidden.length; ++i2) {
-          if (!hidden[i2].lines.length) {
-            signal(hidden[i2], "hide");
-          }
-        }
-      }
-      if (unhidden) {
-        for (var i$12 = 0; i$12 < unhidden.length; ++i$12) {
-          if (unhidden[i$12].lines.length) {
-            signal(unhidden[i$12], "unhide");
-          }
+      cm.display.input.readOnlyChanged(val);
+    });
+
+    option("screenReaderLabel", null, function (cm, val) {
+      val = (val === '') ? null : val;
+      cm.display.input.screenReaderLabelChanged(val);
+    });
+
+    option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
+    option("dragDrop", true, dragDropChanged);
+    option("allowDropFileTypes", null);
+
+    option("cursorBlinkRate", 530);
+    option("cursorScrollMargin", 0);
+    option("cursorHeight", 1, updateSelection, true);
+    option("singleCursorHeightPerLine", true, updateSelection, true);
+    option("workTime", 100);
+    option("workDelay", 100);
+    option("flattenSpans", true, resetModeState, true);
+    option("addModeClass", false, resetModeState, true);
+    option("pollInterval", 100);
+    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
+    option("historyEventDelay", 1250);
+    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
+    option("maxHighlightLength", 10000, resetModeState, true);
+    option("moveInputWithCursor", true, function (cm, val) {
+      if (!val) { cm.display.input.resetPosition(); }
+    });
+
+    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
+    option("autofocus", null);
+    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
+    option("phrases", null);
+  }
+
+  function dragDropChanged(cm, value, old) {
+    var wasOn = old && old != Init;
+    if (!value != !wasOn) {
+      var funcs = cm.display.dragFunctions;
+      var toggle = value ? on : off;
+      toggle(cm.display.scroller, "dragstart", funcs.start);
+      toggle(cm.display.scroller, "dragenter", funcs.enter);
+      toggle(cm.display.scroller, "dragover", funcs.over);
+      toggle(cm.display.scroller, "dragleave", funcs.leave);
+      toggle(cm.display.scroller, "drop", funcs.drop);
+    }
+  }
+
+  function wrappingChanged(cm) {
+    if (cm.options.lineWrapping) {
+      addClass(cm.display.wrapper, "CodeMirror-wrap");
+      cm.display.sizer.style.minWidth = "";
+      cm.display.sizerWidth = null;
+    } else {
+      rmClass(cm.display.wrapper, "CodeMirror-wrap");
+      findMaxLine(cm);
+    }
+    estimateLineHeights(cm);
+    regChange(cm);
+    clearCaches(cm);
+    setTimeout(function () { return updateScrollbars(cm); }, 100);
+  }
+
+  // A CodeMirror instance represents an editor. This is the object
+  // that user code is usually dealing with.
+
+  function CodeMirror(place, options) {
+    var this$1$1 = this;
+
+    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }
+
+    this.options = options = options ? copyObj(options) : {};
+    // Determine effective options based on given values and defaults.
+    copyObj(defaults, options, false);
+
+    var doc = options.value;
+    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
+    else if (options.mode) { doc.modeOption = options.mode; }
+    this.doc = doc;
+
+    var input = new CodeMirror.inputStyles[options.inputStyle](this);
+    var display = this.display = new Display(place, doc, input, options);
+    display.wrapper.CodeMirror = this;
+    themeChanged(this);
+    if (options.lineWrapping)
+      { this.display.wrapper.className += " CodeMirror-wrap"; }
+    initScrollbars(this);
+
+    this.state = {
+      keyMaps: [],  // stores maps added by addKeyMap
+      overlays: [], // highlighting overlays, as added by addOverlay
+      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
+      overwrite: false,
+      delayingBlurEvent: false,
+      focused: false,
+      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
+      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
+      selectingText: false,
+      draggingText: false,
+      highlight: new Delayed(), // stores highlight worker timeout
+      keySeq: null,  // Unfinished key sequence
+      specialChars: null
+    };
+
+    if (options.autofocus && !mobile) { display.input.focus(); }
+
+    // Override magic textarea content restore that IE sometimes does
+    // on our hidden textarea on reload
+    if (ie && ie_version < 11) { setTimeout(function () { return this$1$1.display.input.reset(true); }, 20); }
+
+    registerEventHandlers(this);
+    ensureGlobalHandlers();
+
+    startOperation(this);
+    this.curOp.forceUpdate = true;
+    attachDoc(this, doc);
+
+    if ((options.autofocus && !mobile) || this.hasFocus())
+      { setTimeout(function () {
+        if (this$1$1.hasFocus() && !this$1$1.state.focused) { onFocus(this$1$1); }
+      }, 20); }
+    else
+      { onBlur(this); }
+
+    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
+      { optionHandlers[opt](this, options[opt], Init); } }
+    maybeUpdateLineNumberWidth(this);
+    if (options.finishInit) { options.finishInit(this); }
+    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }
+    endOperation(this);
+    // Suppress optimizelegibility in Webkit, since it breaks text
+    // measuring on line wrapping boundaries.
+    if (webkit && options.lineWrapping &&
+        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
+      { display.lineDiv.style.textRendering = "auto"; }
+  }
+
+  // The default configuration options.
+  CodeMirror.defaults = defaults;
+  // Functions to run when options are changed.
+  CodeMirror.optionHandlers = optionHandlers;
+
+  // Attach the necessary event handlers when initializing the editor
+  function registerEventHandlers(cm) {
+    var d = cm.display;
+    on(d.scroller, "mousedown", operation(cm, onMouseDown));
+    // Older IE's will not fire a second mousedown for a double click
+    if (ie && ie_version < 11)
+      { on(d.scroller, "dblclick", operation(cm, function (e) {
+        if (signalDOMEvent(cm, e)) { return }
+        var pos = posFromMouse(cm, e);
+        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
+        e_preventDefault(e);
+        var word = cm.findWordAt(pos);
+        extendSelection(cm.doc, word.anchor, word.head);
+      })); }
+    else
+      { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
+    // Some browsers fire contextmenu *after* opening the menu, at
+    // which point we can't mess with it anymore. Context menu is
+    // handled in onMouseDown for these browsers.
+    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });
+    on(d.input.getField(), "contextmenu", function (e) {
+      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }
+    });
+
+    // Used to suppress mouse event handling when a touch happens
+    var touchFinished, prevTouch = {end: 0};
+    function finishTouch() {
+      if (d.activeTouch) {
+        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
+        prevTouch = d.activeTouch;
+        prevTouch.end = +new Date;
+      }
+    }
+    function isMouseLikeTouchEvent(e) {
+      if (e.touches.length != 1) { return false }
+      var touch = e.touches[0];
+      return touch.radiusX <= 1 && touch.radiusY <= 1
+    }
+    function farAway(touch, other) {
+      if (other.left == null) { return true }
+      var dx = other.left - touch.left, dy = other.top - touch.top;
+      return dx * dx + dy * dy > 20 * 20
+    }
+    on(d.scroller, "touchstart", function (e) {
+      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
+        d.input.ensurePolled();
+        clearTimeout(touchFinished);
+        var now = +new Date;
+        d.activeTouch = {start: now, moved: false,
+                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
+        if (e.touches.length == 1) {
+          d.activeTouch.left = e.touches[0].pageX;
+          d.activeTouch.top = e.touches[0].pageY;
         }
       }
-      if (display.wrapper.offsetHeight) {
-        doc.scrollTop = cm.display.scroller.scrollTop;
-      }
-      if (op.changeObjs) {
-        signal(cm, "changes", cm, op.changeObjs);
+    });
+    on(d.scroller, "touchmove", function () {
+      if (d.activeTouch) { d.activeTouch.moved = true; }
+    });
+    on(d.scroller, "touchend", function (e) {
+      var touch = d.activeTouch;
+      if (touch && !eventInWidget(d, e) && touch.left != null &&
+          !touch.moved && new Date - touch.start < 300) {
+        var pos = cm.coordsChar(d.activeTouch, "page"), range;
+        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
+          { range = new Range(pos, pos); }
+        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
+          { range = cm.findWordAt(pos); }
+        else // Triple tap
+          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
+        cm.setSelection(range.anchor, range.head);
+        cm.focus();
+        e_preventDefault(e);
       }
-      if (op.update) {
-        op.update.finish();
+      finishTouch();
+    });
+    on(d.scroller, "touchcancel", finishTouch);
+
+    // Sync scrolling between fake scrollbars and real scrollable
+    // area, ensure viewport is updated when scrolling.
+    on(d.scroller, "scroll", function () {
+      if (d.scroller.clientHeight) {
+        updateScrollTop(cm, d.scroller.scrollTop);
+        setScrollLeft(cm, d.scroller.scrollLeft, true);
+        signal(cm, "scroll", cm);
       }
+    });
+
+    // Listen to wheel events in order to try and update the viewport on time.
+    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
+    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });
+
+    // Prevent wrapper from ever scrolling
+    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });
+
+    d.dragFunctions = {
+      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
+      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
+      start: function (e) { return onDragStart(cm, e); },
+      drop: operation(cm, onDrop),
+      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
+    };
+
+    var inp = d.input.getField();
+    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
+    on(inp, "keydown", operation(cm, onKeyDown));
+    on(inp, "keypress", operation(cm, onKeyPress));
+    on(inp, "focus", function (e) { return onFocus(cm, e); });
+    on(inp, "blur", function (e) { return onBlur(cm, e); });
+  }
+
+  var initHooks = [];
+  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };
+
+  // Indent the given line. The how parameter can be "smart",
+  // "add"/null, "subtract", or "prev". When aggressive is false
+  // (typically set to true for forced single-line indents), empty
+  // lines are not indented, and places where the mode returns Pass
+  // are left alone.
+  function indentLine(cm, n, how, aggressive) {
+    var doc = cm.doc, state;
+    if (how == null) { how = "add"; }
+    if (how == "smart") {
+      // Fall back to "prev" when the mode doesn't have an indentation
+      // method.
+      if (!doc.mode.indent) { how = "prev"; }
+      else { state = getContextBefore(cm, n).state; }
     }
-    function runInOp(cm, f) {
-      if (cm.curOp) {
-        return f();
-      }
-      startOperation(cm);
-      try {
-        return f();
-      } finally {
-        endOperation(cm);
+
+    var tabSize = cm.options.tabSize;
+    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
+    if (line.stateAfter) { line.stateAfter = null; }
+    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
+    if (!aggressive && !/\S/.test(line.text)) {
+      indentation = 0;
+      how = "not";
+    } else if (how == "smart") {
+      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
+      if (indentation == Pass || indentation > 150) {
+        if (!aggressive) { return }
+        how = "prev";
+      }
+    }
+    if (how == "prev") {
+      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
+      else { indentation = 0; }
+    } else if (how == "add") {
+      indentation = curSpace + cm.options.indentUnit;
+    } else if (how == "subtract") {
+      indentation = curSpace - cm.options.indentUnit;
+    } else if (typeof how == "number") {
+      indentation = curSpace + how;
+    }
+    indentation = Math.max(0, indentation);
+
+    var indentString = "", pos = 0;
+    if (cm.options.indentWithTabs)
+      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
+    if (pos < indentation) { indentString += spaceStr(indentation - pos); }
+
+    if (indentString != curSpaceString) {
+      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
+      line.stateAfter = null;
+      return true
+    } else {
+      // Ensure that, if the cursor was in the whitespace at the start
+      // of the line, it is moved to the end of that space.
+      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
+        var range = doc.sel.ranges[i$1];
+        if (range.head.line == n && range.head.ch < curSpaceString.length) {
+          var pos$1 = Pos(n, curSpaceString.length);
+          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
+          break
+        }
       }
     }
-    function operation(cm, f) {
-      return function() {
-        if (cm.curOp) {
-          return f.apply(cm, arguments);
-        }
-        startOperation(cm);
-        try {
-          return f.apply(cm, arguments);
-        } finally {
-          endOperation(cm);
+  }
+
+  // This will be set to a {lineWise: bool, text: [string]} object, so
+  // that, when pasting, we know what kind of selections the copied
+  // text was made out of.
+  var lastCopied = null;
+
+  function setLastCopied(newLastCopied) {
+    lastCopied = newLastCopied;
+  }
+
+  function applyTextInput(cm, inserted, deleted, sel, origin) {
+    var doc = cm.doc;
+    cm.display.shift = false;
+    if (!sel) { sel = doc.sel; }
+
+    var recent = +new Date - 200;
+    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
+    var textLines = splitLinesAuto(inserted), multiPaste = null;
+    // When pasting N lines into N selections, insert one line per selection
+    if (paste && sel.ranges.length > 1) {
+      if (lastCopied && lastCopied.text.join("\n") == inserted) {
+        if (sel.ranges.length % lastCopied.text.length == 0) {
+          multiPaste = [];
+          for (var i = 0; i < lastCopied.text.length; i++)
+            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
         }
-      };
+      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
+        multiPaste = map(textLines, function (l) { return [l]; });
+      }
     }
-    function methodOp(f) {
-      return function() {
-        if (this.curOp) {
-          return f.apply(this, arguments);
-        }
-        startOperation(this);
-        try {
-          return f.apply(this, arguments);
-        } finally {
-          endOperation(this);
-        }
-      };
+
+    var updateInput = cm.curOp.updateInput;
+    // Normal behavior is to insert the new text into every selection
+    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
+      var range = sel.ranges[i$1];
+      var from = range.from(), to = range.to();
+      if (range.empty()) {
+        if (deleted && deleted > 0) // Handle deletion
+          { from = Pos(from.line, from.ch - deleted); }
+        else if (cm.state.overwrite && !paste) // Handle overwrite
+          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
+        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n"))
+          { from = to = Pos(from.line, 0); }
+      }
+      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
+                         origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
+      makeChange(cm.doc, changeEvent);
+      signalLater(cm, "inputRead", cm, changeEvent);
+    }
+    if (inserted && !paste)
+      { triggerElectric(cm, inserted); }
+
+    ensureCursorVisible(cm);
+    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
+    cm.curOp.typing = true;
+    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
+  }
+
+  function handlePaste(e, cm) {
+    var pasted = e.clipboardData && e.clipboardData.getData("Text");
+    if (pasted) {
+      e.preventDefault();
+      if (!cm.isReadOnly() && !cm.options.disableInput)
+        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
+      return true
     }
-    function docMethodOp(f) {
-      return function() {
-        var cm = this.cm;
-        if (!cm || cm.curOp) {
-          return f.apply(this, arguments);
-        }
-        startOperation(cm);
-        try {
-          return f.apply(this, arguments);
-        } finally {
-          endOperation(cm);
-        }
-      };
+  }
+
+  function triggerElectric(cm, inserted) {
+    // When an 'electric' character is inserted, immediately trigger a reindent
+    if (!cm.options.electricChars || !cm.options.smartIndent) { return }
+    var sel = cm.doc.sel;
+
+    for (var i = sel.ranges.length - 1; i >= 0; i--) {
+      var range = sel.ranges[i];
+      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }
+      var mode = cm.getModeAt(range.head);
+      var indented = false;
+      if (mode.electricChars) {
+        for (var j = 0; j < mode.electricChars.length; j++)
+          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
+            indented = indentLine(cm, range.head.line, "smart");
+            break
+          } }
+      } else if (mode.electricInput) {
+        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
+          { indented = indentLine(cm, range.head.line, "smart"); }
+      }
+      if (indented) { signalLater(cm, "electricInput", cm, range.head.line); }
     }
-    function startWorker(cm, time) {
-      if (cm.doc.highlightFrontier < cm.display.viewTo) {
-        cm.state.highlight.set(time, bind(highlightWorker, cm));
-      }
+  }
+
+  function copyableRanges(cm) {
+    var text = [], ranges = [];
+    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
+      var line = cm.doc.sel.ranges[i].head.line;
+      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
+      ranges.push(lineRange);
+      text.push(cm.getRange(lineRange.anchor, lineRange.head));
     }
-    function highlightWorker(cm) {
-      var doc = cm.doc;
-      if (doc.highlightFrontier >= cm.display.viewTo) {
-        return;
-      }
-      var end = +new Date() + cm.options.workTime;
-      var context = getContextBefore(cm, doc.highlightFrontier);
-      var changedLines = [];
-      doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
-        if (context.line >= cm.display.viewFrom) {
-          var oldStyles = line.styles;
-          var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
-          var highlighted = highlightLine(cm, line, context, true);
-          if (resetState) {
-            context.state = resetState;
-          }
-          line.styles = highlighted.styles;
-          var oldCls = line.styleClasses, newCls = highlighted.classes;
-          if (newCls) {
-            line.styleClasses = newCls;
-          } else if (oldCls) {
-            line.styleClasses = null;
-          }
-          var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
-          for (var i2 = 0; !ischange && i2 < oldStyles.length; ++i2) {
-            ischange = oldStyles[i2] != line.styles[i2];
+    return {text: text, ranges: ranges}
+  }
+
+  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
+    field.setAttribute("autocorrect", autocorrect ? "" : "off");
+    field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
+    field.setAttribute("spellcheck", !!spellcheck);
+  }
+
+  function hiddenTextarea() {
+    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
+    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
+    // The textarea is kept positioned near the cursor to prevent the
+    // fact that it'll be scrolled into view on input from scrolling
+    // our fake cursor out of view. On webkit, when wrap=off, paste is
+    // very slow. So make the area wide instead.
+    if (webkit) { te.style.width = "1000px"; }
+    else { te.setAttribute("wrap", "off"); }
+    // If border: 0; -- iOS fails to open keyboard (issue #1287)
+    if (ios) { te.style.border = "1px solid black"; }
+    disableBrowserMagic(te);
+    return div
+  }
+
+  // The publicly visible API. Note that methodOp(f) means
+  // 'wrap f in an operation, performed on its `this` parameter'.
+
+  // This is not the complete set of editor methods. Most of the
+  // methods defined on the Doc type are also injected into
+  // CodeMirror.prototype, for backwards compatibility and
+  // convenience.
+
+  function addEditorMethods(CodeMirror) {
+    var optionHandlers = CodeMirror.optionHandlers;
+
+    var helpers = CodeMirror.helpers = {};
+
+    CodeMirror.prototype = {
+      constructor: CodeMirror,
+      focus: function(){window.focus(); this.display.input.focus();},
+
+      setOption: function(option, value) {
+        var options = this.options, old = options[option];
+        if (options[option] == value && option != "mode") { return }
+        options[option] = value;
+        if (optionHandlers.hasOwnProperty(option))
+          { operation(this, optionHandlers[option])(this, value, old); }
+        signal(this, "optionChange", this, option);
+      },
+
+      getOption: function(option) {return this.options[option]},
+      getDoc: function() {return this.doc},
+
+      addKeyMap: function(map, bottom) {
+        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
+      },
+      removeKeyMap: function(map) {
+        var maps = this.state.keyMaps;
+        for (var i = 0; i < maps.length; ++i)
+          { if (maps[i] == map || maps[i].name == map) {
+            maps.splice(i, 1);
+            return true
+          } }
+      },
+
+      addOverlay: methodOp(function(spec, options) {
+        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
+        if (mode.startState) { throw new Error("Overlays may not be stateful.") }
+        insertSorted(this.state.overlays,
+                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,
+                      priority: (options && options.priority) || 0},
+                     function (overlay) { return overlay.priority; });
+        this.state.modeGen++;
+        regChange(this);
+      }),
+      removeOverlay: methodOp(function(spec) {
+        var overlays = this.state.overlays;
+        for (var i = 0; i < overlays.length; ++i) {
+          var cur = overlays[i].modeSpec;
+          if (cur == spec || typeof spec == "string" && cur.name == spec) {
+            overlays.splice(i, 1);
+            this.state.modeGen++;
+            regChange(this);
+            return
           }
-          if (ischange) {
-            changedLines.push(context.line);
+        }
+      }),
+
+      indentLine: methodOp(function(n, dir, aggressive) {
+        if (typeof dir != "string" && typeof dir != "number") {
+          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
+          else { dir = dir ? "add" : "subtract"; }
+        }
+        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
+      }),
+      indentSelection: methodOp(function(how) {
+        var ranges = this.doc.sel.ranges, end = -1;
+        for (var i = 0; i < ranges.length; i++) {
+          var range = ranges[i];
+          if (!range.empty()) {
+            var from = range.from(), to = range.to();
+            var start = Math.max(end, from.line);
+            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
+            for (var j = start; j < end; ++j)
+              { indentLine(this, j, how); }
+            var newRanges = this.doc.sel.ranges;
+            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
+              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
+          } else if (range.head.line > end) {
+            indentLine(this, range.head.line, how, true);
+            end = range.head.line;
+            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }
           }
-          line.stateAfter = context.save();
-          context.nextLine();
+        }
+      }),
+
+      // Fetch the parser token for a given character. Useful for hacks
+      // that want to inspect the mode state (say, for completion).
+      getTokenAt: function(pos, precise) {
+        return takeToken(this, pos, precise)
+      },
+
+      getLineTokens: function(line, precise) {
+        return takeToken(this, Pos(line), precise, true)
+      },
+
+      getTokenTypeAt: function(pos) {
+        pos = clipPos(this.doc, pos);
+        var styles = getLineStyles(this, getLine(this.doc, pos.line));
+        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
+        var type;
+        if (ch == 0) { type = styles[2]; }
+        else { for (;;) {
+          var mid = (before + after) >> 1;
+          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
+          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
+          else { type = styles[mid * 2 + 2]; break }
+        } }
+        var cut = type ? type.indexOf("overlay ") : -1;
+        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
+      },
+
+      getModeAt: function(pos) {
+        var mode = this.doc.mode;
+        if (!mode.innerMode) { return mode }
+        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
+      },
+
+      getHelper: function(pos, type) {
+        return this.getHelpers(pos, type)[0]
+      },
+
+      getHelpers: function(pos, type) {
+        var found = [];
+        if (!helpers.hasOwnProperty(type)) { return found }
+        var help = helpers[type], mode = this.getModeAt(pos);
+        if (typeof mode[type] == "string") {
+          if (help[mode[type]]) { found.push(help[mode[type]]); }
+        } else if (mode[type]) {
+          for (var i = 0; i < mode[type].length; i++) {
+            var val = help[mode[type][i]];
+            if (val) { found.push(val); }
+          }
+        } else if (mode.helperType && help[mode.helperType]) {
+          found.push(help[mode.helperType]);
+        } else if (help[mode.name]) {
+          found.push(help[mode.name]);
+        }
+        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
+          var cur = help._global[i$1];
+          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
+            { found.push(cur.val); }
+        }
+        return found
+      },
+
+      getStateAfter: function(line, precise) {
+        var doc = this.doc;
+        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
+        return getContextBefore(this, line + 1, precise).state
+      },
+
+      cursorCoords: function(start, mode) {
+        var pos, range = this.doc.sel.primary();
+        if (start == null) { pos = range.head; }
+        else if (typeof start == "object") { pos = clipPos(this.doc, start); }
+        else { pos = start ? range.from() : range.to(); }
+        return cursorCoords(this, pos, mode || "page")
+      },
+
+      charCoords: function(pos, mode) {
+        return charCoords(this, clipPos(this.doc, pos), mode || "page")
+      },
+
+      coordsChar: function(coords, mode) {
+        coords = fromCoordSystem(this, coords, mode || "page");
+        return coordsChar(this, coords.left, coords.top)
+      },
+
+      lineAtHeight: function(height, mode) {
+        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
+        return lineAtHeight(this.doc, height + this.display.viewOffset)
+      },
+      heightAtLine: function(line, mode, includeWidgets) {
+        var end = false, lineObj;
+        if (typeof line == "number") {
+          var last = this.doc.first + this.doc.size - 1;
+          if (line < this.doc.first) { line = this.doc.first; }
+          else if (line > last) { line = last; end = true; }
+          lineObj = getLine(this.doc, line);
         } else {
-          if (line.text.length <= cm.options.maxHighlightLength) {
-            processLine(cm, line.text, context);
-          }
-          line.stateAfter = context.line % 5 == 0 ? context.save() : null;
-          context.nextLine();
+          lineObj = line;
         }
-        if (+new Date() > end) {
-          startWorker(cm, cm.options.workDelay);
-          return true;
+        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
+          (end ? this.doc.height - heightAtLine(lineObj) : 0)
+      },
+
+      defaultTextHeight: function() { return textHeight(this.display) },
+      defaultCharWidth: function() { return charWidth(this.display) },
+
+      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},
+
+      addWidget: function(pos, node, scroll, vert, horiz) {
+        var display = this.display;
+        pos = cursorCoords(this, clipPos(this.doc, pos));
+        var top = pos.bottom, left = pos.left;
+        node.style.position = "absolute";
+        node.setAttribute("cm-ignore-events", "true");
+        this.display.input.setUneditable(node);
+        display.sizer.appendChild(node);
+        if (vert == "over") {
+          top = pos.top;
+        } else if (vert == "above" || vert == "near") {
+          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
+          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
+          // Default to positioning above (if specified and possible); otherwise default to positioning below
+          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
+            { top = pos.top - node.offsetHeight; }
+          else if (pos.bottom + node.offsetHeight <= vspace)
+            { top = pos.bottom; }
+          if (left + node.offsetWidth > hspace)
+            { left = hspace - node.offsetWidth; }
+        }
+        node.style.top = top + "px";
+        node.style.left = node.style.right = "";
+        if (horiz == "right") {
+          left = display.sizer.clientWidth - node.offsetWidth;
+          node.style.right = "0px";
+        } else {
+          if (horiz == "left") { left = 0; }
+          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
+          node.style.left = left + "px";
         }
-      });
-      doc.highlightFrontier = context.line;
-      doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
-      if (changedLines.length) {
-        runInOp(cm, function() {
-          for (var i2 = 0; i2 < changedLines.length; i2++) {
-            regLineChange(cm, changedLines[i2], "text");
-          }
+        if (scroll)
+          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
+      },
+
+      triggerOnKeyDown: methodOp(onKeyDown),
+      triggerOnKeyPress: methodOp(onKeyPress),
+      triggerOnKeyUp: onKeyUp,
+      triggerOnMouseDown: methodOp(onMouseDown),
+
+      execCommand: function(cmd) {
+        if (commands.hasOwnProperty(cmd))
+          { return commands[cmd].call(null, this) }
+      },
+
+      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),
+
+      findPosH: function(from, amount, unit, visually) {
+        var dir = 1;
+        if (amount < 0) { dir = -1; amount = -amount; }
+        var cur = clipPos(this.doc, from);
+        for (var i = 0; i < amount; ++i) {
+          cur = findPosH(this.doc, cur, dir, unit, visually);
+          if (cur.hitSide) { break }
+        }
+        return cur
+      },
+
+      moveH: methodOp(function(dir, unit) {
+        var this$1$1 = this;
+
+        this.extendSelectionsBy(function (range) {
+          if (this$1$1.display.shift || this$1$1.doc.extend || range.empty())
+            { return findPosH(this$1$1.doc, range.head, dir, unit, this$1$1.options.rtlMoveVisually) }
+          else
+            { return dir < 0 ? range.from() : range.to() }
+        }, sel_move);
+      }),
+
+      deleteH: methodOp(function(dir, unit) {
+        var sel = this.doc.sel, doc = this.doc;
+        if (sel.somethingSelected())
+          { doc.replaceSelection("", null, "+delete"); }
+        else
+          { deleteNearSelection(this, function (range) {
+            var other = findPosH(doc, range.head, dir, unit, false);
+            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}
+          }); }
+      }),
+
+      findPosV: function(from, amount, unit, goalColumn) {
+        var dir = 1, x = goalColumn;
+        if (amount < 0) { dir = -1; amount = -amount; }
+        var cur = clipPos(this.doc, from);
+        for (var i = 0; i < amount; ++i) {
+          var coords = cursorCoords(this, cur, "div");
+          if (x == null) { x = coords.left; }
+          else { coords.left = x; }
+          cur = findPosV(this, coords, dir, unit);
+          if (cur.hitSide) { break }
+        }
+        return cur
+      },
+
+      moveV: methodOp(function(dir, unit) {
+        var this$1$1 = this;
+
+        var doc = this.doc, goals = [];
+        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
+        doc.extendSelectionsBy(function (range) {
+          if (collapse)
+            { return dir < 0 ? range.from() : range.to() }
+          var headPos = cursorCoords(this$1$1, range.head, "div");
+          if (range.goalColumn != null) { headPos.left = range.goalColumn; }
+          goals.push(headPos.left);
+          var pos = findPosV(this$1$1, headPos, dir, unit);
+          if (unit == "page" && range == doc.sel.primary())
+            { addToScrollTop(this$1$1, charCoords(this$1$1, pos, "div").top - headPos.top); }
+          return pos
+        }, sel_move);
+        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
+          { doc.sel.ranges[i].goalColumn = goals[i]; } }
+      }),
+
+      // Find the word at the given position (as returned by coordsChar).
+      findWordAt: function(pos) {
+        var doc = this.doc, line = getLine(doc, pos.line).text;
+        var start = pos.ch, end = pos.ch;
+        if (line) {
+          var helper = this.getHelper(pos, "wordChars");
+          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
+          var startChar = line.charAt(start);
+          var check = isWordChar(startChar, helper)
+            ? function (ch) { return isWordChar(ch, helper); }
+            : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
+            : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
+          while (start > 0 && check(line.charAt(start - 1))) { --start; }
+          while (end < line.length && check(line.charAt(end))) { ++end; }
+        }
+        return new Range(Pos(pos.line, start), Pos(pos.line, end))
+      },
+
+      toggleOverwrite: function(value) {
+        if (value != null && value == this.state.overwrite) { return }
+        if (this.state.overwrite = !this.state.overwrite)
+          { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
+        else
+          { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
+
+        signal(this, "overwriteToggle", this, this.state.overwrite);
+      },
+      hasFocus: function() { return this.display.input.getField() == activeElt() },
+      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },
+
+      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
+      getScrollInfo: function() {
+        var scroller = this.display.scroller;
+        return {left: scroller.scrollLeft, top: scroller.scrollTop,
+                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
+                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
+                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
+      },
+
+      scrollIntoView: methodOp(function(range, margin) {
+        if (range == null) {
+          range = {from: this.doc.sel.primary().head, to: null};
+          if (margin == null) { margin = this.options.cursorScrollMargin; }
+        } else if (typeof range == "number") {
+          range = {from: Pos(range, 0), to: null};
+        } else if (range.from == null) {
+          range = {from: range, to: null};
+        }
+        if (!range.to) { range.to = range.from; }
+        range.margin = margin || 0;
+
+        if (range.from.line != null) {
+          scrollToRange(this, range);
+        } else {
+          scrollToCoordsRange(this, range.from, range.to, range.margin);
+        }
+      }),
+
+      setSize: methodOp(function(width, height) {
+        var this$1$1 = this;
+
+        var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
+        if (width != null) { this.display.wrapper.style.width = interpret(width); }
+        if (height != null) { this.display.wrapper.style.height = interpret(height); }
+        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
+        var lineNo = this.display.viewFrom;
+        this.doc.iter(lineNo, this.display.viewTo, function (line) {
+          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
+            { if (line.widgets[i].noHScroll) { regLineChange(this$1$1, lineNo, "widget"); break } } }
+          ++lineNo;
         });
-      }
-    }
-    var DisplayUpdate = function(cm, viewport, force) {
-      var display = cm.display;
-      this.viewport = viewport;
-      this.visible = visibleLines(display, cm.doc, viewport);
-      this.editorIsHidden = !display.wrapper.offsetWidth;
-      this.wrapperHeight = display.wrapper.clientHeight;
-      this.wrapperWidth = display.wrapper.clientWidth;
-      this.oldDisplayWidth = displayWidth(cm);
-      this.force = force;
-      this.dims = getDimensions(cm);
-      this.events = [];
+        this.curOp.forceUpdate = true;
+        signal(this, "refresh", this);
+      }),
+
+      operation: function(f){return runInOp(this, f)},
+      startOperation: function(){return startOperation(this)},
+      endOperation: function(){return endOperation(this)},
+
+      refresh: methodOp(function() {
+        var oldHeight = this.display.cachedTextHeight;
+        regChange(this);
+        this.curOp.forceUpdate = true;
+        clearCaches(this);
+        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
+        updateGutterSpace(this.display);
+        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping)
+          { estimateLineHeights(this); }
+        signal(this, "refresh", this);
+      }),
+
+      swapDoc: methodOp(function(doc) {
+        var old = this.doc;
+        old.cm = null;
+        // Cancel the current text selection if any (#5821)
+        if (this.state.selectingText) { this.state.selectingText(); }
+        attachDoc(this, doc);
+        clearCaches(this);
+        this.display.input.reset();
+        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
+        this.curOp.forceScroll = true;
+        signalLater(this, "swapDoc", this, old);
+        return old
+      }),
+
+      phrase: function(phraseText) {
+        var phrases = this.options.phrases;
+        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
+      },
+
+      getInputField: function(){return this.display.input.getField()},
+      getWrapperElement: function(){return this.display.wrapper},
+      getScrollerElement: function(){return this.display.scroller},
+      getGutterElement: function(){return this.display.gutters}
     };
-    DisplayUpdate.prototype.signal = function(emitter, type) {
-      if (hasHandler(emitter, type)) {
-        this.events.push(arguments);
-      }
+    eventMixin(CodeMirror);
+
+    CodeMirror.registerHelper = function(type, name, value) {
+      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
+      helpers[type][name] = value;
     };
-    DisplayUpdate.prototype.finish = function() {
-      for (var i2 = 0; i2 < this.events.length; i2++) {
-        signal.apply(null, this.events[i2]);
-      }
+    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
+      CodeMirror.registerHelper(type, name, value);
+      helpers[type]._global.push({pred: predicate, val: value});
     };
-    function maybeClipScrollbars(cm) {
-      var display = cm.display;
-      if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
-        display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
-        display.heightForcer.style.height = scrollGap(cm) + "px";
-        display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
-        display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
-        display.scrollbarsClipped = true;
-      }
-    }
-    function selectionSnapshot(cm) {
-      if (cm.hasFocus()) {
-        return null;
-      }
-      var active = activeElt();
-      if (!active || !contains(cm.display.lineDiv, active)) {
-        return null;
-      }
-      var result = { activeElt: active };
-      if (window.getSelection) {
-        var sel = window.getSelection();
-        if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
-          result.anchorNode = sel.anchorNode;
-          result.anchorOffset = sel.anchorOffset;
-          result.focusNode = sel.focusNode;
-          result.focusOffset = sel.focusOffset;
+  }
+
+  // Used for horizontal relative motion. Dir is -1 or 1 (left or
+  // right), unit can be "codepoint", "char", "column" (like char, but
+  // doesn't cross line boundaries), "word" (across next word), or
+  // "group" (to the start of next group of word or
+  // non-word-non-whitespace chars). The visually param controls
+  // whether, in right-to-left text, direction 1 means to move towards
+  // the next index in the string, or towards the character to the right
+  // of the current position. The resulting position will have a
+  // hitSide=true property if it reached the end of the document.
+  function findPosH(doc, pos, dir, unit, visually) {
+    var oldPos = pos;
+    var origDir = dir;
+    var lineObj = getLine(doc, pos.line);
+    var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
+    function findNextLine() {
+      var l = pos.line + lineDir;
+      if (l < doc.first || l >= doc.first + doc.size) { return false }
+      pos = new Pos(l, pos.ch, pos.sticky);
+      return lineObj = getLine(doc, l)
+    }
+    function moveOnce(boundToLine) {
+      var next;
+      if (unit == "codepoint") {
+        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
+        if (isNaN(ch)) {
+          next = null;
+        } else {
+          var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;
+          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
         }
+      } else if (visually) {
+        next = moveVisually(doc.cm, lineObj, pos, dir);
+      } else {
+        next = moveLogically(lineObj, pos, dir);
       }
-      return result;
-    }
-    function restoreSelection(snapshot) {
-      if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
-        return;
-      }
-      snapshot.activeElt.focus();
-      if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
-        var sel = window.getSelection(), range2 = document.createRange();
-        range2.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
-        range2.collapse(false);
-        sel.removeAllRanges();
-        sel.addRange(range2);
-        sel.extend(snapshot.focusNode, snapshot.focusOffset);
-      }
-    }
-    function updateDisplayIfNeeded(cm, update) {
-      var display = cm.display, doc = cm.doc;
-      if (update.editorIsHidden) {
-        resetView(cm);
-        return false;
-      }
-      if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
-        return false;
-      }
-      if (maybeUpdateLineNumberWidth(cm)) {
-        resetView(cm);
-        update.dims = getDimensions(cm);
-      }
-      var end = doc.first + doc.size;
-      var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
-      var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
-      if (display.viewFrom < from && from - display.viewFrom < 20) {
-        from = Math.max(doc.first, display.viewFrom);
-      }
-      if (display.viewTo > to && display.viewTo - to < 20) {
-        to = Math.min(end, display.viewTo);
-      }
-      if (sawCollapsedSpans) {
-        from = visualLineNo(cm.doc, from);
-        to = visualLineEndNo(cm.doc, to);
-      }
-      var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
-      adjustView(cm, from, to);
-      display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
-      cm.display.mover.style.top = display.viewOffset + "px";
-      var toUpdate = countDirtyView(cm);
-      if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
-        return false;
+      if (next == null) {
+        if (!boundToLine && findNextLine())
+          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }
+        else
+          { return false }
+      } else {
+        pos = next;
       }
-      var selSnapshot = selectionSnapshot(cm);
-      if (toUpdate > 4) {
-        display.lineDiv.style.display = "none";
-      }
-      patchDisplay(cm, display.updateLineNumbers, update.dims);
-      if (toUpdate > 4) {
-        display.lineDiv.style.display = "";
-      }
-      display.renderedView = display.view;
-      restoreSelection(selSnapshot);
-      removeChildren(display.cursorDiv);
-      removeChildren(display.selectionDiv);
-      display.gutters.style.height = display.sizer.style.minHeight = 0;
-      if (different) {
-        display.lastWrapHeight = update.wrapperHeight;
-        display.lastWrapWidth = update.wrapperWidth;
-        startWorker(cm, 400);
-      }
-      display.updateLineNumbers = null;
-      return true;
+      return true
     }
-    function postUpdateDisplay(cm, update) {
-      var viewport = update.viewport;
-      for (var first = true; ; first = false) {
-        if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
-          if (viewport && viewport.top != null) {
-            viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };
-          }
-          update.visible = visibleLines(cm.display, cm.doc, viewport);
-          if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
-            break;
-          }
-        } else if (first) {
-          update.visible = visibleLines(cm.display, cm.doc, viewport);
-        }
-        if (!updateDisplayIfNeeded(cm, update)) {
-          break;
-        }
-        updateHeightsInViewport(cm);
-        var barMeasure = measureForScrollbars(cm);
-        updateSelection(cm);
-        updateScrollbars(cm, barMeasure);
-        setDocumentHeight(cm, barMeasure);
-        update.force = false;
-      }
-      update.signal(cm, "update", cm);
-      if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
-        update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
-        cm.display.reportedViewFrom = cm.display.viewFrom;
-        cm.display.reportedViewTo = cm.display.viewTo;
-      }
-    }
-    function updateDisplaySimple(cm, viewport) {
-      var update = new DisplayUpdate(cm, viewport);
-      if (updateDisplayIfNeeded(cm, update)) {
-        updateHeightsInViewport(cm);
-        postUpdateDisplay(cm, update);
-        var barMeasure = measureForScrollbars(cm);
-        updateSelection(cm);
-        updateScrollbars(cm, barMeasure);
-        setDocumentHeight(cm, barMeasure);
-        update.finish();
-      }
-    }
-    function patchDisplay(cm, updateNumbersFrom, dims) {
-      var display = cm.display, lineNumbers = cm.options.lineNumbers;
-      var container = display.lineDiv, cur = container.firstChild;
-      function rm(node2) {
-        var next2 = node2.nextSibling;
-        if (webkit && mac && cm.display.currentWheelTarget == node2) {
-          node2.style.display = "none";
-        } else {
-          node2.parentNode.removeChild(node2);
-        }
-        return next2;
-      }
-      var view = display.view, lineN = display.viewFrom;
-      for (var i2 = 0; i2 < view.length; i2++) {
-        var lineView = view[i2];
-        if (lineView.hidden)
-          ;
-        else if (!lineView.node || lineView.node.parentNode != container) {
-          var node = buildLineElement(cm, lineView, lineN, dims);
-          container.insertBefore(node, cur);
-        } else {
-          while (cur != lineView.node) {
-            cur = rm(cur);
-          }
-          var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
-          if (lineView.changes) {
-            if (indexOf(lineView.changes, "gutter") > -1) {
-              updateNumber = false;
-            }
-            updateLineForChanges(cm, lineView, lineN, dims);
-          }
-          if (updateNumber) {
-            removeChildren(lineView.lineNumber);
-            lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
-          }
-          cur = lineView.node.nextSibling;
+
+    if (unit == "char" || unit == "codepoint") {
+      moveOnce();
+    } else if (unit == "column") {
+      moveOnce(true);
+    } else if (unit == "word" || unit == "group") {
+      var sawType = null, group = unit == "group";
+      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
+      for (var first = true;; first = false) {
+        if (dir < 0 && !moveOnce(!first)) { break }
+        var cur = lineObj.text.charAt(pos.ch) || "\n";
+        var type = isWordChar(cur, helper) ? "w"
+          : group && cur == "\n" ? "n"
+          : !group || /\s/.test(cur) ? null
+          : "p";
+        if (group && !first && !type) { type = "s"; }
+        if (sawType && sawType != type) {
+          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
+          break
         }
-        lineN += lineView.size;
-      }
-      while (cur) {
-        cur = rm(cur);
+
+        if (type) { sawType = type; }
+        if (dir > 0 && !moveOnce(!first)) { break }
       }
     }
-    function updateGutterSpace(display) {
-      var width = display.gutters.offsetWidth;
-      display.sizer.style.marginLeft = width + "px";
-      signalLater(display, "gutterChanged", display);
+    var result = skipAtomic(doc, pos, oldPos, origDir, true);
+    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
+    return result
+  }
+
+  // For relative vertical movement. Dir may be -1 or 1. Unit can be
+  // "page" or "line". The resulting position will have a hitSide=true
+  // property if it reached the end of the document.
+  function findPosV(cm, pos, dir, unit) {
+    var doc = cm.doc, x = pos.left, y;
+    if (unit == "page") {
+      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
+      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
+      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
+
+    } else if (unit == "line") {
+      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
     }
-    function setDocumentHeight(cm, measure) {
-      cm.display.sizer.style.minHeight = measure.docHeight + "px";
-      cm.display.heightForcer.style.top = measure.docHeight + "px";
-      cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
+    var target;
+    for (;;) {
+      target = coordsChar(cm, x, y);
+      if (!target.outside) { break }
+      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
+      y += dir * 5;
     }
-    function alignHorizontally(cm) {
-      var display = cm.display, view = display.view;
-      if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
-        return;
-      }
-      var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
-      var gutterW = display.gutters.offsetWidth, left = comp + "px";
-      for (var i2 = 0; i2 < view.length; i2++) {
-        if (!view[i2].hidden) {
-          if (cm.options.fixedGutter) {
-            if (view[i2].gutter) {
-              view[i2].gutter.style.left = left;
-            }
-            if (view[i2].gutterBackground) {
-              view[i2].gutterBackground.style.left = left;
-            }
-          }
-          var align = view[i2].alignable;
-          if (align) {
-            for (var j = 0; j < align.length; j++) {
-              align[j].style.left = left;
-            }
-          }
-        }
-      }
-      if (cm.options.fixedGutter) {
-        display.gutters.style.left = comp + gutterW + "px";
+    return target
+  }
+
+  // CONTENTEDITABLE INPUT STYLE
+
+  var ContentEditableInput = function(cm) {
+    this.cm = cm;
+    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
+    this.polling = new Delayed();
+    this.composing = null;
+    this.gracePeriod = false;
+    this.readDOMTimeout = null;
+  };
+
+  ContentEditableInput.prototype.init = function (display) {
+      var this$1$1 = this;
+
+    var input = this, cm = input.cm;
+    var div = input.div = display.lineDiv;
+    div.contentEditable = true;
+    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
+
+    function belongsToInput(e) {
+      for (var t = e.target; t; t = t.parentNode) {
+        if (t == div) { return true }
+        if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) { break }
       }
+      return false
     }
-    function maybeUpdateLineNumberWidth(cm) {
-      if (!cm.options.lineNumbers) {
-        return false;
-      }
-      var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
-      if (last.length != display.lineNumChars) {
-        var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
-        var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
-        display.lineGutter.style.width = "";
-        display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
-        display.lineNumWidth = display.lineNumInnerWidth + padding;
-        display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
-        display.lineGutter.style.width = display.lineNumWidth + "px";
-        updateGutterSpace(cm.display);
-        return true;
+
+    on(div, "paste", function (e) {
+      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
+      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
+      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1$1.updateFromDOM(); }), 20); }
+    });
+
+    on(div, "compositionstart", function (e) {
+      this$1$1.composing = {data: e.data, done: false};
+    });
+    on(div, "compositionupdate", function (e) {
+      if (!this$1$1.composing) { this$1$1.composing = {data: e.data, done: false}; }
+    });
+    on(div, "compositionend", function (e) {
+      if (this$1$1.composing) {
+        if (e.data != this$1$1.composing.data) { this$1$1.readFromDOMSoon(); }
+        this$1$1.composing.done = true;
       }
-      return false;
-    }
-    function getGutters(gutters, lineNumbers) {
-      var result = [], sawLineNumbers = false;
-      for (var i2 = 0; i2 < gutters.length; i2++) {
-        var name = gutters[i2], style = null;
-        if (typeof name != "string") {
-          style = name.style;
-          name = name.className;
-        }
-        if (name == "CodeMirror-linenumbers") {
-          if (!lineNumbers) {
-            continue;
-          } else {
-            sawLineNumbers = true;
-          }
-        }
-        result.push({ className: name, style });
-      }
-      if (lineNumbers && !sawLineNumbers) {
-        result.push({ className: "CodeMirror-linenumbers", style: null });
-      }
-      return result;
-    }
-    function renderGutters(display) {
-      var gutters = display.gutters, specs = display.gutterSpecs;
-      removeChildren(gutters);
-      display.lineGutter = null;
-      for (var i2 = 0; i2 < specs.length; ++i2) {
-        var ref2 = specs[i2];
-        var className = ref2.className;
-        var style = ref2.style;
-        var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
-        if (style) {
-          gElt.style.cssText = style;
-        }
-        if (className == "CodeMirror-linenumbers") {
-          display.lineGutter = gElt;
-          gElt.style.width = (display.lineNumWidth || 1) + "px";
+    });
+
+    on(div, "touchstart", function () { return input.forceCompositionEnd(); });
+
+    on(div, "input", function () {
+      if (!this$1$1.composing) { this$1$1.readFromDOMSoon(); }
+    });
+
+    function onCopyCut(e) {
+      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }
+      if (cm.somethingSelected()) {
+        setLastCopied({lineWise: false, text: cm.getSelections()});
+        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
+      } else if (!cm.options.lineWiseCopyCut) {
+        return
+      } else {
+        var ranges = copyableRanges(cm);
+        setLastCopied({lineWise: true, text: ranges.text});
+        if (e.type == "cut") {
+          cm.operation(function () {
+            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
+            cm.replaceSelection("", null, "cut");
+          });
         }
       }
-      gutters.style.display = specs.length ? "" : "none";
-      updateGutterSpace(display);
+      if (e.clipboardData) {
+        e.clipboardData.clearData();
+        var content = lastCopied.text.join("\n");
+        // iOS exposes the clipboard API, but seems to discard content inserted into it
+        e.clipboardData.setData("Text", content);
+        if (e.clipboardData.getData("Text") == content) {
+          e.preventDefault();
+          return
+        }
+      }
+      // Old-fashioned briefly-focus-a-textarea hack
+      var kludge = hiddenTextarea(), te = kludge.firstChild;
+      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
+      te.value = lastCopied.text.join("\n");
+      var hadFocus = activeElt();
+      selectInput(te);
+      setTimeout(function () {
+        cm.display.lineSpace.removeChild(kludge);
+        hadFocus.focus();
+        if (hadFocus == div) { input.showPrimarySelection(); }
+      }, 50);
     }
-    function updateGutters(cm) {
-      renderGutters(cm.display);
-      regChange(cm);
-      alignHorizontally(cm);
-    }
-    function Display(place, doc, input2, options) {
-      var d = this;
-      this.input = input2;
-      d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
-      d.scrollbarFiller.setAttribute("cm-not-content", "true");
-      d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
-      d.gutterFiller.setAttribute("cm-not-content", "true");
-      d.lineDiv = eltP("div", null, "CodeMirror-code");
-      d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
-      d.cursorDiv = elt("div", null, "CodeMirror-cursors");
-      d.measure = elt("div", null, "CodeMirror-measure");
-      d.lineMeasure = elt("div", null, "CodeMirror-measure");
-      d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
-      var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
-      d.mover = elt("div", [lines], null, "position: relative");
-      d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
-      d.sizerWidth = null;
-      d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
-      d.gutters = elt("div", null, "CodeMirror-gutters");
-      d.lineGutter = null;
-      d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
-      d.scroller.setAttribute("tabIndex", "-1");
-      d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
-      d.wrapper.setAttribute("translate", "no");
-      if (ie && ie_version < 8) {
-        d.gutters.style.zIndex = -1;
-        d.scroller.style.paddingRight = 0;
-      }
-      if (!webkit && !(gecko && mobile)) {
-        d.scroller.draggable = true;
-      }
-      if (place) {
-        if (place.appendChild) {
-          place.appendChild(d.wrapper);
-        } else {
-          place(d.wrapper);
-        }
-      }
-      d.viewFrom = d.viewTo = doc.first;
-      d.reportedViewFrom = d.reportedViewTo = doc.first;
-      d.view = [];
-      d.renderedView = null;
-      d.externalMeasured = null;
-      d.viewOffset = 0;
-      d.lastWrapHeight = d.lastWrapWidth = 0;
-      d.updateLineNumbers = null;
-      d.nativeBarWidth = d.barHeight = d.barWidth = 0;
-      d.scrollbarsClipped = false;
-      d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
-      d.alignWidgets = false;
-      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
-      d.maxLine = null;
-      d.maxLineLength = 0;
-      d.maxLineChanged = false;
-      d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
-      d.shift = false;
-      d.selForContextMenu = null;
-      d.activeTouch = null;
-      d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
-      renderGutters(d);
-      input2.init(d);
-    }
-    var wheelSamples = 0, wheelPixelsPerUnit = null;
-    if (ie) {
-      wheelPixelsPerUnit = -0.53;
-    } else if (gecko) {
-      wheelPixelsPerUnit = 15;
-    } else if (chrome) {
-      wheelPixelsPerUnit = -0.7;
-    } else if (safari) {
-      wheelPixelsPerUnit = -1 / 3;
-    }
-    function wheelEventDelta(e) {
-      var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
-      if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
-        dx = e.detail;
-      }
-      if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
-        dy = e.detail;
-      } else if (dy == null) {
-        dy = e.wheelDelta;
-      }
-      return { x: dx, y: dy };
-    }
-    function wheelEventPixels(e) {
-      var delta = wheelEventDelta(e);
-      delta.x *= wheelPixelsPerUnit;
-      delta.y *= wheelPixelsPerUnit;
-      return delta;
-    }
-    function onScrollWheel(cm, e) {
-      var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
-      var pixelsPerUnit = wheelPixelsPerUnit;
-      if (event.deltaMode === 0) {
-        dx = e.deltaX;
-        dy = e.deltaY;
-        pixelsPerUnit = 1;
-      }
-      var display = cm.display, scroll = display.scroller;
-      var canScrollX = scroll.scrollWidth > scroll.clientWidth;
-      var canScrollY = scroll.scrollHeight > scroll.clientHeight;
-      if (!(dx && canScrollX || dy && canScrollY)) {
-        return;
-      }
-      if (dy && mac && webkit) {
-        outer:
-          for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
-            for (var i2 = 0; i2 < view.length; i2++) {
-              if (view[i2].node == cur) {
-                cm.display.currentWheelTarget = cur;
-                break outer;
-              }
-            }
-          }
-      }
-      if (dx && !gecko && !presto && pixelsPerUnit != null) {
-        if (dy && canScrollY) {
-          updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
-        }
-        setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
-        if (!dy || dy && canScrollY) {
-          e_preventDefault(e);
-        }
-        display.wheelStartX = null;
-        return;
-      }
-      if (dy && pixelsPerUnit != null) {
-        var pixels = dy * pixelsPerUnit;
-        var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
-        if (pixels < 0) {
-          top = Math.max(0, top + pixels - 50);
-        } else {
-          bot = Math.min(cm.doc.height, bot + pixels + 50);
-        }
-        updateDisplaySimple(cm, { top, bottom: bot });
-      }
-      if (wheelSamples < 20 && e.deltaMode !== 0) {
-        if (display.wheelStartX == null) {
-          display.wheelStartX = scroll.scrollLeft;
-          display.wheelStartY = scroll.scrollTop;
-          display.wheelDX = dx;
-          display.wheelDY = dy;
-          setTimeout(function() {
-            if (display.wheelStartX == null) {
-              return;
-            }
-            var movedX = scroll.scrollLeft - display.wheelStartX;
-            var movedY = scroll.scrollTop - display.wheelStartY;
-            var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
-            display.wheelStartX = display.wheelStartY = null;
-            if (!sample) {
-              return;
-            }
-            wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
-            ++wheelSamples;
-          }, 200);
-        } else {
-          display.wheelDX += dx;
-          display.wheelDY += dy;
-        }
-      }
+    on(div, "copy", onCopyCut);
+    on(div, "cut", onCopyCut);
+  };
+
+  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {
+    // Label for screenreaders, accessibility
+    if(label) {
+      this.div.setAttribute('aria-label', label);
+    } else {
+      this.div.removeAttribute('aria-label');
     }
-    var Selection = function(ranges, primIndex) {
-      this.ranges = ranges;
-      this.primIndex = primIndex;
-    };
-    Selection.prototype.primary = function() {
-      return this.ranges[this.primIndex];
-    };
-    Selection.prototype.equals = function(other) {
-      if (other == this) {
-        return true;
-      }
-      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
-        return false;
-      }
-      for (var i2 = 0; i2 < this.ranges.length; i2++) {
-        var here = this.ranges[i2], there = other.ranges[i2];
-        if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
-          return false;
-        }
-      }
-      return true;
-    };
-    Selection.prototype.deepCopy = function() {
-      var out = [];
-      for (var i2 = 0; i2 < this.ranges.length; i2++) {
-        out[i2] = new Range(copyPos(this.ranges[i2].anchor), copyPos(this.ranges[i2].head));
-      }
-      return new Selection(out, this.primIndex);
-    };
-    Selection.prototype.somethingSelected = function() {
-      for (var i2 = 0; i2 < this.ranges.length; i2++) {
-        if (!this.ranges[i2].empty()) {
-          return true;
-        }
-      }
-      return false;
-    };
-    Selection.prototype.contains = function(pos, end) {
-      if (!end) {
-        end = pos;
-      }
-      for (var i2 = 0; i2 < this.ranges.length; i2++) {
-        var range2 = this.ranges[i2];
-        if (cmp(end, range2.from()) >= 0 && cmp(pos, range2.to()) <= 0) {
-          return i2;
-        }
-      }
-      return -1;
-    };
-    var Range = function(anchor, head) {
-      this.anchor = anchor;
-      this.head = head;
-    };
-    Range.prototype.from = function() {
-      return minPos(this.anchor, this.head);
-    };
-    Range.prototype.to = function() {
-      return maxPos(this.anchor, this.head);
-    };
-    Range.prototype.empty = function() {
-      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
-    };
-    function normalizeSelection(cm, ranges, primIndex) {
-      var mayTouch = cm && cm.options.selectionsMayTouch;
-      var prim = ranges[primIndex];
-      ranges.sort(function(a, b) {
-        return cmp(a.from(), b.from());
-      });
-      primIndex = indexOf(ranges, prim);
-      for (var i2 = 1; i2 < ranges.length; i2++) {
-        var cur = ranges[i2], prev = ranges[i2 - 1];
-        var diff = cmp(prev.to(), cur.from());
-        if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
-          var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
-          var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
-          if (i2 <= primIndex) {
-            --primIndex;
-          }
-          ranges.splice(--i2, 2, new Range(inv ? to : from, inv ? from : to));
+  };
+
+  ContentEditableInput.prototype.prepareSelection = function () {
+    var result = prepareSelection(this.cm, false);
+    result.focus = activeElt() == this.div;
+    return result
+  };
+
+  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
+    if (!info || !this.cm.display.view.length) { return }
+    if (info.focus || takeFocus) { this.showPrimarySelection(); }
+    this.showMultipleSelections(info);
+  };
+
+  ContentEditableInput.prototype.getSelection = function () {
+    return this.cm.display.wrapper.ownerDocument.getSelection()
+  };
+
+  ContentEditableInput.prototype.showPrimarySelection = function () {
+    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
+    var from = prim.from(), to = prim.to();
+
+    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
+      sel.removeAllRanges();
+      return
+    }
+
+    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
+    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
+    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
+        cmp(minPos(curAnchor, curFocus), from) == 0 &&
+        cmp(maxPos(curAnchor, curFocus), to) == 0)
+      { return }
+
+    var view = cm.display.view;
+    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
+        {node: view[0].measure.map[2], offset: 0};
+    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
+    if (!end) {
+      var measure = view[view.length - 1].measure;
+      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
+      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
+    }
+
+    if (!start || !end) {
+      sel.removeAllRanges();
+      return
+    }
+
+    var old = sel.rangeCount && sel.getRangeAt(0), rng;
+    try { rng = range(start.node, start.offset, end.offset, end.node); }
+    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
+    if (rng) {
+      if (!gecko && cm.state.focused) {
+        sel.collapse(start.node, start.offset);
+        if (!rng.collapsed) {
+          sel.removeAllRanges();
+          sel.addRange(rng);
         }
+      } else {
+        sel.removeAllRanges();
+        sel.addRange(rng);
       }
-      return new Selection(ranges, primIndex);
+      if (old && sel.anchorNode == null) { sel.addRange(old); }
+      else if (gecko) { this.startGracePeriod(); }
     }
-    function simpleSelection(anchor, head) {
-      return new Selection([new Range(anchor, head || anchor)], 0);
+    this.rememberSelection();
+  };
+
+  ContentEditableInput.prototype.startGracePeriod = function () {
+      var this$1$1 = this;
+
+    clearTimeout(this.gracePeriod);
+    this.gracePeriod = setTimeout(function () {
+      this$1$1.gracePeriod = false;
+      if (this$1$1.selectionChanged())
+        { this$1$1.cm.operation(function () { return this$1$1.cm.curOp.selectionChanged = true; }); }
+    }, 20);
+  };
+
+  ContentEditableInput.prototype.showMultipleSelections = function (info) {
+    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
+    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
+  };
+
+  ContentEditableInput.prototype.rememberSelection = function () {
+    var sel = this.getSelection();
+    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
+    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
+  };
+
+  ContentEditableInput.prototype.selectionInEditor = function () {
+    var sel = this.getSelection();
+    if (!sel.rangeCount) { return false }
+    var node = sel.getRangeAt(0).commonAncestorContainer;
+    return contains(this.div, node)
+  };
+
+  ContentEditableInput.prototype.focus = function () {
+    if (this.cm.options.readOnly != "nocursor") {
+      if (!this.selectionInEditor() || activeElt() != this.div)
+        { this.showSelection(this.prepareSelection(), true); }
+      this.div.focus();
     }
-    function changeEnd(change) {
-      if (!change.text) {
-        return change.to;
+  };
+  ContentEditableInput.prototype.blur = function () { this.div.blur(); };
+  ContentEditableInput.prototype.getField = function () { return this.div };
+
+  ContentEditableInput.prototype.supportsTouch = function () { return true };
+
+  ContentEditableInput.prototype.receivedFocus = function () {
+      var this$1$1 = this;
+
+    var input = this;
+    if (this.selectionInEditor())
+      { setTimeout(function () { return this$1$1.pollSelection(); }, 20); }
+    else
+      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }
+
+    function poll() {
+      if (input.cm.state.focused) {
+        input.pollSelection();
+        input.polling.set(input.cm.options.pollInterval, poll);
       }
-      return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
     }
-    function adjustForChange(pos, change) {
-      if (cmp(pos, change.from) < 0) {
-        return pos;
-      }
-      if (cmp(pos, change.to) <= 0) {
-        return changeEnd(change);
-      }
-      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
-      if (pos.line == change.to.line) {
-        ch += changeEnd(change).ch - change.to.ch;
-      }
-      return Pos(line, ch);
+    this.polling.set(this.cm.options.pollInterval, poll);
+  };
+
+  ContentEditableInput.prototype.selectionChanged = function () {
+    var sel = this.getSelection();
+    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
+      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
+  };
+
+  ContentEditableInput.prototype.pollSelection = function () {
+    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
+    var sel = this.getSelection(), cm = this.cm;
+    // On Android Chrome (version 56, at least), backspacing into an
+    // uneditable block element will put the cursor in that element,
+    // and then, because it's not editable, hide the virtual keyboard.
+    // Because Android doesn't allow us to actually detect backspace
+    // presses in a sane way, this code checks for when that happens
+    // and simulates a backspace press in this case.
+    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
+      this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
+      this.blur();
+      this.focus();
+      return
+    }
+    if (this.composing) { return }
+    this.rememberSelection();
+    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
+    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
+    if (anchor && head) { runInOp(cm, function () {
+      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
+      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
+    }); }
+  };
+
+  ContentEditableInput.prototype.pollContent = function () {
+    if (this.readDOMTimeout != null) {
+      clearTimeout(this.readDOMTimeout);
+      this.readDOMTimeout = null;
     }
-    function computeSelAfterChange(doc, change) {
-      var out = [];
-      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
-        var range2 = doc.sel.ranges[i2];
-        out.push(new Range(adjustForChange(range2.anchor, change), adjustForChange(range2.head, change)));
-      }
-      return normalizeSelection(doc.cm, out, doc.sel.primIndex);
+
+    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
+    var from = sel.from(), to = sel.to();
+    if (from.ch == 0 && from.line > cm.firstLine())
+      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
+    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
+      { to = Pos(to.line + 1, 0); }
+    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }
+
+    var fromIndex, fromLine, fromNode;
+    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
+      fromLine = lineNo(display.view[0].line);
+      fromNode = display.view[0].node;
+    } else {
+      fromLine = lineNo(display.view[fromIndex].line);
+      fromNode = display.view[fromIndex - 1].node.nextSibling;
+    }
+    var toIndex = findViewIndex(cm, to.line);
+    var toLine, toNode;
+    if (toIndex == display.view.length - 1) {
+      toLine = display.viewTo - 1;
+      toNode = display.lineDiv.lastChild;
+    } else {
+      toLine = lineNo(display.view[toIndex + 1].line) - 1;
+      toNode = display.view[toIndex + 1].node.previousSibling;
     }
-    function offsetPos(pos, old, nw) {
-      if (pos.line == old.line) {
-        return Pos(nw.line, pos.ch - old.ch + nw.ch);
-      } else {
-        return Pos(nw.line + (pos.line - old.line), pos.ch);
-      }
+
+    if (!fromNode) { return false }
+    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
+    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
+    while (newText.length > 1 && oldText.length > 1) {
+      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
+      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
+      else { break }
     }
-    function computeReplacedSel(doc, changes, hint) {
-      var out = [];
-      var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
-      for (var i2 = 0; i2 < changes.length; i2++) {
-        var change = changes[i2];
-        var from = offsetPos(change.from, oldPrev, newPrev);
-        var to = offsetPos(changeEnd(change), oldPrev, newPrev);
-        oldPrev = change.to;
-        newPrev = to;
-        if (hint == "around") {
-          var range2 = doc.sel.ranges[i2], inv = cmp(range2.head, range2.anchor) < 0;
-          out[i2] = new Range(inv ? to : from, inv ? from : to);
-        } else {
-          out[i2] = new Range(from, from);
-        }
+
+    var cutFront = 0, cutEnd = 0;
+    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
+    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
+      { ++cutFront; }
+    var newBot = lst(newText), oldBot = lst(oldText);
+    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
+                             oldBot.length - (oldText.length == 1 ? cutFront : 0));
+    while (cutEnd < maxCutEnd &&
+           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
+      { ++cutEnd; }
+    // Try to move start of change to start of selection if ambiguous
+    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
+      while (cutFront && cutFront > from.ch &&
+             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
+        cutFront--;
+        cutEnd++;
       }
-      return new Selection(out, doc.sel.primIndex);
     }
-    function loadMode(cm) {
-      cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
-      resetModeState(cm);
+
+    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
+    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
+
+    var chFrom = Pos(fromLine, cutFront);
+    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
+    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
+      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
+      return true
     }
-    function resetModeState(cm) {
-      cm.doc.iter(function(line) {
-        if (line.stateAfter) {
-          line.stateAfter = null;
-        }
-        if (line.styles) {
-          line.styles = null;
-        }
-      });
-      cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
-      startWorker(cm, 100);
-      cm.state.modeGen++;
-      if (cm.curOp) {
-        regChange(cm);
+  };
+
+  ContentEditableInput.prototype.ensurePolled = function () {
+    this.forceCompositionEnd();
+  };
+  ContentEditableInput.prototype.reset = function () {
+    this.forceCompositionEnd();
+  };
+  ContentEditableInput.prototype.forceCompositionEnd = function () {
+    if (!this.composing) { return }
+    clearTimeout(this.readDOMTimeout);
+    this.composing = null;
+    this.updateFromDOM();
+    this.div.blur();
+    this.div.focus();
+  };
+  ContentEditableInput.prototype.readFromDOMSoon = function () {
+      var this$1$1 = this;
+
+    if (this.readDOMTimeout != null) { return }
+    this.readDOMTimeout = setTimeout(function () {
+      this$1$1.readDOMTimeout = null;
+      if (this$1$1.composing) {
+        if (this$1$1.composing.done) { this$1$1.composing = null; }
+        else { return }
+      }
+      this$1$1.updateFromDOM();
+    }, 80);
+  };
+
+  ContentEditableInput.prototype.updateFromDOM = function () {
+      var this$1$1 = this;
+
+    if (this.cm.isReadOnly() || !this.pollContent())
+      { runInOp(this.cm, function () { return regChange(this$1$1.cm); }); }
+  };
+
+  ContentEditableInput.prototype.setUneditable = function (node) {
+    node.contentEditable = "false";
+  };
+
+  ContentEditableInput.prototype.onKeyPress = function (e) {
+    if (e.charCode == 0 || this.composing) { return }
+    e.preventDefault();
+    if (!this.cm.isReadOnly())
+      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
+  };
+
+  ContentEditableInput.prototype.readOnlyChanged = function (val) {
+    this.div.contentEditable = String(val != "nocursor");
+  };
+
+  ContentEditableInput.prototype.onContextMenu = function () {};
+  ContentEditableInput.prototype.resetPosition = function () {};
+
+  ContentEditableInput.prototype.needsContentAttribute = true;
+
+  function posToDOM(cm, pos) {
+    var view = findViewForLine(cm, pos.line);
+    if (!view || view.hidden) { return null }
+    var line = getLine(cm.doc, pos.line);
+    var info = mapFromLineView(view, line, pos.line);
+
+    var order = getOrder(line, cm.doc.direction), side = "left";
+    if (order) {
+      var partPos = getBidiPartAt(order, pos.ch);
+      side = partPos % 2 ? "right" : "left";
+    }
+    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
+    result.offset = result.collapse == "right" ? result.end : result.start;
+    return result
+  }
+
+  function isInGutter(node) {
+    for (var scan = node; scan; scan = scan.parentNode)
+      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
+    return false
+  }
+
+  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }
+
+  function domTextBetween(cm, from, to, fromLine, toLine) {
+    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
+    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
+    function close() {
+      if (closing) {
+        text += lineSep;
+        if (extraLinebreak) { text += lineSep; }
+        closing = extraLinebreak = false;
+      }
+    }
+    function addText(str) {
+      if (str) {
+        close();
+        text += str;
+      }
+    }
+    function walk(node) {
+      if (node.nodeType == 1) {
+        var cmText = node.getAttribute("cm-text");
+        if (cmText) {
+          addText(cmText);
+          return
+        }
+        var markerID = node.getAttribute("cm-marker"), range;
+        if (markerID) {
+          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
+          if (found.length && (range = found[0].find(0)))
+            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }
+          return
+        }
+        if (node.getAttribute("contenteditable") == "false") { return }
+        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
+        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }
+
+        if (isBlock) { close(); }
+        for (var i = 0; i < node.childNodes.length; i++)
+          { walk(node.childNodes[i]); }
+
+        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
+        if (isBlock) { closing = true; }
+      } else if (node.nodeType == 3) {
+        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
       }
     }
-    function isWholeLineUpdate(doc, change) {
-      return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
+    for (;;) {
+      walk(from);
+      if (from == to) { break }
+      from = from.nextSibling;
+      extraLinebreak = false;
     }
-    function updateDoc(doc, change, markedSpans, estimateHeight2) {
-      function spansFor(n) {
-        return markedSpans ? markedSpans[n] : null;
-      }
-      function update(line, text2, spans) {
-        updateLine(line, text2, spans, estimateHeight2);
-        signalLater(line, "change", line, change);
+    return text
+  }
+
+  function domToPos(cm, node, offset) {
+    var lineNode;
+    if (node == cm.display.lineDiv) {
+      lineNode = cm.display.lineDiv.childNodes[offset];
+      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
+      node = null; offset = 0;
+    } else {
+      for (lineNode = node;; lineNode = lineNode.parentNode) {
+        if (!lineNode || lineNode == cm.display.lineDiv) { return null }
+        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
       }
-      function linesFor(start, end) {
-        var result = [];
-        for (var i2 = start; i2 < end; ++i2) {
-          result.push(new Line(text[i2], spansFor(i2), estimateHeight2));
-        }
-        return result;
-      }
-      var from = change.from, to = change.to, text = change.text;
-      var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
-      var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
-      if (change.full) {
-        doc.insert(0, linesFor(0, text.length));
-        doc.remove(text.length, doc.size - text.length);
-      } else if (isWholeLineUpdate(doc, change)) {
-        var added = linesFor(0, text.length - 1);
-        update(lastLine, lastLine.text, lastSpans);
-        if (nlines) {
-          doc.remove(from.line, nlines);
-        }
-        if (added.length) {
-          doc.insert(from.line, added);
-        }
-      } else if (firstLine == lastLine) {
-        if (text.length == 1) {
-          update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
-        } else {
-          var added$1 = linesFor(1, text.length - 1);
-          added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));
-          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
-          doc.insert(from.line + 1, added$1);
-        }
-      } else if (text.length == 1) {
-        update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
-        doc.remove(from.line + 1, nlines);
-      } else {
-        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
-        update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
-        var added$2 = linesFor(1, text.length - 1);
-        if (nlines > 1) {
-          doc.remove(from.line + 1, nlines - 1);
-        }
-        doc.insert(from.line + 1, added$2);
+    }
+    for (var i = 0; i < cm.display.view.length; i++) {
+      var lineView = cm.display.view[i];
+      if (lineView.node == lineNode)
+        { return locateNodeInLineView(lineView, node, offset) }
+    }
+  }
+
+  function locateNodeInLineView(lineView, node, offset) {
+    var wrapper = lineView.text.firstChild, bad = false;
+    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
+    if (node == wrapper) {
+      bad = true;
+      node = wrapper.childNodes[offset];
+      offset = 0;
+      if (!node) {
+        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
+        return badPos(Pos(lineNo(line), line.text.length), bad)
       }
-      signalLater(doc, "change", doc, change);
     }
-    function linkedDocs(doc, f, sharedHistOnly) {
-      function propagate(doc2, skip, sharedHist) {
-        if (doc2.linked) {
-          for (var i2 = 0; i2 < doc2.linked.length; ++i2) {
-            var rel = doc2.linked[i2];
-            if (rel.doc == skip) {
-              continue;
-            }
-            var shared = sharedHist && rel.sharedHist;
-            if (sharedHistOnly && !shared) {
-              continue;
-            }
-            f(rel.doc, shared);
-            propagate(rel.doc, doc2, shared);
+
+    var textNode = node.nodeType == 3 ? node : null, topNode = node;
+    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
+      textNode = node.firstChild;
+      if (offset) { offset = textNode.nodeValue.length; }
+    }
+    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
+    var measure = lineView.measure, maps = measure.maps;
+
+    function find(textNode, topNode, offset) {
+      for (var i = -1; i < (maps ? maps.length : 0); i++) {
+        var map = i < 0 ? measure.map : maps[i];
+        for (var j = 0; j < map.length; j += 3) {
+          var curNode = map[j + 2];
+          if (curNode == textNode || curNode == topNode) {
+            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
+            var ch = map[j] + offset;
+            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }
+            return Pos(line, ch)
           }
         }
       }
-      propagate(doc, null, true);
-    }
-    function attachDoc(cm, doc) {
-      if (doc.cm) {
-        throw new Error("This document is already in use.");
-      }
-      cm.doc = doc;
-      doc.cm = cm;
-      estimateLineHeights(cm);
-      loadMode(cm);
-      setDirectionClass(cm);
-      cm.options.direction = doc.direction;
-      if (!cm.options.lineWrapping) {
-        findMaxLine(cm);
-      }
-      cm.options.mode = doc.modeOption;
-      regChange(cm);
     }
-    function setDirectionClass(cm) {
-      (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
+    var found = find(textNode, topNode, offset);
+    if (found) { return badPos(found, bad) }
+
+    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
+    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
+      found = find(after, after.firstChild, 0);
+      if (found)
+        { return badPos(Pos(found.line, found.ch - dist), bad) }
+      else
+        { dist += after.textContent.length; }
     }
-    function directionChanged(cm) {
-      runInOp(cm, function() {
-        setDirectionClass(cm);
-        regChange(cm);
-      });
+    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
+      found = find(before, before.firstChild, -1);
+      if (found)
+        { return badPos(Pos(found.line, found.ch + dist$1), bad) }
+      else
+        { dist$1 += before.textContent.length; }
     }
-    function History(prev) {
-      this.done = [];
-      this.undone = [];
-      this.undoDepth = prev ? prev.undoDepth : Infinity;
-      this.lastModTime = this.lastSelTime = 0;
-      this.lastOp = this.lastSelOp = null;
-      this.lastOrigin = this.lastSelOrigin = null;
-      this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
-    }
-    function historyChangeFromChange(doc, change) {
-      var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to) };
-      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
-      linkedDocs(doc, function(doc2) {
-        return attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);
-      }, true);
-      return histChange;
-    }
-    function clearSelectionEvents(array) {
-      while (array.length) {
-        var last = lst(array);
-        if (last.ranges) {
-          array.pop();
+  }
+
+  // TEXTAREA INPUT STYLE
+
+  var TextareaInput = function(cm) {
+    this.cm = cm;
+    // See input.poll and input.reset
+    this.prevInput = "";
+
+    // Flag that indicates whether we expect input to appear real soon
+    // now (after some event like 'keypress' or 'input') and are
+    // polling intensively.
+    this.pollingFast = false;
+    // Self-resetting timeout for the poller
+    this.polling = new Delayed();
+    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
+    this.hasSelection = false;
+    this.composing = null;
+  };
+
+  TextareaInput.prototype.init = function (display) {
+      var this$1$1 = this;
+
+    var input = this, cm = this.cm;
+    this.createField(display);
+    var te = this.textarea;
+
+    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
+
+    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
+    if (ios) { te.style.width = "0px"; }
+
+    on(te, "input", function () {
+      if (ie && ie_version >= 9 && this$1$1.hasSelection) { this$1$1.hasSelection = null; }
+      input.poll();
+    });
+
+    on(te, "paste", function (e) {
+      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
+
+      cm.state.pasteIncoming = +new Date;
+      input.fastPoll();
+    });
+
+    function prepareCopyCut(e) {
+      if (signalDOMEvent(cm, e)) { return }
+      if (cm.somethingSelected()) {
+        setLastCopied({lineWise: false, text: cm.getSelections()});
+      } else if (!cm.options.lineWiseCopyCut) {
+        return
+      } else {
+        var ranges = copyableRanges(cm);
+        setLastCopied({lineWise: true, text: ranges.text});
+        if (e.type == "cut") {
+          cm.setSelections(ranges.ranges, null, sel_dontScroll);
         } else {
-          break;
+          input.prevInput = "";
+          te.value = ranges.text.join("\n");
+          selectInput(te);
         }
       }
+      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
     }
-    function lastChangeEvent(hist, force) {
-      if (force) {
-        clearSelectionEvents(hist.done);
-        return lst(hist.done);
-      } else if (hist.done.length && !lst(hist.done).ranges) {
-        return lst(hist.done);
-      } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
-        hist.done.pop();
-        return lst(hist.done);
-      }
-    }
-    function addChangeToHistory(doc, change, selAfter, opId) {
-      var hist = doc.history;
-      hist.undone.length = 0;
-      var time = +new Date(), cur;
-      var last;
-      if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
-        last = lst(cur.changes);
-        if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
-          last.to = changeEnd(change);
-        } else {
-          cur.changes.push(historyChangeFromChange(doc, change));
-        }
-      } else {
-        var before = lst(hist.done);
-        if (!before || !before.ranges) {
-          pushSelectionToHistory(doc.sel, hist.done);
-        }
-        cur = {
-          changes: [historyChangeFromChange(doc, change)],
-          generation: hist.generation
-        };
-        hist.done.push(cur);
-        while (hist.done.length > hist.undoDepth) {
-          hist.done.shift();
-          if (!hist.done[0].ranges) {
-            hist.done.shift();
-          }
-        }
+    on(te, "cut", prepareCopyCut);
+    on(te, "copy", prepareCopyCut);
+
+    on(display.scroller, "paste", function (e) {
+      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
+      if (!te.dispatchEvent) {
+        cm.state.pasteIncoming = +new Date;
+        input.focus();
+        return
       }
-      hist.done.push(selAfter);
-      hist.generation = ++hist.maxGeneration;
-      hist.lastModTime = hist.lastSelTime = time;
-      hist.lastOp = hist.lastSelOp = opId;
-      hist.lastOrigin = hist.lastSelOrigin = change.origin;
-      if (!last) {
-        signal(doc, "historyAdded");
+
+      // Pass the `paste` event to the textarea so it's handled by its event listener.
+      var event = new Event("paste");
+      event.clipboardData = e.clipboardData;
+      te.dispatchEvent(event);
+    });
+
+    // Prevent normal selection in the editor (we handle our own)
+    on(display.lineSpace, "selectstart", function (e) {
+      if (!eventInWidget(display, e)) { e_preventDefault(e); }
+    });
+
+    on(te, "compositionstart", function () {
+      var start = cm.getCursor("from");
+      if (input.composing) { input.composing.range.clear(); }
+      input.composing = {
+        start: start,
+        range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
+      };
+    });
+    on(te, "compositionend", function () {
+      if (input.composing) {
+        input.poll();
+        input.composing.range.clear();
+        input.composing = null;
       }
+    });
+  };
+
+  TextareaInput.prototype.createField = function (_display) {
+    // Wraps and hides input textarea
+    this.wrapper = hiddenTextarea();
+    // The semihidden textarea that is focused when the editor is
+    // focused, and receives input.
+    this.textarea = this.wrapper.firstChild;
+  };
+
+  TextareaInput.prototype.screenReaderLabelChanged = function (label) {
+    // Label for screenreaders, accessibility
+    if(label) {
+      this.textarea.setAttribute('aria-label', label);
+    } else {
+      this.textarea.removeAttribute('aria-label');
     }
-    function selectionEventCanBeMerged(doc, origin, prev, sel) {
-      var ch = origin.charAt(0);
-      return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
-    }
-    function addSelectionToHistory(doc, sel, opId, options) {
-      var hist = doc.history, origin = options && options.origin;
-      if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
-        hist.done[hist.done.length - 1] = sel;
-      } else {
-        pushSelectionToHistory(sel, hist.done);
-      }
-      hist.lastSelTime = +new Date();
-      hist.lastSelOrigin = origin;
-      hist.lastSelOp = opId;
-      if (options && options.clearRedo !== false) {
-        clearSelectionEvents(hist.undone);
-      }
+  };
+
+  TextareaInput.prototype.prepareSelection = function () {
+    // Redraw the selection and/or cursor
+    var cm = this.cm, display = cm.display, doc = cm.doc;
+    var result = prepareSelection(cm);
+
+    // Move the hidden textarea near the cursor to prevent scrolling artifacts
+    if (cm.options.moveInputWithCursor) {
+      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
+      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
+      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
+                                          headPos.top + lineOff.top - wrapOff.top));
+      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
+                                           headPos.left + lineOff.left - wrapOff.left));
     }
-    function pushSelectionToHistory(sel, dest) {
-      var top = lst(dest);
-      if (!(top && top.ranges && top.equals(sel))) {
-        dest.push(sel);
-      }
+
+    return result
+  };
+
+  TextareaInput.prototype.showSelection = function (drawn) {
+    var cm = this.cm, display = cm.display;
+    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
+    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
+    if (drawn.teTop != null) {
+      this.wrapper.style.top = drawn.teTop + "px";
+      this.wrapper.style.left = drawn.teLeft + "px";
     }
-    function attachLocalSpans(doc, change, from, to) {
-      var existing = change["spans_" + doc.id], n = 0;
-      doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
-        if (line.markedSpans) {
-          (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
-        }
-        ++n;
-      });
+  };
+
+  // Reset the input to correspond to the selection (or to be empty,
+  // when not typing and nothing is selected)
+  TextareaInput.prototype.reset = function (typing) {
+    if (this.contextMenuPending || this.composing) { return }
+    var cm = this.cm;
+    if (cm.somethingSelected()) {
+      this.prevInput = "";
+      var content = cm.getSelection();
+      this.textarea.value = content;
+      if (cm.state.focused) { selectInput(this.textarea); }
+      if (ie && ie_version >= 9) { this.hasSelection = content; }
+    } else if (!typing) {
+      this.prevInput = this.textarea.value = "";
+      if (ie && ie_version >= 9) { this.hasSelection = null; }
     }
-    function removeClearedSpans(spans) {
-      if (!spans) {
-        return null;
-      }
-      var out;
-      for (var i2 = 0; i2 < spans.length; ++i2) {
-        if (spans[i2].marker.explicitlyCleared) {
-          if (!out) {
-            out = spans.slice(0, i2);
-          }
-        } else if (out) {
-          out.push(spans[i2]);
-        }
-      }
-      return !out ? spans : out.length ? out : null;
-    }
-    function getOldSpans(doc, change) {
-      var found = change["spans_" + doc.id];
-      if (!found) {
-        return null;
-      }
-      var nw = [];
-      for (var i2 = 0; i2 < change.text.length; ++i2) {
-        nw.push(removeClearedSpans(found[i2]));
-      }
-      return nw;
-    }
-    function mergeOldSpans(doc, change) {
-      var old = getOldSpans(doc, change);
-      var stretched = stretchSpansOverChange(doc, change);
-      if (!old) {
-        return stretched;
-      }
-      if (!stretched) {
-        return old;
-      }
-      for (var i2 = 0; i2 < old.length; ++i2) {
-        var oldCur = old[i2], stretchCur = stretched[i2];
-        if (oldCur && stretchCur) {
-          spans:
-            for (var j = 0; j < stretchCur.length; ++j) {
-              var span = stretchCur[j];
-              for (var k = 0; k < oldCur.length; ++k) {
-                if (oldCur[k].marker == span.marker) {
-                  continue spans;
-                }
-              }
-              oldCur.push(span);
-            }
-        } else if (stretchCur) {
-          old[i2] = stretchCur;
-        }
-      }
-      return old;
+  };
+
+  TextareaInput.prototype.getField = function () { return this.textarea };
+
+  TextareaInput.prototype.supportsTouch = function () { return false };
+
+  TextareaInput.prototype.focus = function () {
+    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
+      try { this.textarea.focus(); }
+      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
     }
-    function copyHistoryArray(events, newGroup, instantiateSel) {
-      var copy = [];
-      for (var i2 = 0; i2 < events.length; ++i2) {
-        var event2 = events[i2];
-        if (event2.ranges) {
-          copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event2) : event2);
-          continue;
-        }
-        var changes = event2.changes, newChanges = [];
-        copy.push({ changes: newChanges });
-        for (var j = 0; j < changes.length; ++j) {
-          var change = changes[j], m = void 0;
-          newChanges.push({ from: change.from, to: change.to, text: change.text });
-          if (newGroup) {
-            for (var prop2 in change) {
-              if (m = prop2.match(/^spans_(\d+)$/)) {
-                if (indexOf(newGroup, Number(m[1])) > -1) {
-                  lst(newChanges)[prop2] = change[prop2];
-                  delete change[prop2];
-                }
-              }
-            }
-          }
-        }
+  };
+
+  TextareaInput.prototype.blur = function () { this.textarea.blur(); };
+
+  TextareaInput.prototype.resetPosition = function () {
+    this.wrapper.style.top = this.wrapper.style.left = 0;
+  };
+
+  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };
+
+  // Poll for input changes, using the normal rate of polling. This
+  // runs as long as the editor is focused.
+  TextareaInput.prototype.slowPoll = function () {
+      var this$1$1 = this;
+
+    if (this.pollingFast) { return }
+    this.polling.set(this.cm.options.pollInterval, function () {
+      this$1$1.poll();
+      if (this$1$1.cm.state.focused) { this$1$1.slowPoll(); }
+    });
+  };
+
+  // When an event has just come in that is likely to add or change
+  // something in the input textarea, we poll faster, to ensure that
+  // the change appears on the screen quickly.
+  TextareaInput.prototype.fastPoll = function () {
+    var missed = false, input = this;
+    input.pollingFast = true;
+    function p() {
+      var changed = input.poll();
+      if (!changed && !missed) {missed = true; input.polling.set(60, p);}
+      else {input.pollingFast = false; input.slowPoll();}
+    }
+    input.polling.set(20, p);
+  };
+
+  // Read input from the textarea, and update the document to match.
+  // When something is selected, it is present in the textarea, and
+  // selected (unless it is huge, in which case a placeholder is
+  // used). When nothing is selected, the cursor sits after previously
+  // seen text (can be empty), which is stored in prevInput (we must
+  // not reset the textarea when typing, because that breaks IME).
+  TextareaInput.prototype.poll = function () {
+      var this$1$1 = this;
+
+    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
+    // Since this is called a *lot*, try to bail out as cheaply as
+    // possible when it is clear that nothing happened. hasSelection
+    // will be the case when there is a lot of text in the textarea,
+    // in which case reading its value would be expensive.
+    if (this.contextMenuPending || !cm.state.focused ||
+        (hasSelection(input) && !prevInput && !this.composing) ||
+        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
+      { return false }
+
+    var text = input.value;
+    // If nothing changed, bail.
+    if (text == prevInput && !cm.somethingSelected()) { return false }
+    // Work around nonsensical selection resetting in IE9/10, and
+    // inexplicable appearance of private area unicode characters on
+    // some key combos in Mac (#2689).
+    if (ie && ie_version >= 9 && this.hasSelection === text ||
+        mac && /[\uf700-\uf7ff]/.test(text)) {
+      cm.display.input.reset();
+      return false
+    }
+
+    if (cm.doc.sel == cm.display.selForContextMenu) {
+      var first = text.charCodeAt(0);
+      if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
+      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
+    }
+    // Find the part of the input that is actually new
+    var same = 0, l = Math.min(prevInput.length, text.length);
+    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }
+
+    runInOp(cm, function () {
+      applyTextInput(cm, text.slice(same), prevInput.length - same,
+                     null, this$1$1.composing ? "*compose" : null);
+
+      // Don't leave long text in the textarea, since it makes further polling slow
+      if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1$1.prevInput = ""; }
+      else { this$1$1.prevInput = text; }
+
+      if (this$1$1.composing) {
+        this$1$1.composing.range.clear();
+        this$1$1.composing.range = cm.markText(this$1$1.composing.start, cm.getCursor("to"),
+                                           {className: "CodeMirror-composing"});
       }
-      return copy;
-    }
-    function extendRange(range2, head, other, extend) {
-      if (extend) {
-        var anchor = range2.anchor;
-        if (other) {
-          var posBefore = cmp(head, anchor) < 0;
-          if (posBefore != cmp(other, anchor) < 0) {
-            anchor = head;
-            head = other;
-          } else if (posBefore != cmp(head, other) < 0) {
-            head = other;
+    });
+    return true
+  };
+
+  TextareaInput.prototype.ensurePolled = function () {
+    if (this.pollingFast && this.poll()) { this.pollingFast = false; }
+  };
+
+  TextareaInput.prototype.onKeyPress = function () {
+    if (ie && ie_version >= 9) { this.hasSelection = null; }
+    this.fastPoll();
+  };
+
+  TextareaInput.prototype.onContextMenu = function (e) {
+    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
+    if (input.contextMenuPending) { input.contextMenuPending(); }
+    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
+    if (!pos || presto) { return } // Opera is difficult.
+
+    // Reset the current text selection only if the click is done outside of the selection
+    // and 'resetSelectionOnContextMenu' option is true.
+    var reset = cm.options.resetSelectionOnContextMenu;
+    if (reset && cm.doc.sel.contains(pos) == -1)
+      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }
+
+    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
+    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
+    input.wrapper.style.cssText = "position: static";
+    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
+    var oldScrollY;
+    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
+    display.input.focus();
+    if (webkit) { window.scrollTo(null, oldScrollY); }
+    display.input.reset();
+    // Adds "Select all" to context menu in FF
+    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
+    input.contextMenuPending = rehide;
+    display.selForContextMenu = cm.doc.sel;
+    clearTimeout(display.detectingSelectAll);
+
+    // Select-all will be greyed out if there's nothing to select, so
+    // this adds a zero-width space so that we can later check whether
+    // it got selected.
+    function prepareSelectAllHack() {
+      if (te.selectionStart != null) {
+        var selected = cm.somethingSelected();
+        var extval = "\u200b" + (selected ? te.value : "");
+        te.value = "\u21da"; // Used to catch context-menu undo
+        te.value = extval;
+        input.prevInput = selected ? "" : "\u200b";
+        te.selectionStart = 1; te.selectionEnd = extval.length;
+        // Re-set this, in case some other handler touched the
+        // selection in the meantime.
+        display.selForContextMenu = cm.doc.sel;
+      }
+    }
+    function rehide() {
+      if (input.contextMenuPending != rehide) { return }
+      input.contextMenuPending = false;
+      input.wrapper.style.cssText = oldWrapperCSS;
+      te.style.cssText = oldCSS;
+      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }
+
+      // Try to detect the user choosing select-all
+      if (te.selectionStart != null) {
+        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
+        var i = 0, poll = function () {
+          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
+              te.selectionEnd > 0 && input.prevInput == "\u200b") {
+            operation(cm, selectAll)(cm);
+          } else if (i++ < 10) {
+            display.detectingSelectAll = setTimeout(poll, 500);
+          } else {
+            display.selForContextMenu = null;
+            display.input.reset();
           }
-        }
-        return new Range(anchor, head);
-      } else {
-        return new Range(other || head, head);
-      }
-    }
-    function extendSelection(doc, head, other, options, extend) {
-      if (extend == null) {
-        extend = doc.cm && (doc.cm.display.shift || doc.extend);
+        };
+        display.detectingSelectAll = setTimeout(poll, 200);
       }
-      setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
     }
-    function extendSelections(doc, heads, options) {
-      var out = [];
-      var extend = doc.cm && (doc.cm.display.shift || doc.extend);
-      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
-        out[i2] = extendRange(doc.sel.ranges[i2], heads[i2], null, extend);
-      }
-      var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
-      setSelection(doc, newSel, options);
+
+    if (ie && ie_version >= 9) { prepareSelectAllHack(); }
+    if (captureRightClick) {
+      e_stop(e);
+      var mouseup = function () {
+        off(window, "mouseup", mouseup);
+        setTimeout(rehide, 20);
+      };
+      on(window, "mouseup", mouseup);
+    } else {
+      setTimeout(rehide, 50);
     }
-    function replaceOneSelection(doc, i2, range2, options) {
-      var ranges = doc.sel.ranges.slice(0);
-      ranges[i2] = range2;
-      setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
+  };
+
+  TextareaInput.prototype.readOnlyChanged = function (val) {
+    if (!val) { this.reset(); }
+    this.textarea.disabled = val == "nocursor";
+    this.textarea.readOnly = !!val;
+  };
+
+  TextareaInput.prototype.setUneditable = function () {};
+
+  TextareaInput.prototype.needsContentAttribute = false;
+
+  function fromTextArea(textarea, options) {
+    options = options ? copyObj(options) : {};
+    options.value = textarea.value;
+    if (!options.tabindex && textarea.tabIndex)
+      { options.tabindex = textarea.tabIndex; }
+    if (!options.placeholder && textarea.placeholder)
+      { options.placeholder = textarea.placeholder; }
+    // Set autofocus to true if this textarea is focused, or if it has
+    // autofocus and no other element is focused.
+    if (options.autofocus == null) {
+      var hasFocus = activeElt();
+      options.autofocus = hasFocus == textarea ||
+        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
     }
-    function setSimpleSelection(doc, anchor, head, options) {
-      setSelection(doc, simpleSelection(anchor, head), options);
+
+    function save() {textarea.value = cm.getValue();}
+
+    var realSubmit;
+    if (textarea.form) {
+      on(textarea.form, "submit", save);
+      // Deplorable hack to make the submit method do the right thing.
+      if (!options.leaveSubmitMethodAlone) {
+        var form = textarea.form;
+        realSubmit = form.submit;
+        try {
+          var wrappedSubmit = form.submit = function () {
+            save();
+            form.submit = realSubmit;
+            form.submit();
+            form.submit = wrappedSubmit;
+          };
+        } catch(e) {}
+      }
     }
-    function filterSelectionChange(doc, sel, options) {
-      var obj = {
-        ranges: sel.ranges,
-        update: function(ranges) {
-          this.ranges = [];
-          for (var i2 = 0; i2 < ranges.length; i2++) {
-            this.ranges[i2] = new Range(clipPos(doc, ranges[i2].anchor), clipPos(doc, ranges[i2].head));
-          }
-        },
-        origin: options && options.origin
+
+    options.finishInit = function (cm) {
+      cm.save = save;
+      cm.getTextArea = function () { return textarea; };
+      cm.toTextArea = function () {
+        cm.toTextArea = isNaN; // Prevent this from being ran twice
+        save();
+        textarea.parentNode.removeChild(cm.getWrapperElement());
+        textarea.style.display = "";
+        if (textarea.form) {
+          off(textarea.form, "submit", save);
+          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function")
+            { textarea.form.submit = realSubmit; }
+        }
       };
-      signal(doc, "beforeSelectionChange", doc, obj);
-      if (doc.cm) {
-        signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
-      }
-      if (obj.ranges != sel.ranges) {
-        return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);
-      } else {
-        return sel;
+    };
+
+    textarea.style.display = "none";
+    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
+      options);
+    return cm
+  }
+
+  function addLegacyProps(CodeMirror) {
+    CodeMirror.off = off;
+    CodeMirror.on = on;
+    CodeMirror.wheelEventPixels = wheelEventPixels;
+    CodeMirror.Doc = Doc;
+    CodeMirror.splitLines = splitLinesAuto;
+    CodeMirror.countColumn = countColumn;
+    CodeMirror.findColumn = findColumn;
+    CodeMirror.isWordChar = isWordCharBasic;
+    CodeMirror.Pass = Pass;
+    CodeMirror.signal = signal;
+    CodeMirror.Line = Line;
+    CodeMirror.changeEnd = changeEnd;
+    CodeMirror.scrollbarModel = scrollbarModel;
+    CodeMirror.Pos = Pos;
+    CodeMirror.cmpPos = cmp;
+    CodeMirror.modes = modes;
+    CodeMirror.mimeModes = mimeModes;
+    CodeMirror.resolveMode = resolveMode;
+    CodeMirror.getMode = getMode;
+    CodeMirror.modeExtensions = modeExtensions;
+    CodeMirror.extendMode = extendMode;
+    CodeMirror.copyState = copyState;
+    CodeMirror.startState = startState;
+    CodeMirror.innerMode = innerMode;
+    CodeMirror.commands = commands;
+    CodeMirror.keyMap = keyMap;
+    CodeMirror.keyName = keyName;
+    CodeMirror.isModifierKey = isModifierKey;
+    CodeMirror.lookupKey = lookupKey;
+    CodeMirror.normalizeKeyMap = normalizeKeyMap;
+    CodeMirror.StringStream = StringStream;
+    CodeMirror.SharedTextMarker = SharedTextMarker;
+    CodeMirror.TextMarker = TextMarker;
+    CodeMirror.LineWidget = LineWidget;
+    CodeMirror.e_preventDefault = e_preventDefault;
+    CodeMirror.e_stopPropagation = e_stopPropagation;
+    CodeMirror.e_stop = e_stop;
+    CodeMirror.addClass = addClass;
+    CodeMirror.contains = contains;
+    CodeMirror.rmClass = rmClass;
+    CodeMirror.keyNames = keyNames;
+  }
+
+  // EDITOR CONSTRUCTOR
+
+  defineOptions(CodeMirror);
+
+  addEditorMethods(CodeMirror);
+
+  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
+  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
+  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
+    { CodeMirror.prototype[prop] = (function(method) {
+      return function() {return method.apply(this.doc, arguments)}
+    })(Doc.prototype[prop]); } }
+
+  eventMixin(Doc);
+  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};
+
+  // Extra arguments are stored as the mode's dependencies, which is
+  // used by (legacy) mechanisms like loadmode.js to automatically
+  // load a mode. (Preferred mechanism is the require/define calls.)
+  CodeMirror.defineMode = function(name/*, mode, */) {
+    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
+    defineMode.apply(this, arguments);
+  };
+
+  CodeMirror.defineMIME = defineMIME;
+
+  // Minimal default mode.
+  CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
+  CodeMirror.defineMIME("text/plain", "null");
+
+  // EXTENSIONS
+
+  CodeMirror.defineExtension = function (name, func) {
+    CodeMirror.prototype[name] = func;
+  };
+  CodeMirror.defineDocExtension = function (name, func) {
+    Doc.prototype[name] = func;
+  };
+
+  CodeMirror.fromTextArea = fromTextArea;
+
+  addLegacyProps(CodeMirror);
+
+  CodeMirror.version = "5.65.3";
+
+  return CodeMirror;
+
+})));
+}(codemirror$1));
+
+var CodeMirror = codemirror$1.exports;
+
+var codemirror = '';
+
+var javascript = {exports: {}};
+
+(function (module, exports) {
+// CodeMirror, copyright (c) by Marijn Haverbeke and others
+// Distributed under an MIT license: https://codemirror.net/LICENSE
+
+(function(mod) {
+  mod(codemirror$1.exports);
+})(function(CodeMirror) {
+
+CodeMirror.defineMode("javascript", function(config, parserConfig) {
+  var indentUnit = config.indentUnit;
+  var statementIndent = parserConfig.statementIndent;
+  var jsonldMode = parserConfig.jsonld;
+  var jsonMode = parserConfig.json || jsonldMode;
+  var trackScope = parserConfig.trackScope !== false;
+  var isTS = parserConfig.typescript;
+  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
+
+  // Tokenizer
+
+  var keywords = function(){
+    function kw(type) {return {type: type, style: "keyword"};}
+    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
+    var operator = kw("operator"), atom = {type: "atom", style: "atom"};
+
+    return {
+      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
+      "return": D, "break": D, "continue": D, "new": kw("new"), "delete": C, "void": C, "throw": C,
+      "debugger": kw("debugger"), "var": kw("var"), "const": kw("var"), "let": kw("var"),
+      "function": kw("function"), "catch": kw("catch"),
+      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
+      "in": operator, "typeof": operator, "instanceof": operator,
+      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
+      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
+      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
+      "await": C
+    };
+  }();
+
+  var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
+  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
+
+  function readRegexp(stream) {
+    var escaped = false, next, inSet = false;
+    while ((next = stream.next()) != null) {
+      if (!escaped) {
+        if (next == "/" && !inSet) return;
+        if (next == "[") inSet = true;
+        else if (inSet && next == "]") inSet = false;
       }
+      escaped = !escaped && next == "\\";
     }
-    function setSelectionReplaceHistory(doc, sel, options) {
-      var done = doc.history.done, last = lst(done);
-      if (last && last.ranges) {
-        done[done.length - 1] = sel;
-        setSelectionNoUndo(doc, sel, options);
+  }
+
+  // Used as scratch variables to communicate multiple values without
+  // consing up tons of objects.
+  var type, content;
+  function ret(tp, style, cont) {
+    type = tp; content = cont;
+    return style;
+  }
+  function tokenBase(stream, state) {
+    var ch = stream.next();
+    if (ch == '"' || ch == "'") {
+      state.tokenize = tokenString(ch);
+      return state.tokenize(stream, state);
+    } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
+      return ret("number", "number");
+    } else if (ch == "." && stream.match("..")) {
+      return ret("spread", "meta");
+    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
+      return ret(ch);
+    } else if (ch == "=" && stream.eat(">")) {
+      return ret("=>", "operator");
+    } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
+      return ret("number", "number");
+    } else if (/\d/.test(ch)) {
+      stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
+      return ret("number", "number");
+    } else if (ch == "/") {
+      if (stream.eat("*")) {
+        state.tokenize = tokenComment;
+        return tokenComment(stream, state);
+      } else if (stream.eat("/")) {
+        stream.skipToEnd();
+        return ret("comment", "comment");
+      } else if (expressionAllowed(stream, state, 1)) {
+        readRegexp(stream);
+        stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
+        return ret("regexp", "string-2");
       } else {
-        setSelection(doc, sel, options);
-      }
+        stream.eat("=");
+        return ret("operator", "operator", stream.current());
+      }
+    } else if (ch == "`") {
+      state.tokenize = tokenQuasi;
+      return tokenQuasi(stream, state);
+    } else if (ch == "#" && stream.peek() == "!") {
+      stream.skipToEnd();
+      return ret("meta", "meta");
+    } else if (ch == "#" && stream.eatWhile(wordRE)) {
+      return ret("variable", "property")
+    } else if (ch == "<" && stream.match("!--") ||
+               (ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start)))) {
+      stream.skipToEnd();
+      return ret("comment", "comment")
+    } else if (isOperatorChar.test(ch)) {
+      if (ch != ">" || !state.lexical || state.lexical.type != ">") {
+        if (stream.eat("=")) {
+          if (ch == "!" || ch == "=") stream.eat("=");
+        } else if (/[<>*+\-|&?]/.test(ch)) {
+          stream.eat(ch);
+          if (ch == ">") stream.eat(ch);
+        }
+      }
+      if (ch == "?" && stream.eat(".")) return ret(".")
+      return ret("operator", "operator", stream.current());
+    } else if (wordRE.test(ch)) {
+      stream.eatWhile(wordRE);
+      var word = stream.current();
+      if (state.lastType != ".") {
+        if (keywords.propertyIsEnumerable(word)) {
+          var kw = keywords[word];
+          return ret(kw.type, kw.style, word)
+        }
+        if (word == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
+          return ret("async", "keyword", word)
+      }
+      return ret("variable", "variable", word)
     }
-    function setSelection(doc, sel, options) {
-      setSelectionNoUndo(doc, sel, options);
-      addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
-    }
-    function setSelectionNoUndo(doc, sel, options) {
-      if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
-        sel = filterSelectionChange(doc, sel, options);
-      }
-      var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
-      setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
-      if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor") {
-        ensureCursorVisible(doc.cm);
+  }
+
+  function tokenString(quote) {
+    return function(stream, state) {
+      var escaped = false, next;
+      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
+        state.tokenize = tokenBase;
+        return ret("jsonld-keyword", "meta");
+      }
+      while ((next = stream.next()) != null) {
+        if (next == quote && !escaped) break;
+        escaped = !escaped && next == "\\";
+      }
+      if (!escaped) state.tokenize = tokenBase;
+      return ret("string", "string");
+    };
+  }
+
+  function tokenComment(stream, state) {
+    var maybeEnd = false, ch;
+    while (ch = stream.next()) {
+      if (ch == "/" && maybeEnd) {
+        state.tokenize = tokenBase;
+        break;
       }
+      maybeEnd = (ch == "*");
     }
-    function setSelectionInner(doc, sel) {
-      if (sel.equals(doc.sel)) {
-        return;
-      }
-      doc.sel = sel;
-      if (doc.cm) {
-        doc.cm.curOp.updateInput = 1;
-        doc.cm.curOp.selectionChanged = true;
-        signalCursorActivity(doc.cm);
-      }
-      signalLater(doc, "cursorActivity", doc);
-    }
-    function reCheckSelection(doc) {
-      setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
-    }
-    function skipAtomicInSelection(doc, sel, bias, mayClear) {
-      var out;
-      for (var i2 = 0; i2 < sel.ranges.length; i2++) {
-        var range2 = sel.ranges[i2];
-        var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i2];
-        var newAnchor = skipAtomic(doc, range2.anchor, old && old.anchor, bias, mayClear);
-        var newHead = skipAtomic(doc, range2.head, old && old.head, bias, mayClear);
-        if (out || newAnchor != range2.anchor || newHead != range2.head) {
-          if (!out) {
-            out = sel.ranges.slice(0, i2);
-          }
-          out[i2] = new Range(newAnchor, newHead);
-        }
-      }
-      return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;
-    }
-    function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
-      var line = getLine(doc, pos.line);
-      if (line.markedSpans) {
-        for (var i2 = 0; i2 < line.markedSpans.length; ++i2) {
-          var sp = line.markedSpans[i2], m = sp.marker;
-          var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
-          var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;
-          if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
-            if (mayClear) {
-              signal(m, "beforeCursorEnter");
-              if (m.explicitlyCleared) {
-                if (!line.markedSpans) {
-                  break;
-                } else {
-                  --i2;
-                  continue;
-                }
-              }
-            }
-            if (!m.atomic) {
-              continue;
-            }
-            if (oldPos) {
-              var near = m.find(dir < 0 ? 1 : -1), diff = void 0;
-              if (dir < 0 ? preventCursorRight : preventCursorLeft) {
-                near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
-              }
-              if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
-                return skipAtomicInner(doc, near, pos, dir, mayClear);
-              }
-            }
-            var far = m.find(dir < 0 ? -1 : 1);
-            if (dir < 0 ? preventCursorLeft : preventCursorRight) {
-              far = movePos(doc, far, dir, far.line == pos.line ? line : null);
-            }
-            return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
-          }
-        }
+    return ret("comment", "comment");
+  }
+
+  function tokenQuasi(stream, state) {
+    var escaped = false, next;
+    while ((next = stream.next()) != null) {
+      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
+        state.tokenize = tokenBase;
+        break;
       }
-      return pos;
+      escaped = !escaped && next == "\\";
     }
-    function skipAtomic(doc, pos, oldPos, bias, mayClear) {
-      var dir = bias || 1;
-      var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
-      if (!found) {
-        doc.cantEdit = true;
-        return Pos(doc.first, 0);
-      }
-      return found;
+    return ret("quasi", "string-2", stream.current());
+  }
+
+  var brackets = "([{}])";
+  // This is a crude lookahead trick to try and notice that we're
+  // parsing the argument patterns for a fat-arrow function before we
+  // actually hit the arrow token. It only works if the arrow is on
+  // the same line as the arguments and there's no strange noise
+  // (comments) in between. Fallback is to only notice when we hit the
+  // arrow, and not declare the arguments as locals for the arrow
+  // body.
+  function findFatArrow(stream, state) {
+    if (state.fatArrowAt) state.fatArrowAt = null;
+    var arrow = stream.string.indexOf("=>", stream.start);
+    if (arrow < 0) return;
+
+    if (isTS) { // Try to skip TypeScript return type declarations after the arguments
+      var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
+      if (m) arrow = m.index;
     }
-    function movePos(doc, pos, dir, line) {
-      if (dir < 0 && pos.ch == 0) {
-        if (pos.line > doc.first) {
-          return clipPos(doc, Pos(pos.line - 1));
-        } else {
-          return null;
-        }
-      } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
-        if (pos.line < doc.first + doc.size - 1) {
-          return Pos(pos.line + 1, 0);
-        } else {
-          return null;
-        }
-      } else {
-        return new Pos(pos.line, pos.ch + dir);
+
+    var depth = 0, sawSomething = false;
+    for (var pos = arrow - 1; pos >= 0; --pos) {
+      var ch = stream.string.charAt(pos);
+      var bracket = brackets.indexOf(ch);
+      if (bracket >= 0 && bracket < 3) {
+        if (!depth) { ++pos; break; }
+        if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
+      } else if (bracket >= 3 && bracket < 6) {
+        ++depth;
+      } else if (wordRE.test(ch)) {
+        sawSomething = true;
+      } else if (/["'\/`]/.test(ch)) {
+        for (;; --pos) {
+          if (pos == 0) return
+          var next = stream.string.charAt(pos - 1);
+          if (next == ch && stream.string.charAt(pos - 2) != "\\") { pos--; break }
+        }
+      } else if (sawSomething && !depth) {
+        ++pos;
+        break;
       }
     }
-    function selectAll(cm) {
-      cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
+    if (sawSomething && !depth) state.fatArrowAt = pos;
+  }
+
+  // Parser
+
+  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true,
+                     "regexp": true, "this": true, "import": true, "jsonld-keyword": true};
+
+  function JSLexical(indented, column, type, align, prev, info) {
+    this.indented = indented;
+    this.column = column;
+    this.type = type;
+    this.prev = prev;
+    this.info = info;
+    if (align != null) this.align = align;
+  }
+
+  function inScope(state, varname) {
+    if (!trackScope) return false
+    for (var v = state.localVars; v; v = v.next)
+      if (v.name == varname) return true;
+    for (var cx = state.context; cx; cx = cx.prev) {
+      for (var v = cx.vars; v; v = v.next)
+        if (v.name == varname) return true;
     }
-    function filterChange(doc, change, update) {
-      var obj = {
-        canceled: false,
-        from: change.from,
-        to: change.to,
-        text: change.text,
-        origin: change.origin,
-        cancel: function() {
-          return obj.canceled = true;
-        }
-      };
-      if (update) {
-        obj.update = function(from, to, text, origin) {
-          if (from) {
-            obj.from = clipPos(doc, from);
-          }
-          if (to) {
-            obj.to = clipPos(doc, to);
-          }
-          if (text) {
-            obj.text = text;
-          }
-          if (origin !== void 0) {
-            obj.origin = origin;
-          }
-        };
-      }
-      signal(doc, "beforeChange", doc, obj);
-      if (doc.cm) {
-        signal(doc.cm, "beforeChange", doc.cm, obj);
-      }
-      if (obj.canceled) {
-        if (doc.cm) {
-          doc.cm.curOp.updateInput = 2;
-        }
-        return null;
+  }
+
+  function parseJS(state, style, type, content, stream) {
+    var cc = state.cc;
+    // Communicate our context to the combinators.
+    // (Less wasteful than consing up a hundred closures on every call.)
+    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;
+
+    if (!state.lexical.hasOwnProperty("align"))
+      state.lexical.align = true;
+
+    while(true) {
+      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
+      if (combinator(type, content)) {
+        while(cc.length && cc[cc.length - 1].lex)
+          cc.pop()();
+        if (cx.marked) return cx.marked;
+        if (type == "variable" && inScope(state, content)) return "variable-2";
+        return style;
       }
-      return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
     }
-    function makeChange(doc, change, ignoreReadOnly) {
-      if (doc.cm) {
-        if (!doc.cm.curOp) {
-          return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
-        }
-        if (doc.cm.state.suppressEdits) {
-          return;
-        }
-      }
-      if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
-        change = filterChange(doc, change, true);
-        if (!change) {
-          return;
-        }
-      }
-      var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
-      if (split) {
-        for (var i2 = split.length - 1; i2 >= 0; --i2) {
-          makeChangeInner(doc, { from: split[i2].from, to: split[i2].to, text: i2 ? [""] : change.text, origin: change.origin });
-        }
-      } else {
-        makeChangeInner(doc, change);
-      }
+  }
+
+  // Combinator utils
+
+  var cx = {state: null, column: null, marked: null, cc: null};
+  function pass() {
+    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
+  }
+  function cont() {
+    pass.apply(null, arguments);
+    return true;
+  }
+  function inList(name, list) {
+    for (var v = list; v; v = v.next) if (v.name == name) return true
+    return false;
+  }
+  function register(varname) {
+    var state = cx.state;
+    cx.marked = "def";
+    if (!trackScope) return
+    if (state.context) {
+      if (state.lexical.info == "var" && state.context && state.context.block) {
+        // FIXME function decls are also not block scoped
+        var newContext = registerVarScoped(varname, state.context);
+        if (newContext != null) {
+          state.context = newContext;
+          return
+        }
+      } else if (!inList(varname, state.localVars)) {
+        state.localVars = new Var(varname, state.localVars);
+        return
+      }
+    }
+    // Fall through means this is global
+    if (parserConfig.globalVars && !inList(varname, state.globalVars))
+      state.globalVars = new Var(varname, state.globalVars);
+  }
+  function registerVarScoped(varname, context) {
+    if (!context) {
+      return null
+    } else if (context.block) {
+      var inner = registerVarScoped(varname, context.prev);
+      if (!inner) return null
+      if (inner == context.prev) return context
+      return new Context(inner, context.vars, true)
+    } else if (inList(varname, context.vars)) {
+      return context
+    } else {
+      return new Context(context.prev, new Var(varname, context.vars), false)
     }
-    function makeChangeInner(doc, change) {
-      if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
-        return;
-      }
-      var selAfter = computeSelAfterChange(doc, change);
-      addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
-      makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
-      var rebased = [];
-      linkedDocs(doc, function(doc2, sharedHist) {
-        if (!sharedHist && indexOf(rebased, doc2.history) == -1) {
-          rebaseHist(doc2.history, change);
-          rebased.push(doc2.history);
-        }
-        makeChangeSingleDoc(doc2, change, null, stretchSpansOverChange(doc2, change));
-      });
+  }
+
+  function isModifier(name) {
+    return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly"
+  }
+
+  // Combinators
+
+  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block; }
+  function Var(name, next) { this.name = name; this.next = next; }
+
+  var defaultVars = new Var("this", new Var("arguments", null));
+  function pushcontext() {
+    cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
+    cx.state.localVars = defaultVars;
+  }
+  function pushblockcontext() {
+    cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
+    cx.state.localVars = null;
+  }
+  pushcontext.lex = pushblockcontext.lex = true;
+  function popcontext() {
+    cx.state.localVars = cx.state.context.vars;
+    cx.state.context = cx.state.context.prev;
+  }
+  popcontext.lex = true;
+  function pushlex(type, info) {
+    var result = function() {
+      var state = cx.state, indent = state.indented;
+      if (state.lexical.type == "stat") indent = state.lexical.indented;
+      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
+        indent = outer.indented;
+      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
+    };
+    result.lex = true;
+    return result;
+  }
+  function poplex() {
+    var state = cx.state;
+    if (state.lexical.prev) {
+      if (state.lexical.type == ")")
+        state.indented = state.lexical.indented;
+      state.lexical = state.lexical.prev;
     }
-    function makeChangeFromHistory(doc, type, allowSelectionOnly) {
-      var suppress = doc.cm && doc.cm.state.suppressEdits;
-      if (suppress && !allowSelectionOnly) {
-        return;
-      }
-      var hist = doc.history, event2, selAfter = doc.sel;
-      var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;
-      var i2 = 0;
-      for (; i2 < source.length; i2++) {
-        event2 = source[i2];
-        if (allowSelectionOnly ? event2.ranges && !event2.equals(doc.sel) : !event2.ranges) {
-          break;
-        }
-      }
-      if (i2 == source.length) {
-        return;
-      }
-      hist.lastOrigin = hist.lastSelOrigin = null;
-      for (; ; ) {
-        event2 = source.pop();
-        if (event2.ranges) {
-          pushSelectionToHistory(event2, dest);
-          if (allowSelectionOnly && !event2.equals(doc.sel)) {
-            setSelection(doc, event2, { clearRedo: false });
-            return;
-          }
-          selAfter = event2;
-        } else if (suppress) {
-          source.push(event2);
-          return;
-        } else {
-          break;
-        }
-      }
-      var antiChanges = [];
-      pushSelectionToHistory(selAfter, dest);
-      dest.push({ changes: antiChanges, generation: hist.generation });
-      hist.generation = event2.generation || ++hist.maxGeneration;
-      var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
-      var loop = function(i3) {
-        var change = event2.changes[i3];
-        change.origin = type;
-        if (filter && !filterChange(doc, change, false)) {
-          source.length = 0;
-          return {};
-        }
-        antiChanges.push(historyChangeFromChange(doc, change));
-        var after = i3 ? computeSelAfterChange(doc, change) : lst(source);
-        makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
-        if (!i3 && doc.cm) {
-          doc.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
-        }
-        var rebased = [];
-        linkedDocs(doc, function(doc2, sharedHist) {
-          if (!sharedHist && indexOf(rebased, doc2.history) == -1) {
-            rebaseHist(doc2.history, change);
-            rebased.push(doc2.history);
-          }
-          makeChangeSingleDoc(doc2, change, null, mergeOldSpans(doc2, change));
-        });
-      };
-      for (var i$12 = event2.changes.length - 1; i$12 >= 0; --i$12) {
-        var returned = loop(i$12);
-        if (returned)
-          return returned.v;
+  }
+  poplex.lex = true;
+
+  function expect(wanted) {
+    function exp(type) {
+      if (type == wanted) return cont();
+      else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();
+      else return cont(exp);
+    }    return exp;
+  }
+
+  function statement(type, value) {
+    if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
+    if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
+    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
+    if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
+    if (type == "debugger") return cont(expect(";"));
+    if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
+    if (type == ";") return cont();
+    if (type == "if") {
+      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
+        cx.state.cc.pop()();
+      return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
+    }
+    if (type == "function") return cont(functiondef);
+    if (type == "for") return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);
+    if (type == "class" || (isTS && value == "interface")) {
+      cx.marked = "keyword";
+      return cont(pushlex("form", type == "class" ? type : value), className, poplex)
+    }
+    if (type == "variable") {
+      if (isTS && value == "declare") {
+        cx.marked = "keyword";
+        return cont(statement)
+      } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
+        cx.marked = "keyword";
+        if (value == "enum") return cont(enumdef);
+        else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));
+        else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)
+      } else if (isTS && value == "namespace") {
+        cx.marked = "keyword";
+        return cont(pushlex("form"), expression, statement, poplex)
+      } else if (isTS && value == "abstract") {
+        cx.marked = "keyword";
+        return cont(statement)
+      } else {
+        return cont(pushlex("stat"), maybelabel);
       }
     }
-    function shiftDoc(doc, distance) {
-      if (distance == 0) {
-        return;
-      }
-      doc.first += distance;
-      doc.sel = new Selection(map(doc.sel.ranges, function(range2) {
-        return new Range(Pos(range2.anchor.line + distance, range2.anchor.ch), Pos(range2.head.line + distance, range2.head.ch));
-      }), doc.sel.primIndex);
-      if (doc.cm) {
-        regChange(doc.cm, doc.first, doc.first - distance, distance);
-        for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
-          regLineChange(doc.cm, l, "gutter");
-        }
-      }
+    if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext,
+                                      block, poplex, poplex, popcontext);
+    if (type == "case") return cont(expression, expect(":"));
+    if (type == "default") return cont(expect(":"));
+    if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
+    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
+    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
+    if (type == "async") return cont(statement)
+    if (value == "@") return cont(expression, statement)
+    return pass(pushlex("stat"), expression, expect(";"), poplex);
+  }
+  function maybeCatchBinding(type) {
+    if (type == "(") return cont(funarg, expect(")"))
+  }
+  function expression(type, value) {
+    return expressionInner(type, value, false);
+  }
+  function expressionNoComma(type, value) {
+    return expressionInner(type, value, true);
+  }
+  function parenExpr(type) {
+    if (type != "(") return pass()
+    return cont(pushlex(")"), maybeexpression, expect(")"), poplex)
+  }
+  function expressionInner(type, value, noComma) {
+    if (cx.state.fatArrowAt == cx.stream.start) {
+      var body = noComma ? arrowBodyNoComma : arrowBody;
+      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
+      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
     }
-    function makeChangeSingleDoc(doc, change, selAfter, spans) {
-      if (doc.cm && !doc.cm.curOp) {
-        return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
-      }
-      if (change.to.line < doc.first) {
-        shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
-        return;
-      }
-      if (change.from.line > doc.lastLine()) {
-        return;
-      }
-      if (change.from.line < doc.first) {
-        var shift = change.text.length - 1 - (doc.first - change.from.line);
-        shiftDoc(doc, shift);
-        change = {
-          from: Pos(doc.first, 0),
-          to: Pos(change.to.line + shift, change.to.ch),
-          text: [lst(change.text)],
-          origin: change.origin
-        };
-      }
-      var last = doc.lastLine();
-      if (change.to.line > last) {
-        change = {
-          from: change.from,
-          to: Pos(last, getLine(doc, last).text.length),
-          text: [change.text[0]],
-          origin: change.origin
-        };
-      }
-      change.removed = getBetween(doc, change.from, change.to);
-      if (!selAfter) {
-        selAfter = computeSelAfterChange(doc, change);
-      }
-      if (doc.cm) {
-        makeChangeSingleDocInEditor(doc.cm, change, spans);
-      } else {
-        updateDoc(doc, change, spans);
-      }
-      setSelectionNoUndo(doc, selAfter, sel_dontScroll);
-      if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {
-        doc.cantEdit = false;
-      }
+
+    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
+    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
+    if (type == "function") return cont(functiondef, maybeop);
+    if (type == "class" || (isTS && value == "interface")) { cx.marked = "keyword"; return cont(pushlex("form"), classExpression, poplex); }
+    if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
+    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
+    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
+    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
+    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
+    if (type == "quasi") return pass(quasi, maybeop);
+    if (type == "new") return cont(maybeTarget(noComma));
+    return cont();
+  }
+  function maybeexpression(type) {
+    if (type.match(/[;\}\)\],]/)) return pass();
+    return pass(expression);
+  }
+
+  function maybeoperatorComma(type, value) {
+    if (type == ",") return cont(maybeexpression);
+    return maybeoperatorNoComma(type, value, false);
+  }
+  function maybeoperatorNoComma(type, value, noComma) {
+    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
+    var expr = noComma == false ? expression : expressionNoComma;
+    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
+    if (type == "operator") {
+      if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
+      if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false))
+        return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
+      if (value == "?") return cont(expression, expect(":"), expr);
+      return cont(expr);
+    }
+    if (type == "quasi") { return pass(quasi, me); }
+    if (type == ";") return;
+    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
+    if (type == ".") return cont(property, me);
+    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
+    if (isTS && value == "as") { cx.marked = "keyword"; return cont(typeexpr, me) }
+    if (type == "regexp") {
+      cx.state.lastType = cx.marked = "operator";
+      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
+      return cont(expr)
+    }
+  }
+  function quasi(type, value) {
+    if (type != "quasi") return pass();
+    if (value.slice(value.length - 2) != "${") return cont(quasi);
+    return cont(maybeexpression, continueQuasi);
+  }
+  function continueQuasi(type) {
+    if (type == "}") {
+      cx.marked = "string-2";
+      cx.state.tokenize = tokenQuasi;
+      return cont(quasi);
+    }
+  }
+  function arrowBody(type) {
+    findFatArrow(cx.stream, cx.state);
+    return pass(type == "{" ? statement : expression);
+  }
+  function arrowBodyNoComma(type) {
+    findFatArrow(cx.stream, cx.state);
+    return pass(type == "{" ? statement : expressionNoComma);
+  }
+  function maybeTarget(noComma) {
+    return function(type) {
+      if (type == ".") return cont(noComma ? targetNoComma : target);
+      else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)
+      else return pass(noComma ? expressionNoComma : expression);
+    };
+  }
+  function target(_, value) {
+    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
+  }
+  function targetNoComma(_, value) {
+    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
+  }
+  function maybelabel(type) {
+    if (type == ":") return cont(poplex, statement);
+    return pass(maybeoperatorComma, expect(";"), poplex);
+  }
+  function property(type) {
+    if (type == "variable") {cx.marked = "property"; return cont();}
+  }
+  function objprop(type, value) {
+    if (type == "async") {
+      cx.marked = "property";
+      return cont(objprop);
+    } else if (type == "variable" || cx.style == "keyword") {
+      cx.marked = "property";
+      if (value == "get" || value == "set") return cont(getterSetter);
+      var m; // Work around fat-arrow-detection complication for detecting typescript typed arrow params
+      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
+        cx.state.fatArrowAt = cx.stream.pos + m[0].length;
+      return cont(afterprop);
+    } else if (type == "number" || type == "string") {
+      cx.marked = jsonldMode ? "property" : (cx.style + " property");
+      return cont(afterprop);
+    } else if (type == "jsonld-keyword") {
+      return cont(afterprop);
+    } else if (isTS && isModifier(value)) {
+      cx.marked = "keyword";
+      return cont(objprop)
+    } else if (type == "[") {
+      return cont(expression, maybetype, expect("]"), afterprop);
+    } else if (type == "spread") {
+      return cont(expressionNoComma, afterprop);
+    } else if (value == "*") {
+      cx.marked = "keyword";
+      return cont(objprop);
+    } else if (type == ":") {
+      return pass(afterprop)
+    }
+  }
+  function getterSetter(type) {
+    if (type != "variable") return pass(afterprop);
+    cx.marked = "property";
+    return cont(functiondef);
+  }
+  function afterprop(type) {
+    if (type == ":") return cont(expressionNoComma);
+    if (type == "(") return pass(functiondef);
+  }
+  function commasep(what, end, sep) {
+    function proceed(type, value) {
+      if (sep ? sep.indexOf(type) > -1 : type == ",") {
+        var lex = cx.state.lexical;
+        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
+        return cont(function(type, value) {
+          if (type == end || value == end) return pass()
+          return pass(what)
+        }, proceed);
+      }
+      if (type == end || value == end) return cont();
+      if (sep && sep.indexOf(";") > -1) return pass(what)
+      return cont(expect(end));
+    }
+    return function(type, value) {
+      if (type == end || value == end) return cont();
+      return pass(what, proceed);
+    };
+  }
+  function contCommasep(what, end, info) {
+    for (var i = 3; i < arguments.length; i++)
+      cx.cc.push(arguments[i]);
+    return cont(pushlex(end, info), commasep(what, end), poplex);
+  }
+  function block(type) {
+    if (type == "}") return cont();
+    return pass(statement, block);
+  }
+  function maybetype(type, value) {
+    if (isTS) {
+      if (type == ":") return cont(typeexpr);
+      if (value == "?") return cont(maybetype);
+    }
+  }
+  function maybetypeOrIn(type, value) {
+    if (isTS && (type == ":" || value == "in")) return cont(typeexpr)
+  }
+  function mayberettype(type) {
+    if (isTS && type == ":") {
+      if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr)
+      else return cont(typeexpr)
+    }
+  }
+  function isKW(_, value) {
+    if (value == "is") {
+      cx.marked = "keyword";
+      return cont()
+    }
+  }
+  function typeexpr(type, value) {
+    if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
+      cx.marked = "keyword";
+      return cont(value == "typeof" ? expressionNoComma : typeexpr)
+    }
+    if (type == "variable" || value == "void") {
+      cx.marked = "type";
+      return cont(afterType)
+    }
+    if (value == "|" || value == "&") return cont(typeexpr)
+    if (type == "string" || type == "number" || type == "atom") return cont(afterType);
+    if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType)
+    if (type == "{") return cont(pushlex("}"), typeprops, poplex, afterType)
+    if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType)
+    if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr)
+    if (type == "quasi") { return pass(quasiType, afterType); }
+  }
+  function maybeReturnType(type) {
+    if (type == "=>") return cont(typeexpr)
+  }
+  function typeprops(type) {
+    if (type.match(/[\}\)\]]/)) return cont()
+    if (type == "," || type == ";") return cont(typeprops)
+    return pass(typeprop, typeprops)
+  }
+  function typeprop(type, value) {
+    if (type == "variable" || cx.style == "keyword") {
+      cx.marked = "property";
+      return cont(typeprop)
+    } else if (value == "?" || type == "number" || type == "string") {
+      return cont(typeprop)
+    } else if (type == ":") {
+      return cont(typeexpr)
+    } else if (type == "[") {
+      return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop)
+    } else if (type == "(") {
+      return pass(functiondecl, typeprop)
+    } else if (!type.match(/[;\}\)\],]/)) {
+      return cont()
+    }
+  }
+  function quasiType(type, value) {
+    if (type != "quasi") return pass();
+    if (value.slice(value.length - 2) != "${") return cont(quasiType);
+    return cont(typeexpr, continueQuasiType);
+  }
+  function continueQuasiType(type) {
+    if (type == "}") {
+      cx.marked = "string-2";
+      cx.state.tokenize = tokenQuasi;
+      return cont(quasiType);
+    }
+  }
+  function typearg(type, value) {
+    if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg)
+    if (type == ":") return cont(typeexpr)
+    if (type == "spread") return cont(typearg)
+    return pass(typeexpr)
+  }
+  function afterType(type, value) {
+    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
+    if (value == "|" || type == "." || value == "&") return cont(typeexpr)
+    if (type == "[") return cont(typeexpr, expect("]"), afterType)
+    if (value == "extends" || value == "implements") { cx.marked = "keyword"; return cont(typeexpr) }
+    if (value == "?") return cont(typeexpr, expect(":"), typeexpr)
+  }
+  function maybeTypeArgs(_, value) {
+    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
+  }
+  function typeparam() {
+    return pass(typeexpr, maybeTypeDefault)
+  }
+  function maybeTypeDefault(_, value) {
+    if (value == "=") return cont(typeexpr)
+  }
+  function vardef(_, value) {
+    if (value == "enum") {cx.marked = "keyword"; return cont(enumdef)}
+    return pass(pattern, maybetype, maybeAssign, vardefCont);
+  }
+  function pattern(type, value) {
+    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(pattern) }
+    if (type == "variable") { register(value); return cont(); }
+    if (type == "spread") return cont(pattern);
+    if (type == "[") return contCommasep(eltpattern, "]");
+    if (type == "{") return contCommasep(proppattern, "}");
+  }
+  function proppattern(type, value) {
+    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
+      register(value);
+      return cont(maybeAssign);
+    }
+    if (type == "variable") cx.marked = "property";
+    if (type == "spread") return cont(pattern);
+    if (type == "}") return pass();
+    if (type == "[") return cont(expression, expect(']'), expect(':'), proppattern);
+    return cont(expect(":"), pattern, maybeAssign);
+  }
+  function eltpattern() {
+    return pass(pattern, maybeAssign)
+  }
+  function maybeAssign(_type, value) {
+    if (value == "=") return cont(expressionNoComma);
+  }
+  function vardefCont(type) {
+    if (type == ",") return cont(vardef);
+  }
+  function maybeelse(type, value) {
+    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
+  }
+  function forspec(type, value) {
+    if (value == "await") return cont(forspec);
+    if (type == "(") return cont(pushlex(")"), forspec1, poplex);
+  }
+  function forspec1(type) {
+    if (type == "var") return cont(vardef, forspec2);
+    if (type == "variable") return cont(forspec2);
+    return pass(forspec2)
+  }
+  function forspec2(type, value) {
+    if (type == ")") return cont()
+    if (type == ";") return cont(forspec2)
+    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression, forspec2) }
+    return pass(expression, forspec2)
+  }
+  function functiondef(type, value) {
+    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
+    if (type == "variable") {register(value); return cont(functiondef);}
+    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
+    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef)
+  }
+  function functiondecl(type, value) {
+    if (value == "*") {cx.marked = "keyword"; return cont(functiondecl);}
+    if (type == "variable") {register(value); return cont(functiondecl);}
+    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
+    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl)
+  }
+  function typename(type, value) {
+    if (type == "keyword" || type == "variable") {
+      cx.marked = "type";
+      return cont(typename)
+    } else if (value == "<") {
+      return cont(pushlex(">"), commasep(typeparam, ">"), poplex)
+    }
+  }
+  function funarg(type, value) {
+    if (value == "@") cont(expression, funarg);
+    if (type == "spread") return cont(funarg);
+    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(funarg); }
+    if (isTS && type == "this") return cont(maybetype, maybeAssign)
+    return pass(pattern, maybetype, maybeAssign);
+  }
+  function classExpression(type, value) {
+    // Class expressions may have an optional name.
+    if (type == "variable") return className(type, value);
+    return classNameAfter(type, value);
+  }
+  function className(type, value) {
+    if (type == "variable") {register(value); return cont(classNameAfter);}
+  }
+  function classNameAfter(type, value) {
+    if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter)
+    if (value == "extends" || value == "implements" || (isTS && type == ",")) {
+      if (value == "implements") cx.marked = "keyword";
+      return cont(isTS ? typeexpr : expression, classNameAfter);
+    }
+    if (type == "{") return cont(pushlex("}"), classBody, poplex);
+  }
+  function classBody(type, value) {
+    if (type == "async" ||
+        (type == "variable" &&
+         (value == "static" || value == "get" || value == "set" || (isTS && isModifier(value))) &&
+         cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false))) {
+      cx.marked = "keyword";
+      return cont(classBody);
+    }
+    if (type == "variable" || cx.style == "keyword") {
+      cx.marked = "property";
+      return cont(classfield, classBody);
+    }
+    if (type == "number" || type == "string") return cont(classfield, classBody);
+    if (type == "[")
+      return cont(expression, maybetype, expect("]"), classfield, classBody)
+    if (value == "*") {
+      cx.marked = "keyword";
+      return cont(classBody);
+    }
+    if (isTS && type == "(") return pass(functiondecl, classBody)
+    if (type == ";" || type == ",") return cont(classBody);
+    if (type == "}") return cont();
+    if (value == "@") return cont(expression, classBody)
+  }
+  function classfield(type, value) {
+    if (value == "!") return cont(classfield)
+    if (value == "?") return cont(classfield)
+    if (type == ":") return cont(typeexpr, maybeAssign)
+    if (value == "=") return cont(expressionNoComma)
+    var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
+    return pass(isInterface ? functiondecl : functiondef)
+  }
+  function afterExport(type, value) {
+    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
+    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
+    if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
+    return pass(statement);
+  }
+  function exportField(type, value) {
+    if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
+    if (type == "variable") return pass(expressionNoComma, exportField);
+  }
+  function afterImport(type) {
+    if (type == "string") return cont();
+    if (type == "(") return pass(expression);
+    if (type == ".") return pass(maybeoperatorComma);
+    return pass(importSpec, maybeMoreImports, maybeFrom);
+  }
+  function importSpec(type, value) {
+    if (type == "{") return contCommasep(importSpec, "}");
+    if (type == "variable") register(value);
+    if (value == "*") cx.marked = "keyword";
+    return cont(maybeAs);
+  }
+  function maybeMoreImports(type) {
+    if (type == ",") return cont(importSpec, maybeMoreImports)
+  }
+  function maybeAs(_type, value) {
+    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
+  }
+  function maybeFrom(_type, value) {
+    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
+  }
+  function arrayLiteral(type) {
+    if (type == "]") return cont();
+    return pass(commasep(expressionNoComma, "]"));
+  }
+  function enumdef() {
+    return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
+  }
+  function enummember() {
+    return pass(pattern, maybeAssign);
+  }
+
+  function isContinuedStatement(state, textAfter) {
+    return state.lastType == "operator" || state.lastType == "," ||
+      isOperatorChar.test(textAfter.charAt(0)) ||
+      /[,.]/.test(textAfter.charAt(0));
+  }
+
+  function expressionAllowed(stream, state, backUp) {
+    return state.tokenize == tokenBase &&
+      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
+      (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
+  }
+
+  // Interface
+
+  return {
+    startState: function(basecolumn) {
+      var state = {
+        tokenize: tokenBase,
+        lastType: "sof",
+        cc: [],
+        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
+        localVars: parserConfig.localVars,
+        context: parserConfig.localVars && new Context(null, null, false),
+        indented: basecolumn || 0
+      };
+      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
+        state.globalVars = parserConfig.globalVars;
+      return state;
+    },
+
+    token: function(stream, state) {
+      if (stream.sol()) {
+        if (!state.lexical.hasOwnProperty("align"))
+          state.lexical.align = false;
+        state.indented = stream.indentation();
+        findFatArrow(stream, state);
+      }
+      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
+      var style = state.tokenize(stream, state);
+      if (type == "comment") return style;
+      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
+      return parseJS(state, style, type, content, stream);
+    },
+
+    indent: function(state, textAfter) {
+      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;
+      if (state.tokenize != tokenBase) return 0;
+      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top;
+      // Kludge to prevent 'maybelse' from blocking lexical scope pops
+      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
+        var c = state.cc[i];
+        if (c == poplex) lexical = lexical.prev;
+        else if (c != maybeelse && c != popcontext) break;
+      }
+      while ((lexical.type == "stat" || lexical.type == "form") &&
+             (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
+                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
+                                   !/^[,\.=+\-*:?[\(]/.test(textAfter))))
+        lexical = lexical.prev;
+      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
+        lexical = lexical.prev;
+      var type = lexical.type, closing = firstChar == type;
+
+      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
+      else if (type == "form" && firstChar == "{") return lexical.indented;
+      else if (type == "form") return lexical.indented + indentUnit;
+      else if (type == "stat")
+        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
+      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
+        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
+      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
+      else return lexical.indented + (closing ? 0 : indentUnit);
+    },
+
+    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
+    blockCommentStart: jsonMode ? null : "/*",
+    blockCommentEnd: jsonMode ? null : "*/",
+    blockCommentContinue: jsonMode ? null : " * ",
+    lineComment: jsonMode ? null : "//",
+    fold: "brace",
+    closeBrackets: "()[]{}''\"\"``",
+
+    helperType: jsonMode ? "json" : "javascript",
+    jsonldMode: jsonldMode,
+    jsonMode: jsonMode,
+
+    expressionAllowed: expressionAllowed,
+
+    skipExpression: function(state) {
+      parseJS(state, "atom", "atom", "true", new CodeMirror.StringStream("", 2, null));
     }
-    function makeChangeSingleDocInEditor(cm, change, spans) {
-      var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
-      var recomputeMaxLength = false, checkWidthStart = from.line;
-      if (!cm.options.lineWrapping) {
-        checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
-        doc.iter(checkWidthStart, to.line + 1, function(line) {
-          if (line == display.maxLine) {
-            recomputeMaxLength = true;
-            return true;
-          }
-        });
-      }
-      if (doc.sel.contains(change.from, change.to) > -1) {
-        signalCursorActivity(cm);
-      }
-      updateDoc(doc, change, spans, estimateHeight(cm));
-      if (!cm.options.lineWrapping) {
-        doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
-          var len = lineLength(line);
-          if (len > display.maxLineLength) {
-            display.maxLine = line;
-            display.maxLineLength = len;
-            display.maxLineChanged = true;
-            recomputeMaxLength = false;
-          }
-        });
-        if (recomputeMaxLength) {
-          cm.curOp.updateMaxLine = true;
+  };
+});
+
+CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);
+
+CodeMirror.defineMIME("text/javascript", "javascript");
+CodeMirror.defineMIME("text/ecmascript", "javascript");
+CodeMirror.defineMIME("application/javascript", "javascript");
+CodeMirror.defineMIME("application/x-javascript", "javascript");
+CodeMirror.defineMIME("application/ecmascript", "javascript");
+CodeMirror.defineMIME("application/json", { name: "javascript", json: true });
+CodeMirror.defineMIME("application/x-json", { name: "javascript", json: true });
+CodeMirror.defineMIME("application/manifest+json", { name: "javascript", json: true });
+CodeMirror.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
+CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
+CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });
+
+});
+}());
+
+var css = {exports: {}};
+
+(function (module, exports) {
+// CodeMirror, copyright (c) by Marijn Haverbeke and others
+// Distributed under an MIT license: https://codemirror.net/LICENSE
+
+(function(mod) {
+  mod(codemirror$1.exports);
+})(function(CodeMirror) {
+
+CodeMirror.defineMode("css", function(config, parserConfig) {
+  var inline = parserConfig.inline;
+  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");
+
+  var indentUnit = config.indentUnit,
+      tokenHooks = parserConfig.tokenHooks,
+      documentTypes = parserConfig.documentTypes || {},
+      mediaTypes = parserConfig.mediaTypes || {},
+      mediaFeatures = parserConfig.mediaFeatures || {},
+      mediaValueKeywords = parserConfig.mediaValueKeywords || {},
+      propertyKeywords = parserConfig.propertyKeywords || {},
+      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
+      fontProperties = parserConfig.fontProperties || {},
+      counterDescriptors = parserConfig.counterDescriptors || {},
+      colorKeywords = parserConfig.colorKeywords || {},
+      valueKeywords = parserConfig.valueKeywords || {},
+      allowNested = parserConfig.allowNested,
+      lineComment = parserConfig.lineComment,
+      supportsAtComponent = parserConfig.supportsAtComponent === true,
+      highlightNonStandardPropertyKeywords = config.highlightNonStandardPropertyKeywords !== false;
+
+  var type, override;
+  function ret(style, tp) { type = tp; return style; }
+
+  // Tokenizers
+
+  function tokenBase(stream, state) {
+    var ch = stream.next();
+    if (tokenHooks[ch]) {
+      var result = tokenHooks[ch](stream, state);
+      if (result !== false) return result;
+    }
+    if (ch == "@") {
+      stream.eatWhile(/[\w\\\-]/);
+      return ret("def", stream.current());
+    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
+      return ret(null, "compare");
+    } else if (ch == "\"" || ch == "'") {
+      state.tokenize = tokenString(ch);
+      return state.tokenize(stream, state);
+    } else if (ch == "#") {
+      stream.eatWhile(/[\w\\\-]/);
+      return ret("atom", "hash");
+    } else if (ch == "!") {
+      stream.match(/^\s*\w*/);
+      return ret("keyword", "important");
+    } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
+      stream.eatWhile(/[\w.%]/);
+      return ret("number", "unit");
+    } else if (ch === "-") {
+      if (/[\d.]/.test(stream.peek())) {
+        stream.eatWhile(/[\w.%]/);
+        return ret("number", "unit");
+      } else if (stream.match(/^-[\w\\\-]*/)) {
+        stream.eatWhile(/[\w\\\-]/);
+        if (stream.match(/^\s*:/, false))
+          return ret("variable-2", "variable-definition");
+        return ret("variable-2", "variable");
+      } else if (stream.match(/^\w+-/)) {
+        return ret("meta", "meta");
+      }
+    } else if (/[,+>*\/]/.test(ch)) {
+      return ret(null, "select-op");
+    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
+      return ret("qualifier", "qualifier");
+    } else if (/[:;{}\[\]\(\)]/.test(ch)) {
+      return ret(null, ch);
+    } else if (stream.match(/^[\w-.]+(?=\()/)) {
+      if (/^(url(-prefix)?|domain|regexp)$/i.test(stream.current())) {
+        state.tokenize = tokenParenthesized;
+      }
+      return ret("variable callee", "variable");
+    } else if (/[\w\\\-]/.test(ch)) {
+      stream.eatWhile(/[\w\\\-]/);
+      return ret("property", "word");
+    } else {
+      return ret(null, null);
+    }
+  }
+
+  function tokenString(quote) {
+    return function(stream, state) {
+      var escaped = false, ch;
+      while ((ch = stream.next()) != null) {
+        if (ch == quote && !escaped) {
+          if (quote == ")") stream.backUp(1);
+          break;
         }
+        escaped = !escaped && ch == "\\";
       }
-      retreatFrontier(doc, from.line);
-      startWorker(cm, 400);
-      var lendiff = change.text.length - (to.line - from.line) - 1;
-      if (change.full) {
-        regChange(cm);
-      } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
-        regLineChange(cm, from.line, "text");
+      if (ch == quote || !escaped && quote != ")") state.tokenize = null;
+      return ret("string", "string");
+    };
+  }
+
+  function tokenParenthesized(stream, state) {
+    stream.next(); // Must be '('
+    if (!stream.match(/^\s*[\"\')]/, false))
+      state.tokenize = tokenString(")");
+    else
+      state.tokenize = null;
+    return ret(null, "(");
+  }
+
+  // Context management
+
+  function Context(type, indent, prev) {
+    this.type = type;
+    this.indent = indent;
+    this.prev = prev;
+  }
+
+  function pushContext(state, stream, type, indent) {
+    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
+    return type;
+  }
+
+  function popContext(state) {
+    if (state.context.prev)
+      state.context = state.context.prev;
+    return state.context.type;
+  }
+
+  function pass(type, stream, state) {
+    return states[state.context.type](type, stream, state);
+  }
+  function popAndPass(type, stream, state, n) {
+    for (var i = n || 1; i > 0; i--)
+      state.context = state.context.prev;
+    return pass(type, stream, state);
+  }
+
+  // Parser
+
+  function wordAsValue(stream) {
+    var word = stream.current().toLowerCase();
+    if (valueKeywords.hasOwnProperty(word))
+      override = "atom";
+    else if (colorKeywords.hasOwnProperty(word))
+      override = "keyword";
+    else
+      override = "variable";
+  }
+
+  var states = {};
+
+  states.top = function(type, stream, state) {
+    if (type == "{") {
+      return pushContext(state, stream, "block");
+    } else if (type == "}" && state.context.prev) {
+      return popContext(state);
+    } else if (supportsAtComponent && /@component/i.test(type)) {
+      return pushContext(state, stream, "atComponentBlock");
+    } else if (/^@(-moz-)?document$/i.test(type)) {
+      return pushContext(state, stream, "documentTypes");
+    } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {
+      return pushContext(state, stream, "atBlock");
+    } else if (/^@(font-face|counter-style)/i.test(type)) {
+      state.stateArg = type;
+      return "restricted_atBlock_before";
+    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {
+      return "keyframes";
+    } else if (type && type.charAt(0) == "@") {
+      return pushContext(state, stream, "at");
+    } else if (type == "hash") {
+      override = "builtin";
+    } else if (type == "word") {
+      override = "tag";
+    } else if (type == "variable-definition") {
+      return "maybeprop";
+    } else if (type == "interpolation") {
+      return pushContext(state, stream, "interpolation");
+    } else if (type == ":") {
+      return "pseudo";
+    } else if (allowNested && type == "(") {
+      return pushContext(state, stream, "parens");
+    }
+    return state.context.type;
+  };
+
+  states.block = function(type, stream, state) {
+    if (type == "word") {
+      var word = stream.current().toLowerCase();
+      if (propertyKeywords.hasOwnProperty(word)) {
+        override = "property";
+        return "maybeprop";
+      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
+        override = highlightNonStandardPropertyKeywords ? "string-2" : "property";
+        return "maybeprop";
+      } else if (allowNested) {
+        override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
+        return "block";
       } else {
-        regChange(cm, from.line, to.line + 1, lendiff);
-      }
-      var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
-      if (changeHandler || changesHandler) {
-        var obj = {
-          from,
-          to,
-          text: change.text,
-          removed: change.removed,
-          origin: change.origin
-        };
-        if (changeHandler) {
-          signalLater(cm, "change", cm, obj);
-        }
-        if (changesHandler) {
-          (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
-        }
-      }
-      cm.display.selForContextMenu = null;
-    }
-    function replaceRange(doc, code, from, to, origin) {
-      var assign;
-      if (!to) {
-        to = from;
-      }
-      if (cmp(to, from) < 0) {
-        assign = [to, from], from = assign[0], to = assign[1];
-      }
-      if (typeof code == "string") {
-        code = doc.splitLines(code);
-      }
-      makeChange(doc, { from, to, text: code, origin });
-    }
-    function rebaseHistSelSingle(pos, from, to, diff) {
-      if (to < pos.line) {
-        pos.line += diff;
-      } else if (from < pos.line) {
-        pos.line = from;
-        pos.ch = 0;
-      }
+        override += " error";
+        return "maybeprop";
+      }
+    } else if (type == "meta") {
+      return "block";
+    } else if (!allowNested && (type == "hash" || type == "qualifier")) {
+      override = "error";
+      return "block";
+    } else {
+      return states.top(type, stream, state);
     }
-    function rebaseHistArray(array, from, to, diff) {
-      for (var i2 = 0; i2 < array.length; ++i2) {
-        var sub = array[i2], ok = true;
-        if (sub.ranges) {
-          if (!sub.copied) {
-            sub = array[i2] = sub.deepCopy();
-            sub.copied = true;
-          }
-          for (var j = 0; j < sub.ranges.length; j++) {
-            rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
-            rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
-          }
-          continue;
-        }
-        for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
-          var cur = sub.changes[j$1];
-          if (to < cur.from.line) {
-            cur.from = Pos(cur.from.line + diff, cur.from.ch);
-            cur.to = Pos(cur.to.line + diff, cur.to.ch);
-          } else if (from <= cur.to.line) {
-            ok = false;
-            break;
-          }
-        }
-        if (!ok) {
-          array.splice(0, i2 + 1);
-          i2 = 0;
-        }
-      }
+  };
+
+  states.maybeprop = function(type, stream, state) {
+    if (type == ":") return pushContext(state, stream, "prop");
+    return pass(type, stream, state);
+  };
+
+  states.prop = function(type, stream, state) {
+    if (type == ";") return popContext(state);
+    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
+    if (type == "}" || type == "{") return popAndPass(type, stream, state);
+    if (type == "(") return pushContext(state, stream, "parens");
+
+    if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
+      override += " error";
+    } else if (type == "word") {
+      wordAsValue(stream);
+    } else if (type == "interpolation") {
+      return pushContext(state, stream, "interpolation");
+    }
+    return "prop";
+  };
+
+  states.propBlock = function(type, _stream, state) {
+    if (type == "}") return popContext(state);
+    if (type == "word") { override = "property"; return "maybeprop"; }
+    return state.context.type;
+  };
+
+  states.parens = function(type, stream, state) {
+    if (type == "{" || type == "}") return popAndPass(type, stream, state);
+    if (type == ")") return popContext(state);
+    if (type == "(") return pushContext(state, stream, "parens");
+    if (type == "interpolation") return pushContext(state, stream, "interpolation");
+    if (type == "word") wordAsValue(stream);
+    return "parens";
+  };
+
+  states.pseudo = function(type, stream, state) {
+    if (type == "meta") return "pseudo";
+
+    if (type == "word") {
+      override = "variable-3";
+      return state.context.type;
     }
-    function rebaseHist(hist, change) {
-      var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
-      rebaseHistArray(hist.done, from, to, diff);
-      rebaseHistArray(hist.undone, from, to, diff);
+    return pass(type, stream, state);
+  };
+
+  states.documentTypes = function(type, stream, state) {
+    if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
+      override = "tag";
+      return state.context.type;
+    } else {
+      return states.atBlock(type, stream, state);
     }
-    function changeLine(doc, handle, changeType, op) {
-      var no = handle, line = handle;
-      if (typeof handle == "number") {
-        line = getLine(doc, clipLine(doc, handle));
-      } else {
-        no = lineNo(handle);
-      }
-      if (no == null) {
-        return null;
-      }
-      if (op(line, no) && doc.cm) {
-        regLineChange(doc.cm, no, changeType);
-      }
-      return line;
+  };
+
+  states.atBlock = function(type, stream, state) {
+    if (type == "(") return pushContext(state, stream, "atBlock_parens");
+    if (type == "}" || type == ";") return popAndPass(type, stream, state);
+    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");
+
+    if (type == "interpolation") return pushContext(state, stream, "interpolation");
+
+    if (type == "word") {
+      var word = stream.current().toLowerCase();
+      if (word == "only" || word == "not" || word == "and" || word == "or")
+        override = "keyword";
+      else if (mediaTypes.hasOwnProperty(word))
+        override = "attribute";
+      else if (mediaFeatures.hasOwnProperty(word))
+        override = "property";
+      else if (mediaValueKeywords.hasOwnProperty(word))
+        override = "keyword";
+      else if (propertyKeywords.hasOwnProperty(word))
+        override = "property";
+      else if (nonStandardPropertyKeywords.hasOwnProperty(word))
+        override = highlightNonStandardPropertyKeywords ? "string-2" : "property";
+      else if (valueKeywords.hasOwnProperty(word))
+        override = "atom";
+      else if (colorKeywords.hasOwnProperty(word))
+        override = "keyword";
+      else
+        override = "error";
     }
-    function LeafChunk(lines) {
-      this.lines = lines;
-      this.parent = null;
-      var height = 0;
-      for (var i2 = 0; i2 < lines.length; ++i2) {
-        lines[i2].parent = this;
-        height += lines[i2].height;
-      }
-      this.height = height;
+    return state.context.type;
+  };
+
+  states.atComponentBlock = function(type, stream, state) {
+    if (type == "}")
+      return popAndPass(type, stream, state);
+    if (type == "{")
+      return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
+    if (type == "word")
+      override = "error";
+    return state.context.type;
+  };
+
+  states.atBlock_parens = function(type, stream, state) {
+    if (type == ")") return popContext(state);
+    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
+    return states.atBlock(type, stream, state);
+  };
+
+  states.restricted_atBlock_before = function(type, stream, state) {
+    if (type == "{")
+      return pushContext(state, stream, "restricted_atBlock");
+    if (type == "word" && state.stateArg == "@counter-style") {
+      override = "variable";
+      return "restricted_atBlock_before";
+    }
+    return pass(type, stream, state);
+  };
+
+  states.restricted_atBlock = function(type, stream, state) {
+    if (type == "}") {
+      state.stateArg = null;
+      return popContext(state);
+    }
+    if (type == "word") {
+      if ((state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||
+          (state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))
+        override = "error";
+      else
+        override = "property";
+      return "maybeprop";
     }
-    LeafChunk.prototype = {
-      chunkSize: function() {
-        return this.lines.length;
-      },
-      removeInner: function(at, n) {
-        for (var i2 = at, e = at + n; i2 < e; ++i2) {
-          var line = this.lines[i2];
-          this.height -= line.height;
-          cleanUpLine(line);
-          signalLater(line, "delete");
-        }
-        this.lines.splice(at, n);
-      },
-      collapse: function(lines) {
-        lines.push.apply(lines, this.lines);
-      },
-      insertInner: function(at, lines, height) {
-        this.height += height;
-        this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
-        for (var i2 = 0; i2 < lines.length; ++i2) {
-          lines[i2].parent = this;
-        }
-      },
-      iterN: function(at, n, op) {
-        for (var e = at + n; at < e; ++at) {
-          if (op(this.lines[at])) {
-            return true;
-          }
-        }
-      }
-    };
-    function BranchChunk(children) {
-      this.children = children;
-      var size = 0, height = 0;
-      for (var i2 = 0; i2 < children.length; ++i2) {
-        var ch = children[i2];
-        size += ch.chunkSize();
-        height += ch.height;
-        ch.parent = this;
-      }
-      this.size = size;
-      this.height = height;
-      this.parent = null;
-    }
-    BranchChunk.prototype = {
-      chunkSize: function() {
-        return this.size;
-      },
-      removeInner: function(at, n) {
-        this.size -= n;
-        for (var i2 = 0; i2 < this.children.length; ++i2) {
-          var child = this.children[i2], sz = child.chunkSize();
-          if (at < sz) {
-            var rm = Math.min(n, sz - at), oldHeight = child.height;
-            child.removeInner(at, rm);
-            this.height -= oldHeight - child.height;
-            if (sz == rm) {
-              this.children.splice(i2--, 1);
-              child.parent = null;
-            }
-            if ((n -= rm) == 0) {
-              break;
-            }
-            at = 0;
-          } else {
-            at -= sz;
-          }
-        }
-        if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
-          var lines = [];
-          this.collapse(lines);
-          this.children = [new LeafChunk(lines)];
-          this.children[0].parent = this;
-        }
-      },
-      collapse: function(lines) {
-        for (var i2 = 0; i2 < this.children.length; ++i2) {
-          this.children[i2].collapse(lines);
-        }
-      },
-      insertInner: function(at, lines, height) {
-        this.size += lines.length;
-        this.height += height;
-        for (var i2 = 0; i2 < this.children.length; ++i2) {
-          var child = this.children[i2], sz = child.chunkSize();
-          if (at <= sz) {
-            child.insertInner(at, lines, height);
-            if (child.lines && child.lines.length > 50) {
-              var remaining = child.lines.length % 25 + 25;
-              for (var pos = remaining; pos < child.lines.length; ) {
-                var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
-                child.height -= leaf.height;
-                this.children.splice(++i2, 0, leaf);
-                leaf.parent = this;
-              }
-              child.lines = child.lines.slice(0, remaining);
-              this.maybeSpill();
-            }
-            break;
-          }
-          at -= sz;
-        }
-      },
-      maybeSpill: function() {
-        if (this.children.length <= 10) {
-          return;
-        }
-        var me = this;
-        do {
-          var spilled = me.children.splice(me.children.length - 5, 5);
-          var sibling = new BranchChunk(spilled);
-          if (!me.parent) {
-            var copy = new BranchChunk(me.children);
-            copy.parent = me;
-            me.children = [copy, sibling];
-            me = copy;
-          } else {
-            me.size -= sibling.size;
-            me.height -= sibling.height;
-            var myIndex = indexOf(me.parent.children, me);
-            me.parent.children.splice(myIndex + 1, 0, sibling);
-          }
-          sibling.parent = me.parent;
-        } while (me.children.length > 10);
-        me.parent.maybeSpill();
-      },
-      iterN: function(at, n, op) {
-        for (var i2 = 0; i2 < this.children.length; ++i2) {
-          var child = this.children[i2], sz = child.chunkSize();
-          if (at < sz) {
-            var used = Math.min(n, sz - at);
-            if (child.iterN(at, used, op)) {
-              return true;
-            }
-            if ((n -= used) == 0) {
-              break;
-            }
-            at = 0;
-          } else {
-            at -= sz;
-          }
-        }
-      }
-    };
-    var LineWidget = function(doc, node, options) {
-      if (options) {
-        for (var opt in options) {
-          if (options.hasOwnProperty(opt)) {
-            this[opt] = options[opt];
-          }
-        }
-      }
-      this.doc = doc;
-      this.node = node;
-    };
-    LineWidget.prototype.clear = function() {
-      var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
-      if (no == null || !ws) {
-        return;
-      }
-      for (var i2 = 0; i2 < ws.length; ++i2) {
-        if (ws[i2] == this) {
-          ws.splice(i2--, 1);
-        }
-      }
-      if (!ws.length) {
-        line.widgets = null;
-      }
-      var height = widgetHeight(this);
-      updateLineHeight(line, Math.max(0, line.height - height));
-      if (cm) {
-        runInOp(cm, function() {
-          adjustScrollWhenAboveVisible(cm, line, -height);
-          regLineChange(cm, no, "widget");
-        });
-        signalLater(cm, "lineWidgetCleared", cm, this, no);
-      }
-    };
-    LineWidget.prototype.changed = function() {
-      var this$1$1 = this;
-      var oldH = this.height, cm = this.doc.cm, line = this.line;
-      this.height = null;
-      var diff = widgetHeight(this) - oldH;
-      if (!diff) {
-        return;
-      }
-      if (!lineIsHidden(this.doc, line)) {
-        updateLineHeight(line, line.height + diff);
-      }
-      if (cm) {
-        runInOp(cm, function() {
-          cm.curOp.forceUpdate = true;
-          adjustScrollWhenAboveVisible(cm, line, diff);
-          signalLater(cm, "lineWidgetChanged", cm, this$1$1, lineNo(line));
-        });
-      }
-    };
-    eventMixin(LineWidget);
-    function adjustScrollWhenAboveVisible(cm, line, diff) {
-      if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
-        addToScrollTop(cm, diff);
-      }
-    }
-    function addLineWidget(doc, handle, node, options) {
-      var widget = new LineWidget(doc, node, options);
-      var cm = doc.cm;
-      if (cm && widget.noHScroll) {
-        cm.display.alignWidgets = true;
-      }
-      changeLine(doc, handle, "widget", function(line) {
-        var widgets = line.widgets || (line.widgets = []);
-        if (widget.insertAt == null) {
-          widgets.push(widget);
-        } else {
-          widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
-        }
-        widget.line = line;
-        if (cm && !lineIsHidden(doc, line)) {
-          var aboveVisible = heightAtLine(line) < doc.scrollTop;
-          updateLineHeight(line, line.height + widgetHeight(widget));
-          if (aboveVisible) {
-            addToScrollTop(cm, widget.height);
-          }
-          cm.curOp.forceUpdate = true;
-        }
-        return true;
-      });
-      if (cm) {
-        signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
-      }
-      return widget;
+    return "restricted_atBlock";
+  };
+
+  states.keyframes = function(type, stream, state) {
+    if (type == "word") { override = "variable"; return "keyframes"; }
+    if (type == "{") return pushContext(state, stream, "top");
+    return pass(type, stream, state);
+  };
+
+  states.at = function(type, stream, state) {
+    if (type == ";") return popContext(state);
+    if (type == "{" || type == "}") return popAndPass(type, stream, state);
+    if (type == "word") override = "tag";
+    else if (type == "hash") override = "builtin";
+    return "at";
+  };
+
+  states.interpolation = function(type, stream, state) {
+    if (type == "}") return popContext(state);
+    if (type == "{" || type == ";") return popAndPass(type, stream, state);
+    if (type == "word") override = "variable";
+    else if (type != "variable" && type != "(" && type != ")") override = "error";
+    return "interpolation";
+  };
+
+  return {
+    startState: function(base) {
+      return {tokenize: null,
+              state: inline ? "block" : "top",
+              stateArg: null,
+              context: new Context(inline ? "block" : "top", base || 0, null)};
+    },
+
+    token: function(stream, state) {
+      if (!state.tokenize && stream.eatSpace()) return null;
+      var style = (state.tokenize || tokenBase)(stream, state);
+      if (style && typeof style == "object") {
+        type = style[1];
+        style = style[0];
+      }
+      override = style;
+      if (type != "comment")
+        state.state = states[state.state](type, stream, state);
+      return override;
+    },
+
+    indent: function(state, textAfter) {
+      var cx = state.context, ch = textAfter && textAfter.charAt(0);
+      var indent = cx.indent;
+      if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
+      if (cx.prev) {
+        if (ch == "}" && (cx.type == "block" || cx.type == "top" ||
+                          cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
+          // Resume indentation from parent context.
+          cx = cx.prev;
+          indent = cx.indent;
+        } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
+            ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
+          // Dedent relative to current context.
+          indent = Math.max(0, cx.indent - indentUnit);
+        }
+      }
+      return indent;
+    },
+
+    electricChars: "}",
+    blockCommentStart: "/*",
+    blockCommentEnd: "*/",
+    blockCommentContinue: " * ",
+    lineComment: lineComment,
+    fold: "brace"
+  };
+});
+
+  function keySet(array) {
+    var keys = {};
+    for (var i = 0; i < array.length; ++i) {
+      keys[array[i].toLowerCase()] = true;
     }
-    var nextMarkerId = 0;
-    var TextMarker = function(doc, type) {
-      this.lines = [];
-      this.type = type;
-      this.doc = doc;
-      this.id = ++nextMarkerId;
-    };
-    TextMarker.prototype.clear = function() {
-      if (this.explicitlyCleared) {
-        return;
-      }
-      var cm = this.doc.cm, withOp = cm && !cm.curOp;
-      if (withOp) {
-        startOperation(cm);
-      }
-      if (hasHandler(this, "clear")) {
-        var found = this.find();
-        if (found) {
-          signalLater(this, "clear", found.from, found.to);
-        }
-      }
-      var min = null, max = null;
-      for (var i2 = 0; i2 < this.lines.length; ++i2) {
-        var line = this.lines[i2];
-        var span = getMarkedSpanFor(line.markedSpans, this);
-        if (cm && !this.collapsed) {
-          regLineChange(cm, lineNo(line), "text");
-        } else if (cm) {
-          if (span.to != null) {
-            max = lineNo(line);
-          }
-          if (span.from != null) {
-            min = lineNo(line);
-          }
-        }
-        line.markedSpans = removeMarkedSpan(line.markedSpans, span);
-        if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
-          updateLineHeight(line, textHeight(cm.display));
-        }
-      }
-      if (cm && this.collapsed && !cm.options.lineWrapping) {
-        for (var i$12 = 0; i$12 < this.lines.length; ++i$12) {
-          var visual = visualLine(this.lines[i$12]), len = lineLength(visual);
-          if (len > cm.display.maxLineLength) {
-            cm.display.maxLine = visual;
-            cm.display.maxLineLength = len;
-            cm.display.maxLineChanged = true;
-          }
-        }
-      }
-      if (min != null && cm && this.collapsed) {
-        regChange(cm, min, max + 1);
-      }
-      this.lines.length = 0;
-      this.explicitlyCleared = true;
-      if (this.atomic && this.doc.cantEdit) {
-        this.doc.cantEdit = false;
-        if (cm) {
-          reCheckSelection(cm.doc);
-        }
-      }
-      if (cm) {
-        signalLater(cm, "markerCleared", cm, this, min, max);
-      }
-      if (withOp) {
-        endOperation(cm);
-      }
-      if (this.parent) {
-        this.parent.clear();
-      }
-    };
-    TextMarker.prototype.find = function(side, lineObj) {
-      if (side == null && this.type == "bookmark") {
-        side = 1;
-      }
-      var from, to;
-      for (var i2 = 0; i2 < this.lines.length; ++i2) {
-        var line = this.lines[i2];
-        var span = getMarkedSpanFor(line.markedSpans, this);
-        if (span.from != null) {
-          from = Pos(lineObj ? line : lineNo(line), span.from);
-          if (side == -1) {
-            return from;
-          }
-        }
-        if (span.to != null) {
-          to = Pos(lineObj ? line : lineNo(line), span.to);
-          if (side == 1) {
-            return to;
-          }
-        }
-      }
-      return from && { from, to };
-    };
-    TextMarker.prototype.changed = function() {
-      var this$1$1 = this;
-      var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
-      if (!pos || !cm) {
-        return;
-      }
-      runInOp(cm, function() {
-        var line = pos.line, lineN = lineNo(pos.line);
-        var view = findViewForLine(cm, lineN);
-        if (view) {
-          clearLineMeasurementCacheFor(view);
-          cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
-        }
-        cm.curOp.updateMaxLine = true;
-        if (!lineIsHidden(widget.doc, line) && widget.height != null) {
-          var oldHeight = widget.height;
-          widget.height = null;
-          var dHeight = widgetHeight(widget) - oldHeight;
-          if (dHeight) {
-            updateLineHeight(line, line.height + dHeight);
-          }
-        }
-        signalLater(cm, "markerChanged", cm, this$1$1);
-      });
-    };
-    TextMarker.prototype.attachLine = function(line) {
-      if (!this.lines.length && this.doc.cm) {
-        var op = this.doc.cm.curOp;
-        if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
-          (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
-        }
-      }
-      this.lines.push(line);
-    };
-    TextMarker.prototype.detachLine = function(line) {
-      this.lines.splice(indexOf(this.lines, line), 1);
-      if (!this.lines.length && this.doc.cm) {
-        var op = this.doc.cm.curOp;
-        (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
-      }
-    };
-    eventMixin(TextMarker);
-    function markText(doc, from, to, options, type) {
-      if (options && options.shared) {
-        return markTextShared(doc, from, to, options, type);
-      }
-      if (doc.cm && !doc.cm.curOp) {
-        return operation(doc.cm, markText)(doc, from, to, options, type);
-      }
-      var marker = new TextMarker(doc, type), diff = cmp(from, to);
-      if (options) {
-        copyObj(options, marker, false);
-      }
-      if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
-        return marker;
-      }
-      if (marker.replacedWith) {
-        marker.collapsed = true;
-        marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
-        if (!options.handleMouseEvents) {
-          marker.widgetNode.setAttribute("cm-ignore-events", "true");
-        }
-        if (options.insertLeft) {
-          marker.widgetNode.insertLeft = true;
-        }
-      }
-      if (marker.collapsed) {
-        if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
-          throw new Error("Inserting collapsed marker partially overlapping an existing one");
-        }
-        seeCollapsedSpans();
-      }
-      if (marker.addToHistory) {
-        addChangeToHistory(doc, { from, to, origin: "markText" }, doc.sel, NaN);
-      }
-      var curLine = from.line, cm = doc.cm, updateMaxLine;
-      doc.iter(curLine, to.line + 1, function(line) {
-        if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
-          updateMaxLine = true;
-        }
-        if (marker.collapsed && curLine != from.line) {
-          updateLineHeight(line, 0);
-        }
-        addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);
-        ++curLine;
-      });
-      if (marker.collapsed) {
-        doc.iter(from.line, to.line + 1, function(line) {
-          if (lineIsHidden(doc, line)) {
-            updateLineHeight(line, 0);
-          }
-        });
-      }
-      if (marker.clearOnEnter) {
-        on(marker, "beforeCursorEnter", function() {
-          return marker.clear();
-        });
-      }
-      if (marker.readOnly) {
-        seeReadOnlySpans();
-        if (doc.history.done.length || doc.history.undone.length) {
-          doc.clearHistory();
-        }
-      }
-      if (marker.collapsed) {
-        marker.id = ++nextMarkerId;
-        marker.atomic = true;
-      }
-      if (cm) {
-        if (updateMaxLine) {
-          cm.curOp.updateMaxLine = true;
-        }
-        if (marker.collapsed) {
-          regChange(cm, from.line, to.line + 1);
-        } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
-          for (var i2 = from.line; i2 <= to.line; i2++) {
-            regLineChange(cm, i2, "text");
-          }
-        }
-        if (marker.atomic) {
-          reCheckSelection(cm.doc);
-        }
-        signalLater(cm, "markerAdded", cm, marker);
-      }
-      return marker;
-    }
-    var SharedTextMarker = function(markers, primary) {
-      this.markers = markers;
-      this.primary = primary;
-      for (var i2 = 0; i2 < markers.length; ++i2) {
-        markers[i2].parent = this;
-      }
-    };
-    SharedTextMarker.prototype.clear = function() {
-      if (this.explicitlyCleared) {
-        return;
-      }
-      this.explicitlyCleared = true;
-      for (var i2 = 0; i2 < this.markers.length; ++i2) {
-        this.markers[i2].clear();
-      }
-      signalLater(this, "clear");
-    };
-    SharedTextMarker.prototype.find = function(side, lineObj) {
-      return this.primary.find(side, lineObj);
-    };
-    eventMixin(SharedTextMarker);
-    function markTextShared(doc, from, to, options, type) {
-      options = copyObj(options);
-      options.shared = false;
-      var markers = [markText(doc, from, to, options, type)], primary = markers[0];
-      var widget = options.widgetNode;
-      linkedDocs(doc, function(doc2) {
-        if (widget) {
-          options.widgetNode = widget.cloneNode(true);
-        }
-        markers.push(markText(doc2, clipPos(doc2, from), clipPos(doc2, to), options, type));
-        for (var i2 = 0; i2 < doc2.linked.length; ++i2) {
-          if (doc2.linked[i2].isParent) {
-            return;
-          }
-        }
-        primary = lst(markers);
-      });
-      return new SharedTextMarker(markers, primary);
-    }
-    function findSharedMarkers(doc) {
-      return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m) {
-        return m.parent;
-      });
-    }
-    function copySharedMarkers(doc, markers) {
-      for (var i2 = 0; i2 < markers.length; i2++) {
-        var marker = markers[i2], pos = marker.find();
-        var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
-        if (cmp(mFrom, mTo)) {
-          var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
-          marker.markers.push(subMark);
-          subMark.parent = marker;
-        }
-      }
-    }
-    function detachSharedMarkers(markers) {
-      var loop = function(i3) {
-        var marker = markers[i3], linked = [marker.primary.doc];
-        linkedDocs(marker.primary.doc, function(d) {
-          return linked.push(d);
-        });
-        for (var j = 0; j < marker.markers.length; j++) {
-          var subMarker = marker.markers[j];
-          if (indexOf(linked, subMarker.doc) == -1) {
-            subMarker.parent = null;
-            marker.markers.splice(j--, 1);
-          }
-        }
-      };
-      for (var i2 = 0; i2 < markers.length; i2++)
-        loop(i2);
-    }
-    var nextDocId = 0;
-    var Doc = function(text, mode, firstLine, lineSep, direction) {
-      if (!(this instanceof Doc)) {
-        return new Doc(text, mode, firstLine, lineSep, direction);
-      }
-      if (firstLine == null) {
-        firstLine = 0;
-      }
-      BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
-      this.first = firstLine;
-      this.scrollTop = this.scrollLeft = 0;
-      this.cantEdit = false;
-      this.cleanGeneration = 1;
-      this.modeFrontier = this.highlightFrontier = firstLine;
-      var start = Pos(firstLine, 0);
-      this.sel = simpleSelection(start);
-      this.history = new History(null);
-      this.id = ++nextDocId;
-      this.modeOption = mode;
-      this.lineSep = lineSep;
-      this.direction = direction == "rtl" ? "rtl" : "ltr";
-      this.extend = false;
-      if (typeof text == "string") {
-        text = this.splitLines(text);
-      }
-      updateDoc(this, { from: start, to: start, text });
-      setSelection(this, simpleSelection(start), sel_dontScroll);
-    };
-    Doc.prototype = createObj(BranchChunk.prototype, {
-      constructor: Doc,
-      iter: function(from, to, op) {
-        if (op) {
-          this.iterN(from - this.first, to - from, op);
-        } else {
-          this.iterN(this.first, this.first + this.size, from);
-        }
-      },
-      insert: function(at, lines) {
-        var height = 0;
-        for (var i2 = 0; i2 < lines.length; ++i2) {
-          height += lines[i2].height;
-        }
-        this.insertInner(at - this.first, lines, height);
-      },
-      remove: function(at, n) {
-        this.removeInner(at - this.first, n);
-      },
-      getValue: function(lineSep) {
-        var lines = getLines(this, this.first, this.first + this.size);
-        if (lineSep === false) {
-          return lines;
-        }
-        return lines.join(lineSep || this.lineSeparator());
-      },
-      setValue: docMethodOp(function(code) {
-        var top = Pos(this.first, 0), last = this.first + this.size - 1;
-        makeChange(this, {
-          from: top,
-          to: Pos(last, getLine(this, last).text.length),
-          text: this.splitLines(code),
-          origin: "setValue",
-          full: true
-        }, true);
-        if (this.cm) {
-          scrollToCoords(this.cm, 0, 0);
-        }
-        setSelection(this, simpleSelection(top), sel_dontScroll);
-      }),
-      replaceRange: function(code, from, to, origin) {
-        from = clipPos(this, from);
-        to = to ? clipPos(this, to) : from;
-        replaceRange(this, code, from, to, origin);
-      },
-      getRange: function(from, to, lineSep) {
-        var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
-        if (lineSep === false) {
-          return lines;
-        }
-        if (lineSep === "") {
-          return lines.join("");
-        }
-        return lines.join(lineSep || this.lineSeparator());
-      },
-      getLine: function(line) {
-        var l = this.getLineHandle(line);
-        return l && l.text;
-      },
-      getLineHandle: function(line) {
-        if (isLine(this, line)) {
-          return getLine(this, line);
-        }
-      },
-      getLineNumber: function(line) {
-        return lineNo(line);
-      },
-      getLineHandleVisualStart: function(line) {
-        if (typeof line == "number") {
-          line = getLine(this, line);
-        }
-        return visualLine(line);
-      },
-      lineCount: function() {
-        return this.size;
-      },
-      firstLine: function() {
-        return this.first;
-      },
-      lastLine: function() {
-        return this.first + this.size - 1;
-      },
-      clipPos: function(pos) {
-        return clipPos(this, pos);
-      },
-      getCursor: function(start) {
-        var range2 = this.sel.primary(), pos;
-        if (start == null || start == "head") {
-          pos = range2.head;
-        } else if (start == "anchor") {
-          pos = range2.anchor;
-        } else if (start == "end" || start == "to" || start === false) {
-          pos = range2.to();
-        } else {
-          pos = range2.from();
-        }
-        return pos;
-      },
-      listSelections: function() {
-        return this.sel.ranges;
-      },
-      somethingSelected: function() {
-        return this.sel.somethingSelected();
-      },
-      setCursor: docMethodOp(function(line, ch, options) {
-        setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
-      }),
-      setSelection: docMethodOp(function(anchor, head, options) {
-        setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
-      }),
-      extendSelection: docMethodOp(function(head, other, options) {
-        extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
-      }),
-      extendSelections: docMethodOp(function(heads, options) {
-        extendSelections(this, clipPosArray(this, heads), options);
-      }),
-      extendSelectionsBy: docMethodOp(function(f, options) {
-        var heads = map(this.sel.ranges, f);
-        extendSelections(this, clipPosArray(this, heads), options);
-      }),
-      setSelections: docMethodOp(function(ranges, primary, options) {
-        if (!ranges.length) {
-          return;
-        }
-        var out = [];
-        for (var i2 = 0; i2 < ranges.length; i2++) {
-          out[i2] = new Range(clipPos(this, ranges[i2].anchor), clipPos(this, ranges[i2].head || ranges[i2].anchor));
-        }
-        if (primary == null) {
-          primary = Math.min(ranges.length - 1, this.sel.primIndex);
-        }
-        setSelection(this, normalizeSelection(this.cm, out, primary), options);
-      }),
-      addSelection: docMethodOp(function(anchor, head, options) {
-        var ranges = this.sel.ranges.slice(0);
-        ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
-        setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
-      }),
-      getSelection: function(lineSep) {
-        var ranges = this.sel.ranges, lines;
-        for (var i2 = 0; i2 < ranges.length; i2++) {
-          var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
-          lines = lines ? lines.concat(sel) : sel;
-        }
-        if (lineSep === false) {
-          return lines;
-        } else {
-          return lines.join(lineSep || this.lineSeparator());
-        }
-      },
-      getSelections: function(lineSep) {
-        var parts = [], ranges = this.sel.ranges;
-        for (var i2 = 0; i2 < ranges.length; i2++) {
-          var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
-          if (lineSep !== false) {
-            sel = sel.join(lineSep || this.lineSeparator());
-          }
-          parts[i2] = sel;
-        }
-        return parts;
-      },
-      replaceSelection: function(code, collapse, origin) {
-        var dup = [];
-        for (var i2 = 0; i2 < this.sel.ranges.length; i2++) {
-          dup[i2] = code;
-        }
-        this.replaceSelections(dup, collapse, origin || "+input");
-      },
-      replaceSelections: docMethodOp(function(code, collapse, origin) {
-        var changes = [], sel = this.sel;
-        for (var i2 = 0; i2 < sel.ranges.length; i2++) {
-          var range2 = sel.ranges[i2];
-          changes[i2] = { from: range2.from(), to: range2.to(), text: this.splitLines(code[i2]), origin };
-        }
-        var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
-        for (var i$12 = changes.length - 1; i$12 >= 0; i$12--) {
-          makeChange(this, changes[i$12]);
-        }
-        if (newSel) {
-          setSelectionReplaceHistory(this, newSel);
-        } else if (this.cm) {
-          ensureCursorVisible(this.cm);
-        }
-      }),
-      undo: docMethodOp(function() {
-        makeChangeFromHistory(this, "undo");
-      }),
-      redo: docMethodOp(function() {
-        makeChangeFromHistory(this, "redo");
-      }),
-      undoSelection: docMethodOp(function() {
-        makeChangeFromHistory(this, "undo", true);
-      }),
-      redoSelection: docMethodOp(function() {
-        makeChangeFromHistory(this, "redo", true);
-      }),
-      setExtending: function(val) {
-        this.extend = val;
-      },
-      getExtending: function() {
-        return this.extend;
-      },
-      historySize: function() {
-        var hist = this.history, done = 0, undone = 0;
-        for (var i2 = 0; i2 < hist.done.length; i2++) {
-          if (!hist.done[i2].ranges) {
-            ++done;
-          }
-        }
-        for (var i$12 = 0; i$12 < hist.undone.length; i$12++) {
-          if (!hist.undone[i$12].ranges) {
-            ++undone;
-          }
-        }
-        return { undo: done, redo: undone };
-      },
-      clearHistory: function() {
-        var this$1$1 = this;
-        this.history = new History(this.history);
-        linkedDocs(this, function(doc) {
-          return doc.history = this$1$1.history;
-        }, true);
-      },
-      markClean: function() {
-        this.cleanGeneration = this.changeGeneration(true);
-      },
-      changeGeneration: function(forceSplit) {
-        if (forceSplit) {
-          this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
-        }
-        return this.history.generation;
-      },
-      isClean: function(gen) {
-        return this.history.generation == (gen || this.cleanGeneration);
-      },
-      getHistory: function() {
-        return {
-          done: copyHistoryArray(this.history.done),
-          undone: copyHistoryArray(this.history.undone)
-        };
-      },
-      setHistory: function(histData) {
-        var hist = this.history = new History(this.history);
-        hist.done = copyHistoryArray(histData.done.slice(0), null, true);
-        hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
-      },
-      setGutterMarker: docMethodOp(function(line, gutterID, value) {
-        return changeLine(this, line, "gutter", function(line2) {
-          var markers = line2.gutterMarkers || (line2.gutterMarkers = {});
-          markers[gutterID] = value;
-          if (!value && isEmpty(markers)) {
-            line2.gutterMarkers = null;
-          }
-          return true;
-        });
-      }),
-      clearGutter: docMethodOp(function(gutterID) {
-        var this$1$1 = this;
-        this.iter(function(line) {
-          if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
-            changeLine(this$1$1, line, "gutter", function() {
-              line.gutterMarkers[gutterID] = null;
-              if (isEmpty(line.gutterMarkers)) {
-                line.gutterMarkers = null;
-              }
-              return true;
-            });
-          }
-        });
-      }),
-      lineInfo: function(line) {
-        var n;
-        if (typeof line == "number") {
-          if (!isLine(this, line)) {
-            return null;
-          }
-          n = line;
-          line = getLine(this, line);
-          if (!line) {
-            return null;
-          }
-        } else {
-          n = lineNo(line);
-          if (n == null) {
-            return null;
-          }
-        }
-        return {
-          line: n,
-          handle: line,
-          text: line.text,
-          gutterMarkers: line.gutterMarkers,
-          textClass: line.textClass,
-          bgClass: line.bgClass,
-          wrapClass: line.wrapClass,
-          widgets: line.widgets
-        };
-      },
-      addLineClass: docMethodOp(function(handle, where, cls) {
-        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
-          var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
-          if (!line[prop2]) {
-            line[prop2] = cls;
-          } else if (classTest(cls).test(line[prop2])) {
-            return false;
-          } else {
-            line[prop2] += " " + cls;
-          }
-          return true;
-        });
-      }),
-      removeLineClass: docMethodOp(function(handle, where, cls) {
-        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
-          var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
-          var cur = line[prop2];
-          if (!cur) {
-            return false;
-          } else if (cls == null) {
-            line[prop2] = null;
-          } else {
-            var found = cur.match(classTest(cls));
-            if (!found) {
-              return false;
-            }
-            var end = found.index + found[0].length;
-            line[prop2] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
-          }
-          return true;
-        });
-      }),
-      addLineWidget: docMethodOp(function(handle, node, options) {
-        return addLineWidget(this, handle, node, options);
-      }),
-      removeLineWidget: function(widget) {
-        widget.clear();
-      },
-      markText: function(from, to, options) {
-        return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
-      },
-      setBookmark: function(pos, options) {
-        var realOpts = {
-          replacedWith: options && (options.nodeType == null ? options.widget : options),
-          insertLeft: options && options.insertLeft,
-          clearWhenEmpty: false,
-          shared: options && options.shared,
-          handleMouseEvents: options && options.handleMouseEvents
-        };
-        pos = clipPos(this, pos);
-        return markText(this, pos, pos, realOpts, "bookmark");
-      },
-      findMarksAt: function(pos) {
-        pos = clipPos(this, pos);
-        var markers = [], spans = getLine(this, pos.line).markedSpans;
-        if (spans) {
-          for (var i2 = 0; i2 < spans.length; ++i2) {
-            var span = spans[i2];
-            if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
-              markers.push(span.marker.parent || span.marker);
-            }
-          }
-        }
-        return markers;
-      },
-      findMarks: function(from, to, filter) {
-        from = clipPos(this, from);
-        to = clipPos(this, to);
-        var found = [], lineNo2 = from.line;
-        this.iter(from.line, to.line + 1, function(line) {
-          var spans = line.markedSpans;
-          if (spans) {
-            for (var i2 = 0; i2 < spans.length; i2++) {
-              var span = spans[i2];
-              if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
-                found.push(span.marker.parent || span.marker);
-              }
-            }
-          }
-          ++lineNo2;
-        });
-        return found;
-      },
-      getAllMarks: function() {
-        var markers = [];
-        this.iter(function(line) {
-          var sps = line.markedSpans;
-          if (sps) {
-            for (var i2 = 0; i2 < sps.length; ++i2) {
-              if (sps[i2].from != null) {
-                markers.push(sps[i2].marker);
-              }
-            }
-          }
-        });
-        return markers;
-      },
-      posFromIndex: function(off2) {
-        var ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;
-        this.iter(function(line) {
-          var sz = line.text.length + sepSize;
-          if (sz > off2) {
-            ch = off2;
-            return true;
-          }
-          off2 -= sz;
-          ++lineNo2;
-        });
-        return clipPos(this, Pos(lineNo2, ch));
-      },
-      indexFromPos: function(coords) {
-        coords = clipPos(this, coords);
-        var index = coords.ch;
-        if (coords.line < this.first || coords.ch < 0) {
-          return 0;
-        }
-        var sepSize = this.lineSeparator().length;
-        this.iter(this.first, coords.line, function(line) {
-          index += line.text.length + sepSize;
-        });
-        return index;
-      },
-      copy: function(copyHistory) {
-        var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
-        doc.scrollTop = this.scrollTop;
-        doc.scrollLeft = this.scrollLeft;
-        doc.sel = this.sel;
-        doc.extend = false;
-        if (copyHistory) {
-          doc.history.undoDepth = this.history.undoDepth;
-          doc.setHistory(this.getHistory());
-        }
-        return doc;
-      },
-      linkedDoc: function(options) {
-        if (!options) {
-          options = {};
-        }
-        var from = this.first, to = this.first + this.size;
-        if (options.from != null && options.from > from) {
-          from = options.from;
-        }
-        if (options.to != null && options.to < to) {
-          to = options.to;
-        }
-        var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
-        if (options.sharedHist) {
-          copy.history = this.history;
-        }
-        (this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options.sharedHist });
-        copy.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
-        copySharedMarkers(copy, findSharedMarkers(this));
-        return copy;
-      },
-      unlinkDoc: function(other) {
-        if (other instanceof CodeMirror2) {
-          other = other.doc;
-        }
-        if (this.linked) {
-          for (var i2 = 0; i2 < this.linked.length; ++i2) {
-            var link = this.linked[i2];
-            if (link.doc != other) {
-              continue;
-            }
-            this.linked.splice(i2, 1);
-            other.unlinkDoc(this);
-            detachSharedMarkers(findSharedMarkers(this));
-            break;
-          }
-        }
-        if (other.history == this.history) {
-          var splitIds = [other.id];
-          linkedDocs(other, function(doc) {
-            return splitIds.push(doc.id);
-          }, true);
-          other.history = new History(null);
-          other.history.done = copyHistoryArray(this.history.done, splitIds);
-          other.history.undone = copyHistoryArray(this.history.undone, splitIds);
-        }
-      },
-      iterLinkedDocs: function(f) {
-        linkedDocs(this, f);
-      },
-      getMode: function() {
-        return this.mode;
-      },
-      getEditor: function() {
-        return this.cm;
-      },
-      splitLines: function(str) {
-        if (this.lineSep) {
-          return str.split(this.lineSep);
-        }
-        return splitLinesAuto(str);
-      },
-      lineSeparator: function() {
-        return this.lineSep || "\n";
-      },
-      setDirection: docMethodOp(function(dir) {
-        if (dir != "rtl") {
-          dir = "ltr";
-        }
-        if (dir == this.direction) {
-          return;
-        }
-        this.direction = dir;
-        this.iter(function(line) {
-          return line.order = null;
-        });
-        if (this.cm) {
-          directionChanged(this.cm);
-        }
-      })
-    });
-    Doc.prototype.eachLine = Doc.prototype.iter;
-    var lastDrop = 0;
-    function onDrop(e) {
-      var cm = this;
-      clearDragCursor(cm);
-      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
-        return;
-      }
-      e_preventDefault(e);
-      if (ie) {
-        lastDrop = +new Date();
-      }
-      var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
-      if (!pos || cm.isReadOnly()) {
-        return;
-      }
-      if (files && files.length && window.FileReader && window.File) {
-        var n = files.length, text = Array(n), read = 0;
-        var markAsReadAndPasteIfAllFilesAreRead = function() {
-          if (++read == n) {
-            operation(cm, function() {
-              pos = clipPos(cm.doc, pos);
-              var change = {
-                from: pos,
-                to: pos,
-                text: cm.doc.splitLines(text.filter(function(t) {
-                  return t != null;
-                }).join(cm.doc.lineSeparator())),
-                origin: "paste"
-              };
-              makeChange(cm.doc, change);
-              setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
-            })();
-          }
-        };
-        var readTextFromFile = function(file, i3) {
-          if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
-            markAsReadAndPasteIfAllFilesAreRead();
-            return;
-          }
-          var reader = new FileReader();
-          reader.onerror = function() {
-            return markAsReadAndPasteIfAllFilesAreRead();
-          };
-          reader.onload = function() {
-            var content = reader.result;
-            if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
-              markAsReadAndPasteIfAllFilesAreRead();
-              return;
-            }
-            text[i3] = content;
-            markAsReadAndPasteIfAllFilesAreRead();
-          };
-          reader.readAsText(file);
-        };
-        for (var i2 = 0; i2 < files.length; i2++) {
-          readTextFromFile(files[i2], i2);
-        }
-      } else {
-        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
-          cm.state.draggingText(e);
-          setTimeout(function() {
-            return cm.display.input.focus();
-          }, 20);
-          return;
-        }
-        try {
-          var text$1 = e.dataTransfer.getData("Text");
-          if (text$1) {
-            var selected;
-            if (cm.state.draggingText && !cm.state.draggingText.copy) {
-              selected = cm.listSelections();
-            }
-            setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
-            if (selected) {
-              for (var i$12 = 0; i$12 < selected.length; ++i$12) {
-                replaceRange(cm.doc, "", selected[i$12].anchor, selected[i$12].head, "drag");
-              }
-            }
-            cm.replaceSelection(text$1, "around", "paste");
-            cm.display.input.focus();
-          }
-        } catch (e$1) {
-        }
-      }
-    }
-    function onDragStart(cm, e) {
-      if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
-        e_stop(e);
-        return;
-      }
-      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
-        return;
-      }
-      e.dataTransfer.setData("Text", cm.getSelection());
-      e.dataTransfer.effectAllowed = "copyMove";
-      if (e.dataTransfer.setDragImage && !safari) {
-        var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
-        img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
-        if (presto) {
-          img.width = img.height = 1;
-          cm.display.wrapper.appendChild(img);
-          img._top = img.offsetTop;
-        }
-        e.dataTransfer.setDragImage(img, 0, 0);
-        if (presto) {
-          img.parentNode.removeChild(img);
-        }
-      }
-    }
-    function onDragOver(cm, e) {
-      var pos = posFromMouse(cm, e);
-      if (!pos) {
-        return;
-      }
-      var frag = document.createDocumentFragment();
-      drawSelectionCursor(cm, pos, frag);
-      if (!cm.display.dragCursor) {
-        cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
-        cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
-      }
-      removeChildrenAndAdd(cm.display.dragCursor, frag);
-    }
-    function clearDragCursor(cm) {
-      if (cm.display.dragCursor) {
-        cm.display.lineSpace.removeChild(cm.display.dragCursor);
-        cm.display.dragCursor = null;
-      }
-    }
-    function forEachCodeMirror(f) {
-      if (!document.getElementsByClassName) {
-        return;
-      }
-      var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
-      for (var i2 = 0; i2 < byClass.length; i2++) {
-        var cm = byClass[i2].CodeMirror;
-        if (cm) {
-          editors.push(cm);
-        }
-      }
-      if (editors.length) {
-        editors[0].operation(function() {
-          for (var i3 = 0; i3 < editors.length; i3++) {
-            f(editors[i3]);
-          }
-        });
-      }
-    }
-    var globalsRegistered = false;
-    function ensureGlobalHandlers() {
-      if (globalsRegistered) {
-        return;
-      }
-      registerGlobalHandlers();
-      globalsRegistered = true;
-    }
-    function registerGlobalHandlers() {
-      var resizeTimer;
-      on(window, "resize", function() {
-        if (resizeTimer == null) {
-          resizeTimer = setTimeout(function() {
-            resizeTimer = null;
-            forEachCodeMirror(onResize);
-          }, 100);
-        }
-      });
-      on(window, "blur", function() {
-        return forEachCodeMirror(onBlur);
-      });
-    }
-    function onResize(cm) {
-      var d = cm.display;
-      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
-      d.scrollbarsClipped = false;
-      cm.setSize();
-    }
-    var keyNames = {
-      3: "Pause",
-      8: "Backspace",
-      9: "Tab",
-      13: "Enter",
-      16: "Shift",
-      17: "Ctrl",
-      18: "Alt",
-      19: "Pause",
-      20: "CapsLock",
-      27: "Esc",
-      32: "Space",
-      33: "PageUp",
-      34: "PageDown",
-      35: "End",
-      36: "Home",
-      37: "Left",
-      38: "Up",
-      39: "Right",
-      40: "Down",
-      44: "PrintScrn",
-      45: "Insert",
-      46: "Delete",
-      59: ";",
-      61: "=",
-      91: "Mod",
-      92: "Mod",
-      93: "Mod",
-      106: "*",
-      107: "=",
-      109: "-",
-      110: ".",
-      111: "/",
-      145: "ScrollLock",
-      173: "-",
-      186: ";",
-      187: "=",
-      188: ",",
-      189: "-",
-      190: ".",
-      191: "/",
-      192: "`",
-      219: "[",
-      220: "\\",
-      221: "]",
-      222: "'",
-      224: "Mod",
-      63232: "Up",
-      63233: "Down",
-      63234: "Left",
-      63235: "Right",
-      63272: "Delete",
-      63273: "Home",
-      63275: "End",
-      63276: "PageUp",
-      63277: "PageDown",
-      63302: "Insert"
-    };
-    for (var i = 0; i < 10; i++) {
-      keyNames[i + 48] = keyNames[i + 96] = String(i);
-    }
-    for (var i$1 = 65; i$1 <= 90; i$1++) {
-      keyNames[i$1] = String.fromCharCode(i$1);
-    }
-    for (var i$2 = 1; i$2 <= 12; i$2++) {
-      keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
-    }
-    var keyMap = {};
-    keyMap.basic = {
-      "Left": "goCharLeft",
-      "Right": "goCharRight",
-      "Up": "goLineUp",
-      "Down": "goLineDown",
-      "End": "goLineEnd",
-      "Home": "goLineStartSmart",
-      "PageUp": "goPageUp",
-      "PageDown": "goPageDown",
-      "Delete": "delCharAfter",
-      "Backspace": "delCharBefore",
-      "Shift-Backspace": "delCharBefore",
-      "Tab": "defaultTab",
-      "Shift-Tab": "indentAuto",
-      "Enter": "newlineAndIndent",
-      "Insert": "toggleOverwrite",
-      "Esc": "singleSelection"
-    };
-    keyMap.pcDefault = {
-      "Ctrl-A": "selectAll",
-      "Ctrl-D": "deleteLine",
-      "Ctrl-Z": "undo",
-      "Shift-Ctrl-Z": "redo",
-      "Ctrl-Y": "redo",
-      "Ctrl-Home": "goDocStart",
-      "Ctrl-End": "goDocEnd",
-      "Ctrl-Up": "goLineUp",
-      "Ctrl-Down": "goLineDown",
-      "Ctrl-Left": "goGroupLeft",
-      "Ctrl-Right": "goGroupRight",
-      "Alt-Left": "goLineStart",
-      "Alt-Right": "goLineEnd",
-      "Ctrl-Backspace": "delGroupBefore",
-      "Ctrl-Delete": "delGroupAfter",
-      "Ctrl-S": "save",
-      "Ctrl-F": "find",
-      "Ctrl-G": "findNext",
-      "Shift-Ctrl-G": "findPrev",
-      "Shift-Ctrl-F": "replace",
-      "Shift-Ctrl-R": "replaceAll",
-      "Ctrl-[": "indentLess",
-      "Ctrl-]": "indentMore",
-      "Ctrl-U": "undoSelection",
-      "Shift-Ctrl-U": "redoSelection",
-      "Alt-U": "redoSelection",
-      "fallthrough": "basic"
-    };
-    keyMap.emacsy = {
-      "Ctrl-F": "goCharRight",
-      "Ctrl-B": "goCharLeft",
-      "Ctrl-P": "goLineUp",
-      "Ctrl-N": "goLineDown",
-      "Ctrl-A": "goLineStart",
-      "Ctrl-E": "goLineEnd",
-      "Ctrl-V": "goPageDown",
-      "Shift-Ctrl-V": "goPageUp",
-      "Ctrl-D": "delCharAfter",
-      "Ctrl-H": "delCharBefore",
-      "Alt-Backspace": "delWordBefore",
-      "Ctrl-K": "killLine",
-      "Ctrl-T": "transposeChars",
-      "Ctrl-O": "openLine"
-    };
-    keyMap.macDefault = {
-      "Cmd-A": "selectAll",
-      "Cmd-D": "deleteLine",
-      "Cmd-Z": "undo",
-      "Shift-Cmd-Z": "redo",
-      "Cmd-Y": "redo",
-      "Cmd-Home": "goDocStart",
-      "Cmd-Up": "goDocStart",
-      "Cmd-End": "goDocEnd",
-      "Cmd-Down": "goDocEnd",
-      "Alt-Left": "goGroupLeft",
-      "Alt-Right": "goGroupRight",
-      "Cmd-Left": "goLineLeft",
-      "Cmd-Right": "goLineRight",
-      "Alt-Backspace": "delGroupBefore",
-      "Ctrl-Alt-Backspace": "delGroupAfter",
-      "Alt-Delete": "delGroupAfter",
-      "Cmd-S": "save",
-      "Cmd-F": "find",
-      "Cmd-G": "findNext",
-      "Shift-Cmd-G": "findPrev",
-      "Cmd-Alt-F": "replace",
-      "Shift-Cmd-Alt-F": "replaceAll",
-      "Cmd-[": "indentLess",
-      "Cmd-]": "indentMore",
-      "Cmd-Backspace": "delWrappedLineLeft",
-      "Cmd-Delete": "delWrappedLineRight",
-      "Cmd-U": "undoSelection",
-      "Shift-Cmd-U": "redoSelection",
-      "Ctrl-Up": "goDocStart",
-      "Ctrl-Down": "goDocEnd",
-      "fallthrough": ["basic", "emacsy"]
-    };
-    keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
-    function normalizeKeyName(name) {
-      var parts = name.split(/-(?!$)/);
-      name = parts[parts.length - 1];
-      var alt, ctrl, shift, cmd;
-      for (var i2 = 0; i2 < parts.length - 1; i2++) {
-        var mod = parts[i2];
-        if (/^(cmd|meta|m)$/i.test(mod)) {
-          cmd = true;
-        } else if (/^a(lt)?$/i.test(mod)) {
-          alt = true;
-        } else if (/^(c|ctrl|control)$/i.test(mod)) {
-          ctrl = true;
-        } else if (/^s(hift)?$/i.test(mod)) {
-          shift = true;
-        } else {
-          throw new Error("Unrecognized modifier name: " + mod);
-        }
-      }
-      if (alt) {
-        name = "Alt-" + name;
-      }
-      if (ctrl) {
-        name = "Ctrl-" + name;
-      }
-      if (cmd) {
-        name = "Cmd-" + name;
-      }
-      if (shift) {
-        name = "Shift-" + name;
-      }
-      return name;
-    }
-    function normalizeKeyMap(keymap) {
-      var copy = {};
-      for (var keyname in keymap) {
-        if (keymap.hasOwnProperty(keyname)) {
-          var value = keymap[keyname];
-          if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
-            continue;
-          }
-          if (value == "...") {
-            delete keymap[keyname];
-            continue;
-          }
-          var keys = map(keyname.split(" "), normalizeKeyName);
-          for (var i2 = 0; i2 < keys.length; i2++) {
-            var val = void 0, name = void 0;
-            if (i2 == keys.length - 1) {
-              name = keys.join(" ");
-              val = value;
-            } else {
-              name = keys.slice(0, i2 + 1).join(" ");
-              val = "...";
-            }
-            var prev = copy[name];
-            if (!prev) {
-              copy[name] = val;
-            } else if (prev != val) {
-              throw new Error("Inconsistent bindings for " + name);
-            }
-          }
-          delete keymap[keyname];
-        }
-      }
-      for (var prop2 in copy) {
-        keymap[prop2] = copy[prop2];
-      }
-      return keymap;
-    }
-    function lookupKey(key, map2, handle, context) {
-      map2 = getKeyMap(map2);
-      var found = map2.call ? map2.call(key, context) : map2[key];
-      if (found === false) {
-        return "nothing";
-      }
-      if (found === "...") {
-        return "multi";
-      }
-      if (found != null && handle(found)) {
-        return "handled";
-      }
-      if (map2.fallthrough) {
-        if (Object.prototype.toString.call(map2.fallthrough) != "[object Array]") {
-          return lookupKey(key, map2.fallthrough, handle, context);
-        }
-        for (var i2 = 0; i2 < map2.fallthrough.length; i2++) {
-          var result = lookupKey(key, map2.fallthrough[i2], handle, context);
-          if (result) {
-            return result;
-          }
-        }
-      }
-    }
-    function isModifierKey(value) {
-      var name = typeof value == "string" ? value : keyNames[value.keyCode];
-      return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
-    }
-    function addModifierNames(name, event2, noShift) {
-      var base = name;
-      if (event2.altKey && base != "Alt") {
-        name = "Alt-" + name;
-      }
-      if ((flipCtrlCmd ? event2.metaKey : event2.ctrlKey) && base != "Ctrl") {
-        name = "Ctrl-" + name;
-      }
-      if ((flipCtrlCmd ? event2.ctrlKey : event2.metaKey) && base != "Mod") {
-        name = "Cmd-" + name;
-      }
-      if (!noShift && event2.shiftKey && base != "Shift") {
-        name = "Shift-" + name;
-      }
-      return name;
-    }
-    function keyName(event2, noShift) {
-      if (presto && event2.keyCode == 34 && event2["char"]) {
-        return false;
-      }
-      var name = keyNames[event2.keyCode];
-      if (name == null || event2.altGraphKey) {
-        return false;
-      }
-      if (event2.keyCode == 3 && event2.code) {
-        name = event2.code;
-      }
-      return addModifierNames(name, event2, noShift);
-    }
-    function getKeyMap(val) {
-      return typeof val == "string" ? keyMap[val] : val;
-    }
-    function deleteNearSelection(cm, compute) {
-      var ranges = cm.doc.sel.ranges, kill = [];
-      for (var i2 = 0; i2 < ranges.length; i2++) {
-        var toKill = compute(ranges[i2]);
-        while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
-          var replaced = kill.pop();
-          if (cmp(replaced.from, toKill.from) < 0) {
-            toKill.from = replaced.from;
-            break;
-          }
-        }
-        kill.push(toKill);
-      }
-      runInOp(cm, function() {
-        for (var i3 = kill.length - 1; i3 >= 0; i3--) {
-          replaceRange(cm.doc, "", kill[i3].from, kill[i3].to, "+delete");
-        }
-        ensureCursorVisible(cm);
-      });
-    }
-    function moveCharLogically(line, ch, dir) {
-      var target = skipExtendingChars(line.text, ch + dir, dir);
-      return target < 0 || target > line.text.length ? null : target;
-    }
-    function moveLogically(line, start, dir) {
-      var ch = moveCharLogically(line, start.ch, dir);
-      return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
-    }
-    function endOfLine(visually, cm, lineObj, lineNo2, dir) {
-      if (visually) {
-        if (cm.doc.direction == "rtl") {
-          dir = -dir;
-        }
-        var order = getOrder(lineObj, cm.doc.direction);
-        if (order) {
-          var part = dir < 0 ? lst(order) : order[0];
-          var moveInStorageOrder = dir < 0 == (part.level == 1);
-          var sticky = moveInStorageOrder ? "after" : "before";
-          var ch;
-          if (part.level > 0 || cm.doc.direction == "rtl") {
-            var prep = prepareMeasureForLine(cm, lineObj);
-            ch = dir < 0 ? lineObj.text.length - 1 : 0;
-            var targetTop = measureCharPrepared(cm, prep, ch).top;
-            ch = findFirst(function(ch2) {
-              return measureCharPrepared(cm, prep, ch2).top == targetTop;
-            }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
-            if (sticky == "before") {
-              ch = moveCharLogically(lineObj, ch, 1);
-            }
-          } else {
-            ch = dir < 0 ? part.to : part.from;
-          }
-          return new Pos(lineNo2, ch, sticky);
-        }
-      }
-      return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
-    }
-    function moveVisually(cm, line, start, dir) {
-      var bidi = getOrder(line, cm.doc.direction);
-      if (!bidi) {
-        return moveLogically(line, start, dir);
-      }
-      if (start.ch >= line.text.length) {
-        start.ch = line.text.length;
-        start.sticky = "before";
-      } else if (start.ch <= 0) {
-        start.ch = 0;
-        start.sticky = "after";
-      }
-      var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
-      if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
-        return moveLogically(line, start, dir);
-      }
-      var mv = function(pos, dir2) {
-        return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);
-      };
-      var prep;
-      var getWrappedLineExtent = function(ch2) {
-        if (!cm.options.lineWrapping) {
-          return { begin: 0, end: line.text.length };
-        }
-        prep = prep || prepareMeasureForLine(cm, line);
-        return wrappedLineExtentChar(cm, line, prep, ch2);
-      };
-      var wrappedLineExtent2 = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);
-      if (cm.doc.direction == "rtl" || part.level == 1) {
-        var moveInStorageOrder = part.level == 1 == dir < 0;
-        var ch = mv(start, moveInStorageOrder ? 1 : -1);
-        if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent2.begin : ch <= part.to && ch <= wrappedLineExtent2.end)) {
-          var sticky = moveInStorageOrder ? "before" : "after";
-          return new Pos(start.line, ch, sticky);
-        }
-      }
-      var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {
-        var getRes = function(ch3, moveInStorageOrder3) {
-          return moveInStorageOrder3 ? new Pos(start.line, mv(ch3, 1), "before") : new Pos(start.line, ch3, "after");
-        };
-        for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
-          var part2 = bidi[partPos2];
-          var moveInStorageOrder2 = dir2 > 0 == (part2.level != 1);
-          var ch2 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
-          if (part2.from <= ch2 && ch2 < part2.to) {
-            return getRes(ch2, moveInStorageOrder2);
-          }
-          ch2 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);
-          if (wrappedLineExtent3.begin <= ch2 && ch2 < wrappedLineExtent3.end) {
-            return getRes(ch2, moveInStorageOrder2);
-          }
-        }
-      };
-      var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);
-      if (res) {
-        return res;
-      }
-      var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
-      if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
-        res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
-        if (res) {
-          return res;
-        }
-      }
-      return null;
-    }
-    var commands = {
-      selectAll,
-      singleSelection: function(cm) {
-        return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
-      },
-      killLine: function(cm) {
-        return deleteNearSelection(cm, function(range2) {
-          if (range2.empty()) {
-            var len = getLine(cm.doc, range2.head.line).text.length;
-            if (range2.head.ch == len && range2.head.line < cm.lastLine()) {
-              return { from: range2.head, to: Pos(range2.head.line + 1, 0) };
-            } else {
-              return { from: range2.head, to: Pos(range2.head.line, len) };
-            }
-          } else {
-            return { from: range2.from(), to: range2.to() };
-          }
-        });
-      },
-      deleteLine: function(cm) {
-        return deleteNearSelection(cm, function(range2) {
-          return {
-            from: Pos(range2.from().line, 0),
-            to: clipPos(cm.doc, Pos(range2.to().line + 1, 0))
-          };
-        });
-      },
-      delLineLeft: function(cm) {
-        return deleteNearSelection(cm, function(range2) {
-          return {
-            from: Pos(range2.from().line, 0),
-            to: range2.from()
-          };
-        });
-      },
-      delWrappedLineLeft: function(cm) {
-        return deleteNearSelection(cm, function(range2) {
-          var top = cm.charCoords(range2.head, "div").top + 5;
-          var leftPos = cm.coordsChar({ left: 0, top }, "div");
-          return { from: leftPos, to: range2.from() };
-        });
-      },
-      delWrappedLineRight: function(cm) {
-        return deleteNearSelection(cm, function(range2) {
-          var top = cm.charCoords(range2.head, "div").top + 5;
-          var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
-          return { from: range2.from(), to: rightPos };
-        });
-      },
-      undo: function(cm) {
-        return cm.undo();
-      },
-      redo: function(cm) {
-        return cm.redo();
-      },
-      undoSelection: function(cm) {
-        return cm.undoSelection();
-      },
-      redoSelection: function(cm) {
-        return cm.redoSelection();
-      },
-      goDocStart: function(cm) {
-        return cm.extendSelection(Pos(cm.firstLine(), 0));
-      },
-      goDocEnd: function(cm) {
-        return cm.extendSelection(Pos(cm.lastLine()));
-      },
-      goLineStart: function(cm) {
-        return cm.extendSelectionsBy(function(range2) {
-          return lineStart(cm, range2.head.line);
-        }, { origin: "+move", bias: 1 });
-      },
-      goLineStartSmart: function(cm) {
-        return cm.extendSelectionsBy(function(range2) {
-          return lineStartSmart(cm, range2.head);
-        }, { origin: "+move", bias: 1 });
-      },
-      goLineEnd: function(cm) {
-        return cm.extendSelectionsBy(function(range2) {
-          return lineEnd(cm, range2.head.line);
-        }, { origin: "+move", bias: -1 });
-      },
-      goLineRight: function(cm) {
-        return cm.extendSelectionsBy(function(range2) {
-          var top = cm.cursorCoords(range2.head, "div").top + 5;
-          return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
-        }, sel_move);
-      },
-      goLineLeft: function(cm) {
-        return cm.extendSelectionsBy(function(range2) {
-          var top = cm.cursorCoords(range2.head, "div").top + 5;
-          return cm.coordsChar({ left: 0, top }, "div");
-        }, sel_move);
-      },
-      goLineLeftSmart: function(cm) {
-        return cm.extendSelectionsBy(function(range2) {
-          var top = cm.cursorCoords(range2.head, "div").top + 5;
-          var pos = cm.coordsChar({ left: 0, top }, "div");
-          if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
-            return lineStartSmart(cm, range2.head);
-          }
-          return pos;
-        }, sel_move);
-      },
-      goLineUp: function(cm) {
-        return cm.moveV(-1, "line");
-      },
-      goLineDown: function(cm) {
-        return cm.moveV(1, "line");
-      },
-      goPageUp: function(cm) {
-        return cm.moveV(-1, "page");
-      },
-      goPageDown: function(cm) {
-        return cm.moveV(1, "page");
-      },
-      goCharLeft: function(cm) {
-        return cm.moveH(-1, "char");
-      },
-      goCharRight: function(cm) {
-        return cm.moveH(1, "char");
-      },
-      goColumnLeft: function(cm) {
-        return cm.moveH(-1, "column");
-      },
-      goColumnRight: function(cm) {
-        return cm.moveH(1, "column");
-      },
-      goWordLeft: function(cm) {
-        return cm.moveH(-1, "word");
-      },
-      goGroupRight: function(cm) {
-        return cm.moveH(1, "group");
-      },
-      goGroupLeft: function(cm) {
-        return cm.moveH(-1, "group");
-      },
-      goWordRight: function(cm) {
-        return cm.moveH(1, "word");
-      },
-      delCharBefore: function(cm) {
-        return cm.deleteH(-1, "codepoint");
-      },
-      delCharAfter: function(cm) {
-        return cm.deleteH(1, "char");
-      },
-      delWordBefore: function(cm) {
-        return cm.deleteH(-1, "word");
-      },
-      delWordAfter: function(cm) {
-        return cm.deleteH(1, "word");
-      },
-      delGroupBefore: function(cm) {
-        return cm.deleteH(-1, "group");
-      },
-      delGroupAfter: function(cm) {
-        return cm.deleteH(1, "group");
-      },
-      indentAuto: function(cm) {
-        return cm.indentSelection("smart");
-      },
-      indentMore: function(cm) {
-        return cm.indentSelection("add");
-      },
-      indentLess: function(cm) {
-        return cm.indentSelection("subtract");
-      },
-      insertTab: function(cm) {
-        return cm.replaceSelection("	");
-      },
-      insertSoftTab: function(cm) {
-        var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
-        for (var i2 = 0; i2 < ranges.length; i2++) {
-          var pos = ranges[i2].from();
-          var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
-          spaces.push(spaceStr(tabSize - col % tabSize));
-        }
-        cm.replaceSelections(spaces);
-      },
-      defaultTab: function(cm) {
-        if (cm.somethingSelected()) {
-          cm.indentSelection("add");
-        } else {
-          cm.execCommand("insertTab");
-        }
-      },
-      transposeChars: function(cm) {
-        return runInOp(cm, function() {
-          var ranges = cm.listSelections(), newSel = [];
-          for (var i2 = 0; i2 < ranges.length; i2++) {
-            if (!ranges[i2].empty()) {
-              continue;
-            }
-            var cur = ranges[i2].head, line = getLine(cm.doc, cur.line).text;
-            if (line) {
-              if (cur.ch == line.length) {
-                cur = new Pos(cur.line, cur.ch - 1);
-              }
-              if (cur.ch > 0) {
-                cur = new Pos(cur.line, cur.ch + 1);
-                cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
-              } else if (cur.line > cm.doc.first) {
-                var prev = getLine(cm.doc, cur.line - 1).text;
-                if (prev) {
-                  cur = new Pos(cur.line, 1);
-                  cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
-                }
-              }
-            }
-            newSel.push(new Range(cur, cur));
-          }
-          cm.setSelections(newSel);
-        });
-      },
-      newlineAndIndent: function(cm) {
-        return runInOp(cm, function() {
-          var sels = cm.listSelections();
-          for (var i2 = sels.length - 1; i2 >= 0; i2--) {
-            cm.replaceRange(cm.doc.lineSeparator(), sels[i2].anchor, sels[i2].head, "+input");
-          }
-          sels = cm.listSelections();
-          for (var i$12 = 0; i$12 < sels.length; i$12++) {
-            cm.indentLine(sels[i$12].from().line, null, true);
-          }
-          ensureCursorVisible(cm);
-        });
-      },
-      openLine: function(cm) {
-        return cm.replaceSelection("\n", "start");
-      },
-      toggleOverwrite: function(cm) {
-        return cm.toggleOverwrite();
-      }
-    };
-    function lineStart(cm, lineN) {
-      var line = getLine(cm.doc, lineN);
-      var visual = visualLine(line);
-      if (visual != line) {
-        lineN = lineNo(visual);
-      }
-      return endOfLine(true, cm, visual, lineN, 1);
-    }
-    function lineEnd(cm, lineN) {
-      var line = getLine(cm.doc, lineN);
-      var visual = visualLineEnd(line);
-      if (visual != line) {
-        lineN = lineNo(visual);
-      }
-      return endOfLine(true, cm, line, lineN, -1);
-    }
-    function lineStartSmart(cm, pos) {
-      var start = lineStart(cm, pos.line);
-      var line = getLine(cm.doc, start.line);
-      var order = getOrder(line, cm.doc.direction);
-      if (!order || order[0].level == 0) {
-        var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
-        var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
-        return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
-      }
-      return start;
-    }
-    function doHandleBinding(cm, bound, dropShift) {
-      if (typeof bound == "string") {
-        bound = commands[bound];
-        if (!bound) {
-          return false;
-        }
-      }
-      cm.display.input.ensurePolled();
-      var prevShift = cm.display.shift, done = false;
-      try {
-        if (cm.isReadOnly()) {
-          cm.state.suppressEdits = true;
-        }
-        if (dropShift) {
-          cm.display.shift = false;
-        }
-        done = bound(cm) != Pass;
-      } finally {
-        cm.display.shift = prevShift;
-        cm.state.suppressEdits = false;
-      }
-      return done;
-    }
-    function lookupKeyForEditor(cm, name, handle) {
-      for (var i2 = 0; i2 < cm.state.keyMaps.length; i2++) {
-        var result = lookupKey(name, cm.state.keyMaps[i2], handle, cm);
-        if (result) {
-          return result;
-        }
-      }
-      return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
-    }
-    var stopSeq = new Delayed();
-    function dispatchKey(cm, name, e, handle) {
-      var seq = cm.state.keySeq;
-      if (seq) {
-        if (isModifierKey(name)) {
-          return "handled";
-        }
-        if (/\'$/.test(name)) {
-          cm.state.keySeq = null;
-        } else {
-          stopSeq.set(50, function() {
-            if (cm.state.keySeq == seq) {
-              cm.state.keySeq = null;
-              cm.display.input.reset();
-            }
-          });
-        }
-        if (dispatchKeyInner(cm, seq + " " + name, e, handle)) {
-          return true;
-        }
-      }
-      return dispatchKeyInner(cm, name, e, handle);
-    }
-    function dispatchKeyInner(cm, name, e, handle) {
-      var result = lookupKeyForEditor(cm, name, handle);
-      if (result == "multi") {
-        cm.state.keySeq = name;
-      }
-      if (result == "handled") {
-        signalLater(cm, "keyHandled", cm, name, e);
-      }
-      if (result == "handled" || result == "multi") {
-        e_preventDefault(e);
-        restartBlink(cm);
-      }
-      return !!result;
-    }
-    function handleKeyBinding(cm, e) {
-      var name = keyName(e, true);
-      if (!name) {
-        return false;
-      }
-      if (e.shiftKey && !cm.state.keySeq) {
-        return dispatchKey(cm, "Shift-" + name, e, function(b) {
-          return doHandleBinding(cm, b, true);
-        }) || dispatchKey(cm, name, e, function(b) {
-          if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
-            return doHandleBinding(cm, b);
-          }
-        });
-      } else {
-        return dispatchKey(cm, name, e, function(b) {
-          return doHandleBinding(cm, b);
-        });
-      }
-    }
-    function handleCharBinding(cm, e, ch) {
-      return dispatchKey(cm, "'" + ch + "'", e, function(b) {
-        return doHandleBinding(cm, b, true);
-      });
-    }
-    var lastStoppedKey = null;
-    function onKeyDown(e) {
-      var cm = this;
-      if (e.target && e.target != cm.display.input.getField()) {
-        return;
-      }
-      cm.curOp.focus = activeElt();
-      if (signalDOMEvent(cm, e)) {
-        return;
-      }
-      if (ie && ie_version < 11 && e.keyCode == 27) {
-        e.returnValue = false;
-      }
-      var code = e.keyCode;
-      cm.display.shift = code == 16 || e.shiftKey;
-      var handled = handleKeyBinding(cm, e);
-      if (presto) {
-        lastStoppedKey = handled ? code : null;
-        if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
-          cm.replaceSelection("", null, "cut");
-        }
-      }
-      if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
-        document.execCommand("cut");
-      }
-      if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
-        showCrossHair(cm);
-      }
-    }
-    function showCrossHair(cm) {
-      var lineDiv = cm.display.lineDiv;
-      addClass(lineDiv, "CodeMirror-crosshair");
-      function up(e) {
-        if (e.keyCode == 18 || !e.altKey) {
-          rmClass(lineDiv, "CodeMirror-crosshair");
-          off(document, "keyup", up);
-          off(document, "mouseover", up);
-        }
-      }
-      on(document, "keyup", up);
-      on(document, "mouseover", up);
-    }
-    function onKeyUp(e) {
-      if (e.keyCode == 16) {
-        this.doc.sel.shift = false;
-      }
-      signalDOMEvent(this, e);
-    }
-    function onKeyPress(e) {
-      var cm = this;
-      if (e.target && e.target != cm.display.input.getField()) {
-        return;
-      }
-      if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
-        return;
-      }
-      var keyCode = e.keyCode, charCode = e.charCode;
-      if (presto && keyCode == lastStoppedKey) {
-        lastStoppedKey = null;
-        e_preventDefault(e);
-        return;
-      }
-      if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
-        return;
-      }
-      var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
-      if (ch == "\b") {
-        return;
-      }
-      if (handleCharBinding(cm, e, ch)) {
-        return;
-      }
-      cm.display.input.onKeyPress(e);
-    }
-    var DOUBLECLICK_DELAY = 400;
-    var PastClick = function(time, pos, button) {
-      this.time = time;
-      this.pos = pos;
-      this.button = button;
-    };
-    PastClick.prototype.compare = function(time, pos, button) {
-      return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
-    };
-    var lastClick, lastDoubleClick;
-    function clickRepeat(pos, button) {
-      var now = +new Date();
-      if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
-        lastClick = lastDoubleClick = null;
-        return "triple";
-      } else if (lastClick && lastClick.compare(now, pos, button)) {
-        lastDoubleClick = new PastClick(now, pos, button);
-        lastClick = null;
-        return "double";
-      } else {
-        lastClick = new PastClick(now, pos, button);
-        lastDoubleClick = null;
-        return "single";
-      }
-    }
-    function onMouseDown(e) {
-      var cm = this, display = cm.display;
-      if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
-        return;
-      }
-      display.input.ensurePolled();
-      display.shift = e.shiftKey;
-      if (eventInWidget(display, e)) {
-        if (!webkit) {
-          display.scroller.draggable = false;
-          setTimeout(function() {
-            return display.scroller.draggable = true;
-          }, 100);
-        }
-        return;
-      }
-      if (clickInGutter(cm, e)) {
-        return;
-      }
-      var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
-      window.focus();
-      if (button == 1 && cm.state.selectingText) {
-        cm.state.selectingText(e);
-      }
-      if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
-        return;
-      }
-      if (button == 1) {
-        if (pos) {
-          leftButtonDown(cm, pos, repeat, e);
-        } else if (e_target(e) == display.scroller) {
-          e_preventDefault(e);
-        }
-      } else if (button == 2) {
-        if (pos) {
-          extendSelection(cm.doc, pos);
-        }
-        setTimeout(function() {
-          return display.input.focus();
-        }, 20);
-      } else if (button == 3) {
-        if (captureRightClick) {
-          cm.display.input.onContextMenu(e);
-        } else {
-          delayBlurEvent(cm);
-        }
-      }
-    }
-    function handleMappedButton(cm, button, pos, repeat, event2) {
-      var name = "Click";
-      if (repeat == "double") {
-        name = "Double" + name;
-      } else if (repeat == "triple") {
-        name = "Triple" + name;
-      }
-      name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
-      return dispatchKey(cm, addModifierNames(name, event2), event2, function(bound) {
-        if (typeof bound == "string") {
-          bound = commands[bound];
-        }
-        if (!bound) {
-          return false;
-        }
-        var done = false;
-        try {
-          if (cm.isReadOnly()) {
-            cm.state.suppressEdits = true;
-          }
-          done = bound(cm, pos) != Pass;
-        } finally {
-          cm.state.suppressEdits = false;
-        }
-        return done;
-      });
-    }
-    function configureMouse(cm, repeat, event2) {
-      var option = cm.getOption("configureMouse");
-      var value = option ? option(cm, repeat, event2) : {};
-      if (value.unit == null) {
-        var rect = chromeOS ? event2.shiftKey && event2.metaKey : event2.altKey;
-        value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
-      }
-      if (value.extend == null || cm.doc.extend) {
-        value.extend = cm.doc.extend || event2.shiftKey;
-      }
-      if (value.addNew == null) {
-        value.addNew = mac ? event2.metaKey : event2.ctrlKey;
-      }
-      if (value.moveOnDrag == null) {
-        value.moveOnDrag = !(mac ? event2.altKey : event2.ctrlKey);
-      }
-      return value;
-    }
-    function leftButtonDown(cm, pos, repeat, event2) {
-      if (ie) {
-        setTimeout(bind(ensureFocus, cm), 0);
-      } else {
-        cm.curOp.focus = activeElt();
-      }
-      var behavior = configureMouse(cm, repeat, event2);
-      var sel = cm.doc.sel, contained;
-      if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
-        leftButtonStartDrag(cm, event2, pos, behavior);
-      } else {
-        leftButtonSelect(cm, event2, pos, behavior);
-      }
-    }
-    function leftButtonStartDrag(cm, event2, pos, behavior) {
-      var display = cm.display, moved = false;
-      var dragEnd = operation(cm, function(e) {
-        if (webkit) {
-          display.scroller.draggable = false;
-        }
-        cm.state.draggingText = false;
-        if (cm.state.delayingBlurEvent) {
-          if (cm.hasFocus()) {
-            cm.state.delayingBlurEvent = false;
-          } else {
-            delayBlurEvent(cm);
-          }
-        }
-        off(display.wrapper.ownerDocument, "mouseup", dragEnd);
-        off(display.wrapper.ownerDocument, "mousemove", mouseMove);
-        off(display.scroller, "dragstart", dragStart);
-        off(display.scroller, "drop", dragEnd);
-        if (!moved) {
-          e_preventDefault(e);
-          if (!behavior.addNew) {
-            extendSelection(cm.doc, pos, null, null, behavior.extend);
-          }
-          if (webkit && !safari || ie && ie_version == 9) {
-            setTimeout(function() {
-              display.wrapper.ownerDocument.body.focus({ preventScroll: true });
-              display.input.focus();
-            }, 20);
-          } else {
-            display.input.focus();
-          }
-        }
-      });
-      var mouseMove = function(e2) {
-        moved = moved || Math.abs(event2.clientX - e2.clientX) + Math.abs(event2.clientY - e2.clientY) >= 10;
-      };
-      var dragStart = function() {
-        return moved = true;
-      };
-      if (webkit) {
-        display.scroller.draggable = true;
-      }
-      cm.state.draggingText = dragEnd;
-      dragEnd.copy = !behavior.moveOnDrag;
-      on(display.wrapper.ownerDocument, "mouseup", dragEnd);
-      on(display.wrapper.ownerDocument, "mousemove", mouseMove);
-      on(display.scroller, "dragstart", dragStart);
-      on(display.scroller, "drop", dragEnd);
-      cm.state.delayingBlurEvent = true;
-      setTimeout(function() {
-        return display.input.focus();
-      }, 20);
-      if (display.scroller.dragDrop) {
-        display.scroller.dragDrop();
-      }
-    }
-    function rangeForUnit(cm, pos, unit) {
-      if (unit == "char") {
-        return new Range(pos, pos);
-      }
-      if (unit == "word") {
-        return cm.findWordAt(pos);
-      }
-      if (unit == "line") {
-        return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
-      }
-      var result = unit(cm, pos);
-      return new Range(result.from, result.to);
-    }
-    function leftButtonSelect(cm, event2, start, behavior) {
-      if (ie) {
-        delayBlurEvent(cm);
-      }
-      var display = cm.display, doc = cm.doc;
-      e_preventDefault(event2);
-      var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
-      if (behavior.addNew && !behavior.extend) {
-        ourIndex = doc.sel.contains(start);
-        if (ourIndex > -1) {
-          ourRange = ranges[ourIndex];
-        } else {
-          ourRange = new Range(start, start);
-        }
-      } else {
-        ourRange = doc.sel.primary();
-        ourIndex = doc.sel.primIndex;
-      }
-      if (behavior.unit == "rectangle") {
-        if (!behavior.addNew) {
-          ourRange = new Range(start, start);
-        }
-        start = posFromMouse(cm, event2, true, true);
-        ourIndex = -1;
-      } else {
-        var range2 = rangeForUnit(cm, start, behavior.unit);
-        if (behavior.extend) {
-          ourRange = extendRange(ourRange, range2.anchor, range2.head, behavior.extend);
-        } else {
-          ourRange = range2;
-        }
-      }
-      if (!behavior.addNew) {
-        ourIndex = 0;
-        setSelection(doc, new Selection([ourRange], 0), sel_mouse);
-        startSel = doc.sel;
-      } else if (ourIndex == -1) {
-        ourIndex = ranges.length;
-        setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), { scroll: false, origin: "*mouse" });
-      } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
-        setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), { scroll: false, origin: "*mouse" });
-        startSel = doc.sel;
-      } else {
-        replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
-      }
-      var lastPos = start;
-      function extendTo(pos) {
-        if (cmp(lastPos, pos) == 0) {
-          return;
-        }
-        lastPos = pos;
-        if (behavior.unit == "rectangle") {
-          var ranges2 = [], tabSize = cm.options.tabSize;
-          var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
-          var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
-          var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
-          for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
-            var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
-            if (left == right) {
-              ranges2.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
-            } else if (text.length > leftPos) {
-              ranges2.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
-            }
-          }
-          if (!ranges2.length) {
-            ranges2.push(new Range(start, start));
-          }
-          setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex), { origin: "*mouse", scroll: false });
-          cm.scrollIntoView(pos);
-        } else {
-          var oldRange = ourRange;
-          var range3 = rangeForUnit(cm, pos, behavior.unit);
-          var anchor = oldRange.anchor, head;
-          if (cmp(range3.anchor, anchor) > 0) {
-            head = range3.head;
-            anchor = minPos(oldRange.from(), range3.anchor);
-          } else {
-            head = range3.anchor;
-            anchor = maxPos(oldRange.to(), range3.head);
-          }
-          var ranges$1 = startSel.ranges.slice(0);
-          ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
-          setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
-        }
-      }
-      var editorSize = display.wrapper.getBoundingClientRect();
-      var counter = 0;
-      function extend(e) {
-        var curCount = ++counter;
-        var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
-        if (!cur) {
-          return;
-        }
-        if (cmp(cur, lastPos) != 0) {
-          cm.curOp.focus = activeElt();
-          extendTo(cur);
-          var visible = visibleLines(display, doc);
-          if (cur.line >= visible.to || cur.line < visible.from) {
-            setTimeout(operation(cm, function() {
-              if (counter == curCount) {
-                extend(e);
-              }
-            }), 150);
-          }
-        } else {
-          var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
-          if (outside) {
-            setTimeout(operation(cm, function() {
-              if (counter != curCount) {
-                return;
-              }
-              display.scroller.scrollTop += outside;
-              extend(e);
-            }), 50);
-          }
-        }
-      }
-      function done(e) {
-        cm.state.selectingText = false;
-        counter = Infinity;
-        if (e) {
-          e_preventDefault(e);
-          display.input.focus();
-        }
-        off(display.wrapper.ownerDocument, "mousemove", move);
-        off(display.wrapper.ownerDocument, "mouseup", up);
-        doc.history.lastSelOrigin = null;
-      }
-      var move = operation(cm, function(e) {
-        if (e.buttons === 0 || !e_button(e)) {
-          done(e);
-        } else {
-          extend(e);
-        }
-      });
-      var up = operation(cm, done);
-      cm.state.selectingText = up;
-      on(display.wrapper.ownerDocument, "mousemove", move);
-      on(display.wrapper.ownerDocument, "mouseup", up);
-    }
-    function bidiSimplify(cm, range2) {
-      var anchor = range2.anchor;
-      var head = range2.head;
-      var anchorLine = getLine(cm.doc, anchor.line);
-      if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
-        return range2;
-      }
-      var order = getOrder(anchorLine);
-      if (!order) {
-        return range2;
-      }
-      var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
-      if (part.from != anchor.ch && part.to != anchor.ch) {
-        return range2;
-      }
-      var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
-      if (boundary == 0 || boundary == order.length) {
-        return range2;
-      }
-      var leftSide;
-      if (head.line != anchor.line) {
-        leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
-      } else {
-        var headIndex = getBidiPartAt(order, head.ch, head.sticky);
-        var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
-        if (headIndex == boundary - 1 || headIndex == boundary) {
-          leftSide = dir < 0;
-        } else {
-          leftSide = dir > 0;
-        }
-      }
-      var usePart = order[boundary + (leftSide ? -1 : 0)];
-      var from = leftSide == (usePart.level == 1);
-      var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
-      return anchor.ch == ch && anchor.sticky == sticky ? range2 : new Range(new Pos(anchor.line, ch, sticky), head);
-    }
-    function gutterEvent(cm, e, type, prevent) {
-      var mX, mY;
-      if (e.touches) {
-        mX = e.touches[0].clientX;
-        mY = e.touches[0].clientY;
-      } else {
-        try {
-          mX = e.clientX;
-          mY = e.clientY;
-        } catch (e$1) {
-          return false;
-        }
-      }
-      if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
-        return false;
-      }
-      if (prevent) {
-        e_preventDefault(e);
-      }
-      var display = cm.display;
-      var lineBox = display.lineDiv.getBoundingClientRect();
-      if (mY > lineBox.bottom || !hasHandler(cm, type)) {
-        return e_defaultPrevented(e);
-      }
-      mY -= lineBox.top - display.viewOffset;
-      for (var i2 = 0; i2 < cm.display.gutterSpecs.length; ++i2) {
-        var g = display.gutters.childNodes[i2];
-        if (g && g.getBoundingClientRect().right >= mX) {
-          var line = lineAtHeight(cm.doc, mY);
-          var gutter = cm.display.gutterSpecs[i2];
-          signal(cm, type, cm, line, gutter.className, e);
-          return e_defaultPrevented(e);
-        }
-      }
-    }
-    function clickInGutter(cm, e) {
-      return gutterEvent(cm, e, "gutterClick", true);
-    }
-    function onContextMenu(cm, e) {
-      if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
-        return;
-      }
-      if (signalDOMEvent(cm, e, "contextmenu")) {
-        return;
-      }
-      if (!captureRightClick) {
-        cm.display.input.onContextMenu(e);
-      }
-    }
-    function contextMenuInGutter(cm, e) {
-      if (!hasHandler(cm, "gutterContextMenu")) {
-        return false;
-      }
-      return gutterEvent(cm, e, "gutterContextMenu", false);
-    }
-    function themeChanged(cm) {
-      cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
-      clearCaches(cm);
-    }
-    var Init = { toString: function() {
-      return "CodeMirror.Init";
-    } };
-    var defaults = {};
-    var optionHandlers = {};
-    function defineOptions(CodeMirror3) {
-      var optionHandlers2 = CodeMirror3.optionHandlers;
-      function option(name, deflt, handle, notOnInit) {
-        CodeMirror3.defaults[name] = deflt;
-        if (handle) {
-          optionHandlers2[name] = notOnInit ? function(cm, val, old) {
-            if (old != Init) {
-              handle(cm, val, old);
-            }
-          } : handle;
-        }
-      }
-      CodeMirror3.defineOption = option;
-      CodeMirror3.Init = Init;
-      option("value", "", function(cm, val) {
-        return cm.setValue(val);
-      }, true);
-      option("mode", null, function(cm, val) {
-        cm.doc.modeOption = val;
-        loadMode(cm);
-      }, true);
-      option("indentUnit", 2, loadMode, true);
-      option("indentWithTabs", false);
-      option("smartIndent", true);
-      option("tabSize", 4, function(cm) {
-        resetModeState(cm);
-        clearCaches(cm);
-        regChange(cm);
-      }, true);
-      option("lineSeparator", null, function(cm, val) {
-        cm.doc.lineSep = val;
-        if (!val) {
-          return;
-        }
-        var newBreaks = [], lineNo2 = cm.doc.first;
-        cm.doc.iter(function(line) {
-          for (var pos = 0; ; ) {
-            var found = line.text.indexOf(val, pos);
-            if (found == -1) {
-              break;
-            }
-            pos = found + val.length;
-            newBreaks.push(Pos(lineNo2, found));
-          }
-          lineNo2++;
-        });
-        for (var i2 = newBreaks.length - 1; i2 >= 0; i2--) {
-          replaceRange(cm.doc, val, newBreaks[i2], Pos(newBreaks[i2].line, newBreaks[i2].ch + val.length));
-        }
-      });
-      option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
-        cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
-        if (old != Init) {
-          cm.refresh();
-        }
-      });
-      option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
-        return cm.refresh();
-      }, true);
-      option("electricChars", true);
-      option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
-        throw new Error("inputStyle can not (yet) be changed in a running editor");
-      }, true);
-      option("spellcheck", false, function(cm, val) {
-        return cm.getInputField().spellcheck = val;
-      }, true);
-      option("autocorrect", false, function(cm, val) {
-        return cm.getInputField().autocorrect = val;
-      }, true);
-      option("autocapitalize", false, function(cm, val) {
-        return cm.getInputField().autocapitalize = val;
-      }, true);
-      option("rtlMoveVisually", !windows);
-      option("wholeLineUpdateBefore", true);
-      option("theme", "default", function(cm) {
-        themeChanged(cm);
-        updateGutters(cm);
-      }, true);
-      option("keyMap", "default", function(cm, val, old) {
-        var next2 = getKeyMap(val);
-        var prev = old != Init && getKeyMap(old);
-        if (prev && prev.detach) {
-          prev.detach(cm, next2);
-        }
-        if (next2.attach) {
-          next2.attach(cm, prev || null);
-        }
-      });
-      option("extraKeys", null);
-      option("configureMouse", null);
-      option("lineWrapping", false, wrappingChanged, true);
-      option("gutters", [], function(cm, val) {
-        cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
-        updateGutters(cm);
-      }, true);
-      option("fixedGutter", true, function(cm, val) {
-        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
-        cm.refresh();
-      }, true);
-      option("coverGutterNextToScrollbar", false, function(cm) {
-        return updateScrollbars(cm);
-      }, true);
-      option("scrollbarStyle", "native", function(cm) {
-        initScrollbars(cm);
-        updateScrollbars(cm);
-        cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
-        cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
-      }, true);
-      option("lineNumbers", false, function(cm, val) {
-        cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
-        updateGutters(cm);
-      }, true);
-      option("firstLineNumber", 1, updateGutters, true);
-      option("lineNumberFormatter", function(integer) {
-        return integer;
-      }, updateGutters, true);
-      option("showCursorWhenSelecting", false, updateSelection, true);
-      option("resetSelectionOnContextMenu", true);
-      option("lineWiseCopyCut", true);
-      option("pasteLinesPerSelection", true);
-      option("selectionsMayTouch", false);
-      option("readOnly", false, function(cm, val) {
-        if (val == "nocursor") {
-          onBlur(cm);
-          cm.display.input.blur();
-        }
-        cm.display.input.readOnlyChanged(val);
-      });
-      option("screenReaderLabel", null, function(cm, val) {
-        val = val === "" ? null : val;
-        cm.display.input.screenReaderLabelChanged(val);
-      });
-      option("disableInput", false, function(cm, val) {
-        if (!val) {
-          cm.display.input.reset();
-        }
-      }, true);
-      option("dragDrop", true, dragDropChanged);
-      option("allowDropFileTypes", null);
-      option("cursorBlinkRate", 530);
-      option("cursorScrollMargin", 0);
-      option("cursorHeight", 1, updateSelection, true);
-      option("singleCursorHeightPerLine", true, updateSelection, true);
-      option("workTime", 100);
-      option("workDelay", 100);
-      option("flattenSpans", true, resetModeState, true);
-      option("addModeClass", false, resetModeState, true);
-      option("pollInterval", 100);
-      option("undoDepth", 200, function(cm, val) {
-        return cm.doc.history.undoDepth = val;
-      });
-      option("historyEventDelay", 1250);
-      option("viewportMargin", 10, function(cm) {
-        return cm.refresh();
-      }, true);
-      option("maxHighlightLength", 1e4, resetModeState, true);
-      option("moveInputWithCursor", true, function(cm, val) {
-        if (!val) {
-          cm.display.input.resetPosition();
-        }
-      });
-      option("tabindex", null, function(cm, val) {
-        return cm.display.input.getField().tabIndex = val || "";
-      });
-      option("autofocus", null);
-      option("direction", "ltr", function(cm, val) {
-        return cm.doc.setDirection(val);
-      }, true);
-      option("phrases", null);
-    }
-    function dragDropChanged(cm, value, old) {
-      var wasOn = old && old != Init;
-      if (!value != !wasOn) {
-        var funcs = cm.display.dragFunctions;
-        var toggle = value ? on : off;
-        toggle(cm.display.scroller, "dragstart", funcs.start);
-        toggle(cm.display.scroller, "dragenter", funcs.enter);
-        toggle(cm.display.scroller, "dragover", funcs.over);
-        toggle(cm.display.scroller, "dragleave", funcs.leave);
-        toggle(cm.display.scroller, "drop", funcs.drop);
-      }
-    }
-    function wrappingChanged(cm) {
-      if (cm.options.lineWrapping) {
-        addClass(cm.display.wrapper, "CodeMirror-wrap");
-        cm.display.sizer.style.minWidth = "";
-        cm.display.sizerWidth = null;
-      } else {
-        rmClass(cm.display.wrapper, "CodeMirror-wrap");
-        findMaxLine(cm);
-      }
-      estimateLineHeights(cm);
-      regChange(cm);
-      clearCaches(cm);
-      setTimeout(function() {
-        return updateScrollbars(cm);
-      }, 100);
-    }
-    function CodeMirror2(place, options) {
-      var this$1$1 = this;
-      if (!(this instanceof CodeMirror2)) {
-        return new CodeMirror2(place, options);
-      }
-      this.options = options = options ? copyObj(options) : {};
-      copyObj(defaults, options, false);
-      var doc = options.value;
-      if (typeof doc == "string") {
-        doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
-      } else if (options.mode) {
-        doc.modeOption = options.mode;
-      }
-      this.doc = doc;
-      var input2 = new CodeMirror2.inputStyles[options.inputStyle](this);
-      var display = this.display = new Display(place, doc, input2, options);
-      display.wrapper.CodeMirror = this;
-      themeChanged(this);
-      if (options.lineWrapping) {
-        this.display.wrapper.className += " CodeMirror-wrap";
-      }
-      initScrollbars(this);
-      this.state = {
-        keyMaps: [],
-        overlays: [],
-        modeGen: 0,
-        overwrite: false,
-        delayingBlurEvent: false,
-        focused: false,
-        suppressEdits: false,
-        pasteIncoming: -1,
-        cutIncoming: -1,
-        selectingText: false,
-        draggingText: false,
-        highlight: new Delayed(),
-        keySeq: null,
-        specialChars: null
-      };
-      if (options.autofocus && !mobile) {
-        display.input.focus();
-      }
-      if (ie && ie_version < 11) {
-        setTimeout(function() {
-          return this$1$1.display.input.reset(true);
-        }, 20);
-      }
-      registerEventHandlers(this);
-      ensureGlobalHandlers();
-      startOperation(this);
-      this.curOp.forceUpdate = true;
-      attachDoc(this, doc);
-      if (options.autofocus && !mobile || this.hasFocus()) {
-        setTimeout(function() {
-          if (this$1$1.hasFocus() && !this$1$1.state.focused) {
-            onFocus(this$1$1);
-          }
-        }, 20);
-      } else {
-        onBlur(this);
-      }
-      for (var opt in optionHandlers) {
-        if (optionHandlers.hasOwnProperty(opt)) {
-          optionHandlers[opt](this, options[opt], Init);
-        }
-      }
-      maybeUpdateLineNumberWidth(this);
-      if (options.finishInit) {
-        options.finishInit(this);
-      }
-      for (var i2 = 0; i2 < initHooks.length; ++i2) {
-        initHooks[i2](this);
-      }
-      endOperation(this);
-      if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
-        display.lineDiv.style.textRendering = "auto";
-      }
-    }
-    CodeMirror2.defaults = defaults;
-    CodeMirror2.optionHandlers = optionHandlers;
-    function registerEventHandlers(cm) {
-      var d = cm.display;
-      on(d.scroller, "mousedown", operation(cm, onMouseDown));
-      if (ie && ie_version < 11) {
-        on(d.scroller, "dblclick", operation(cm, function(e) {
-          if (signalDOMEvent(cm, e)) {
-            return;
-          }
-          var pos = posFromMouse(cm, e);
-          if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
-            return;
-          }
-          e_preventDefault(e);
-          var word = cm.findWordAt(pos);
-          extendSelection(cm.doc, word.anchor, word.head);
-        }));
-      } else {
-        on(d.scroller, "dblclick", function(e) {
-          return signalDOMEvent(cm, e) || e_preventDefault(e);
-        });
-      }
-      on(d.scroller, "contextmenu", function(e) {
-        return onContextMenu(cm, e);
-      });
-      on(d.input.getField(), "contextmenu", function(e) {
-        if (!d.scroller.contains(e.target)) {
-          onContextMenu(cm, e);
-        }
-      });
-      var touchFinished, prevTouch = { end: 0 };
-      function finishTouch() {
-        if (d.activeTouch) {
-          touchFinished = setTimeout(function() {
-            return d.activeTouch = null;
-          }, 1e3);
-          prevTouch = d.activeTouch;
-          prevTouch.end = +new Date();
-        }
-      }
-      function isMouseLikeTouchEvent(e) {
-        if (e.touches.length != 1) {
-          return false;
-        }
-        var touch = e.touches[0];
-        return touch.radiusX <= 1 && touch.radiusY <= 1;
-      }
-      function farAway(touch, other) {
-        if (other.left == null) {
-          return true;
-        }
-        var dx = other.left - touch.left, dy = other.top - touch.top;
-        return dx * dx + dy * dy > 20 * 20;
-      }
-      on(d.scroller, "touchstart", function(e) {
-        if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
-          d.input.ensurePolled();
-          clearTimeout(touchFinished);
-          var now = +new Date();
-          d.activeTouch = {
-            start: now,
-            moved: false,
-            prev: now - prevTouch.end <= 300 ? prevTouch : null
-          };
-          if (e.touches.length == 1) {
-            d.activeTouch.left = e.touches[0].pageX;
-            d.activeTouch.top = e.touches[0].pageY;
-          }
-        }
-      });
-      on(d.scroller, "touchmove", function() {
-        if (d.activeTouch) {
-          d.activeTouch.moved = true;
-        }
-      });
-      on(d.scroller, "touchend", function(e) {
-        var touch = d.activeTouch;
-        if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
-          var pos = cm.coordsChar(d.activeTouch, "page"), range2;
-          if (!touch.prev || farAway(touch, touch.prev)) {
-            range2 = new Range(pos, pos);
-          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
-            range2 = cm.findWordAt(pos);
-          } else {
-            range2 = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
-          }
-          cm.setSelection(range2.anchor, range2.head);
-          cm.focus();
-          e_preventDefault(e);
-        }
-        finishTouch();
-      });
-      on(d.scroller, "touchcancel", finishTouch);
-      on(d.scroller, "scroll", function() {
-        if (d.scroller.clientHeight) {
-          updateScrollTop(cm, d.scroller.scrollTop);
-          setScrollLeft(cm, d.scroller.scrollLeft, true);
-          signal(cm, "scroll", cm);
-        }
-      });
-      on(d.scroller, "mousewheel", function(e) {
-        return onScrollWheel(cm, e);
-      });
-      on(d.scroller, "DOMMouseScroll", function(e) {
-        return onScrollWheel(cm, e);
-      });
-      on(d.wrapper, "scroll", function() {
-        return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
-      });
-      d.dragFunctions = {
-        enter: function(e) {
-          if (!signalDOMEvent(cm, e)) {
-            e_stop(e);
-          }
-        },
-        over: function(e) {
-          if (!signalDOMEvent(cm, e)) {
-            onDragOver(cm, e);
-            e_stop(e);
-          }
-        },
-        start: function(e) {
-          return onDragStart(cm, e);
-        },
-        drop: operation(cm, onDrop),
-        leave: function(e) {
-          if (!signalDOMEvent(cm, e)) {
-            clearDragCursor(cm);
-          }
-        }
-      };
-      var inp = d.input.getField();
-      on(inp, "keyup", function(e) {
-        return onKeyUp.call(cm, e);
-      });
-      on(inp, "keydown", operation(cm, onKeyDown));
-      on(inp, "keypress", operation(cm, onKeyPress));
-      on(inp, "focus", function(e) {
-        return onFocus(cm, e);
-      });
-      on(inp, "blur", function(e) {
-        return onBlur(cm, e);
-      });
-    }
-    var initHooks = [];
-    CodeMirror2.defineInitHook = function(f) {
-      return initHooks.push(f);
-    };
-    function indentLine(cm, n, how, aggressive) {
-      var doc = cm.doc, state2;
-      if (how == null) {
-        how = "add";
-      }
-      if (how == "smart") {
-        if (!doc.mode.indent) {
-          how = "prev";
-        } else {
-          state2 = getContextBefore(cm, n).state;
-        }
-      }
-      var tabSize = cm.options.tabSize;
-      var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
-      if (line.stateAfter) {
-        line.stateAfter = null;
-      }
-      var curSpaceString = line.text.match(/^\s*/)[0], indentation;
-      if (!aggressive && !/\S/.test(line.text)) {
-        indentation = 0;
-        how = "not";
-      } else if (how == "smart") {
-        indentation = doc.mode.indent(state2, line.text.slice(curSpaceString.length), line.text);
-        if (indentation == Pass || indentation > 150) {
-          if (!aggressive) {
-            return;
-          }
-          how = "prev";
-        }
-      }
-      if (how == "prev") {
-        if (n > doc.first) {
-          indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
-        } else {
-          indentation = 0;
-        }
-      } else if (how == "add") {
-        indentation = curSpace + cm.options.indentUnit;
-      } else if (how == "subtract") {
-        indentation = curSpace - cm.options.indentUnit;
-      } else if (typeof how == "number") {
-        indentation = curSpace + how;
-      }
-      indentation = Math.max(0, indentation);
-      var indentString = "", pos = 0;
-      if (cm.options.indentWithTabs) {
-        for (var i2 = Math.floor(indentation / tabSize); i2; --i2) {
-          pos += tabSize;
-          indentString += "	";
-        }
-      }
-      if (pos < indentation) {
-        indentString += spaceStr(indentation - pos);
-      }
-      if (indentString != curSpaceString) {
-        replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
-        line.stateAfter = null;
-        return true;
-      } else {
-        for (var i$12 = 0; i$12 < doc.sel.ranges.length; i$12++) {
-          var range2 = doc.sel.ranges[i$12];
-          if (range2.head.line == n && range2.head.ch < curSpaceString.length) {
-            var pos$1 = Pos(n, curSpaceString.length);
-            replaceOneSelection(doc, i$12, new Range(pos$1, pos$1));
-            break;
-          }
-        }
-      }
-    }
-    var lastCopied = null;
-    function setLastCopied(newLastCopied) {
-      lastCopied = newLastCopied;
-    }
-    function applyTextInput(cm, inserted, deleted, sel, origin) {
-      var doc = cm.doc;
-      cm.display.shift = false;
-      if (!sel) {
-        sel = doc.sel;
-      }
-      var recent = +new Date() - 200;
-      var paste = origin == "paste" || cm.state.pasteIncoming > recent;
-      var textLines = splitLinesAuto(inserted), multiPaste = null;
-      if (paste && sel.ranges.length > 1) {
-        if (lastCopied && lastCopied.text.join("\n") == inserted) {
-          if (sel.ranges.length % lastCopied.text.length == 0) {
-            multiPaste = [];
-            for (var i2 = 0; i2 < lastCopied.text.length; i2++) {
-              multiPaste.push(doc.splitLines(lastCopied.text[i2]));
-            }
-          }
-        } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
-          multiPaste = map(textLines, function(l) {
-            return [l];
-          });
-        }
-      }
-      var updateInput = cm.curOp.updateInput;
-      for (var i$12 = sel.ranges.length - 1; i$12 >= 0; i$12--) {
-        var range2 = sel.ranges[i$12];
-        var from = range2.from(), to = range2.to();
-        if (range2.empty()) {
-          if (deleted && deleted > 0) {
-            from = Pos(from.line, from.ch - deleted);
-          } else if (cm.state.overwrite && !paste) {
-            to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
-          } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
-            from = to = Pos(from.line, 0);
-          }
-        }
-        var changeEvent = {
-          from,
-          to,
-          text: multiPaste ? multiPaste[i$12 % multiPaste.length] : textLines,
-          origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
-        };
-        makeChange(cm.doc, changeEvent);
-        signalLater(cm, "inputRead", cm, changeEvent);
-      }
-      if (inserted && !paste) {
-        triggerElectric(cm, inserted);
-      }
-      ensureCursorVisible(cm);
-      if (cm.curOp.updateInput < 2) {
-        cm.curOp.updateInput = updateInput;
-      }
-      cm.curOp.typing = true;
-      cm.state.pasteIncoming = cm.state.cutIncoming = -1;
-    }
-    function handlePaste(e, cm) {
-      var pasted = e.clipboardData && e.clipboardData.getData("Text");
-      if (pasted) {
-        e.preventDefault();
-        if (!cm.isReadOnly() && !cm.options.disableInput) {
-          runInOp(cm, function() {
-            return applyTextInput(cm, pasted, 0, null, "paste");
-          });
-        }
-        return true;
-      }
-    }
-    function triggerElectric(cm, inserted) {
-      if (!cm.options.electricChars || !cm.options.smartIndent) {
-        return;
-      }
-      var sel = cm.doc.sel;
-      for (var i2 = sel.ranges.length - 1; i2 >= 0; i2--) {
-        var range2 = sel.ranges[i2];
-        if (range2.head.ch > 100 || i2 && sel.ranges[i2 - 1].head.line == range2.head.line) {
-          continue;
-        }
-        var mode = cm.getModeAt(range2.head);
-        var indented = false;
-        if (mode.electricChars) {
-          for (var j = 0; j < mode.electricChars.length; j++) {
-            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
-              indented = indentLine(cm, range2.head.line, "smart");
-              break;
-            }
-          }
-        } else if (mode.electricInput) {
-          if (mode.electricInput.test(getLine(cm.doc, range2.head.line).text.slice(0, range2.head.ch))) {
-            indented = indentLine(cm, range2.head.line, "smart");
-          }
-        }
-        if (indented) {
-          signalLater(cm, "electricInput", cm, range2.head.line);
-        }
-      }
-    }
-    function copyableRanges(cm) {
-      var text = [], ranges = [];
-      for (var i2 = 0; i2 < cm.doc.sel.ranges.length; i2++) {
-        var line = cm.doc.sel.ranges[i2].head.line;
-        var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
-        ranges.push(lineRange);
-        text.push(cm.getRange(lineRange.anchor, lineRange.head));
-      }
-      return { text, ranges };
-    }
-    function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
-      field.setAttribute("autocorrect", autocorrect ? "" : "off");
-      field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
-      field.setAttribute("spellcheck", !!spellcheck);
-    }
-    function hiddenTextarea() {
-      var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
-      var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
-      if (webkit) {
-        te.style.width = "1000px";
-      } else {
-        te.setAttribute("wrap", "off");
-      }
-      if (ios) {
-        te.style.border = "1px solid black";
-      }
-      disableBrowserMagic(te);
-      return div;
-    }
-    function addEditorMethods(CodeMirror3) {
-      var optionHandlers2 = CodeMirror3.optionHandlers;
-      var helpers = CodeMirror3.helpers = {};
-      CodeMirror3.prototype = {
-        constructor: CodeMirror3,
-        focus: function() {
-          window.focus();
-          this.display.input.focus();
-        },
-        setOption: function(option, value) {
-          var options = this.options, old = options[option];
-          if (options[option] == value && option != "mode") {
-            return;
-          }
-          options[option] = value;
-          if (optionHandlers2.hasOwnProperty(option)) {
-            operation(this, optionHandlers2[option])(this, value, old);
-          }
-          signal(this, "optionChange", this, option);
-        },
-        getOption: function(option) {
-          return this.options[option];
-        },
-        getDoc: function() {
-          return this.doc;
-        },
-        addKeyMap: function(map2, bottom) {
-          this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map2));
-        },
-        removeKeyMap: function(map2) {
-          var maps = this.state.keyMaps;
-          for (var i2 = 0; i2 < maps.length; ++i2) {
-            if (maps[i2] == map2 || maps[i2].name == map2) {
-              maps.splice(i2, 1);
-              return true;
-            }
-          }
-        },
-        addOverlay: methodOp(function(spec, options) {
-          var mode = spec.token ? spec : CodeMirror3.getMode(this.options, spec);
-          if (mode.startState) {
-            throw new Error("Overlays may not be stateful.");
-          }
-          insertSorted(this.state.overlays, {
-            mode,
-            modeSpec: spec,
-            opaque: options && options.opaque,
-            priority: options && options.priority || 0
-          }, function(overlay) {
-            return overlay.priority;
-          });
-          this.state.modeGen++;
-          regChange(this);
-        }),
-        removeOverlay: methodOp(function(spec) {
-          var overlays = this.state.overlays;
-          for (var i2 = 0; i2 < overlays.length; ++i2) {
-            var cur = overlays[i2].modeSpec;
-            if (cur == spec || typeof spec == "string" && cur.name == spec) {
-              overlays.splice(i2, 1);
-              this.state.modeGen++;
-              regChange(this);
-              return;
-            }
-          }
-        }),
-        indentLine: methodOp(function(n, dir, aggressive) {
-          if (typeof dir != "string" && typeof dir != "number") {
-            if (dir == null) {
-              dir = this.options.smartIndent ? "smart" : "prev";
-            } else {
-              dir = dir ? "add" : "subtract";
-            }
-          }
-          if (isLine(this.doc, n)) {
-            indentLine(this, n, dir, aggressive);
-          }
-        }),
-        indentSelection: methodOp(function(how) {
-          var ranges = this.doc.sel.ranges, end = -1;
-          for (var i2 = 0; i2 < ranges.length; i2++) {
-            var range2 = ranges[i2];
-            if (!range2.empty()) {
-              var from = range2.from(), to = range2.to();
-              var start = Math.max(end, from.line);
-              end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
-              for (var j = start; j < end; ++j) {
-                indentLine(this, j, how);
-              }
-              var newRanges = this.doc.sel.ranges;
-              if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i2].from().ch > 0) {
-                replaceOneSelection(this.doc, i2, new Range(from, newRanges[i2].to()), sel_dontScroll);
-              }
-            } else if (range2.head.line > end) {
-              indentLine(this, range2.head.line, how, true);
-              end = range2.head.line;
-              if (i2 == this.doc.sel.primIndex) {
-                ensureCursorVisible(this);
-              }
-            }
-          }
-        }),
-        getTokenAt: function(pos, precise) {
-          return takeToken(this, pos, precise);
-        },
-        getLineTokens: function(line, precise) {
-          return takeToken(this, Pos(line), precise, true);
-        },
-        getTokenTypeAt: function(pos) {
-          pos = clipPos(this.doc, pos);
-          var styles = getLineStyles(this, getLine(this.doc, pos.line));
-          var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
-          var type;
-          if (ch == 0) {
-            type = styles[2];
-          } else {
-            for (; ; ) {
-              var mid = before + after >> 1;
-              if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
-                after = mid;
-              } else if (styles[mid * 2 + 1] < ch) {
-                before = mid + 1;
-              } else {
-                type = styles[mid * 2 + 2];
-                break;
-              }
-            }
-          }
-          var cut = type ? type.indexOf("overlay ") : -1;
-          return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
-        },
-        getModeAt: function(pos) {
-          var mode = this.doc.mode;
-          if (!mode.innerMode) {
-            return mode;
-          }
-          return CodeMirror3.innerMode(mode, this.getTokenAt(pos).state).mode;
-        },
-        getHelper: function(pos, type) {
-          return this.getHelpers(pos, type)[0];
-        },
-        getHelpers: function(pos, type) {
-          var found = [];
-          if (!helpers.hasOwnProperty(type)) {
-            return found;
-          }
-          var help = helpers[type], mode = this.getModeAt(pos);
-          if (typeof mode[type] == "string") {
-            if (help[mode[type]]) {
-              found.push(help[mode[type]]);
-            }
-          } else if (mode[type]) {
-            for (var i2 = 0; i2 < mode[type].length; i2++) {
-              var val = help[mode[type][i2]];
-              if (val) {
-                found.push(val);
-              }
-            }
-          } else if (mode.helperType && help[mode.helperType]) {
-            found.push(help[mode.helperType]);
-          } else if (help[mode.name]) {
-            found.push(help[mode.name]);
-          }
-          for (var i$12 = 0; i$12 < help._global.length; i$12++) {
-            var cur = help._global[i$12];
-            if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
-              found.push(cur.val);
-            }
-          }
-          return found;
-        },
-        getStateAfter: function(line, precise) {
-          var doc = this.doc;
-          line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
-          return getContextBefore(this, line + 1, precise).state;
-        },
-        cursorCoords: function(start, mode) {
-          var pos, range2 = this.doc.sel.primary();
-          if (start == null) {
-            pos = range2.head;
-          } else if (typeof start == "object") {
-            pos = clipPos(this.doc, start);
-          } else {
-            pos = start ? range2.from() : range2.to();
-          }
-          return cursorCoords(this, pos, mode || "page");
-        },
-        charCoords: function(pos, mode) {
-          return charCoords(this, clipPos(this.doc, pos), mode || "page");
-        },
-        coordsChar: function(coords, mode) {
-          coords = fromCoordSystem(this, coords, mode || "page");
-          return coordsChar(this, coords.left, coords.top);
-        },
-        lineAtHeight: function(height, mode) {
-          height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
-          return lineAtHeight(this.doc, height + this.display.viewOffset);
-        },
-        heightAtLine: function(line, mode, includeWidgets) {
-          var end = false, lineObj;
-          if (typeof line == "number") {
-            var last = this.doc.first + this.doc.size - 1;
-            if (line < this.doc.first) {
-              line = this.doc.first;
-            } else if (line > last) {
-              line = last;
-              end = true;
-            }
-            lineObj = getLine(this.doc, line);
-          } else {
-            lineObj = line;
-          }
-          return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
-        },
-        defaultTextHeight: function() {
-          return textHeight(this.display);
-        },
-        defaultCharWidth: function() {
-          return charWidth(this.display);
-        },
-        getViewport: function() {
-          return { from: this.display.viewFrom, to: this.display.viewTo };
-        },
-        addWidget: function(pos, node, scroll, vert, horiz) {
-          var display = this.display;
-          pos = cursorCoords(this, clipPos(this.doc, pos));
-          var top = pos.bottom, left = pos.left;
-          node.style.position = "absolute";
-          node.setAttribute("cm-ignore-events", "true");
-          this.display.input.setUneditable(node);
-          display.sizer.appendChild(node);
-          if (vert == "over") {
-            top = pos.top;
-          } else if (vert == "above" || vert == "near") {
-            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
-            if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
-              top = pos.top - node.offsetHeight;
-            } else if (pos.bottom + node.offsetHeight <= vspace) {
-              top = pos.bottom;
-            }
-            if (left + node.offsetWidth > hspace) {
-              left = hspace - node.offsetWidth;
-            }
-          }
-          node.style.top = top + "px";
-          node.style.left = node.style.right = "";
-          if (horiz == "right") {
-            left = display.sizer.clientWidth - node.offsetWidth;
-            node.style.right = "0px";
-          } else {
-            if (horiz == "left") {
-              left = 0;
-            } else if (horiz == "middle") {
-              left = (display.sizer.clientWidth - node.offsetWidth) / 2;
-            }
-            node.style.left = left + "px";
-          }
-          if (scroll) {
-            scrollIntoView(this, { left, top, right: left + node.offsetWidth, bottom: top + node.offsetHeight });
-          }
-        },
-        triggerOnKeyDown: methodOp(onKeyDown),
-        triggerOnKeyPress: methodOp(onKeyPress),
-        triggerOnKeyUp: onKeyUp,
-        triggerOnMouseDown: methodOp(onMouseDown),
-        execCommand: function(cmd) {
-          if (commands.hasOwnProperty(cmd)) {
-            return commands[cmd].call(null, this);
-          }
-        },
-        triggerElectric: methodOp(function(text) {
-          triggerElectric(this, text);
-        }),
-        findPosH: function(from, amount, unit, visually) {
-          var dir = 1;
-          if (amount < 0) {
-            dir = -1;
-            amount = -amount;
-          }
-          var cur = clipPos(this.doc, from);
-          for (var i2 = 0; i2 < amount; ++i2) {
-            cur = findPosH(this.doc, cur, dir, unit, visually);
-            if (cur.hitSide) {
-              break;
-            }
-          }
-          return cur;
-        },
-        moveH: methodOp(function(dir, unit) {
-          var this$1$1 = this;
-          this.extendSelectionsBy(function(range2) {
-            if (this$1$1.display.shift || this$1$1.doc.extend || range2.empty()) {
-              return findPosH(this$1$1.doc, range2.head, dir, unit, this$1$1.options.rtlMoveVisually);
-            } else {
-              return dir < 0 ? range2.from() : range2.to();
-            }
-          }, sel_move);
-        }),
-        deleteH: methodOp(function(dir, unit) {
-          var sel = this.doc.sel, doc = this.doc;
-          if (sel.somethingSelected()) {
-            doc.replaceSelection("", null, "+delete");
-          } else {
-            deleteNearSelection(this, function(range2) {
-              var other = findPosH(doc, range2.head, dir, unit, false);
-              return dir < 0 ? { from: other, to: range2.head } : { from: range2.head, to: other };
-            });
-          }
-        }),
-        findPosV: function(from, amount, unit, goalColumn) {
-          var dir = 1, x = goalColumn;
-          if (amount < 0) {
-            dir = -1;
-            amount = -amount;
-          }
-          var cur = clipPos(this.doc, from);
-          for (var i2 = 0; i2 < amount; ++i2) {
-            var coords = cursorCoords(this, cur, "div");
-            if (x == null) {
-              x = coords.left;
-            } else {
-              coords.left = x;
-            }
-            cur = findPosV(this, coords, dir, unit);
-            if (cur.hitSide) {
-              break;
-            }
-          }
-          return cur;
-        },
-        moveV: methodOp(function(dir, unit) {
-          var this$1$1 = this;
-          var doc = this.doc, goals = [];
-          var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
-          doc.extendSelectionsBy(function(range2) {
-            if (collapse) {
-              return dir < 0 ? range2.from() : range2.to();
-            }
-            var headPos = cursorCoords(this$1$1, range2.head, "div");
-            if (range2.goalColumn != null) {
-              headPos.left = range2.goalColumn;
-            }
-            goals.push(headPos.left);
-            var pos = findPosV(this$1$1, headPos, dir, unit);
-            if (unit == "page" && range2 == doc.sel.primary()) {
-              addToScrollTop(this$1$1, charCoords(this$1$1, pos, "div").top - headPos.top);
-            }
-            return pos;
-          }, sel_move);
-          if (goals.length) {
-            for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
-              doc.sel.ranges[i2].goalColumn = goals[i2];
-            }
-          }
-        }),
-        findWordAt: function(pos) {
-          var doc = this.doc, line = getLine(doc, pos.line).text;
-          var start = pos.ch, end = pos.ch;
-          if (line) {
-            var helper = this.getHelper(pos, "wordChars");
-            if ((pos.sticky == "before" || end == line.length) && start) {
-              --start;
-            } else {
-              ++end;
-            }
-            var startChar = line.charAt(start);
-            var check = isWordChar(startChar, helper) ? function(ch) {
-              return isWordChar(ch, helper);
-            } : /\s/.test(startChar) ? function(ch) {
-              return /\s/.test(ch);
-            } : function(ch) {
-              return !/\s/.test(ch) && !isWordChar(ch);
-            };
-            while (start > 0 && check(line.charAt(start - 1))) {
-              --start;
-            }
-            while (end < line.length && check(line.charAt(end))) {
-              ++end;
-            }
-          }
-          return new Range(Pos(pos.line, start), Pos(pos.line, end));
-        },
-        toggleOverwrite: function(value) {
-          if (value != null && value == this.state.overwrite) {
-            return;
-          }
-          if (this.state.overwrite = !this.state.overwrite) {
-            addClass(this.display.cursorDiv, "CodeMirror-overwrite");
-          } else {
-            rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
-          }
-          signal(this, "overwriteToggle", this, this.state.overwrite);
-        },
-        hasFocus: function() {
-          return this.display.input.getField() == activeElt();
-        },
-        isReadOnly: function() {
-          return !!(this.options.readOnly || this.doc.cantEdit);
-        },
-        scrollTo: methodOp(function(x, y) {
-          scrollToCoords(this, x, y);
-        }),
-        getScrollInfo: function() {
-          var scroller = this.display.scroller;
-          return {
-            left: scroller.scrollLeft,
-            top: scroller.scrollTop,
-            height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
-            width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
-            clientHeight: displayHeight(this),
-            clientWidth: displayWidth(this)
-          };
-        },
-        scrollIntoView: methodOp(function(range2, margin) {
-          if (range2 == null) {
-            range2 = { from: this.doc.sel.primary().head, to: null };
-            if (margin == null) {
-              margin = this.options.cursorScrollMargin;
-            }
-          } else if (typeof range2 == "number") {
-            range2 = { from: Pos(range2, 0), to: null };
-          } else if (range2.from == null) {
-            range2 = { from: range2, to: null };
-          }
-          if (!range2.to) {
-            range2.to = range2.from;
-          }
-          range2.margin = margin || 0;
-          if (range2.from.line != null) {
-            scrollToRange(this, range2);
-          } else {
-            scrollToCoordsRange(this, range2.from, range2.to, range2.margin);
-          }
-        }),
-        setSize: methodOp(function(width, height) {
-          var this$1$1 = this;
-          var interpret = function(val) {
-            return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
-          };
-          if (width != null) {
-            this.display.wrapper.style.width = interpret(width);
-          }
-          if (height != null) {
-            this.display.wrapper.style.height = interpret(height);
-          }
-          if (this.options.lineWrapping) {
-            clearLineMeasurementCache(this);
-          }
-          var lineNo2 = this.display.viewFrom;
-          this.doc.iter(lineNo2, this.display.viewTo, function(line) {
-            if (line.widgets) {
-              for (var i2 = 0; i2 < line.widgets.length; i2++) {
-                if (line.widgets[i2].noHScroll) {
-                  regLineChange(this$1$1, lineNo2, "widget");
-                  break;
-                }
-              }
-            }
-            ++lineNo2;
-          });
-          this.curOp.forceUpdate = true;
-          signal(this, "refresh", this);
-        }),
-        operation: function(f) {
-          return runInOp(this, f);
-        },
-        startOperation: function() {
-          return startOperation(this);
-        },
-        endOperation: function() {
-          return endOperation(this);
-        },
-        refresh: methodOp(function() {
-          var oldHeight = this.display.cachedTextHeight;
-          regChange(this);
-          this.curOp.forceUpdate = true;
-          clearCaches(this);
-          scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
-          updateGutterSpace(this.display);
-          if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
-            estimateLineHeights(this);
-          }
-          signal(this, "refresh", this);
-        }),
-        swapDoc: methodOp(function(doc) {
-          var old = this.doc;
-          old.cm = null;
-          if (this.state.selectingText) {
-            this.state.selectingText();
-          }
-          attachDoc(this, doc);
-          clearCaches(this);
-          this.display.input.reset();
-          scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
-          this.curOp.forceScroll = true;
-          signalLater(this, "swapDoc", this, old);
-          return old;
-        }),
-        phrase: function(phraseText) {
-          var phrases = this.options.phrases;
-          return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
-        },
-        getInputField: function() {
-          return this.display.input.getField();
-        },
-        getWrapperElement: function() {
-          return this.display.wrapper;
-        },
-        getScrollerElement: function() {
-          return this.display.scroller;
-        },
-        getGutterElement: function() {
-          return this.display.gutters;
-        }
-      };
-      eventMixin(CodeMirror3);
-      CodeMirror3.registerHelper = function(type, name, value) {
-        if (!helpers.hasOwnProperty(type)) {
-          helpers[type] = CodeMirror3[type] = { _global: [] };
-        }
-        helpers[type][name] = value;
-      };
-      CodeMirror3.registerGlobalHelper = function(type, name, predicate, value) {
-        CodeMirror3.registerHelper(type, name, value);
-        helpers[type]._global.push({ pred: predicate, val: value });
-      };
-    }
-    function findPosH(doc, pos, dir, unit, visually) {
-      var oldPos = pos;
-      var origDir = dir;
-      var lineObj = getLine(doc, pos.line);
-      var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
-      function findNextLine() {
-        var l = pos.line + lineDir;
-        if (l < doc.first || l >= doc.first + doc.size) {
-          return false;
-        }
-        pos = new Pos(l, pos.ch, pos.sticky);
-        return lineObj = getLine(doc, l);
-      }
-      function moveOnce(boundToLine) {
-        var next2;
-        if (unit == "codepoint") {
-          var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
-          if (isNaN(ch)) {
-            next2 = null;
-          } else {
-            var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
-            next2 = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
-          }
-        } else if (visually) {
-          next2 = moveVisually(doc.cm, lineObj, pos, dir);
-        } else {
-          next2 = moveLogically(lineObj, pos, dir);
-        }
-        if (next2 == null) {
-          if (!boundToLine && findNextLine()) {
-            pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);
-          } else {
-            return false;
-          }
-        } else {
-          pos = next2;
-        }
-        return true;
-      }
-      if (unit == "char" || unit == "codepoint") {
-        moveOnce();
-      } else if (unit == "column") {
-        moveOnce(true);
-      } else if (unit == "word" || unit == "group") {
-        var sawType = null, group = unit == "group";
-        var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
-        for (var first = true; ; first = false) {
-          if (dir < 0 && !moveOnce(!first)) {
-            break;
-          }
-          var cur = lineObj.text.charAt(pos.ch) || "\n";
-          var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
-          if (group && !first && !type) {
-            type = "s";
-          }
-          if (sawType && sawType != type) {
-            if (dir < 0) {
-              dir = 1;
-              moveOnce();
-              pos.sticky = "after";
-            }
-            break;
-          }
-          if (type) {
-            sawType = type;
-          }
-          if (dir > 0 && !moveOnce(!first)) {
-            break;
-          }
-        }
-      }
-      var result = skipAtomic(doc, pos, oldPos, origDir, true);
-      if (equalCursorPos(oldPos, result)) {
-        result.hitSide = true;
-      }
-      return result;
-    }
-    function findPosV(cm, pos, dir, unit) {
-      var doc = cm.doc, x = pos.left, y;
-      if (unit == "page") {
-        var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
-        var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
-        y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
-      } else if (unit == "line") {
-        y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
-      }
-      var target;
-      for (; ; ) {
-        target = coordsChar(cm, x, y);
-        if (!target.outside) {
-          break;
-        }
-        if (dir < 0 ? y <= 0 : y >= doc.height) {
-          target.hitSide = true;
-          break;
-        }
-        y += dir * 5;
-      }
-      return target;
-    }
-    var ContentEditableInput = function(cm) {
-      this.cm = cm;
-      this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
-      this.polling = new Delayed();
-      this.composing = null;
-      this.gracePeriod = false;
-      this.readDOMTimeout = null;
-    };
-    ContentEditableInput.prototype.init = function(display) {
-      var this$1$1 = this;
-      var input2 = this, cm = input2.cm;
-      var div = input2.div = display.lineDiv;
-      div.contentEditable = true;
-      disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
-      function belongsToInput(e) {
-        for (var t = e.target; t; t = t.parentNode) {
-          if (t == div) {
-            return true;
-          }
-          if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) {
-            break;
-          }
-        }
-        return false;
-      }
-      on(div, "paste", function(e) {
-        if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {
-          return;
-        }
-        if (ie_version <= 11) {
-          setTimeout(operation(cm, function() {
-            return this$1$1.updateFromDOM();
-          }), 20);
-        }
-      });
-      on(div, "compositionstart", function(e) {
-        this$1$1.composing = { data: e.data, done: false };
-      });
-      on(div, "compositionupdate", function(e) {
-        if (!this$1$1.composing) {
-          this$1$1.composing = { data: e.data, done: false };
-        }
-      });
-      on(div, "compositionend", function(e) {
-        if (this$1$1.composing) {
-          if (e.data != this$1$1.composing.data) {
-            this$1$1.readFromDOMSoon();
-          }
-          this$1$1.composing.done = true;
-        }
-      });
-      on(div, "touchstart", function() {
-        return input2.forceCompositionEnd();
-      });
-      on(div, "input", function() {
-        if (!this$1$1.composing) {
-          this$1$1.readFromDOMSoon();
-        }
-      });
-      function onCopyCut(e) {
-        if (!belongsToInput(e) || signalDOMEvent(cm, e)) {
-          return;
-        }
-        if (cm.somethingSelected()) {
-          setLastCopied({ lineWise: false, text: cm.getSelections() });
-          if (e.type == "cut") {
-            cm.replaceSelection("", null, "cut");
-          }
-        } else if (!cm.options.lineWiseCopyCut) {
-          return;
-        } else {
-          var ranges = copyableRanges(cm);
-          setLastCopied({ lineWise: true, text: ranges.text });
-          if (e.type == "cut") {
-            cm.operation(function() {
-              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
-              cm.replaceSelection("", null, "cut");
-            });
-          }
-        }
-        if (e.clipboardData) {
-          e.clipboardData.clearData();
-          var content = lastCopied.text.join("\n");
-          e.clipboardData.setData("Text", content);
-          if (e.clipboardData.getData("Text") == content) {
-            e.preventDefault();
-            return;
-          }
-        }
-        var kludge = hiddenTextarea(), te = kludge.firstChild;
-        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
-        te.value = lastCopied.text.join("\n");
-        var hadFocus = activeElt();
-        selectInput(te);
-        setTimeout(function() {
-          cm.display.lineSpace.removeChild(kludge);
-          hadFocus.focus();
-          if (hadFocus == div) {
-            input2.showPrimarySelection();
-          }
-        }, 50);
-      }
-      on(div, "copy", onCopyCut);
-      on(div, "cut", onCopyCut);
-    };
-    ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
-      if (label) {
-        this.div.setAttribute("aria-label", label);
-      } else {
-        this.div.removeAttribute("aria-label");
-      }
-    };
-    ContentEditableInput.prototype.prepareSelection = function() {
-      var result = prepareSelection(this.cm, false);
-      result.focus = activeElt() == this.div;
-      return result;
-    };
-    ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
-      if (!info || !this.cm.display.view.length) {
-        return;
-      }
-      if (info.focus || takeFocus) {
-        this.showPrimarySelection();
-      }
-      this.showMultipleSelections(info);
-    };
-    ContentEditableInput.prototype.getSelection = function() {
-      return this.cm.display.wrapper.ownerDocument.getSelection();
-    };
-    ContentEditableInput.prototype.showPrimarySelection = function() {
-      var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
-      var from = prim.from(), to = prim.to();
-      if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
-        sel.removeAllRanges();
-        return;
-      }
-      var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
-      var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
-      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
-        return;
-      }
-      var view = cm.display.view;
-      var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };
-      var end = to.line < cm.display.viewTo && posToDOM(cm, to);
-      if (!end) {
-        var measure = view[view.length - 1].measure;
-        var map2 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
-        end = { node: map2[map2.length - 1], offset: map2[map2.length - 2] - map2[map2.length - 3] };
-      }
-      if (!start || !end) {
-        sel.removeAllRanges();
-        return;
-      }
-      var old = sel.rangeCount && sel.getRangeAt(0), rng;
-      try {
-        rng = range(start.node, start.offset, end.offset, end.node);
-      } catch (e) {
-      }
-      if (rng) {
-        if (!gecko && cm.state.focused) {
-          sel.collapse(start.node, start.offset);
-          if (!rng.collapsed) {
-            sel.removeAllRanges();
-            sel.addRange(rng);
-          }
-        } else {
-          sel.removeAllRanges();
-          sel.addRange(rng);
-        }
-        if (old && sel.anchorNode == null) {
-          sel.addRange(old);
-        } else if (gecko) {
-          this.startGracePeriod();
-        }
-      }
-      this.rememberSelection();
-    };
-    ContentEditableInput.prototype.startGracePeriod = function() {
-      var this$1$1 = this;
-      clearTimeout(this.gracePeriod);
-      this.gracePeriod = setTimeout(function() {
-        this$1$1.gracePeriod = false;
-        if (this$1$1.selectionChanged()) {
-          this$1$1.cm.operation(function() {
-            return this$1$1.cm.curOp.selectionChanged = true;
-          });
-        }
-      }, 20);
-    };
-    ContentEditableInput.prototype.showMultipleSelections = function(info) {
-      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
-      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
-    };
-    ContentEditableInput.prototype.rememberSelection = function() {
-      var sel = this.getSelection();
-      this.lastAnchorNode = sel.anchorNode;
-      this.lastAnchorOffset = sel.anchorOffset;
-      this.lastFocusNode = sel.focusNode;
-      this.lastFocusOffset = sel.focusOffset;
-    };
-    ContentEditableInput.prototype.selectionInEditor = function() {
-      var sel = this.getSelection();
-      if (!sel.rangeCount) {
-        return false;
-      }
-      var node = sel.getRangeAt(0).commonAncestorContainer;
-      return contains(this.div, node);
-    };
-    ContentEditableInput.prototype.focus = function() {
-      if (this.cm.options.readOnly != "nocursor") {
-        if (!this.selectionInEditor() || activeElt() != this.div) {
-          this.showSelection(this.prepareSelection(), true);
-        }
-        this.div.focus();
-      }
-    };
-    ContentEditableInput.prototype.blur = function() {
-      this.div.blur();
-    };
-    ContentEditableInput.prototype.getField = function() {
-      return this.div;
-    };
-    ContentEditableInput.prototype.supportsTouch = function() {
-      return true;
-    };
-    ContentEditableInput.prototype.receivedFocus = function() {
-      var this$1$1 = this;
-      var input2 = this;
-      if (this.selectionInEditor()) {
-        setTimeout(function() {
-          return this$1$1.pollSelection();
-        }, 20);
-      } else {
-        runInOp(this.cm, function() {
-          return input2.cm.curOp.selectionChanged = true;
-        });
-      }
-      function poll() {
-        if (input2.cm.state.focused) {
-          input2.pollSelection();
-          input2.polling.set(input2.cm.options.pollInterval, poll);
-        }
-      }
-      this.polling.set(this.cm.options.pollInterval, poll);
-    };
-    ContentEditableInput.prototype.selectionChanged = function() {
-      var sel = this.getSelection();
-      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
-    };
-    ContentEditableInput.prototype.pollSelection = function() {
-      if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
-        return;
-      }
-      var sel = this.getSelection(), cm = this.cm;
-      if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
-        this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
-        this.blur();
-        this.focus();
-        return;
-      }
-      if (this.composing) {
-        return;
-      }
-      this.rememberSelection();
-      var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
-      var head = domToPos(cm, sel.focusNode, sel.focusOffset);
-      if (anchor && head) {
-        runInOp(cm, function() {
-          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
-          if (anchor.bad || head.bad) {
-            cm.curOp.selectionChanged = true;
-          }
-        });
-      }
-    };
-    ContentEditableInput.prototype.pollContent = function() {
-      if (this.readDOMTimeout != null) {
-        clearTimeout(this.readDOMTimeout);
-        this.readDOMTimeout = null;
-      }
-      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
-      var from = sel.from(), to = sel.to();
-      if (from.ch == 0 && from.line > cm.firstLine()) {
-        from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
-      }
-      if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
-        to = Pos(to.line + 1, 0);
-      }
-      if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
-        return false;
-      }
-      var fromIndex, fromLine, fromNode;
-      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
-        fromLine = lineNo(display.view[0].line);
-        fromNode = display.view[0].node;
-      } else {
-        fromLine = lineNo(display.view[fromIndex].line);
-        fromNode = display.view[fromIndex - 1].node.nextSibling;
-      }
-      var toIndex = findViewIndex(cm, to.line);
-      var toLine, toNode;
-      if (toIndex == display.view.length - 1) {
-        toLine = display.viewTo - 1;
-        toNode = display.lineDiv.lastChild;
-      } else {
-        toLine = lineNo(display.view[toIndex + 1].line) - 1;
-        toNode = display.view[toIndex + 1].node.previousSibling;
-      }
-      if (!fromNode) {
-        return false;
-      }
-      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
-      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
-      while (newText.length > 1 && oldText.length > 1) {
-        if (lst(newText) == lst(oldText)) {
-          newText.pop();
-          oldText.pop();
-          toLine--;
-        } else if (newText[0] == oldText[0]) {
-          newText.shift();
-          oldText.shift();
-          fromLine++;
-        } else {
-          break;
-        }
-      }
-      var cutFront = 0, cutEnd = 0;
-      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
-      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
-        ++cutFront;
-      }
-      var newBot = lst(newText), oldBot = lst(oldText);
-      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
-      while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
-        ++cutEnd;
-      }
-      if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
-        while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
-          cutFront--;
-          cutEnd++;
-        }
-      }
-      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
-      newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
-      var chFrom = Pos(fromLine, cutFront);
-      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
-      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
-        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
-        return true;
-      }
-    };
-    ContentEditableInput.prototype.ensurePolled = function() {
-      this.forceCompositionEnd();
-    };
-    ContentEditableInput.prototype.reset = function() {
-      this.forceCompositionEnd();
-    };
-    ContentEditableInput.prototype.forceCompositionEnd = function() {
-      if (!this.composing) {
-        return;
-      }
-      clearTimeout(this.readDOMTimeout);
-      this.composing = null;
-      this.updateFromDOM();
-      this.div.blur();
-      this.div.focus();
-    };
-    ContentEditableInput.prototype.readFromDOMSoon = function() {
-      var this$1$1 = this;
-      if (this.readDOMTimeout != null) {
-        return;
-      }
-      this.readDOMTimeout = setTimeout(function() {
-        this$1$1.readDOMTimeout = null;
-        if (this$1$1.composing) {
-          if (this$1$1.composing.done) {
-            this$1$1.composing = null;
-          } else {
-            return;
-          }
-        }
-        this$1$1.updateFromDOM();
-      }, 80);
-    };
-    ContentEditableInput.prototype.updateFromDOM = function() {
-      var this$1$1 = this;
-      if (this.cm.isReadOnly() || !this.pollContent()) {
-        runInOp(this.cm, function() {
-          return regChange(this$1$1.cm);
-        });
-      }
-    };
-    ContentEditableInput.prototype.setUneditable = function(node) {
-      node.contentEditable = "false";
-    };
-    ContentEditableInput.prototype.onKeyPress = function(e) {
-      if (e.charCode == 0 || this.composing) {
-        return;
-      }
-      e.preventDefault();
-      if (!this.cm.isReadOnly()) {
-        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
-      }
-    };
-    ContentEditableInput.prototype.readOnlyChanged = function(val) {
-      this.div.contentEditable = String(val != "nocursor");
-    };
-    ContentEditableInput.prototype.onContextMenu = function() {
-    };
-    ContentEditableInput.prototype.resetPosition = function() {
-    };
-    ContentEditableInput.prototype.needsContentAttribute = true;
-    function posToDOM(cm, pos) {
-      var view = findViewForLine(cm, pos.line);
-      if (!view || view.hidden) {
-        return null;
-      }
-      var line = getLine(cm.doc, pos.line);
-      var info = mapFromLineView(view, line, pos.line);
-      var order = getOrder(line, cm.doc.direction), side = "left";
-      if (order) {
-        var partPos = getBidiPartAt(order, pos.ch);
-        side = partPos % 2 ? "right" : "left";
-      }
-      var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
-      result.offset = result.collapse == "right" ? result.end : result.start;
-      return result;
-    }
-    function isInGutter(node) {
-      for (var scan = node; scan; scan = scan.parentNode) {
-        if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
-          return true;
-        }
-      }
-      return false;
-    }
-    function badPos(pos, bad) {
-      if (bad) {
-        pos.bad = true;
-      }
-      return pos;
-    }
-    function domTextBetween(cm, from, to, fromLine, toLine) {
-      var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
-      function recognizeMarker(id) {
-        return function(marker) {
-          return marker.id == id;
-        };
-      }
-      function close() {
-        if (closing) {
-          text += lineSep;
-          if (extraLinebreak) {
-            text += lineSep;
-          }
-          closing = extraLinebreak = false;
-        }
-      }
-      function addText(str) {
-        if (str) {
-          close();
-          text += str;
-        }
-      }
-      function walk2(node) {
-        if (node.nodeType == 1) {
-          var cmText = node.getAttribute("cm-text");
-          if (cmText) {
-            addText(cmText);
-            return;
-          }
-          var markerID = node.getAttribute("cm-marker"), range2;
-          if (markerID) {
-            var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
-            if (found.length && (range2 = found[0].find(0))) {
-              addText(getBetween(cm.doc, range2.from, range2.to).join(lineSep));
-            }
-            return;
-          }
-          if (node.getAttribute("contenteditable") == "false") {
-            return;
-          }
-          var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
-          if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
-            return;
-          }
-          if (isBlock) {
-            close();
-          }
-          for (var i2 = 0; i2 < node.childNodes.length; i2++) {
-            walk2(node.childNodes[i2]);
-          }
-          if (/^(pre|p)$/i.test(node.nodeName)) {
-            extraLinebreak = true;
-          }
-          if (isBlock) {
-            closing = true;
-          }
-        } else if (node.nodeType == 3) {
-          addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
-        }
-      }
-      for (; ; ) {
-        walk2(from);
-        if (from == to) {
-          break;
-        }
-        from = from.nextSibling;
-        extraLinebreak = false;
-      }
-      return text;
-    }
-    function domToPos(cm, node, offset) {
-      var lineNode;
-      if (node == cm.display.lineDiv) {
-        lineNode = cm.display.lineDiv.childNodes[offset];
-        if (!lineNode) {
-          return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
-        }
-        node = null;
-        offset = 0;
-      } else {
-        for (lineNode = node; ; lineNode = lineNode.parentNode) {
-          if (!lineNode || lineNode == cm.display.lineDiv) {
-            return null;
-          }
-          if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
-            break;
-          }
-        }
-      }
-      for (var i2 = 0; i2 < cm.display.view.length; i2++) {
-        var lineView = cm.display.view[i2];
-        if (lineView.node == lineNode) {
-          return locateNodeInLineView(lineView, node, offset);
-        }
-      }
-    }
-    function locateNodeInLineView(lineView, node, offset) {
-      var wrapper = lineView.text.firstChild, bad = false;
-      if (!node || !contains(wrapper, node)) {
-        return badPos(Pos(lineNo(lineView.line), 0), true);
-      }
-      if (node == wrapper) {
-        bad = true;
-        node = wrapper.childNodes[offset];
-        offset = 0;
-        if (!node) {
-          var line = lineView.rest ? lst(lineView.rest) : lineView.line;
-          return badPos(Pos(lineNo(line), line.text.length), bad);
-        }
-      }
-      var textNode = node.nodeType == 3 ? node : null, topNode = node;
-      if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
-        textNode = node.firstChild;
-        if (offset) {
-          offset = textNode.nodeValue.length;
-        }
-      }
-      while (topNode.parentNode != wrapper) {
-        topNode = topNode.parentNode;
-      }
-      var measure = lineView.measure, maps = measure.maps;
-      function find(textNode2, topNode2, offset2) {
-        for (var i2 = -1; i2 < (maps ? maps.length : 0); i2++) {
-          var map2 = i2 < 0 ? measure.map : maps[i2];
-          for (var j = 0; j < map2.length; j += 3) {
-            var curNode = map2[j + 2];
-            if (curNode == textNode2 || curNode == topNode2) {
-              var line2 = lineNo(i2 < 0 ? lineView.line : lineView.rest[i2]);
-              var ch = map2[j] + offset2;
-              if (offset2 < 0 || curNode != textNode2) {
-                ch = map2[j + (offset2 ? 1 : 0)];
-              }
-              return Pos(line2, ch);
-            }
-          }
-        }
-      }
-      var found = find(textNode, topNode, offset);
-      if (found) {
-        return badPos(found, bad);
-      }
-      for (var after = topNode.nextSibling, dist2 = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
-        found = find(after, after.firstChild, 0);
-        if (found) {
-          return badPos(Pos(found.line, found.ch - dist2), bad);
-        } else {
-          dist2 += after.textContent.length;
-        }
-      }
-      for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
-        found = find(before, before.firstChild, -1);
-        if (found) {
-          return badPos(Pos(found.line, found.ch + dist$1), bad);
-        } else {
-          dist$1 += before.textContent.length;
-        }
-      }
-    }
-    var TextareaInput = function(cm) {
-      this.cm = cm;
-      this.prevInput = "";
-      this.pollingFast = false;
-      this.polling = new Delayed();
-      this.hasSelection = false;
-      this.composing = null;
-    };
-    TextareaInput.prototype.init = function(display) {
-      var this$1$1 = this;
-      var input2 = this, cm = this.cm;
-      this.createField(display);
-      var te = this.textarea;
-      display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
-      if (ios) {
-        te.style.width = "0px";
-      }
-      on(te, "input", function() {
-        if (ie && ie_version >= 9 && this$1$1.hasSelection) {
-          this$1$1.hasSelection = null;
-        }
-        input2.poll();
-      });
-      on(te, "paste", function(e) {
-        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
-          return;
-        }
-        cm.state.pasteIncoming = +new Date();
-        input2.fastPoll();
-      });
-      function prepareCopyCut(e) {
-        if (signalDOMEvent(cm, e)) {
-          return;
-        }
-        if (cm.somethingSelected()) {
-          setLastCopied({ lineWise: false, text: cm.getSelections() });
-        } else if (!cm.options.lineWiseCopyCut) {
-          return;
-        } else {
-          var ranges = copyableRanges(cm);
-          setLastCopied({ lineWise: true, text: ranges.text });
-          if (e.type == "cut") {
-            cm.setSelections(ranges.ranges, null, sel_dontScroll);
-          } else {
-            input2.prevInput = "";
-            te.value = ranges.text.join("\n");
-            selectInput(te);
-          }
-        }
-        if (e.type == "cut") {
-          cm.state.cutIncoming = +new Date();
-        }
-      }
-      on(te, "cut", prepareCopyCut);
-      on(te, "copy", prepareCopyCut);
-      on(display.scroller, "paste", function(e) {
-        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
-          return;
-        }
-        if (!te.dispatchEvent) {
-          cm.state.pasteIncoming = +new Date();
-          input2.focus();
-          return;
-        }
-        var event2 = new Event("paste");
-        event2.clipboardData = e.clipboardData;
-        te.dispatchEvent(event2);
-      });
-      on(display.lineSpace, "selectstart", function(e) {
-        if (!eventInWidget(display, e)) {
-          e_preventDefault(e);
-        }
-      });
-      on(te, "compositionstart", function() {
-        var start = cm.getCursor("from");
-        if (input2.composing) {
-          input2.composing.range.clear();
-        }
-        input2.composing = {
-          start,
-          range: cm.markText(start, cm.getCursor("to"), { className: "CodeMirror-composing" })
-        };
-      });
-      on(te, "compositionend", function() {
-        if (input2.composing) {
-          input2.poll();
-          input2.composing.range.clear();
-          input2.composing = null;
-        }
-      });
-    };
-    TextareaInput.prototype.createField = function(_display) {
-      this.wrapper = hiddenTextarea();
-      this.textarea = this.wrapper.firstChild;
-    };
-    TextareaInput.prototype.screenReaderLabelChanged = function(label) {
-      if (label) {
-        this.textarea.setAttribute("aria-label", label);
-      } else {
-        this.textarea.removeAttribute("aria-label");
-      }
-    };
-    TextareaInput.prototype.prepareSelection = function() {
-      var cm = this.cm, display = cm.display, doc = cm.doc;
-      var result = prepareSelection(cm);
-      if (cm.options.moveInputWithCursor) {
-        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
-        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
-        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
-        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
-      }
-      return result;
-    };
-    TextareaInput.prototype.showSelection = function(drawn) {
-      var cm = this.cm, display = cm.display;
-      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
-      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
-      if (drawn.teTop != null) {
-        this.wrapper.style.top = drawn.teTop + "px";
-        this.wrapper.style.left = drawn.teLeft + "px";
-      }
-    };
-    TextareaInput.prototype.reset = function(typing) {
-      if (this.contextMenuPending || this.composing) {
-        return;
-      }
-      var cm = this.cm;
-      if (cm.somethingSelected()) {
-        this.prevInput = "";
-        var content = cm.getSelection();
-        this.textarea.value = content;
-        if (cm.state.focused) {
-          selectInput(this.textarea);
-        }
-        if (ie && ie_version >= 9) {
-          this.hasSelection = content;
-        }
-      } else if (!typing) {
-        this.prevInput = this.textarea.value = "";
-        if (ie && ie_version >= 9) {
-          this.hasSelection = null;
-        }
-      }
-    };
-    TextareaInput.prototype.getField = function() {
-      return this.textarea;
-    };
-    TextareaInput.prototype.supportsTouch = function() {
-      return false;
-    };
-    TextareaInput.prototype.focus = function() {
-      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
-        try {
-          this.textarea.focus();
-        } catch (e) {
-        }
-      }
-    };
-    TextareaInput.prototype.blur = function() {
-      this.textarea.blur();
-    };
-    TextareaInput.prototype.resetPosition = function() {
-      this.wrapper.style.top = this.wrapper.style.left = 0;
-    };
-    TextareaInput.prototype.receivedFocus = function() {
-      this.slowPoll();
-    };
-    TextareaInput.prototype.slowPoll = function() {
-      var this$1$1 = this;
-      if (this.pollingFast) {
-        return;
-      }
-      this.polling.set(this.cm.options.pollInterval, function() {
-        this$1$1.poll();
-        if (this$1$1.cm.state.focused) {
-          this$1$1.slowPoll();
-        }
-      });
-    };
-    TextareaInput.prototype.fastPoll = function() {
-      var missed = false, input2 = this;
-      input2.pollingFast = true;
-      function p() {
-        var changed = input2.poll();
-        if (!changed && !missed) {
-          missed = true;
-          input2.polling.set(60, p);
-        } else {
-          input2.pollingFast = false;
-          input2.slowPoll();
-        }
-      }
-      input2.polling.set(20, p);
-    };
-    TextareaInput.prototype.poll = function() {
-      var this$1$1 = this;
-      var cm = this.cm, input2 = this.textarea, prevInput = this.prevInput;
-      if (this.contextMenuPending || !cm.state.focused || hasSelection(input2) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
-        return false;
-      }
-      var text = input2.value;
-      if (text == prevInput && !cm.somethingSelected()) {
-        return false;
-      }
-      if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
-        cm.display.input.reset();
-        return false;
-      }
-      if (cm.doc.sel == cm.display.selForContextMenu) {
-        var first = text.charCodeAt(0);
-        if (first == 8203 && !prevInput) {
-          prevInput = "\u200B";
-        }
-        if (first == 8666) {
-          this.reset();
-          return this.cm.execCommand("undo");
-        }
-      }
-      var same = 0, l = Math.min(prevInput.length, text.length);
-      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
-        ++same;
-      }
-      runInOp(cm, function() {
-        applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1$1.composing ? "*compose" : null);
-        if (text.length > 1e3 || text.indexOf("\n") > -1) {
-          input2.value = this$1$1.prevInput = "";
-        } else {
-          this$1$1.prevInput = text;
-        }
-        if (this$1$1.composing) {
-          this$1$1.composing.range.clear();
-          this$1$1.composing.range = cm.markText(this$1$1.composing.start, cm.getCursor("to"), { className: "CodeMirror-composing" });
-        }
-      });
-      return true;
-    };
-    TextareaInput.prototype.ensurePolled = function() {
-      if (this.pollingFast && this.poll()) {
-        this.pollingFast = false;
-      }
-    };
-    TextareaInput.prototype.onKeyPress = function() {
-      if (ie && ie_version >= 9) {
-        this.hasSelection = null;
-      }
-      this.fastPoll();
-    };
-    TextareaInput.prototype.onContextMenu = function(e) {
-      var input2 = this, cm = input2.cm, display = cm.display, te = input2.textarea;
-      if (input2.contextMenuPending) {
-        input2.contextMenuPending();
-      }
-      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
-      if (!pos || presto) {
-        return;
-      }
-      var reset = cm.options.resetSelectionOnContextMenu;
-      if (reset && cm.doc.sel.contains(pos) == -1) {
-        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
-      }
-      var oldCSS = te.style.cssText, oldWrapperCSS = input2.wrapper.style.cssText;
-      var wrapperBox = input2.wrapper.offsetParent.getBoundingClientRect();
-      input2.wrapper.style.cssText = "position: static";
-      te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
-      var oldScrollY;
-      if (webkit) {
-        oldScrollY = window.scrollY;
-      }
-      display.input.focus();
-      if (webkit) {
-        window.scrollTo(null, oldScrollY);
-      }
-      display.input.reset();
-      if (!cm.somethingSelected()) {
-        te.value = input2.prevInput = " ";
-      }
-      input2.contextMenuPending = rehide;
-      display.selForContextMenu = cm.doc.sel;
-      clearTimeout(display.detectingSelectAll);
-      function prepareSelectAllHack() {
-        if (te.selectionStart != null) {
-          var selected = cm.somethingSelected();
-          var extval = "\u200B" + (selected ? te.value : "");
-          te.value = "\u21DA";
-          te.value = extval;
-          input2.prevInput = selected ? "" : "\u200B";
-          te.selectionStart = 1;
-          te.selectionEnd = extval.length;
-          display.selForContextMenu = cm.doc.sel;
-        }
-      }
-      function rehide() {
-        if (input2.contextMenuPending != rehide) {
-          return;
-        }
-        input2.contextMenuPending = false;
-        input2.wrapper.style.cssText = oldWrapperCSS;
-        te.style.cssText = oldCSS;
-        if (ie && ie_version < 9) {
-          display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
-        }
-        if (te.selectionStart != null) {
-          if (!ie || ie && ie_version < 9) {
-            prepareSelectAllHack();
-          }
-          var i2 = 0, poll = function() {
-            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input2.prevInput == "\u200B") {
-              operation(cm, selectAll)(cm);
-            } else if (i2++ < 10) {
-              display.detectingSelectAll = setTimeout(poll, 500);
-            } else {
-              display.selForContextMenu = null;
-              display.input.reset();
-            }
-          };
-          display.detectingSelectAll = setTimeout(poll, 200);
-        }
-      }
-      if (ie && ie_version >= 9) {
-        prepareSelectAllHack();
-      }
-      if (captureRightClick) {
-        e_stop(e);
-        var mouseup = function() {
-          off(window, "mouseup", mouseup);
-          setTimeout(rehide, 20);
-        };
-        on(window, "mouseup", mouseup);
-      } else {
-        setTimeout(rehide, 50);
-      }
-    };
-    TextareaInput.prototype.readOnlyChanged = function(val) {
-      if (!val) {
-        this.reset();
-      }
-      this.textarea.disabled = val == "nocursor";
-      this.textarea.readOnly = !!val;
-    };
-    TextareaInput.prototype.setUneditable = function() {
-    };
-    TextareaInput.prototype.needsContentAttribute = false;
-    function fromTextArea(textarea, options) {
-      options = options ? copyObj(options) : {};
-      options.value = textarea.value;
-      if (!options.tabindex && textarea.tabIndex) {
-        options.tabindex = textarea.tabIndex;
-      }
-      if (!options.placeholder && textarea.placeholder) {
-        options.placeholder = textarea.placeholder;
-      }
-      if (options.autofocus == null) {
-        var hasFocus = activeElt();
-        options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
-      }
-      function save() {
-        textarea.value = cm.getValue();
-      }
-      var realSubmit;
-      if (textarea.form) {
-        on(textarea.form, "submit", save);
-        if (!options.leaveSubmitMethodAlone) {
-          var form = textarea.form;
-          realSubmit = form.submit;
-          try {
-            var wrappedSubmit = form.submit = function() {
-              save();
-              form.submit = realSubmit;
-              form.submit();
-              form.submit = wrappedSubmit;
-            };
-          } catch (e) {
-          }
-        }
-      }
-      options.finishInit = function(cm2) {
-        cm2.save = save;
-        cm2.getTextArea = function() {
-          return textarea;
-        };
-        cm2.toTextArea = function() {
-          cm2.toTextArea = isNaN;
-          save();
-          textarea.parentNode.removeChild(cm2.getWrapperElement());
-          textarea.style.display = "";
-          if (textarea.form) {
-            off(textarea.form, "submit", save);
-            if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
-              textarea.form.submit = realSubmit;
-            }
-          }
-        };
-      };
-      textarea.style.display = "none";
-      var cm = CodeMirror2(function(node) {
-        return textarea.parentNode.insertBefore(node, textarea.nextSibling);
-      }, options);
-      return cm;
-    }
-    function addLegacyProps(CodeMirror3) {
-      CodeMirror3.off = off;
-      CodeMirror3.on = on;
-      CodeMirror3.wheelEventPixels = wheelEventPixels;
-      CodeMirror3.Doc = Doc;
-      CodeMirror3.splitLines = splitLinesAuto;
-      CodeMirror3.countColumn = countColumn;
-      CodeMirror3.findColumn = findColumn;
-      CodeMirror3.isWordChar = isWordCharBasic;
-      CodeMirror3.Pass = Pass;
-      CodeMirror3.signal = signal;
-      CodeMirror3.Line = Line;
-      CodeMirror3.changeEnd = changeEnd;
-      CodeMirror3.scrollbarModel = scrollbarModel;
-      CodeMirror3.Pos = Pos;
-      CodeMirror3.cmpPos = cmp;
-      CodeMirror3.modes = modes;
-      CodeMirror3.mimeModes = mimeModes;
-      CodeMirror3.resolveMode = resolveMode;
-      CodeMirror3.getMode = getMode;
-      CodeMirror3.modeExtensions = modeExtensions;
-      CodeMirror3.extendMode = extendMode;
-      CodeMirror3.copyState = copyState;
-      CodeMirror3.startState = startState;
-      CodeMirror3.innerMode = innerMode;
-      CodeMirror3.commands = commands;
-      CodeMirror3.keyMap = keyMap;
-      CodeMirror3.keyName = keyName;
-      CodeMirror3.isModifierKey = isModifierKey;
-      CodeMirror3.lookupKey = lookupKey;
-      CodeMirror3.normalizeKeyMap = normalizeKeyMap;
-      CodeMirror3.StringStream = StringStream;
-      CodeMirror3.SharedTextMarker = SharedTextMarker;
-      CodeMirror3.TextMarker = TextMarker;
-      CodeMirror3.LineWidget = LineWidget;
-      CodeMirror3.e_preventDefault = e_preventDefault;
-      CodeMirror3.e_stopPropagation = e_stopPropagation;
-      CodeMirror3.e_stop = e_stop;
-      CodeMirror3.addClass = addClass;
-      CodeMirror3.contains = contains;
-      CodeMirror3.rmClass = rmClass;
-      CodeMirror3.keyNames = keyNames;
-    }
-    defineOptions(CodeMirror2);
-    addEditorMethods(CodeMirror2);
-    var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
-    for (var prop in Doc.prototype) {
-      if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
-        CodeMirror2.prototype[prop] = function(method) {
-          return function() {
-            return method.apply(this.doc, arguments);
-          };
-        }(Doc.prototype[prop]);
-      }
-    }
-    eventMixin(Doc);
-    CodeMirror2.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };
-    CodeMirror2.defineMode = function(name) {
-      if (!CodeMirror2.defaults.mode && name != "null") {
-        CodeMirror2.defaults.mode = name;
-      }
-      defineMode.apply(this, arguments);
-    };
-    CodeMirror2.defineMIME = defineMIME;
-    CodeMirror2.defineMode("null", function() {
-      return { token: function(stream) {
-        return stream.skipToEnd();
-      } };
-    });
-    CodeMirror2.defineMIME("text/plain", "null");
-    CodeMirror2.defineExtension = function(name, func) {
-      CodeMirror2.prototype[name] = func;
-    };
-    CodeMirror2.defineDocExtension = function(name, func) {
-      Doc.prototype[name] = func;
-    };
-    CodeMirror2.fromTextArea = fromTextArea;
-    addLegacyProps(CodeMirror2);
-    CodeMirror2.version = "5.63.1";
-    return CodeMirror2;
-  });
-})(codemirror$1);
-var CodeMirror = codemirror$1.exports;
-var codemirror = "";
-var javascript = { exports: {} };
-(function(module, exports) {
-  (function(mod) {
-    mod(codemirror$1.exports);
-  })(function(CodeMirror2) {
-    CodeMirror2.defineMode("javascript", function(config, parserConfig) {
-      var indentUnit = config.indentUnit;
-      var statementIndent = parserConfig.statementIndent;
-      var jsonldMode = parserConfig.jsonld;
-      var jsonMode = parserConfig.json || jsonldMode;
-      var trackScope = parserConfig.trackScope !== false;
-      var isTS = parserConfig.typescript;
-      var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
-      var keywords = function() {
-        function kw(type2) {
-          return { type: type2, style: "keyword" };
-        }
-        var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
-        var operator = kw("operator"), atom = { type: "atom", style: "atom" };
-        return {
-          "if": kw("if"),
-          "while": A,
-          "with": A,
-          "else": B,
-          "do": B,
-          "try": B,
-          "finally": B,
-          "return": D,
-          "break": D,
-          "continue": D,
-          "new": kw("new"),
-          "delete": C,
-          "void": C,
-          "throw": C,
-          "debugger": kw("debugger"),
-          "var": kw("var"),
-          "const": kw("var"),
-          "let": kw("var"),
-          "function": kw("function"),
-          "catch": kw("catch"),
-          "for": kw("for"),
-          "switch": kw("switch"),
-          "case": kw("case"),
-          "default": kw("default"),
-          "in": operator,
-          "typeof": operator,
-          "instanceof": operator,
-          "true": atom,
-          "false": atom,
-          "null": atom,
-          "undefined": atom,
-          "NaN": atom,
-          "Infinity": atom,
-          "this": kw("this"),
-          "class": kw("class"),
-          "super": kw("atom"),
-          "yield": C,
-          "export": kw("export"),
-          "import": kw("import"),
-          "extends": C,
-          "await": C
-        };
-      }();
-      var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
-      var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
-      function readRegexp2(stream) {
-        var escaped = false, next2, inSet = false;
-        while ((next2 = stream.next()) != null) {
-          if (!escaped) {
-            if (next2 == "/" && !inSet)
-              return;
-            if (next2 == "[")
-              inSet = true;
-            else if (inSet && next2 == "]")
-              inSet = false;
-          }
-          escaped = !escaped && next2 == "\\";
-        }
-      }
-      var type, content;
-      function ret(tp, style, cont2) {
-        type = tp;
-        content = cont2;
-        return style;
-      }
-      function tokenBase(stream, state2) {
-        var ch = stream.next();
-        if (ch == '"' || ch == "'") {
-          state2.tokenize = tokenString(ch);
-          return state2.tokenize(stream, state2);
-        } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
-          return ret("number", "number");
-        } else if (ch == "." && stream.match("..")) {
-          return ret("spread", "meta");
-        } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
-          return ret(ch);
-        } else if (ch == "=" && stream.eat(">")) {
-          return ret("=>", "operator");
-        } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
-          return ret("number", "number");
-        } else if (/\d/.test(ch)) {
-          stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
-          return ret("number", "number");
-        } else if (ch == "/") {
-          if (stream.eat("*")) {
-            state2.tokenize = tokenComment;
-            return tokenComment(stream, state2);
-          } else if (stream.eat("/")) {
-            stream.skipToEnd();
-            return ret("comment", "comment");
-          } else if (expressionAllowed(stream, state2, 1)) {
-            readRegexp2(stream);
-            stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
-            return ret("regexp", "string-2");
-          } else {
-            stream.eat("=");
-            return ret("operator", "operator", stream.current());
-          }
-        } else if (ch == "`") {
-          state2.tokenize = tokenQuasi;
-          return tokenQuasi(stream, state2);
-        } else if (ch == "#" && stream.peek() == "!") {
-          stream.skipToEnd();
-          return ret("meta", "meta");
-        } else if (ch == "#" && stream.eatWhile(wordRE)) {
-          return ret("variable", "property");
-        } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start))) {
-          stream.skipToEnd();
-          return ret("comment", "comment");
-        } else if (isOperatorChar.test(ch)) {
-          if (ch != ">" || !state2.lexical || state2.lexical.type != ">") {
-            if (stream.eat("=")) {
-              if (ch == "!" || ch == "=")
-                stream.eat("=");
-            } else if (/[<>*+\-|&?]/.test(ch)) {
-              stream.eat(ch);
-              if (ch == ">")
-                stream.eat(ch);
-            }
-          }
-          if (ch == "?" && stream.eat("."))
-            return ret(".");
-          return ret("operator", "operator", stream.current());
-        } else if (wordRE.test(ch)) {
-          stream.eatWhile(wordRE);
-          var word = stream.current();
-          if (state2.lastType != ".") {
-            if (keywords.propertyIsEnumerable(word)) {
-              var kw = keywords[word];
-              return ret(kw.type, kw.style, word);
-            }
-            if (word == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
-              return ret("async", "keyword", word);
-          }
-          return ret("variable", "variable", word);
-        }
-      }
-      function tokenString(quote) {
-        return function(stream, state2) {
-          var escaped = false, next2;
-          if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
-            state2.tokenize = tokenBase;
-            return ret("jsonld-keyword", "meta");
-          }
-          while ((next2 = stream.next()) != null) {
-            if (next2 == quote && !escaped)
-              break;
-            escaped = !escaped && next2 == "\\";
-          }
-          if (!escaped)
-            state2.tokenize = tokenBase;
-          return ret("string", "string");
-        };
-      }
-      function tokenComment(stream, state2) {
-        var maybeEnd = false, ch;
-        while (ch = stream.next()) {
-          if (ch == "/" && maybeEnd) {
-            state2.tokenize = tokenBase;
-            break;
-          }
-          maybeEnd = ch == "*";
-        }
-        return ret("comment", "comment");
-      }
-      function tokenQuasi(stream, state2) {
-        var escaped = false, next2;
-        while ((next2 = stream.next()) != null) {
-          if (!escaped && (next2 == "`" || next2 == "$" && stream.eat("{"))) {
-            state2.tokenize = tokenBase;
-            break;
-          }
-          escaped = !escaped && next2 == "\\";
-        }
-        return ret("quasi", "string-2", stream.current());
-      }
-      var brackets = "([{}])";
-      function findFatArrow(stream, state2) {
-        if (state2.fatArrowAt)
-          state2.fatArrowAt = null;
-        var arrow = stream.string.indexOf("=>", stream.start);
-        if (arrow < 0)
-          return;
-        if (isTS) {
-          var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
-          if (m)
-            arrow = m.index;
-        }
-        var depth = 0, sawSomething = false;
-        for (var pos = arrow - 1; pos >= 0; --pos) {
-          var ch = stream.string.charAt(pos);
-          var bracket = brackets.indexOf(ch);
-          if (bracket >= 0 && bracket < 3) {
-            if (!depth) {
-              ++pos;
-              break;
-            }
-            if (--depth == 0) {
-              if (ch == "(")
-                sawSomething = true;
-              break;
-            }
-          } else if (bracket >= 3 && bracket < 6) {
-            ++depth;
-          } else if (wordRE.test(ch)) {
-            sawSomething = true;
-          } else if (/["'\/`]/.test(ch)) {
-            for (; ; --pos) {
-              if (pos == 0)
-                return;
-              var next2 = stream.string.charAt(pos - 1);
-              if (next2 == ch && stream.string.charAt(pos - 2) != "\\") {
-                pos--;
-                break;
-              }
-            }
-          } else if (sawSomething && !depth) {
-            ++pos;
-            break;
-          }
-        }
-        if (sawSomething && !depth)
-          state2.fatArrowAt = pos;
-      }
-      var atomicTypes = {
-        "atom": true,
-        "number": true,
-        "variable": true,
-        "string": true,
-        "regexp": true,
-        "this": true,
-        "import": true,
-        "jsonld-keyword": true
-      };
-      function JSLexical(indented, column, type2, align, prev, info) {
-        this.indented = indented;
-        this.column = column;
-        this.type = type2;
-        this.prev = prev;
-        this.info = info;
-        if (align != null)
-          this.align = align;
-      }
-      function inScope(state2, varname) {
-        if (!trackScope)
-          return false;
-        for (var v = state2.localVars; v; v = v.next)
-          if (v.name == varname)
-            return true;
-        for (var cx2 = state2.context; cx2; cx2 = cx2.prev) {
-          for (var v = cx2.vars; v; v = v.next)
-            if (v.name == varname)
-              return true;
-        }
-      }
-      function parseJS(state2, style, type2, content2, stream) {
-        var cc = state2.cc;
-        cx.state = state2;
-        cx.stream = stream;
-        cx.marked = null, cx.cc = cc;
-        cx.style = style;
-        if (!state2.lexical.hasOwnProperty("align"))
-          state2.lexical.align = true;
-        while (true) {
-          var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
-          if (combinator(type2, content2)) {
-            while (cc.length && cc[cc.length - 1].lex)
-              cc.pop()();
-            if (cx.marked)
-              return cx.marked;
-            if (type2 == "variable" && inScope(state2, content2))
-              return "variable-2";
-            return style;
-          }
-        }
-      }
-      var cx = { state: null, column: null, marked: null, cc: null };
-      function pass() {
-        for (var i = arguments.length - 1; i >= 0; i--)
-          cx.cc.push(arguments[i]);
-      }
-      function cont() {
-        pass.apply(null, arguments);
-        return true;
-      }
-      function inList(name, list) {
-        for (var v = list; v; v = v.next)
-          if (v.name == name)
-            return true;
-        return false;
-      }
-      function register(varname) {
-        var state2 = cx.state;
-        cx.marked = "def";
-        if (!trackScope)
-          return;
-        if (state2.context) {
-          if (state2.lexical.info == "var" && state2.context && state2.context.block) {
-            var newContext = registerVarScoped(varname, state2.context);
-            if (newContext != null) {
-              state2.context = newContext;
-              return;
-            }
-          } else if (!inList(varname, state2.localVars)) {
-            state2.localVars = new Var(varname, state2.localVars);
-            return;
-          }
-        }
-        if (parserConfig.globalVars && !inList(varname, state2.globalVars))
-          state2.globalVars = new Var(varname, state2.globalVars);
-      }
-      function registerVarScoped(varname, context) {
-        if (!context) {
-          return null;
-        } else if (context.block) {
-          var inner = registerVarScoped(varname, context.prev);
-          if (!inner)
-            return null;
-          if (inner == context.prev)
-            return context;
-          return new Context(inner, context.vars, true);
-        } else if (inList(varname, context.vars)) {
-          return context;
-        } else {
-          return new Context(context.prev, new Var(varname, context.vars), false);
-        }
-      }
-      function isModifier(name) {
-        return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly";
-      }
-      function Context(prev, vars, block2) {
-        this.prev = prev;
-        this.vars = vars;
-        this.block = block2;
-      }
-      function Var(name, next2) {
-        this.name = name;
-        this.next = next2;
-      }
-      var defaultVars = new Var("this", new Var("arguments", null));
-      function pushcontext() {
-        cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
-        cx.state.localVars = defaultVars;
-      }
-      function pushblockcontext() {
-        cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
-        cx.state.localVars = null;
-      }
-      function popcontext() {
-        cx.state.localVars = cx.state.context.vars;
-        cx.state.context = cx.state.context.prev;
-      }
-      popcontext.lex = true;
-      function pushlex(type2, info) {
-        var result = function() {
-          var state2 = cx.state, indent = state2.indented;
-          if (state2.lexical.type == "stat")
-            indent = state2.lexical.indented;
-          else
-            for (var outer = state2.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
-              indent = outer.indented;
-          state2.lexical = new JSLexical(indent, cx.stream.column(), type2, null, state2.lexical, info);
-        };
-        result.lex = true;
-        return result;
-      }
-      function poplex() {
-        var state2 = cx.state;
-        if (state2.lexical.prev) {
-          if (state2.lexical.type == ")")
-            state2.indented = state2.lexical.indented;
-          state2.lexical = state2.lexical.prev;
-        }
-      }
-      poplex.lex = true;
-      function expect2(wanted) {
-        function exp(type2) {
-          if (type2 == wanted)
-            return cont();
-          else if (wanted == ";" || type2 == "}" || type2 == ")" || type2 == "]")
-            return pass();
-          else
-            return cont(exp);
-        }
-        return exp;
-      }
-      function statement(type2, value) {
-        if (type2 == "var")
-          return cont(pushlex("vardef", value), vardef, expect2(";"), poplex);
-        if (type2 == "keyword a")
-          return cont(pushlex("form"), parenExpr, statement, poplex);
-        if (type2 == "keyword b")
-          return cont(pushlex("form"), statement, poplex);
-        if (type2 == "keyword d")
-          return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect2(";"), poplex);
-        if (type2 == "debugger")
-          return cont(expect2(";"));
-        if (type2 == "{")
-          return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
-        if (type2 == ";")
-          return cont();
-        if (type2 == "if") {
-          if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
-            cx.state.cc.pop()();
-          return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
-        }
-        if (type2 == "function")
-          return cont(functiondef);
-        if (type2 == "for")
-          return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);
-        if (type2 == "class" || isTS && value == "interface") {
-          cx.marked = "keyword";
-          return cont(pushlex("form", type2 == "class" ? type2 : value), className, poplex);
-        }
-        if (type2 == "variable") {
-          if (isTS && value == "declare") {
-            cx.marked = "keyword";
-            return cont(statement);
-          } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
-            cx.marked = "keyword";
-            if (value == "enum")
-              return cont(enumdef);
-            else if (value == "type")
-              return cont(typename, expect2("operator"), typeexpr, expect2(";"));
-            else
-              return cont(pushlex("form"), pattern, expect2("{"), pushlex("}"), block, poplex, poplex);
-          } else if (isTS && value == "namespace") {
-            cx.marked = "keyword";
-            return cont(pushlex("form"), expression, statement, poplex);
-          } else if (isTS && value == "abstract") {
-            cx.marked = "keyword";
-            return cont(statement);
-          } else {
-            return cont(pushlex("stat"), maybelabel);
-          }
-        }
-        if (type2 == "switch")
-          return cont(pushlex("form"), parenExpr, expect2("{"), pushlex("}", "switch"), pushblockcontext, block, poplex, poplex, popcontext);
-        if (type2 == "case")
-          return cont(expression, expect2(":"));
-        if (type2 == "default")
-          return cont(expect2(":"));
-        if (type2 == "catch")
-          return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
-        if (type2 == "export")
-          return cont(pushlex("stat"), afterExport, poplex);
-        if (type2 == "import")
-          return cont(pushlex("stat"), afterImport, poplex);
-        if (type2 == "async")
-          return cont(statement);
-        if (value == "@")
-          return cont(expression, statement);
-        return pass(pushlex("stat"), expression, expect2(";"), poplex);
-      }
-      function maybeCatchBinding(type2) {
-        if (type2 == "(")
-          return cont(funarg, expect2(")"));
-      }
-      function expression(type2, value) {
-        return expressionInner(type2, value, false);
-      }
-      function expressionNoComma(type2, value) {
-        return expressionInner(type2, value, true);
-      }
-      function parenExpr(type2) {
-        if (type2 != "(")
-          return pass();
-        return cont(pushlex(")"), maybeexpression, expect2(")"), poplex);
-      }
-      function expressionInner(type2, value, noComma) {
-        if (cx.state.fatArrowAt == cx.stream.start) {
-          var body = noComma ? arrowBodyNoComma : arrowBody;
-          if (type2 == "(")
-            return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect2("=>"), body, popcontext);
-          else if (type2 == "variable")
-            return pass(pushcontext, pattern, expect2("=>"), body, popcontext);
-        }
-        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
-        if (atomicTypes.hasOwnProperty(type2))
-          return cont(maybeop);
-        if (type2 == "function")
-          return cont(functiondef, maybeop);
-        if (type2 == "class" || isTS && value == "interface") {
-          cx.marked = "keyword";
-          return cont(pushlex("form"), classExpression, poplex);
-        }
-        if (type2 == "keyword c" || type2 == "async")
-          return cont(noComma ? expressionNoComma : expression);
-        if (type2 == "(")
-          return cont(pushlex(")"), maybeexpression, expect2(")"), poplex, maybeop);
-        if (type2 == "operator" || type2 == "spread")
-          return cont(noComma ? expressionNoComma : expression);
-        if (type2 == "[")
-          return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
-        if (type2 == "{")
-          return contCommasep(objprop, "}", null, maybeop);
-        if (type2 == "quasi")
-          return pass(quasi, maybeop);
-        if (type2 == "new")
-          return cont(maybeTarget(noComma));
-        return cont();
-      }
-      function maybeexpression(type2) {
-        if (type2.match(/[;\}\)\],]/))
-          return pass();
-        return pass(expression);
-      }
-      function maybeoperatorComma(type2, value) {
-        if (type2 == ",")
-          return cont(maybeexpression);
-        return maybeoperatorNoComma(type2, value, false);
-      }
-      function maybeoperatorNoComma(type2, value, noComma) {
-        var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
-        var expr = noComma == false ? expression : expressionNoComma;
-        if (type2 == "=>")
-          return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
-        if (type2 == "operator") {
-          if (/\+\+|--/.test(value) || isTS && value == "!")
-            return cont(me);
-          if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false))
-            return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
-          if (value == "?")
-            return cont(expression, expect2(":"), expr);
-          return cont(expr);
-        }
-        if (type2 == "quasi") {
-          return pass(quasi, me);
-        }
-        if (type2 == ";")
-          return;
-        if (type2 == "(")
-          return contCommasep(expressionNoComma, ")", "call", me);
-        if (type2 == ".")
-          return cont(property, me);
-        if (type2 == "[")
-          return cont(pushlex("]"), maybeexpression, expect2("]"), poplex, me);
-        if (isTS && value == "as") {
-          cx.marked = "keyword";
-          return cont(typeexpr, me);
-        }
-        if (type2 == "regexp") {
-          cx.state.lastType = cx.marked = "operator";
-          cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
-          return cont(expr);
-        }
-      }
-      function quasi(type2, value) {
-        if (type2 != "quasi")
-          return pass();
-        if (value.slice(value.length - 2) != "${")
-          return cont(quasi);
-        return cont(maybeexpression, continueQuasi);
-      }
-      function continueQuasi(type2) {
-        if (type2 == "}") {
-          cx.marked = "string-2";
-          cx.state.tokenize = tokenQuasi;
-          return cont(quasi);
-        }
-      }
-      function arrowBody(type2) {
-        findFatArrow(cx.stream, cx.state);
-        return pass(type2 == "{" ? statement : expression);
-      }
-      function arrowBodyNoComma(type2) {
-        findFatArrow(cx.stream, cx.state);
-        return pass(type2 == "{" ? statement : expressionNoComma);
-      }
-      function maybeTarget(noComma) {
-        return function(type2) {
-          if (type2 == ".")
-            return cont(noComma ? targetNoComma : target);
-          else if (type2 == "variable" && isTS)
-            return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);
-          else
-            return pass(noComma ? expressionNoComma : expression);
-        };
-      }
-      function target(_, value) {
-        if (value == "target") {
-          cx.marked = "keyword";
-          return cont(maybeoperatorComma);
-        }
-      }
-      function targetNoComma(_, value) {
-        if (value == "target") {
-          cx.marked = "keyword";
-          return cont(maybeoperatorNoComma);
-        }
-      }
-      function maybelabel(type2) {
-        if (type2 == ":")
-          return cont(poplex, statement);
-        return pass(maybeoperatorComma, expect2(";"), poplex);
-      }
-      function property(type2) {
-        if (type2 == "variable") {
-          cx.marked = "property";
-          return cont();
-        }
-      }
-      function objprop(type2, value) {
-        if (type2 == "async") {
-          cx.marked = "property";
-          return cont(objprop);
-        } else if (type2 == "variable" || cx.style == "keyword") {
-          cx.marked = "property";
-          if (value == "get" || value == "set")
-            return cont(getterSetter);
-          var m;
-          if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
-            cx.state.fatArrowAt = cx.stream.pos + m[0].length;
-          return cont(afterprop);
-        } else if (type2 == "number" || type2 == "string") {
-          cx.marked = jsonldMode ? "property" : cx.style + " property";
-          return cont(afterprop);
-        } else if (type2 == "jsonld-keyword") {
-          return cont(afterprop);
-        } else if (isTS && isModifier(value)) {
-          cx.marked = "keyword";
-          return cont(objprop);
-        } else if (type2 == "[") {
-          return cont(expression, maybetype, expect2("]"), afterprop);
-        } else if (type2 == "spread") {
-          return cont(expressionNoComma, afterprop);
-        } else if (value == "*") {
-          cx.marked = "keyword";
-          return cont(objprop);
-        } else if (type2 == ":") {
-          return pass(afterprop);
-        }
-      }
-      function getterSetter(type2) {
-        if (type2 != "variable")
-          return pass(afterprop);
-        cx.marked = "property";
-        return cont(functiondef);
-      }
-      function afterprop(type2) {
-        if (type2 == ":")
-          return cont(expressionNoComma);
-        if (type2 == "(")
-          return pass(functiondef);
-      }
-      function commasep(what, end, sep) {
-        function proceed(type2, value) {
-          if (sep ? sep.indexOf(type2) > -1 : type2 == ",") {
-            var lex = cx.state.lexical;
-            if (lex.info == "call")
-              lex.pos = (lex.pos || 0) + 1;
-            return cont(function(type3, value2) {
-              if (type3 == end || value2 == end)
-                return pass();
-              return pass(what);
-            }, proceed);
-          }
-          if (type2 == end || value == end)
-            return cont();
-          if (sep && sep.indexOf(";") > -1)
-            return pass(what);
-          return cont(expect2(end));
-        }
-        return function(type2, value) {
-          if (type2 == end || value == end)
-            return cont();
-          return pass(what, proceed);
-        };
-      }
-      function contCommasep(what, end, info) {
-        for (var i = 3; i < arguments.length; i++)
-          cx.cc.push(arguments[i]);
-        return cont(pushlex(end, info), commasep(what, end), poplex);
-      }
-      function block(type2) {
-        if (type2 == "}")
-          return cont();
-        return pass(statement, block);
-      }
-      function maybetype(type2, value) {
-        if (isTS) {
-          if (type2 == ":")
-            return cont(typeexpr);
-          if (value == "?")
-            return cont(maybetype);
-        }
-      }
-      function maybetypeOrIn(type2, value) {
-        if (isTS && (type2 == ":" || value == "in"))
-          return cont(typeexpr);
-      }
-      function mayberettype(type2) {
-        if (isTS && type2 == ":") {
-          if (cx.stream.match(/^\s*\w+\s+is\b/, false))
-            return cont(expression, isKW, typeexpr);
-          else
-            return cont(typeexpr);
-        }
-      }
-      function isKW(_, value) {
-        if (value == "is") {
-          cx.marked = "keyword";
-          return cont();
-        }
-      }
-      function typeexpr(type2, value) {
-        if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
-          cx.marked = "keyword";
-          return cont(value == "typeof" ? expressionNoComma : typeexpr);
-        }
-        if (type2 == "variable" || value == "void") {
-          cx.marked = "type";
-          return cont(afterType);
-        }
-        if (value == "|" || value == "&")
-          return cont(typeexpr);
-        if (type2 == "string" || type2 == "number" || type2 == "atom")
-          return cont(afterType);
-        if (type2 == "[")
-          return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
-        if (type2 == "{")
-          return cont(pushlex("}"), typeprops, poplex, afterType);
-        if (type2 == "(")
-          return cont(commasep(typearg, ")"), maybeReturnType, afterType);
-        if (type2 == "<")
-          return cont(commasep(typeexpr, ">"), typeexpr);
-        if (type2 == "quasi") {
-          return pass(quasiType, afterType);
-        }
-      }
-      function maybeReturnType(type2) {
-        if (type2 == "=>")
-          return cont(typeexpr);
-      }
-      function typeprops(type2) {
-        if (type2.match(/[\}\)\]]/))
-          return cont();
-        if (type2 == "," || type2 == ";")
-          return cont(typeprops);
-        return pass(typeprop, typeprops);
-      }
-      function typeprop(type2, value) {
-        if (type2 == "variable" || cx.style == "keyword") {
-          cx.marked = "property";
-          return cont(typeprop);
-        } else if (value == "?" || type2 == "number" || type2 == "string") {
-          return cont(typeprop);
-        } else if (type2 == ":") {
-          return cont(typeexpr);
-        } else if (type2 == "[") {
-          return cont(expect2("variable"), maybetypeOrIn, expect2("]"), typeprop);
-        } else if (type2 == "(") {
-          return pass(functiondecl, typeprop);
-        } else if (!type2.match(/[;\}\)\],]/)) {
-          return cont();
-        }
-      }
-      function quasiType(type2, value) {
-        if (type2 != "quasi")
-          return pass();
-        if (value.slice(value.length - 2) != "${")
-          return cont(quasiType);
-        return cont(typeexpr, continueQuasiType);
-      }
-      function continueQuasiType(type2) {
-        if (type2 == "}") {
-          cx.marked = "string-2";
-          cx.state.tokenize = tokenQuasi;
-          return cont(quasiType);
-        }
-      }
-      function typearg(type2, value) {
-        if (type2 == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?")
-          return cont(typearg);
-        if (type2 == ":")
-          return cont(typeexpr);
-        if (type2 == "spread")
-          return cont(typearg);
-        return pass(typeexpr);
-      }
-      function afterType(type2, value) {
-        if (value == "<")
-          return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
-        if (value == "|" || type2 == "." || value == "&")
-          return cont(typeexpr);
-        if (type2 == "[")
-          return cont(typeexpr, expect2("]"), afterType);
-        if (value == "extends" || value == "implements") {
-          cx.marked = "keyword";
-          return cont(typeexpr);
-        }
-        if (value == "?")
-          return cont(typeexpr, expect2(":"), typeexpr);
-      }
-      function maybeTypeArgs(_, value) {
-        if (value == "<")
-          return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
-      }
-      function typeparam() {
-        return pass(typeexpr, maybeTypeDefault);
-      }
-      function maybeTypeDefault(_, value) {
-        if (value == "=")
-          return cont(typeexpr);
-      }
-      function vardef(_, value) {
-        if (value == "enum") {
-          cx.marked = "keyword";
-          return cont(enumdef);
-        }
-        return pass(pattern, maybetype, maybeAssign, vardefCont);
-      }
-      function pattern(type2, value) {
-        if (isTS && isModifier(value)) {
-          cx.marked = "keyword";
-          return cont(pattern);
-        }
-        if (type2 == "variable") {
-          register(value);
-          return cont();
-        }
-        if (type2 == "spread")
-          return cont(pattern);
-        if (type2 == "[")
-          return contCommasep(eltpattern, "]");
-        if (type2 == "{")
-          return contCommasep(proppattern, "}");
-      }
-      function proppattern(type2, value) {
-        if (type2 == "variable" && !cx.stream.match(/^\s*:/, false)) {
-          register(value);
-          return cont(maybeAssign);
-        }
-        if (type2 == "variable")
-          cx.marked = "property";
-        if (type2 == "spread")
-          return cont(pattern);
-        if (type2 == "}")
-          return pass();
-        if (type2 == "[")
-          return cont(expression, expect2("]"), expect2(":"), proppattern);
-        return cont(expect2(":"), pattern, maybeAssign);
-      }
-      function eltpattern() {
-        return pass(pattern, maybeAssign);
-      }
-      function maybeAssign(_type, value) {
-        if (value == "=")
-          return cont(expressionNoComma);
-      }
-      function vardefCont(type2) {
-        if (type2 == ",")
-          return cont(vardef);
-      }
-      function maybeelse(type2, value) {
-        if (type2 == "keyword b" && value == "else")
-          return cont(pushlex("form", "else"), statement, poplex);
-      }
-      function forspec(type2, value) {
-        if (value == "await")
-          return cont(forspec);
-        if (type2 == "(")
-          return cont(pushlex(")"), forspec1, poplex);
-      }
-      function forspec1(type2) {
-        if (type2 == "var")
-          return cont(vardef, forspec2);
-        if (type2 == "variable")
-          return cont(forspec2);
-        return pass(forspec2);
-      }
-      function forspec2(type2, value) {
-        if (type2 == ")")
-          return cont();
-        if (type2 == ";")
-          return cont(forspec2);
-        if (value == "in" || value == "of") {
-          cx.marked = "keyword";
-          return cont(expression, forspec2);
-        }
-        return pass(expression, forspec2);
-      }
-      function functiondef(type2, value) {
-        if (value == "*") {
-          cx.marked = "keyword";
-          return cont(functiondef);
-        }
-        if (type2 == "variable") {
-          register(value);
-          return cont(functiondef);
-        }
-        if (type2 == "(")
-          return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
-        if (isTS && value == "<")
-          return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
-      }
-      function functiondecl(type2, value) {
-        if (value == "*") {
-          cx.marked = "keyword";
-          return cont(functiondecl);
-        }
-        if (type2 == "variable") {
-          register(value);
-          return cont(functiondecl);
-        }
-        if (type2 == "(")
-          return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
-        if (isTS && value == "<")
-          return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
-      }
-      function typename(type2, value) {
-        if (type2 == "keyword" || type2 == "variable") {
-          cx.marked = "type";
-          return cont(typename);
-        } else if (value == "<") {
-          return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
-        }
-      }
-      function funarg(type2, value) {
-        if (value == "@")
-          cont(expression, funarg);
-        if (type2 == "spread")
-          return cont(funarg);
-        if (isTS && isModifier(value)) {
-          cx.marked = "keyword";
-          return cont(funarg);
-        }
-        if (isTS && type2 == "this")
-          return cont(maybetype, maybeAssign);
-        return pass(pattern, maybetype, maybeAssign);
-      }
-      function classExpression(type2, value) {
-        if (type2 == "variable")
-          return className(type2, value);
-        return classNameAfter(type2, value);
-      }
-      function className(type2, value) {
-        if (type2 == "variable") {
-          register(value);
-          return cont(classNameAfter);
-        }
-      }
-      function classNameAfter(type2, value) {
-        if (value == "<")
-          return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);
-        if (value == "extends" || value == "implements" || isTS && type2 == ",") {
-          if (value == "implements")
-            cx.marked = "keyword";
-          return cont(isTS ? typeexpr : expression, classNameAfter);
-        }
-        if (type2 == "{")
-          return cont(pushlex("}"), classBody, poplex);
-      }
-      function classBody(type2, value) {
-        if (type2 == "async" || type2 == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
-          cx.marked = "keyword";
-          return cont(classBody);
-        }
-        if (type2 == "variable" || cx.style == "keyword") {
-          cx.marked = "property";
-          return cont(classfield, classBody);
-        }
-        if (type2 == "number" || type2 == "string")
-          return cont(classfield, classBody);
-        if (type2 == "[")
-          return cont(expression, maybetype, expect2("]"), classfield, classBody);
-        if (value == "*") {
-          cx.marked = "keyword";
-          return cont(classBody);
-        }
-        if (isTS && type2 == "(")
-          return pass(functiondecl, classBody);
-        if (type2 == ";" || type2 == ",")
-          return cont(classBody);
-        if (type2 == "}")
-          return cont();
-        if (value == "@")
-          return cont(expression, classBody);
-      }
-      function classfield(type2, value) {
-        if (value == "!")
-          return cont(classfield);
-        if (value == "?")
-          return cont(classfield);
-        if (type2 == ":")
-          return cont(typeexpr, maybeAssign);
-        if (value == "=")
-          return cont(expressionNoComma);
-        var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
-        return pass(isInterface ? functiondecl : functiondef);
-      }
-      function afterExport(type2, value) {
-        if (value == "*") {
-          cx.marked = "keyword";
-          return cont(maybeFrom, expect2(";"));
-        }
-        if (value == "default") {
-          cx.marked = "keyword";
-          return cont(expression, expect2(";"));
-        }
-        if (type2 == "{")
-          return cont(commasep(exportField, "}"), maybeFrom, expect2(";"));
-        return pass(statement);
-      }
-      function exportField(type2, value) {
-        if (value == "as") {
-          cx.marked = "keyword";
-          return cont(expect2("variable"));
-        }
-        if (type2 == "variable")
-          return pass(expressionNoComma, exportField);
-      }
-      function afterImport(type2) {
-        if (type2 == "string")
-          return cont();
-        if (type2 == "(")
-          return pass(expression);
-        if (type2 == ".")
-          return pass(maybeoperatorComma);
-        return pass(importSpec, maybeMoreImports, maybeFrom);
-      }
-      function importSpec(type2, value) {
-        if (type2 == "{")
-          return contCommasep(importSpec, "}");
-        if (type2 == "variable")
-          register(value);
-        if (value == "*")
-          cx.marked = "keyword";
-        return cont(maybeAs);
-      }
-      function maybeMoreImports(type2) {
-        if (type2 == ",")
-          return cont(importSpec, maybeMoreImports);
-      }
-      function maybeAs(_type, value) {
-        if (value == "as") {
-          cx.marked = "keyword";
-          return cont(importSpec);
-        }
-      }
-      function maybeFrom(_type, value) {
-        if (value == "from") {
-          cx.marked = "keyword";
-          return cont(expression);
-        }
-      }
-      function arrayLiteral(type2) {
-        if (type2 == "]")
-          return cont();
-        return pass(commasep(expressionNoComma, "]"));
-      }
-      function enumdef() {
-        return pass(pushlex("form"), pattern, expect2("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
-      }
-      function enummember() {
-        return pass(pattern, maybeAssign);
-      }
-      function isContinuedStatement(state2, textAfter) {
-        return state2.lastType == "operator" || state2.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
-      }
-      function expressionAllowed(stream, state2, backUp) {
-        return state2.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state2.lastType) || state2.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
-      }
-      return {
-        startState: function(basecolumn) {
-          var state2 = {
-            tokenize: tokenBase,
-            lastType: "sof",
-            cc: [],
-            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
-            localVars: parserConfig.localVars,
-            context: parserConfig.localVars && new Context(null, null, false),
-            indented: basecolumn || 0
-          };
-          if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
-            state2.globalVars = parserConfig.globalVars;
-          return state2;
-        },
-        token: function(stream, state2) {
-          if (stream.sol()) {
-            if (!state2.lexical.hasOwnProperty("align"))
-              state2.lexical.align = false;
-            state2.indented = stream.indentation();
-            findFatArrow(stream, state2);
-          }
-          if (state2.tokenize != tokenComment && stream.eatSpace())
-            return null;
-          var style = state2.tokenize(stream, state2);
-          if (type == "comment")
-            return style;
-          state2.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
-          return parseJS(state2, style, type, content, stream);
-        },
-        indent: function(state2, textAfter) {
-          if (state2.tokenize == tokenComment || state2.tokenize == tokenQuasi)
-            return CodeMirror2.Pass;
-          if (state2.tokenize != tokenBase)
-            return 0;
-          var firstChar = textAfter && textAfter.charAt(0), lexical = state2.lexical, top;
-          if (!/^\s*else\b/.test(textAfter))
-            for (var i = state2.cc.length - 1; i >= 0; --i) {
-              var c = state2.cc[i];
-              if (c == poplex)
-                lexical = lexical.prev;
-              else if (c != maybeelse && c != popcontext)
-                break;
-            }
-          while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state2.cc[state2.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter)))
-            lexical = lexical.prev;
-          if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
-            lexical = lexical.prev;
-          var type2 = lexical.type, closing = firstChar == type2;
-          if (type2 == "vardef")
-            return lexical.indented + (state2.lastType == "operator" || state2.lastType == "," ? lexical.info.length + 1 : 0);
-          else if (type2 == "form" && firstChar == "{")
-            return lexical.indented;
-          else if (type2 == "form")
-            return lexical.indented + indentUnit;
-          else if (type2 == "stat")
-            return lexical.indented + (isContinuedStatement(state2, textAfter) ? statementIndent || indentUnit : 0);
-          else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
-            return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
-          else if (lexical.align)
-            return lexical.column + (closing ? 0 : 1);
-          else
-            return lexical.indented + (closing ? 0 : indentUnit);
-        },
-        electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
-        blockCommentStart: jsonMode ? null : "/*",
-        blockCommentEnd: jsonMode ? null : "*/",
-        blockCommentContinue: jsonMode ? null : " * ",
-        lineComment: jsonMode ? null : "//",
-        fold: "brace",
-        closeBrackets: "()[]{}''\"\"``",
-        helperType: jsonMode ? "json" : "javascript",
-        jsonldMode,
-        jsonMode,
-        expressionAllowed,
-        skipExpression: function(state2) {
-          parseJS(state2, "atom", "atom", "true", new CodeMirror2.StringStream("", 2, null));
-        }
-      };
-    });
-    CodeMirror2.registerHelper("wordChars", "javascript", /[\w$]/);
-    CodeMirror2.defineMIME("text/javascript", "javascript");
-    CodeMirror2.defineMIME("text/ecmascript", "javascript");
-    CodeMirror2.defineMIME("application/javascript", "javascript");
-    CodeMirror2.defineMIME("application/x-javascript", "javascript");
-    CodeMirror2.defineMIME("application/ecmascript", "javascript");
-    CodeMirror2.defineMIME("application/json", { name: "javascript", json: true });
-    CodeMirror2.defineMIME("application/x-json", { name: "javascript", json: true });
-    CodeMirror2.defineMIME("application/manifest+json", { name: "javascript", json: true });
-    CodeMirror2.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
-    CodeMirror2.defineMIME("text/typescript", { name: "javascript", typescript: true });
-    CodeMirror2.defineMIME("application/typescript", { name: "javascript", typescript: true });
-  });
-})();
-var css = { exports: {} };
-(function(module, exports) {
-  (function(mod) {
-    mod(codemirror$1.exports);
-  })(function(CodeMirror2) {
-    CodeMirror2.defineMode("css", function(config, parserConfig) {
-      var inline = parserConfig.inline;
-      if (!parserConfig.propertyKeywords)
-        parserConfig = CodeMirror2.resolveMode("text/css");
-      var indentUnit = config.indentUnit, tokenHooks = parserConfig.tokenHooks, documentTypes2 = parserConfig.documentTypes || {}, mediaTypes2 = parserConfig.mediaTypes || {}, mediaFeatures2 = parserConfig.mediaFeatures || {}, mediaValueKeywords2 = parserConfig.mediaValueKeywords || {}, propertyKeywords2 = parserConfig.propertyKeywords || {}, nonStandardPropertyKeywords2 = parserConfig.nonStandardPropertyKeywords || {}, fontProperties2 = parserConfig.fontProperties || {}, counterDescriptors2 = parserConfig.counterDescriptors || {}, colorKeywords2 = parserConfig.colorKeywords || {}, valueKeywords2 = parserConfig.valueKeywords || {}, allowNested = parserConfig.allowNested, lineComment = parserConfig.lineComment, supportsAtComponent = parserConfig.supportsAtComponent === true, highlightNonStandardPropertyKeywords = config.highlightNonStandardPropertyKeywords !== false;
-      var type, override;
-      function ret(style, tp) {
-        type = tp;
-        return style;
-      }
-      function tokenBase(stream, state2) {
-        var ch = stream.next();
-        if (tokenHooks[ch]) {
-          var result = tokenHooks[ch](stream, state2);
-          if (result !== false)
-            return result;
-        }
-        if (ch == "@") {
-          stream.eatWhile(/[\w\\\-]/);
-          return ret("def", stream.current());
-        } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
-          return ret(null, "compare");
-        } else if (ch == '"' || ch == "'") {
-          state2.tokenize = tokenString(ch);
-          return state2.tokenize(stream, state2);
-        } else if (ch == "#") {
-          stream.eatWhile(/[\w\\\-]/);
-          return ret("atom", "hash");
-        } else if (ch == "!") {
-          stream.match(/^\s*\w*/);
-          return ret("keyword", "important");
-        } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
-          stream.eatWhile(/[\w.%]/);
-          return ret("number", "unit");
-        } else if (ch === "-") {
-          if (/[\d.]/.test(stream.peek())) {
-            stream.eatWhile(/[\w.%]/);
-            return ret("number", "unit");
-          } else if (stream.match(/^-[\w\\\-]*/)) {
-            stream.eatWhile(/[\w\\\-]/);
-            if (stream.match(/^\s*:/, false))
-              return ret("variable-2", "variable-definition");
-            return ret("variable-2", "variable");
-          } else if (stream.match(/^\w+-/)) {
-            return ret("meta", "meta");
-          }
-        } else if (/[,+>*\/]/.test(ch)) {
-          return ret(null, "select-op");
-        } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
-          return ret("qualifier", "qualifier");
-        } else if (/[:;{}\[\]\(\)]/.test(ch)) {
-          return ret(null, ch);
-        } else if (stream.match(/^[\w-.]+(?=\()/)) {
-          if (/^(url(-prefix)?|domain|regexp)$/i.test(stream.current())) {
-            state2.tokenize = tokenParenthesized;
-          }
-          return ret("variable callee", "variable");
-        } else if (/[\w\\\-]/.test(ch)) {
-          stream.eatWhile(/[\w\\\-]/);
-          return ret("property", "word");
-        } else {
-          return ret(null, null);
-        }
-      }
-      function tokenString(quote) {
-        return function(stream, state2) {
-          var escaped = false, ch;
-          while ((ch = stream.next()) != null) {
-            if (ch == quote && !escaped) {
-              if (quote == ")")
-                stream.backUp(1);
-              break;
-            }
-            escaped = !escaped && ch == "\\";
-          }
-          if (ch == quote || !escaped && quote != ")")
-            state2.tokenize = null;
-          return ret("string", "string");
-        };
-      }
-      function tokenParenthesized(stream, state2) {
-        stream.next();
-        if (!stream.match(/^\s*[\"\')]/, false))
-          state2.tokenize = tokenString(")");
-        else
-          state2.tokenize = null;
-        return ret(null, "(");
-      }
-      function Context(type2, indent, prev) {
-        this.type = type2;
-        this.indent = indent;
-        this.prev = prev;
-      }
-      function pushContext(state2, stream, type2, indent) {
-        state2.context = new Context(type2, stream.indentation() + (indent === false ? 0 : indentUnit), state2.context);
-        return type2;
-      }
-      function popContext(state2) {
-        if (state2.context.prev)
-          state2.context = state2.context.prev;
-        return state2.context.type;
-      }
-      function pass(type2, stream, state2) {
-        return states[state2.context.type](type2, stream, state2);
-      }
-      function popAndPass(type2, stream, state2, n) {
-        for (var i = n || 1; i > 0; i--)
-          state2.context = state2.context.prev;
-        return pass(type2, stream, state2);
-      }
-      function wordAsValue(stream) {
-        var word = stream.current().toLowerCase();
-        if (valueKeywords2.hasOwnProperty(word))
-          override = "atom";
-        else if (colorKeywords2.hasOwnProperty(word))
-          override = "keyword";
-        else
-          override = "variable";
-      }
-      var states = {};
-      states.top = function(type2, stream, state2) {
-        if (type2 == "{") {
-          return pushContext(state2, stream, "block");
-        } else if (type2 == "}" && state2.context.prev) {
-          return popContext(state2);
-        } else if (supportsAtComponent && /@component/i.test(type2)) {
-          return pushContext(state2, stream, "atComponentBlock");
-        } else if (/^@(-moz-)?document$/i.test(type2)) {
-          return pushContext(state2, stream, "documentTypes");
-        } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type2)) {
-          return pushContext(state2, stream, "atBlock");
-        } else if (/^@(font-face|counter-style)/i.test(type2)) {
-          state2.stateArg = type2;
-          return "restricted_atBlock_before";
-        } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type2)) {
-          return "keyframes";
-        } else if (type2 && type2.charAt(0) == "@") {
-          return pushContext(state2, stream, "at");
-        } else if (type2 == "hash") {
-          override = "builtin";
-        } else if (type2 == "word") {
-          override = "tag";
-        } else if (type2 == "variable-definition") {
-          return "maybeprop";
-        } else if (type2 == "interpolation") {
-          return pushContext(state2, stream, "interpolation");
-        } else if (type2 == ":") {
-          return "pseudo";
-        } else if (allowNested && type2 == "(") {
-          return pushContext(state2, stream, "parens");
-        }
-        return state2.context.type;
-      };
-      states.block = function(type2, stream, state2) {
-        if (type2 == "word") {
-          var word = stream.current().toLowerCase();
-          if (propertyKeywords2.hasOwnProperty(word)) {
-            override = "property";
-            return "maybeprop";
-          } else if (nonStandardPropertyKeywords2.hasOwnProperty(word)) {
-            override = highlightNonStandardPropertyKeywords ? "string-2" : "property";
-            return "maybeprop";
-          } else if (allowNested) {
-            override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
-            return "block";
-          } else {
-            override += " error";
-            return "maybeprop";
-          }
-        } else if (type2 == "meta") {
-          return "block";
-        } else if (!allowNested && (type2 == "hash" || type2 == "qualifier")) {
-          override = "error";
-          return "block";
-        } else {
-          return states.top(type2, stream, state2);
-        }
-      };
-      states.maybeprop = function(type2, stream, state2) {
-        if (type2 == ":")
-          return pushContext(state2, stream, "prop");
-        return pass(type2, stream, state2);
-      };
-      states.prop = function(type2, stream, state2) {
-        if (type2 == ";")
-          return popContext(state2);
-        if (type2 == "{" && allowNested)
-          return pushContext(state2, stream, "propBlock");
-        if (type2 == "}" || type2 == "{")
-          return popAndPass(type2, stream, state2);
-        if (type2 == "(")
-          return pushContext(state2, stream, "parens");
-        if (type2 == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
-          override += " error";
-        } else if (type2 == "word") {
-          wordAsValue(stream);
-        } else if (type2 == "interpolation") {
-          return pushContext(state2, stream, "interpolation");
-        }
-        return "prop";
-      };
-      states.propBlock = function(type2, _stream, state2) {
-        if (type2 == "}")
-          return popContext(state2);
-        if (type2 == "word") {
-          override = "property";
-          return "maybeprop";
-        }
-        return state2.context.type;
-      };
-      states.parens = function(type2, stream, state2) {
-        if (type2 == "{" || type2 == "}")
-          return popAndPass(type2, stream, state2);
-        if (type2 == ")")
-          return popContext(state2);
-        if (type2 == "(")
-          return pushContext(state2, stream, "parens");
-        if (type2 == "interpolation")
-          return pushContext(state2, stream, "interpolation");
-        if (type2 == "word")
-          wordAsValue(stream);
-        return "parens";
-      };
-      states.pseudo = function(type2, stream, state2) {
-        if (type2 == "meta")
-          return "pseudo";
-        if (type2 == "word") {
-          override = "variable-3";
-          return state2.context.type;
-        }
-        return pass(type2, stream, state2);
-      };
-      states.documentTypes = function(type2, stream, state2) {
-        if (type2 == "word" && documentTypes2.hasOwnProperty(stream.current())) {
-          override = "tag";
-          return state2.context.type;
-        } else {
-          return states.atBlock(type2, stream, state2);
-        }
-      };
-      states.atBlock = function(type2, stream, state2) {
-        if (type2 == "(")
-          return pushContext(state2, stream, "atBlock_parens");
-        if (type2 == "}" || type2 == ";")
-          return popAndPass(type2, stream, state2);
-        if (type2 == "{")
-          return popContext(state2) && pushContext(state2, stream, allowNested ? "block" : "top");
-        if (type2 == "interpolation")
-          return pushContext(state2, stream, "interpolation");
-        if (type2 == "word") {
-          var word = stream.current().toLowerCase();
-          if (word == "only" || word == "not" || word == "and" || word == "or")
-            override = "keyword";
-          else if (mediaTypes2.hasOwnProperty(word))
-            override = "attribute";
-          else if (mediaFeatures2.hasOwnProperty(word))
-            override = "property";
-          else if (mediaValueKeywords2.hasOwnProperty(word))
-            override = "keyword";
-          else if (propertyKeywords2.hasOwnProperty(word))
-            override = "property";
-          else if (nonStandardPropertyKeywords2.hasOwnProperty(word))
-            override = highlightNonStandardPropertyKeywords ? "string-2" : "property";
-          else if (valueKeywords2.hasOwnProperty(word))
-            override = "atom";
-          else if (colorKeywords2.hasOwnProperty(word))
-            override = "keyword";
-          else
-            override = "error";
-        }
-        return state2.context.type;
-      };
-      states.atComponentBlock = function(type2, stream, state2) {
-        if (type2 == "}")
-          return popAndPass(type2, stream, state2);
-        if (type2 == "{")
-          return popContext(state2) && pushContext(state2, stream, allowNested ? "block" : "top", false);
-        if (type2 == "word")
-          override = "error";
-        return state2.context.type;
-      };
-      states.atBlock_parens = function(type2, stream, state2) {
-        if (type2 == ")")
-          return popContext(state2);
-        if (type2 == "{" || type2 == "}")
-          return popAndPass(type2, stream, state2, 2);
-        return states.atBlock(type2, stream, state2);
-      };
-      states.restricted_atBlock_before = function(type2, stream, state2) {
-        if (type2 == "{")
-          return pushContext(state2, stream, "restricted_atBlock");
-        if (type2 == "word" && state2.stateArg == "@counter-style") {
-          override = "variable";
-          return "restricted_atBlock_before";
-        }
-        return pass(type2, stream, state2);
-      };
-      states.restricted_atBlock = function(type2, stream, state2) {
-        if (type2 == "}") {
-          state2.stateArg = null;
-          return popContext(state2);
-        }
-        if (type2 == "word") {
-          if (state2.stateArg == "@font-face" && !fontProperties2.hasOwnProperty(stream.current().toLowerCase()) || state2.stateArg == "@counter-style" && !counterDescriptors2.hasOwnProperty(stream.current().toLowerCase()))
-            override = "error";
-          else
-            override = "property";
-          return "maybeprop";
-        }
-        return "restricted_atBlock";
-      };
-      states.keyframes = function(type2, stream, state2) {
-        if (type2 == "word") {
-          override = "variable";
-          return "keyframes";
-        }
-        if (type2 == "{")
-          return pushContext(state2, stream, "top");
-        return pass(type2, stream, state2);
-      };
-      states.at = function(type2, stream, state2) {
-        if (type2 == ";")
-          return popContext(state2);
-        if (type2 == "{" || type2 == "}")
-          return popAndPass(type2, stream, state2);
-        if (type2 == "word")
-          override = "tag";
-        else if (type2 == "hash")
-          override = "builtin";
-        return "at";
-      };
-      states.interpolation = function(type2, stream, state2) {
-        if (type2 == "}")
-          return popContext(state2);
-        if (type2 == "{" || type2 == ";")
-          return popAndPass(type2, stream, state2);
-        if (type2 == "word")
-          override = "variable";
-        else if (type2 != "variable" && type2 != "(" && type2 != ")")
-          override = "error";
-        return "interpolation";
-      };
-      return {
-        startState: function(base) {
-          return {
-            tokenize: null,
-            state: inline ? "block" : "top",
-            stateArg: null,
-            context: new Context(inline ? "block" : "top", base || 0, null)
-          };
-        },
-        token: function(stream, state2) {
-          if (!state2.tokenize && stream.eatSpace())
-            return null;
-          var style = (state2.tokenize || tokenBase)(stream, state2);
-          if (style && typeof style == "object") {
-            type = style[1];
-            style = style[0];
-          }
-          override = style;
-          if (type != "comment")
-            state2.state = states[state2.state](type, stream, state2);
-          return override;
-        },
-        indent: function(state2, textAfter) {
-          var cx = state2.context, ch = textAfter && textAfter.charAt(0);
-          var indent = cx.indent;
-          if (cx.type == "prop" && (ch == "}" || ch == ")"))
-            cx = cx.prev;
-          if (cx.prev) {
-            if (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
-              cx = cx.prev;
-              indent = cx.indent;
-            } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") || ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
-              indent = Math.max(0, cx.indent - indentUnit);
-            }
-          }
-          return indent;
-        },
-        electricChars: "}",
-        blockCommentStart: "/*",
-        blockCommentEnd: "*/",
-        blockCommentContinue: " * ",
-        lineComment,
-        fold: "brace"
-      };
-    });
-    function keySet(array) {
-      var keys = {};
-      for (var i = 0; i < array.length; ++i) {
-        keys[array[i].toLowerCase()] = true;
-      }
-      return keys;
-    }
-    var documentTypes_ = [
-      "domain",
-      "regexp",
-      "url",
-      "url-prefix"
-    ], documentTypes = keySet(documentTypes_);
-    var mediaTypes_ = [
-      "all",
-      "aural",
-      "braille",
-      "handheld",
-      "print",
-      "projection",
-      "screen",
-      "tty",
-      "tv",
-      "embossed"
-    ], mediaTypes = keySet(mediaTypes_);
-    var mediaFeatures_ = [
-      "width",
-      "min-width",
-      "max-width",
-      "height",
-      "min-height",
-      "max-height",
-      "device-width",
-      "min-device-width",
-      "max-device-width",
-      "device-height",
-      "min-device-height",
-      "max-device-height",
-      "aspect-ratio",
-      "min-aspect-ratio",
-      "max-aspect-ratio",
-      "device-aspect-ratio",
-      "min-device-aspect-ratio",
-      "max-device-aspect-ratio",
-      "color",
-      "min-color",
-      "max-color",
-      "color-index",
-      "min-color-index",
-      "max-color-index",
-      "monochrome",
-      "min-monochrome",
-      "max-monochrome",
-      "resolution",
-      "min-resolution",
-      "max-resolution",
-      "scan",
-      "grid",
-      "orientation",
-      "device-pixel-ratio",
-      "min-device-pixel-ratio",
-      "max-device-pixel-ratio",
-      "pointer",
-      "any-pointer",
-      "hover",
-      "any-hover",
-      "prefers-color-scheme"
-    ], mediaFeatures = keySet(mediaFeatures_);
-    var mediaValueKeywords_ = [
-      "landscape",
-      "portrait",
-      "none",
-      "coarse",
-      "fine",
-      "on-demand",
-      "hover",
-      "interlace",
-      "progressive",
-      "dark",
-      "light"
-    ], mediaValueKeywords = keySet(mediaValueKeywords_);
-    var propertyKeywords_ = [
-      "align-content",
-      "align-items",
-      "align-self",
-      "alignment-adjust",
-      "alignment-baseline",
-      "all",
-      "anchor-point",
-      "animation",
-      "animation-delay",
-      "animation-direction",
-      "animation-duration",
-      "animation-fill-mode",
-      "animation-iteration-count",
-      "animation-name",
-      "animation-play-state",
-      "animation-timing-function",
-      "appearance",
-      "azimuth",
-      "backdrop-filter",
-      "backface-visibility",
-      "background",
-      "background-attachment",
-      "background-blend-mode",
-      "background-clip",
-      "background-color",
-      "background-image",
-      "background-origin",
-      "background-position",
-      "background-position-x",
-      "background-position-y",
-      "background-repeat",
-      "background-size",
-      "baseline-shift",
-      "binding",
-      "bleed",
-      "block-size",
-      "bookmark-label",
-      "bookmark-level",
-      "bookmark-state",
-      "bookmark-target",
-      "border",
-      "border-bottom",
-      "border-bottom-color",
-      "border-bottom-left-radius",
-      "border-bottom-right-radius",
-      "border-bottom-style",
-      "border-bottom-width",
-      "border-collapse",
-      "border-color",
-      "border-image",
-      "border-image-outset",
-      "border-image-repeat",
-      "border-image-slice",
-      "border-image-source",
-      "border-image-width",
-      "border-left",
-      "border-left-color",
-      "border-left-style",
-      "border-left-width",
-      "border-radius",
-      "border-right",
-      "border-right-color",
-      "border-right-style",
-      "border-right-width",
-      "border-spacing",
-      "border-style",
-      "border-top",
-      "border-top-color",
-      "border-top-left-radius",
-      "border-top-right-radius",
-      "border-top-style",
-      "border-top-width",
-      "border-width",
-      "bottom",
-      "box-decoration-break",
-      "box-shadow",
-      "box-sizing",
-      "break-after",
-      "break-before",
-      "break-inside",
-      "caption-side",
-      "caret-color",
-      "clear",
-      "clip",
-      "color",
-      "color-profile",
-      "column-count",
-      "column-fill",
-      "column-gap",
-      "column-rule",
-      "column-rule-color",
-      "column-rule-style",
-      "column-rule-width",
-      "column-span",
-      "column-width",
-      "columns",
-      "contain",
-      "content",
-      "counter-increment",
-      "counter-reset",
-      "crop",
-      "cue",
-      "cue-after",
-      "cue-before",
-      "cursor",
-      "direction",
-      "display",
-      "dominant-baseline",
-      "drop-initial-after-adjust",
-      "drop-initial-after-align",
-      "drop-initial-before-adjust",
-      "drop-initial-before-align",
-      "drop-initial-size",
-      "drop-initial-value",
-      "elevation",
-      "empty-cells",
-      "fit",
-      "fit-content",
-      "fit-position",
-      "flex",
-      "flex-basis",
-      "flex-direction",
-      "flex-flow",
-      "flex-grow",
-      "flex-shrink",
-      "flex-wrap",
-      "float",
-      "float-offset",
-      "flow-from",
-      "flow-into",
-      "font",
-      "font-family",
-      "font-feature-settings",
-      "font-kerning",
-      "font-language-override",
-      "font-optical-sizing",
-      "font-size",
-      "font-size-adjust",
-      "font-stretch",
-      "font-style",
-      "font-synthesis",
-      "font-variant",
-      "font-variant-alternates",
-      "font-variant-caps",
-      "font-variant-east-asian",
-      "font-variant-ligatures",
-      "font-variant-numeric",
-      "font-variant-position",
-      "font-variation-settings",
-      "font-weight",
-      "gap",
-      "grid",
-      "grid-area",
-      "grid-auto-columns",
-      "grid-auto-flow",
-      "grid-auto-rows",
-      "grid-column",
-      "grid-column-end",
-      "grid-column-gap",
-      "grid-column-start",
-      "grid-gap",
-      "grid-row",
-      "grid-row-end",
-      "grid-row-gap",
-      "grid-row-start",
-      "grid-template",
-      "grid-template-areas",
-      "grid-template-columns",
-      "grid-template-rows",
-      "hanging-punctuation",
-      "height",
-      "hyphens",
-      "icon",
-      "image-orientation",
-      "image-rendering",
-      "image-resolution",
-      "inline-box-align",
-      "inset",
-      "inset-block",
-      "inset-block-end",
-      "inset-block-start",
-      "inset-inline",
-      "inset-inline-end",
-      "inset-inline-start",
-      "isolation",
-      "justify-content",
-      "justify-items",
-      "justify-self",
-      "left",
-      "letter-spacing",
-      "line-break",
-      "line-height",
-      "line-height-step",
-      "line-stacking",
-      "line-stacking-ruby",
-      "line-stacking-shift",
-      "line-stacking-strategy",
-      "list-style",
-      "list-style-image",
-      "list-style-position",
-      "list-style-type",
-      "margin",
-      "margin-bottom",
-      "margin-left",
-      "margin-right",
-      "margin-top",
-      "marks",
-      "marquee-direction",
-      "marquee-loop",
-      "marquee-play-count",
-      "marquee-speed",
-      "marquee-style",
-      "mask-clip",
-      "mask-composite",
-      "mask-image",
-      "mask-mode",
-      "mask-origin",
-      "mask-position",
-      "mask-repeat",
-      "mask-size",
-      "mask-type",
-      "max-block-size",
-      "max-height",
-      "max-inline-size",
-      "max-width",
-      "min-block-size",
-      "min-height",
-      "min-inline-size",
-      "min-width",
-      "mix-blend-mode",
-      "move-to",
-      "nav-down",
-      "nav-index",
-      "nav-left",
-      "nav-right",
-      "nav-up",
-      "object-fit",
-      "object-position",
-      "offset",
-      "offset-anchor",
-      "offset-distance",
-      "offset-path",
-      "offset-position",
-      "offset-rotate",
-      "opacity",
-      "order",
-      "orphans",
-      "outline",
-      "outline-color",
-      "outline-offset",
-      "outline-style",
-      "outline-width",
-      "overflow",
-      "overflow-style",
-      "overflow-wrap",
-      "overflow-x",
-      "overflow-y",
-      "padding",
-      "padding-bottom",
-      "padding-left",
-      "padding-right",
-      "padding-top",
-      "page",
-      "page-break-after",
-      "page-break-before",
-      "page-break-inside",
-      "page-policy",
-      "pause",
-      "pause-after",
-      "pause-before",
-      "perspective",
-      "perspective-origin",
-      "pitch",
-      "pitch-range",
-      "place-content",
-      "place-items",
-      "place-self",
-      "play-during",
-      "position",
-      "presentation-level",
-      "punctuation-trim",
-      "quotes",
-      "region-break-after",
-      "region-break-before",
-      "region-break-inside",
-      "region-fragment",
-      "rendering-intent",
-      "resize",
-      "rest",
-      "rest-after",
-      "rest-before",
-      "richness",
-      "right",
-      "rotate",
-      "rotation",
-      "rotation-point",
-      "row-gap",
-      "ruby-align",
-      "ruby-overhang",
-      "ruby-position",
-      "ruby-span",
-      "scale",
-      "scroll-behavior",
-      "scroll-margin",
-      "scroll-margin-block",
-      "scroll-margin-block-end",
-      "scroll-margin-block-start",
-      "scroll-margin-bottom",
-      "scroll-margin-inline",
-      "scroll-margin-inline-end",
-      "scroll-margin-inline-start",
-      "scroll-margin-left",
-      "scroll-margin-right",
-      "scroll-margin-top",
-      "scroll-padding",
-      "scroll-padding-block",
-      "scroll-padding-block-end",
-      "scroll-padding-block-start",
-      "scroll-padding-bottom",
-      "scroll-padding-inline",
-      "scroll-padding-inline-end",
-      "scroll-padding-inline-start",
-      "scroll-padding-left",
-      "scroll-padding-right",
-      "scroll-padding-top",
-      "scroll-snap-align",
-      "scroll-snap-type",
-      "shape-image-threshold",
-      "shape-inside",
-      "shape-margin",
-      "shape-outside",
-      "size",
-      "speak",
-      "speak-as",
-      "speak-header",
-      "speak-numeral",
-      "speak-punctuation",
-      "speech-rate",
-      "stress",
-      "string-set",
-      "tab-size",
-      "table-layout",
-      "target",
-      "target-name",
-      "target-new",
-      "target-position",
-      "text-align",
-      "text-align-last",
-      "text-combine-upright",
-      "text-decoration",
-      "text-decoration-color",
-      "text-decoration-line",
-      "text-decoration-skip",
-      "text-decoration-skip-ink",
-      "text-decoration-style",
-      "text-emphasis",
-      "text-emphasis-color",
-      "text-emphasis-position",
-      "text-emphasis-style",
-      "text-height",
-      "text-indent",
-      "text-justify",
-      "text-orientation",
-      "text-outline",
-      "text-overflow",
-      "text-rendering",
-      "text-shadow",
-      "text-size-adjust",
-      "text-space-collapse",
-      "text-transform",
-      "text-underline-position",
-      "text-wrap",
-      "top",
-      "touch-action",
-      "transform",
-      "transform-origin",
-      "transform-style",
-      "transition",
-      "transition-delay",
-      "transition-duration",
-      "transition-property",
-      "transition-timing-function",
-      "translate",
-      "unicode-bidi",
-      "user-select",
-      "vertical-align",
-      "visibility",
-      "voice-balance",
-      "voice-duration",
-      "voice-family",
-      "voice-pitch",
-      "voice-range",
-      "voice-rate",
-      "voice-stress",
-      "voice-volume",
-      "volume",
-      "white-space",
-      "widows",
-      "width",
-      "will-change",
-      "word-break",
-      "word-spacing",
-      "word-wrap",
-      "writing-mode",
-      "z-index",
-      "clip-path",
-      "clip-rule",
-      "mask",
-      "enable-background",
-      "filter",
-      "flood-color",
-      "flood-opacity",
-      "lighting-color",
-      "stop-color",
-      "stop-opacity",
-      "pointer-events",
-      "color-interpolation",
-      "color-interpolation-filters",
-      "color-rendering",
-      "fill",
-      "fill-opacity",
-      "fill-rule",
-      "image-rendering",
-      "marker",
-      "marker-end",
-      "marker-mid",
-      "marker-start",
-      "paint-order",
-      "shape-rendering",
-      "stroke",
-      "stroke-dasharray",
-      "stroke-dashoffset",
-      "stroke-linecap",
-      "stroke-linejoin",
-      "stroke-miterlimit",
-      "stroke-opacity",
-      "stroke-width",
-      "text-rendering",
-      "baseline-shift",
-      "dominant-baseline",
-      "glyph-orientation-horizontal",
-      "glyph-orientation-vertical",
-      "text-anchor",
-      "writing-mode"
-    ], propertyKeywords = keySet(propertyKeywords_);
-    var nonStandardPropertyKeywords_ = [
-      "accent-color",
-      "aspect-ratio",
-      "border-block",
-      "border-block-color",
-      "border-block-end",
-      "border-block-end-color",
-      "border-block-end-style",
-      "border-block-end-width",
-      "border-block-start",
-      "border-block-start-color",
-      "border-block-start-style",
-      "border-block-start-width",
-      "border-block-style",
-      "border-block-width",
-      "border-inline",
-      "border-inline-color",
-      "border-inline-end",
-      "border-inline-end-color",
-      "border-inline-end-style",
-      "border-inline-end-width",
-      "border-inline-start",
-      "border-inline-start-color",
-      "border-inline-start-style",
-      "border-inline-start-width",
-      "border-inline-style",
-      "border-inline-width",
-      "content-visibility",
-      "margin-block",
-      "margin-block-end",
-      "margin-block-start",
-      "margin-inline",
-      "margin-inline-end",
-      "margin-inline-start",
-      "overflow-anchor",
-      "overscroll-behavior",
-      "padding-block",
-      "padding-block-end",
-      "padding-block-start",
-      "padding-inline",
-      "padding-inline-end",
-      "padding-inline-start",
-      "scroll-snap-stop",
-      "scrollbar-3d-light-color",
-      "scrollbar-arrow-color",
-      "scrollbar-base-color",
-      "scrollbar-dark-shadow-color",
-      "scrollbar-face-color",
-      "scrollbar-highlight-color",
-      "scrollbar-shadow-color",
-      "scrollbar-track-color",
-      "searchfield-cancel-button",
-      "searchfield-decoration",
-      "searchfield-results-button",
-      "searchfield-results-decoration",
-      "shape-inside",
-      "zoom"
-    ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);
-    var fontProperties_ = [
-      "font-display",
-      "font-family",
-      "src",
-      "unicode-range",
-      "font-variant",
-      "font-feature-settings",
-      "font-stretch",
-      "font-weight",
-      "font-style"
-    ], fontProperties = keySet(fontProperties_);
-    var counterDescriptors_ = [
-      "additive-symbols",
-      "fallback",
-      "negative",
-      "pad",
-      "prefix",
-      "range",
-      "speak-as",
-      "suffix",
-      "symbols",
-      "system"
-    ], counterDescriptors = keySet(counterDescriptors_);
-    var colorKeywords_ = [
-      "aliceblue",
-      "antiquewhite",
-      "aqua",
-      "aquamarine",
-      "azure",
-      "beige",
-      "bisque",
-      "black",
-      "blanchedalmond",
-      "blue",
-      "blueviolet",
-      "brown",
-      "burlywood",
-      "cadetblue",
-      "chartreuse",
-      "chocolate",
-      "coral",
-      "cornflowerblue",
-      "cornsilk",
-      "crimson",
-      "cyan",
-      "darkblue",
-      "darkcyan",
-      "darkgoldenrod",
-      "darkgray",
-      "darkgreen",
-      "darkgrey",
-      "darkkhaki",
-      "darkmagenta",
-      "darkolivegreen",
-      "darkorange",
-      "darkorchid",
-      "darkred",
-      "darksalmon",
-      "darkseagreen",
-      "darkslateblue",
-      "darkslategray",
-      "darkslategrey",
-      "darkturquoise",
-      "darkviolet",
-      "deeppink",
-      "deepskyblue",
-      "dimgray",
-      "dimgrey",
-      "dodgerblue",
-      "firebrick",
-      "floralwhite",
-      "forestgreen",
-      "fuchsia",
-      "gainsboro",
-      "ghostwhite",
-      "gold",
-      "goldenrod",
-      "gray",
-      "grey",
-      "green",
-      "greenyellow",
-      "honeydew",
-      "hotpink",
-      "indianred",
-      "indigo",
-      "ivory",
-      "khaki",
-      "lavender",
-      "lavenderblush",
-      "lawngreen",
-      "lemonchiffon",
-      "lightblue",
-      "lightcoral",
-      "lightcyan",
-      "lightgoldenrodyellow",
-      "lightgray",
-      "lightgreen",
-      "lightgrey",
-      "lightpink",
-      "lightsalmon",
-      "lightseagreen",
-      "lightskyblue",
-      "lightslategray",
-      "lightslategrey",
-      "lightsteelblue",
-      "lightyellow",
-      "lime",
-      "limegreen",
-      "linen",
-      "magenta",
-      "maroon",
-      "mediumaquamarine",
-      "mediumblue",
-      "mediumorchid",
-      "mediumpurple",
-      "mediumseagreen",
-      "mediumslateblue",
-      "mediumspringgreen",
-      "mediumturquoise",
-      "mediumvioletred",
-      "midnightblue",
-      "mintcream",
-      "mistyrose",
-      "moccasin",
-      "navajowhite",
-      "navy",
-      "oldlace",
-      "olive",
-      "olivedrab",
-      "orange",
-      "orangered",
-      "orchid",
-      "palegoldenrod",
-      "palegreen",
-      "paleturquoise",
-      "palevioletred",
-      "papayawhip",
-      "peachpuff",
-      "peru",
-      "pink",
-      "plum",
-      "powderblue",
-      "purple",
-      "rebeccapurple",
-      "red",
-      "rosybrown",
-      "royalblue",
-      "saddlebrown",
-      "salmon",
-      "sandybrown",
-      "seagreen",
-      "seashell",
-      "sienna",
-      "silver",
-      "skyblue",
-      "slateblue",
-      "slategray",
-      "slategrey",
-      "snow",
-      "springgreen",
-      "steelblue",
-      "tan",
-      "teal",
-      "thistle",
-      "tomato",
-      "turquoise",
-      "violet",
-      "wheat",
-      "white",
-      "whitesmoke",
-      "yellow",
-      "yellowgreen"
-    ], colorKeywords = keySet(colorKeywords_);
-    var valueKeywords_ = [
-      "above",
-      "absolute",
-      "activeborder",
-      "additive",
-      "activecaption",
-      "afar",
-      "after-white-space",
-      "ahead",
-      "alias",
-      "all",
-      "all-scroll",
-      "alphabetic",
-      "alternate",
-      "always",
-      "amharic",
-      "amharic-abegede",
-      "antialiased",
-      "appworkspace",
-      "arabic-indic",
-      "armenian",
-      "asterisks",
-      "attr",
-      "auto",
-      "auto-flow",
-      "avoid",
-      "avoid-column",
-      "avoid-page",
-      "avoid-region",
-      "axis-pan",
-      "background",
-      "backwards",
-      "baseline",
-      "below",
-      "bidi-override",
-      "binary",
-      "bengali",
-      "blink",
-      "block",
-      "block-axis",
-      "blur",
-      "bold",
-      "bolder",
-      "border",
-      "border-box",
-      "both",
-      "bottom",
-      "break",
-      "break-all",
-      "break-word",
-      "brightness",
-      "bullets",
-      "button",
-      "button-bevel",
-      "buttonface",
-      "buttonhighlight",
-      "buttonshadow",
-      "buttontext",
-      "calc",
-      "cambodian",
-      "capitalize",
-      "caps-lock-indicator",
-      "caption",
-      "captiontext",
-      "caret",
-      "cell",
-      "center",
-      "checkbox",
-      "circle",
-      "cjk-decimal",
-      "cjk-earthly-branch",
-      "cjk-heavenly-stem",
-      "cjk-ideographic",
-      "clear",
-      "clip",
-      "close-quote",
-      "col-resize",
-      "collapse",
-      "color",
-      "color-burn",
-      "color-dodge",
-      "column",
-      "column-reverse",
-      "compact",
-      "condensed",
-      "contain",
-      "content",
-      "contents",
-      "content-box",
-      "context-menu",
-      "continuous",
-      "contrast",
-      "copy",
-      "counter",
-      "counters",
-      "cover",
-      "crop",
-      "cross",
-      "crosshair",
-      "cubic-bezier",
-      "currentcolor",
-      "cursive",
-      "cyclic",
-      "darken",
-      "dashed",
-      "decimal",
-      "decimal-leading-zero",
-      "default",
-      "default-button",
-      "dense",
-      "destination-atop",
-      "destination-in",
-      "destination-out",
-      "destination-over",
-      "devanagari",
-      "difference",
-      "disc",
-      "discard",
-      "disclosure-closed",
-      "disclosure-open",
-      "document",
-      "dot-dash",
-      "dot-dot-dash",
-      "dotted",
-      "double",
-      "down",
-      "drop-shadow",
-      "e-resize",
-      "ease",
-      "ease-in",
-      "ease-in-out",
-      "ease-out",
-      "element",
-      "ellipse",
-      "ellipsis",
-      "embed",
-      "end",
-      "ethiopic",
-      "ethiopic-abegede",
-      "ethiopic-abegede-am-et",
-      "ethiopic-abegede-gez",
-      "ethiopic-abegede-ti-er",
-      "ethiopic-abegede-ti-et",
-      "ethiopic-halehame-aa-er",
-      "ethiopic-halehame-aa-et",
-      "ethiopic-halehame-am-et",
-      "ethiopic-halehame-gez",
-      "ethiopic-halehame-om-et",
-      "ethiopic-halehame-sid-et",
-      "ethiopic-halehame-so-et",
-      "ethiopic-halehame-ti-er",
-      "ethiopic-halehame-ti-et",
-      "ethiopic-halehame-tig",
-      "ethiopic-numeric",
-      "ew-resize",
-      "exclusion",
-      "expanded",
-      "extends",
-      "extra-condensed",
-      "extra-expanded",
-      "fantasy",
-      "fast",
-      "fill",
-      "fill-box",
-      "fixed",
-      "flat",
-      "flex",
-      "flex-end",
-      "flex-start",
-      "footnotes",
-      "forwards",
-      "from",
-      "geometricPrecision",
-      "georgian",
-      "grayscale",
-      "graytext",
-      "grid",
-      "groove",
-      "gujarati",
-      "gurmukhi",
-      "hand",
-      "hangul",
-      "hangul-consonant",
-      "hard-light",
-      "hebrew",
-      "help",
-      "hidden",
-      "hide",
-      "higher",
-      "highlight",
-      "highlighttext",
-      "hiragana",
-      "hiragana-iroha",
-      "horizontal",
-      "hsl",
-      "hsla",
-      "hue",
-      "hue-rotate",
-      "icon",
-      "ignore",
-      "inactiveborder",
-      "inactivecaption",
-      "inactivecaptiontext",
-      "infinite",
-      "infobackground",
-      "infotext",
-      "inherit",
-      "initial",
-      "inline",
-      "inline-axis",
-      "inline-block",
-      "inline-flex",
-      "inline-grid",
-      "inline-table",
-      "inset",
-      "inside",
-      "intrinsic",
-      "invert",
-      "italic",
-      "japanese-formal",
-      "japanese-informal",
-      "justify",
-      "kannada",
-      "katakana",
-      "katakana-iroha",
-      "keep-all",
-      "khmer",
-      "korean-hangul-formal",
-      "korean-hanja-formal",
-      "korean-hanja-informal",
-      "landscape",
-      "lao",
-      "large",
-      "larger",
-      "left",
-      "level",
-      "lighter",
-      "lighten",
-      "line-through",
-      "linear",
-      "linear-gradient",
-      "lines",
-      "list-item",
-      "listbox",
-      "listitem",
-      "local",
-      "logical",
-      "loud",
-      "lower",
-      "lower-alpha",
-      "lower-armenian",
-      "lower-greek",
-      "lower-hexadecimal",
-      "lower-latin",
-      "lower-norwegian",
-      "lower-roman",
-      "lowercase",
-      "ltr",
-      "luminosity",
-      "malayalam",
-      "manipulation",
-      "match",
-      "matrix",
-      "matrix3d",
-      "media-controls-background",
-      "media-current-time-display",
-      "media-fullscreen-button",
-      "media-mute-button",
-      "media-play-button",
-      "media-return-to-realtime-button",
-      "media-rewind-button",
-      "media-seek-back-button",
-      "media-seek-forward-button",
-      "media-slider",
-      "media-sliderthumb",
-      "media-time-remaining-display",
-      "media-volume-slider",
-      "media-volume-slider-container",
-      "media-volume-sliderthumb",
-      "medium",
-      "menu",
-      "menulist",
-      "menulist-button",
-      "menulist-text",
-      "menulist-textfield",
-      "menutext",
-      "message-box",
-      "middle",
-      "min-intrinsic",
-      "mix",
-      "mongolian",
-      "monospace",
-      "move",
-      "multiple",
-      "multiple_mask_images",
-      "multiply",
-      "myanmar",
-      "n-resize",
-      "narrower",
-      "ne-resize",
-      "nesw-resize",
-      "no-close-quote",
-      "no-drop",
-      "no-open-quote",
-      "no-repeat",
-      "none",
-      "normal",
-      "not-allowed",
-      "nowrap",
-      "ns-resize",
-      "numbers",
-      "numeric",
-      "nw-resize",
-      "nwse-resize",
-      "oblique",
-      "octal",
-      "opacity",
-      "open-quote",
-      "optimizeLegibility",
-      "optimizeSpeed",
-      "oriya",
-      "oromo",
-      "outset",
-      "outside",
-      "outside-shape",
-      "overlay",
-      "overline",
-      "padding",
-      "padding-box",
-      "painted",
-      "page",
-      "paused",
-      "persian",
-      "perspective",
-      "pinch-zoom",
-      "plus-darker",
-      "plus-lighter",
-      "pointer",
-      "polygon",
-      "portrait",
-      "pre",
-      "pre-line",
-      "pre-wrap",
-      "preserve-3d",
-      "progress",
-      "push-button",
-      "radial-gradient",
-      "radio",
-      "read-only",
-      "read-write",
-      "read-write-plaintext-only",
-      "rectangle",
-      "region",
-      "relative",
-      "repeat",
-      "repeating-linear-gradient",
-      "repeating-radial-gradient",
-      "repeat-x",
-      "repeat-y",
-      "reset",
-      "reverse",
-      "rgb",
-      "rgba",
-      "ridge",
-      "right",
-      "rotate",
-      "rotate3d",
-      "rotateX",
-      "rotateY",
-      "rotateZ",
-      "round",
-      "row",
-      "row-resize",
-      "row-reverse",
-      "rtl",
-      "run-in",
-      "running",
-      "s-resize",
-      "sans-serif",
-      "saturate",
-      "saturation",
-      "scale",
-      "scale3d",
-      "scaleX",
-      "scaleY",
-      "scaleZ",
-      "screen",
-      "scroll",
-      "scrollbar",
-      "scroll-position",
-      "se-resize",
-      "searchfield",
-      "searchfield-cancel-button",
-      "searchfield-decoration",
-      "searchfield-results-button",
-      "searchfield-results-decoration",
-      "self-start",
-      "self-end",
-      "semi-condensed",
-      "semi-expanded",
-      "separate",
-      "sepia",
-      "serif",
-      "show",
-      "sidama",
-      "simp-chinese-formal",
-      "simp-chinese-informal",
-      "single",
-      "skew",
-      "skewX",
-      "skewY",
-      "skip-white-space",
-      "slide",
-      "slider-horizontal",
-      "slider-vertical",
-      "sliderthumb-horizontal",
-      "sliderthumb-vertical",
-      "slow",
-      "small",
-      "small-caps",
-      "small-caption",
-      "smaller",
-      "soft-light",
-      "solid",
-      "somali",
-      "source-atop",
-      "source-in",
-      "source-out",
-      "source-over",
-      "space",
-      "space-around",
-      "space-between",
-      "space-evenly",
-      "spell-out",
-      "square",
-      "square-button",
-      "start",
-      "static",
-      "status-bar",
-      "stretch",
-      "stroke",
-      "stroke-box",
-      "sub",
-      "subpixel-antialiased",
-      "svg_masks",
-      "super",
-      "sw-resize",
-      "symbolic",
-      "symbols",
-      "system-ui",
-      "table",
-      "table-caption",
-      "table-cell",
-      "table-column",
-      "table-column-group",
-      "table-footer-group",
-      "table-header-group",
-      "table-row",
-      "table-row-group",
-      "tamil",
-      "telugu",
-      "text",
-      "text-bottom",
-      "text-top",
-      "textarea",
-      "textfield",
-      "thai",
-      "thick",
-      "thin",
-      "threeddarkshadow",
-      "threedface",
-      "threedhighlight",
-      "threedlightshadow",
-      "threedshadow",
-      "tibetan",
-      "tigre",
-      "tigrinya-er",
-      "tigrinya-er-abegede",
-      "tigrinya-et",
-      "tigrinya-et-abegede",
-      "to",
-      "top",
-      "trad-chinese-formal",
-      "trad-chinese-informal",
-      "transform",
-      "translate",
-      "translate3d",
-      "translateX",
-      "translateY",
-      "translateZ",
-      "transparent",
-      "ultra-condensed",
-      "ultra-expanded",
-      "underline",
-      "unidirectional-pan",
-      "unset",
-      "up",
-      "upper-alpha",
-      "upper-armenian",
-      "upper-greek",
-      "upper-hexadecimal",
-      "upper-latin",
-      "upper-norwegian",
-      "upper-roman",
-      "uppercase",
-      "urdu",
-      "url",
-      "var",
-      "vertical",
-      "vertical-text",
-      "view-box",
-      "visible",
-      "visibleFill",
-      "visiblePainted",
-      "visibleStroke",
-      "visual",
-      "w-resize",
-      "wait",
-      "wave",
-      "wider",
-      "window",
-      "windowframe",
-      "windowtext",
-      "words",
-      "wrap",
-      "wrap-reverse",
-      "x-large",
-      "x-small",
-      "xor",
-      "xx-large",
-      "xx-small"
-    ], valueKeywords = keySet(valueKeywords_);
-    var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);
-    CodeMirror2.registerHelper("hintWords", "css", allWords);
-    function tokenCComment(stream, state2) {
-      var maybeEnd = false, ch;
-      while ((ch = stream.next()) != null) {
-        if (maybeEnd && ch == "/") {
-          state2.tokenize = null;
-          break;
-        }
-        maybeEnd = ch == "*";
-      }
-      return ["comment", "comment"];
-    }
-    CodeMirror2.defineMIME("text/css", {
-      documentTypes,
-      mediaTypes,
-      mediaFeatures,
-      mediaValueKeywords,
-      propertyKeywords,
-      nonStandardPropertyKeywords,
-      fontProperties,
-      counterDescriptors,
-      colorKeywords,
-      valueKeywords,
-      tokenHooks: {
-        "/": function(stream, state2) {
-          if (!stream.eat("*"))
-            return false;
-          state2.tokenize = tokenCComment;
-          return tokenCComment(stream, state2);
-        }
-      },
-      name: "css"
-    });
-    CodeMirror2.defineMIME("text/x-scss", {
-      mediaTypes,
-      mediaFeatures,
-      mediaValueKeywords,
-      propertyKeywords,
-      nonStandardPropertyKeywords,
-      colorKeywords,
-      valueKeywords,
-      fontProperties,
-      allowNested: true,
-      lineComment: "//",
-      tokenHooks: {
-        "/": function(stream, state2) {
-          if (stream.eat("/")) {
-            stream.skipToEnd();
-            return ["comment", "comment"];
-          } else if (stream.eat("*")) {
-            state2.tokenize = tokenCComment;
-            return tokenCComment(stream, state2);
-          } else {
-            return ["operator", "operator"];
-          }
-        },
-        ":": function(stream) {
-          if (stream.match(/^\s*\{/, false))
-            return [null, null];
-          return false;
-        },
-        "$": function(stream) {
-          stream.match(/^[\w-]+/);
-          if (stream.match(/^\s*:/, false))
-            return ["variable-2", "variable-definition"];
-          return ["variable-2", "variable"];
-        },
-        "#": function(stream) {
-          if (!stream.eat("{"))
-            return false;
-          return [null, "interpolation"];
+    return keys;
+  }
+
+  var documentTypes_ = [
+    "domain", "regexp", "url", "url-prefix"
+  ], documentTypes = keySet(documentTypes_);
+
+  var mediaTypes_ = [
+    "all", "aural", "braille", "handheld", "print", "projection", "screen",
+    "tty", "tv", "embossed"
+  ], mediaTypes = keySet(mediaTypes_);
+
+  var mediaFeatures_ = [
+    "width", "min-width", "max-width", "height", "min-height", "max-height",
+    "device-width", "min-device-width", "max-device-width", "device-height",
+    "min-device-height", "max-device-height", "aspect-ratio",
+    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
+    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
+    "max-color", "color-index", "min-color-index", "max-color-index",
+    "monochrome", "min-monochrome", "max-monochrome", "resolution",
+    "min-resolution", "max-resolution", "scan", "grid", "orientation",
+    "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio",
+    "pointer", "any-pointer", "hover", "any-hover", "prefers-color-scheme",
+    "dynamic-range", "video-dynamic-range"
+  ], mediaFeatures = keySet(mediaFeatures_);
+
+  var mediaValueKeywords_ = [
+    "landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover",
+    "interlace", "progressive",
+    "dark", "light",
+    "standard", "high"
+  ], mediaValueKeywords = keySet(mediaValueKeywords_);
+
+  var propertyKeywords_ = [
+    "align-content", "align-items", "align-self", "alignment-adjust",
+    "alignment-baseline", "all", "anchor-point", "animation", "animation-delay",
+    "animation-direction", "animation-duration", "animation-fill-mode",
+    "animation-iteration-count", "animation-name", "animation-play-state",
+    "animation-timing-function", "appearance", "azimuth", "backdrop-filter",
+    "backface-visibility", "background", "background-attachment",
+    "background-blend-mode", "background-clip", "background-color",
+    "background-image", "background-origin", "background-position",
+    "background-position-x", "background-position-y", "background-repeat",
+    "background-size", "baseline-shift", "binding", "bleed", "block-size",
+    "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target",
+    "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius",
+    "border-bottom-right-radius", "border-bottom-style", "border-bottom-width",
+    "border-collapse", "border-color", "border-image", "border-image-outset",
+    "border-image-repeat", "border-image-slice", "border-image-source",
+    "border-image-width", "border-left", "border-left-color", "border-left-style",
+    "border-left-width", "border-radius", "border-right", "border-right-color",
+    "border-right-style", "border-right-width", "border-spacing", "border-style",
+    "border-top", "border-top-color", "border-top-left-radius",
+    "border-top-right-radius", "border-top-style", "border-top-width",
+    "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing",
+    "break-after", "break-before", "break-inside", "caption-side", "caret-color",
+    "clear", "clip", "color", "color-profile", "column-count", "column-fill",
+    "column-gap", "column-rule", "column-rule-color", "column-rule-style",
+    "column-rule-width", "column-span", "column-width", "columns", "contain",
+    "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after",
+    "cue-before", "cursor", "direction", "display", "dominant-baseline",
+    "drop-initial-after-adjust", "drop-initial-after-align",
+    "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size",
+    "drop-initial-value", "elevation", "empty-cells", "fit", "fit-content", "fit-position",
+    "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow",
+    "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into",
+    "font", "font-family", "font-feature-settings", "font-kerning",
+    "font-language-override", "font-optical-sizing", "font-size",
+    "font-size-adjust", "font-stretch", "font-style", "font-synthesis",
+    "font-variant", "font-variant-alternates", "font-variant-caps",
+    "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric",
+    "font-variant-position", "font-variation-settings", "font-weight", "gap",
+    "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows",
+    "grid-column", "grid-column-end", "grid-column-gap", "grid-column-start",
+    "grid-gap", "grid-row", "grid-row-end", "grid-row-gap", "grid-row-start",
+    "grid-template", "grid-template-areas", "grid-template-columns",
+    "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon",
+    "image-orientation", "image-rendering", "image-resolution", "inline-box-align",
+    "inset", "inset-block", "inset-block-end", "inset-block-start", "inset-inline",
+    "inset-inline-end", "inset-inline-start", "isolation", "justify-content",
+    "justify-items", "justify-self", "left", "letter-spacing", "line-break",
+    "line-height", "line-height-step", "line-stacking", "line-stacking-ruby",
+    "line-stacking-shift", "line-stacking-strategy", "list-style",
+    "list-style-image", "list-style-position", "list-style-type", "margin",
+    "margin-bottom", "margin-left", "margin-right", "margin-top", "marks",
+    "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed",
+    "marquee-style", "mask-clip", "mask-composite", "mask-image", "mask-mode",
+    "mask-origin", "mask-position", "mask-repeat", "mask-size","mask-type",
+    "max-block-size", "max-height", "max-inline-size",
+    "max-width", "min-block-size", "min-height", "min-inline-size", "min-width",
+    "mix-blend-mode", "move-to", "nav-down", "nav-index", "nav-left", "nav-right",
+    "nav-up", "object-fit", "object-position", "offset", "offset-anchor",
+    "offset-distance", "offset-path", "offset-position", "offset-rotate",
+    "opacity", "order", "orphans", "outline", "outline-color", "outline-offset",
+    "outline-style", "outline-width", "overflow", "overflow-style",
+    "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom",
+    "padding-left", "padding-right", "padding-top", "page", "page-break-after",
+    "page-break-before", "page-break-inside", "page-policy", "pause",
+    "pause-after", "pause-before", "perspective", "perspective-origin", "pitch",
+    "pitch-range", "place-content", "place-items", "place-self", "play-during",
+    "position", "presentation-level", "punctuation-trim", "quotes",
+    "region-break-after", "region-break-before", "region-break-inside",
+    "region-fragment", "rendering-intent", "resize", "rest", "rest-after",
+    "rest-before", "richness", "right", "rotate", "rotation", "rotation-point",
+    "row-gap", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span",
+    "scale", "scroll-behavior", "scroll-margin", "scroll-margin-block",
+    "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom",
+    "scroll-margin-inline", "scroll-margin-inline-end",
+    "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right",
+    "scroll-margin-top", "scroll-padding", "scroll-padding-block",
+    "scroll-padding-block-end", "scroll-padding-block-start",
+    "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end",
+    "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right",
+    "scroll-padding-top", "scroll-snap-align", "scroll-snap-type",
+    "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside",
+    "size", "speak", "speak-as", "speak-header", "speak-numeral",
+    "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size",
+    "table-layout", "target", "target-name", "target-new", "target-position",
+    "text-align", "text-align-last", "text-combine-upright", "text-decoration",
+    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
+    "text-decoration-skip-ink", "text-decoration-style", "text-emphasis",
+    "text-emphasis-color", "text-emphasis-position", "text-emphasis-style",
+    "text-height", "text-indent", "text-justify", "text-orientation",
+    "text-outline", "text-overflow", "text-rendering", "text-shadow",
+    "text-size-adjust", "text-space-collapse", "text-transform",
+    "text-underline-position", "text-wrap", "top", "touch-action", "transform", "transform-origin",
+    "transform-style", "transition", "transition-delay", "transition-duration",
+    "transition-property", "transition-timing-function", "translate",
+    "unicode-bidi", "user-select", "vertical-align", "visibility", "voice-balance",
+    "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate",
+    "voice-stress", "voice-volume", "volume", "white-space", "widows", "width",
+    "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "z-index",
+    // SVG-specific
+    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
+    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
+    "color-interpolation", "color-interpolation-filters",
+    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
+    "marker", "marker-end", "marker-mid", "marker-start", "paint-order", "shape-rendering", "stroke",
+    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
+    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
+    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
+    "glyph-orientation-vertical", "text-anchor", "writing-mode",
+  ], propertyKeywords = keySet(propertyKeywords_);
+
+  var nonStandardPropertyKeywords_ = [
+    "accent-color", "aspect-ratio", "border-block", "border-block-color", "border-block-end",
+    "border-block-end-color", "border-block-end-style", "border-block-end-width",
+    "border-block-start", "border-block-start-color", "border-block-start-style",
+    "border-block-start-width", "border-block-style", "border-block-width",
+    "border-inline", "border-inline-color", "border-inline-end",
+    "border-inline-end-color", "border-inline-end-style",
+    "border-inline-end-width", "border-inline-start", "border-inline-start-color",
+    "border-inline-start-style", "border-inline-start-width",
+    "border-inline-style", "border-inline-width", "content-visibility", "margin-block",
+    "margin-block-end", "margin-block-start", "margin-inline", "margin-inline-end",
+    "margin-inline-start", "overflow-anchor", "overscroll-behavior", "padding-block", "padding-block-end",
+    "padding-block-start", "padding-inline", "padding-inline-end",
+    "padding-inline-start", "scroll-snap-stop", "scrollbar-3d-light-color",
+    "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
+    "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
+    "scrollbar-track-color", "searchfield-cancel-button", "searchfield-decoration",
+    "searchfield-results-button", "searchfield-results-decoration", "shape-inside", "zoom"
+  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);
+
+  var fontProperties_ = [
+    "font-display", "font-family", "src", "unicode-range", "font-variant",
+     "font-feature-settings", "font-stretch", "font-weight", "font-style"
+  ], fontProperties = keySet(fontProperties_);
+
+  var counterDescriptors_ = [
+    "additive-symbols", "fallback", "negative", "pad", "prefix", "range",
+    "speak-as", "suffix", "symbols", "system"
+  ], counterDescriptors = keySet(counterDescriptors_);
+
+  var colorKeywords_ = [
+    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
+    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
+    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
+    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
+    "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen",
+    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
+    "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet",
+    "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick",
+    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
+    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
+    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
+    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
+    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink",
+    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey",
+    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
+    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
+    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
+    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
+    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
+    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
+    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
+    "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",
+    "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
+    "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan",
+    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
+    "whitesmoke", "yellow", "yellowgreen"
+  ], colorKeywords = keySet(colorKeywords_);
+
+  var valueKeywords_ = [
+    "above", "absolute", "activeborder", "additive", "activecaption", "afar",
+    "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate",
+    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
+    "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page",
+    "avoid-region", "axis-pan", "background", "backwards", "baseline", "below", "bidi-override", "binary",
+    "bengali", "blink", "block", "block-axis", "blur", "bold", "bolder", "border", "border-box",
+    "both", "bottom", "break", "break-all", "break-word", "brightness", "bullets", "button", "button-bevel",
+    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian",
+    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
+    "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch",
+    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
+    "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse",
+    "compact", "condensed", "conic-gradient", "contain", "content", "contents",
+    "content-box", "context-menu", "continuous", "contrast", "copy", "counter", "counters", "cover", "crop",
+    "cross", "crosshair", "cubic-bezier", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",
+    "decimal-leading-zero", "default", "default-button", "dense", "destination-atop",
+    "destination-in", "destination-out", "destination-over", "devanagari", "difference",
+    "disc", "discard", "disclosure-closed", "disclosure-open", "document",
+    "dot-dash", "dot-dot-dash",
+    "dotted", "double", "down", "drop-shadow", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
+    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
+    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
+    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
+    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
+    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
+    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
+    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig",
+    "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed",
+    "extra-expanded", "fantasy", "fast", "fill", "fill-box", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes",
+    "forwards", "from", "geometricPrecision", "georgian", "grayscale", "graytext", "grid", "groove",
+    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew",
+    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
+    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "hue-rotate", "icon", "ignore",
+    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
+    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
+    "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert",
+    "italic", "japanese-formal", "japanese-informal", "justify", "kannada",
+    "katakana", "katakana-iroha", "keep-all", "khmer",
+    "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal",
+    "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten",
+    "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem",
+    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
+    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
+    "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "manipulation", "match", "matrix", "matrix3d",
+    "media-controls-background", "media-current-time-display",
+    "media-fullscreen-button", "media-mute-button", "media-play-button",
+    "media-return-to-realtime-button", "media-rewind-button",
+    "media-seek-back-button", "media-seek-forward-button", "media-slider",
+    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
+    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
+    "menu", "menulist", "menulist-button", "menulist-text",
+    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
+    "mix", "mongolian", "monospace", "move", "multiple", "multiple_mask_images", "multiply", "myanmar", "n-resize",
+    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
+    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
+    "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote",
+    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
+    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
+    "painted", "page", "paused", "persian", "perspective", "pinch-zoom", "plus-darker", "plus-lighter",
+    "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d",
+    "progress", "push-button", "radial-gradient", "radio", "read-only",
+    "read-write", "read-write-plaintext-only", "rectangle", "region",
+    "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient",
+    "repeating-conic-gradient", "repeat-x", "repeat-y", "reset", "reverse",
+    "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY",
+    "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running",
+    "s-resize", "sans-serif", "saturate", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen",
+    "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield",
+    "searchfield-cancel-button", "searchfield-decoration",
+    "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end",
+    "semi-condensed", "semi-expanded", "separate", "sepia", "serif", "show", "sidama",
+    "simp-chinese-formal", "simp-chinese-informal", "single",
+    "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",
+    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
+    "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali",
+    "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square",
+    "square-button", "start", "static", "status-bar", "stretch", "stroke", "stroke-box", "sub",
+    "subpixel-antialiased", "svg_masks", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table",
+    "table-caption", "table-cell", "table-column", "table-column-group",
+    "table-footer-group", "table-header-group", "table-row", "table-row-group",
+    "tamil",
+    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
+    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
+    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
+    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
+    "trad-chinese-formal", "trad-chinese-informal", "transform",
+    "translate", "translate3d", "translateX", "translateY", "translateZ",
+    "transparent", "ultra-condensed", "ultra-expanded", "underline", "unidirectional-pan", "unset", "up",
+    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
+    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
+    "var", "vertical", "vertical-text", "view-box", "visible", "visibleFill", "visiblePainted",
+    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
+    "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor",
+    "xx-large", "xx-small"
+  ], valueKeywords = keySet(valueKeywords_);
+
+  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)
+    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)
+    .concat(valueKeywords_);
+  CodeMirror.registerHelper("hintWords", "css", allWords);
+
+  function tokenCComment(stream, state) {
+    var maybeEnd = false, ch;
+    while ((ch = stream.next()) != null) {
+      if (maybeEnd && ch == "/") {
+        state.tokenize = null;
+        break;
+      }
+      maybeEnd = (ch == "*");
+    }
+    return ["comment", "comment"];
+  }
+
+  CodeMirror.defineMIME("text/css", {
+    documentTypes: documentTypes,
+    mediaTypes: mediaTypes,
+    mediaFeatures: mediaFeatures,
+    mediaValueKeywords: mediaValueKeywords,
+    propertyKeywords: propertyKeywords,
+    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
+    fontProperties: fontProperties,
+    counterDescriptors: counterDescriptors,
+    colorKeywords: colorKeywords,
+    valueKeywords: valueKeywords,
+    tokenHooks: {
+      "/": function(stream, state) {
+        if (!stream.eat("*")) return false;
+        state.tokenize = tokenCComment;
+        return tokenCComment(stream, state);
+      }
+    },
+    name: "css"
+  });
+
+  CodeMirror.defineMIME("text/x-scss", {
+    mediaTypes: mediaTypes,
+    mediaFeatures: mediaFeatures,
+    mediaValueKeywords: mediaValueKeywords,
+    propertyKeywords: propertyKeywords,
+    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
+    colorKeywords: colorKeywords,
+    valueKeywords: valueKeywords,
+    fontProperties: fontProperties,
+    allowNested: true,
+    lineComment: "//",
+    tokenHooks: {
+      "/": function(stream, state) {
+        if (stream.eat("/")) {
+          stream.skipToEnd();
+          return ["comment", "comment"];
+        } else if (stream.eat("*")) {
+          state.tokenize = tokenCComment;
+          return tokenCComment(stream, state);
+        } else {
+          return ["operator", "operator"];
         }
       },
-      name: "css",
-      helperType: "scss"
-    });
-    CodeMirror2.defineMIME("text/x-less", {
-      mediaTypes,
-      mediaFeatures,
-      mediaValueKeywords,
-      propertyKeywords,
-      nonStandardPropertyKeywords,
-      colorKeywords,
-      valueKeywords,
-      fontProperties,
-      allowNested: true,
-      lineComment: "//",
-      tokenHooks: {
-        "/": function(stream, state2) {
-          if (stream.eat("/")) {
-            stream.skipToEnd();
-            return ["comment", "comment"];
-          } else if (stream.eat("*")) {
-            state2.tokenize = tokenCComment;
-            return tokenCComment(stream, state2);
-          } else {
-            return ["operator", "operator"];
-          }
-        },
-        "@": function(stream) {
-          if (stream.eat("{"))
-            return [null, "interpolation"];
-          if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false))
-            return false;
-          stream.eatWhile(/[\w\\\-]/);
-          if (stream.match(/^\s*:/, false))
-            return ["variable-2", "variable-definition"];
-          return ["variable-2", "variable"];
-        },
-        "&": function() {
-          return ["atom", "atom"];
-        }
+      ":": function(stream) {
+        if (stream.match(/^\s*\{/, false))
+          return [null, null]
+        return false;
       },
-      name: "css",
-      helperType: "less"
-    });
-    CodeMirror2.defineMIME("text/x-gss", {
-      documentTypes,
-      mediaTypes,
-      mediaFeatures,
-      propertyKeywords,
-      nonStandardPropertyKeywords,
-      fontProperties,
-      counterDescriptors,
-      colorKeywords,
-      valueKeywords,
-      supportsAtComponent: true,
-      tokenHooks: {
-        "/": function(stream, state2) {
-          if (!stream.eat("*"))
-            return false;
-          state2.tokenize = tokenCComment;
-          return tokenCComment(stream, state2);
-        }
+      "$": function(stream) {
+        stream.match(/^[\w-]+/);
+        if (stream.match(/^\s*:/, false))
+          return ["variable-2", "variable-definition"];
+        return ["variable-2", "variable"];
       },
-      name: "css",
-      helperType: "gss"
-    });
+      "#": function(stream) {
+        if (!stream.eat("{")) return false;
+        return [null, "interpolation"];
+      }
+    },
+    name: "css",
+    helperType: "scss"
   });
-})();
-var xml = { exports: {} };
-(function(module, exports) {
-  (function(mod) {
-    mod(codemirror$1.exports);
-  })(function(CodeMirror2) {
-    var htmlConfig = {
-      autoSelfClosers: {
-        "area": true,
-        "base": true,
-        "br": true,
-        "col": true,
-        "command": true,
-        "embed": true,
-        "frame": true,
-        "hr": true,
-        "img": true,
-        "input": true,
-        "keygen": true,
-        "link": true,
-        "meta": true,
-        "param": true,
-        "source": true,
-        "track": true,
-        "wbr": true,
-        "menuitem": true
-      },
-      implicitlyClosed: {
-        "dd": true,
-        "li": true,
-        "optgroup": true,
-        "option": true,
-        "p": true,
-        "rp": true,
-        "rt": true,
-        "tbody": true,
-        "td": true,
-        "tfoot": true,
-        "th": true,
-        "tr": true
+
+  CodeMirror.defineMIME("text/x-less", {
+    mediaTypes: mediaTypes,
+    mediaFeatures: mediaFeatures,
+    mediaValueKeywords: mediaValueKeywords,
+    propertyKeywords: propertyKeywords,
+    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
+    colorKeywords: colorKeywords,
+    valueKeywords: valueKeywords,
+    fontProperties: fontProperties,
+    allowNested: true,
+    lineComment: "//",
+    tokenHooks: {
+      "/": function(stream, state) {
+        if (stream.eat("/")) {
+          stream.skipToEnd();
+          return ["comment", "comment"];
+        } else if (stream.eat("*")) {
+          state.tokenize = tokenCComment;
+          return tokenCComment(stream, state);
+        } else {
+          return ["operator", "operator"];
+        }
       },
-      contextGrabbers: {
-        "dd": { "dd": true, "dt": true },
-        "dt": { "dd": true, "dt": true },
-        "li": { "li": true },
-        "option": { "option": true, "optgroup": true },
-        "optgroup": { "optgroup": true },
-        "p": {
-          "address": true,
-          "article": true,
-          "aside": true,
-          "blockquote": true,
-          "dir": true,
-          "div": true,
-          "dl": true,
-          "fieldset": true,
-          "footer": true,
-          "form": true,
-          "h1": true,
-          "h2": true,
-          "h3": true,
-          "h4": true,
-          "h5": true,
-          "h6": true,
-          "header": true,
-          "hgroup": true,
-          "hr": true,
-          "menu": true,
-          "nav": true,
-          "ol": true,
-          "p": true,
-          "pre": true,
-          "section": true,
-          "table": true,
-          "ul": true
-        },
-        "rp": { "rp": true, "rt": true },
-        "rt": { "rp": true, "rt": true },
-        "tbody": { "tbody": true, "tfoot": true },
-        "td": { "td": true, "th": true },
-        "tfoot": { "tbody": true },
-        "th": { "td": true, "th": true },
-        "thead": { "tbody": true, "tfoot": true },
-        "tr": { "tr": true }
+      "@": function(stream) {
+        if (stream.eat("{")) return [null, "interpolation"];
+        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false)) return false;
+        stream.eatWhile(/[\w\\\-]/);
+        if (stream.match(/^\s*:/, false))
+          return ["variable-2", "variable-definition"];
+        return ["variable-2", "variable"];
       },
-      doNotIndent: { "pre": true },
-      allowUnquoted: true,
-      allowMissing: true,
-      caseFold: true
-    };
-    var xmlConfig = {
-      autoSelfClosers: {},
-      implicitlyClosed: {},
-      contextGrabbers: {},
-      doNotIndent: {},
-      allowUnquoted: false,
-      allowMissing: false,
-      allowMissingTagName: false,
-      caseFold: false
-    };
-    CodeMirror2.defineMode("xml", function(editorConf, config_) {
-      var indentUnit = editorConf.indentUnit;
-      var config = {};
-      var defaults = config_.htmlMode ? htmlConfig : xmlConfig;
-      for (var prop in defaults)
-        config[prop] = defaults[prop];
-      for (var prop in config_)
-        config[prop] = config_[prop];
-      var type, setStyle;
-      function inText(stream, state2) {
-        function chain(parser) {
-          state2.tokenize = parser;
-          return parser(stream, state2);
-        }
-        var ch = stream.next();
-        if (ch == "<") {
-          if (stream.eat("!")) {
-            if (stream.eat("[")) {
-              if (stream.match("CDATA["))
-                return chain(inBlock("atom", "]]>"));
-              else
-                return null;
-            } else if (stream.match("--")) {
-              return chain(inBlock("comment", "-->"));
-            } else if (stream.match("DOCTYPE", true, true)) {
-              stream.eatWhile(/[\w\._\-]/);
-              return chain(doctype(1));
-            } else {
-              return null;
-            }
-          } else if (stream.eat("?")) {
-            stream.eatWhile(/[\w\._\-]/);
-            state2.tokenize = inBlock("meta", "?>");
-            return "meta";
-          } else {
-            type = stream.eat("/") ? "closeTag" : "openTag";
-            state2.tokenize = inTag;
-            return "tag bracket";
-          }
-        } else if (ch == "&") {
-          var ok;
-          if (stream.eat("#")) {
-            if (stream.eat("x")) {
-              ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
-            } else {
-              ok = stream.eatWhile(/[\d]/) && stream.eat(";");
-            }
-          } else {
-            ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
-          }
-          return ok ? "atom" : "error";
+      "&": function() {
+        return ["atom", "atom"];
+      }
+    },
+    name: "css",
+    helperType: "less"
+  });
+
+  CodeMirror.defineMIME("text/x-gss", {
+    documentTypes: documentTypes,
+    mediaTypes: mediaTypes,
+    mediaFeatures: mediaFeatures,
+    propertyKeywords: propertyKeywords,
+    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
+    fontProperties: fontProperties,
+    counterDescriptors: counterDescriptors,
+    colorKeywords: colorKeywords,
+    valueKeywords: valueKeywords,
+    supportsAtComponent: true,
+    tokenHooks: {
+      "/": function(stream, state) {
+        if (!stream.eat("*")) return false;
+        state.tokenize = tokenCComment;
+        return tokenCComment(stream, state);
+      }
+    },
+    name: "css",
+    helperType: "gss"
+  });
+
+});
+}());
+
+var xml = {exports: {}};
+
+(function (module, exports) {
+// CodeMirror, copyright (c) by Marijn Haverbeke and others
+// Distributed under an MIT license: https://codemirror.net/LICENSE
+
+(function(mod) {
+  mod(codemirror$1.exports);
+})(function(CodeMirror) {
+
+var htmlConfig = {
+  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
+                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
+                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
+                    'track': true, 'wbr': true, 'menuitem': true},
+  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
+                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
+                     'th': true, 'tr': true},
+  contextGrabbers: {
+    'dd': {'dd': true, 'dt': true},
+    'dt': {'dd': true, 'dt': true},
+    'li': {'li': true},
+    'option': {'option': true, 'optgroup': true},
+    'optgroup': {'optgroup': true},
+    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
+          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
+          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
+          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
+          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
+    'rp': {'rp': true, 'rt': true},
+    'rt': {'rp': true, 'rt': true},
+    'tbody': {'tbody': true, 'tfoot': true},
+    'td': {'td': true, 'th': true},
+    'tfoot': {'tbody': true},
+    'th': {'td': true, 'th': true},
+    'thead': {'tbody': true, 'tfoot': true},
+    'tr': {'tr': true}
+  },
+  doNotIndent: {"pre": true},
+  allowUnquoted: true,
+  allowMissing: true,
+  caseFold: true
+};
+
+var xmlConfig = {
+  autoSelfClosers: {},
+  implicitlyClosed: {},
+  contextGrabbers: {},
+  doNotIndent: {},
+  allowUnquoted: false,
+  allowMissing: false,
+  allowMissingTagName: false,
+  caseFold: false
+};
+
+CodeMirror.defineMode("xml", function(editorConf, config_) {
+  var indentUnit = editorConf.indentUnit;
+  var config = {};
+  var defaults = config_.htmlMode ? htmlConfig : xmlConfig;
+  for (var prop in defaults) config[prop] = defaults[prop];
+  for (var prop in config_) config[prop] = config_[prop];
+
+  // Return variables for tokenizers
+  var type, setStyle;
+
+  function inText(stream, state) {
+    function chain(parser) {
+      state.tokenize = parser;
+      return parser(stream, state);
+    }
+
+    var ch = stream.next();
+    if (ch == "<") {
+      if (stream.eat("!")) {
+        if (stream.eat("[")) {
+          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
+          else return null;
+        } else if (stream.match("--")) {
+          return chain(inBlock("comment", "-->"));
+        } else if (stream.match("DOCTYPE", true, true)) {
+          stream.eatWhile(/[\w\._\-]/);
+          return chain(doctype(1));
         } else {
-          stream.eatWhile(/[^&<]/);
           return null;
         }
+      } else if (stream.eat("?")) {
+        stream.eatWhile(/[\w\._\-]/);
+        state.tokenize = inBlock("meta", "?>");
+        return "meta";
+      } else {
+        type = stream.eat("/") ? "closeTag" : "openTag";
+        state.tokenize = inTag;
+        return "tag bracket";
       }
-      inText.isInText = true;
-      function inTag(stream, state2) {
-        var ch = stream.next();
-        if (ch == ">" || ch == "/" && stream.eat(">")) {
-          state2.tokenize = inText;
-          type = ch == ">" ? "endTag" : "selfcloseTag";
-          return "tag bracket";
-        } else if (ch == "=") {
-          type = "equals";
-          return null;
-        } else if (ch == "<") {
-          state2.tokenize = inText;
-          state2.state = baseState;
-          state2.tagName = state2.tagStart = null;
-          var next2 = state2.tokenize(stream, state2);
-          return next2 ? next2 + " tag error" : "tag error";
-        } else if (/[\'\"]/.test(ch)) {
-          state2.tokenize = inAttribute(ch);
-          state2.stringStartCol = stream.column();
-          return state2.tokenize(stream, state2);
+    } else if (ch == "&") {
+      var ok;
+      if (stream.eat("#")) {
+        if (stream.eat("x")) {
+          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
         } else {
-          stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
-          return "word";
-        }
-      }
-      function inAttribute(quote) {
-        var closure = function(stream, state2) {
-          while (!stream.eol()) {
-            if (stream.next() == quote) {
-              state2.tokenize = inTag;
-              break;
-            }
-          }
-          return "string";
-        };
-        closure.isInAttribute = true;
-        return closure;
-      }
-      function inBlock(style, terminator) {
-        return function(stream, state2) {
-          while (!stream.eol()) {
-            if (stream.match(terminator)) {
-              state2.tokenize = inText;
-              break;
-            }
-            stream.next();
-          }
-          return style;
-        };
-      }
-      function doctype(depth) {
-        return function(stream, state2) {
-          var ch;
-          while ((ch = stream.next()) != null) {
-            if (ch == "<") {
-              state2.tokenize = doctype(depth + 1);
-              return state2.tokenize(stream, state2);
-            } else if (ch == ">") {
-              if (depth == 1) {
-                state2.tokenize = inText;
-                break;
-              } else {
-                state2.tokenize = doctype(depth - 1);
-                return state2.tokenize(stream, state2);
-              }
-            }
-          }
-          return "meta";
-        };
-      }
-      function lower(tagName) {
-        return tagName && tagName.toLowerCase();
-      }
-      function Context(state2, tagName, startOfLine) {
-        this.prev = state2.context;
-        this.tagName = tagName || "";
-        this.indent = state2.indented;
-        this.startOfLine = startOfLine;
-        if (config.doNotIndent.hasOwnProperty(tagName) || state2.context && state2.context.noIndent)
-          this.noIndent = true;
-      }
-      function popContext(state2) {
-        if (state2.context)
-          state2.context = state2.context.prev;
-      }
-      function maybePopContext(state2, nextTagName) {
-        var parentTagName;
-        while (true) {
-          if (!state2.context) {
-            return;
-          }
-          parentTagName = state2.context.tagName;
-          if (!config.contextGrabbers.hasOwnProperty(lower(parentTagName)) || !config.contextGrabbers[lower(parentTagName)].hasOwnProperty(lower(nextTagName))) {
-            return;
-          }
-          popContext(state2);
+          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
         }
+      } else {
+        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
       }
-      function baseState(type2, stream, state2) {
-        if (type2 == "openTag") {
-          state2.tagStart = stream.column();
-          return tagNameState;
-        } else if (type2 == "closeTag") {
-          return closeTagNameState;
-        } else {
-          return baseState;
+      return ok ? "atom" : "error";
+    } else {
+      stream.eatWhile(/[^&<]/);
+      return null;
+    }
+  }
+  inText.isInText = true;
+
+  function inTag(stream, state) {
+    var ch = stream.next();
+    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
+      state.tokenize = inText;
+      type = ch == ">" ? "endTag" : "selfcloseTag";
+      return "tag bracket";
+    } else if (ch == "=") {
+      type = "equals";
+      return null;
+    } else if (ch == "<") {
+      state.tokenize = inText;
+      state.state = baseState;
+      state.tagName = state.tagStart = null;
+      var next = state.tokenize(stream, state);
+      return next ? next + " tag error" : "tag error";
+    } else if (/[\'\"]/.test(ch)) {
+      state.tokenize = inAttribute(ch);
+      state.stringStartCol = stream.column();
+      return state.tokenize(stream, state);
+    } else {
+      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
+      return "word";
+    }
+  }
+
+  function inAttribute(quote) {
+    var closure = function(stream, state) {
+      while (!stream.eol()) {
+        if (stream.next() == quote) {
+          state.tokenize = inTag;
+          break;
         }
       }
-      function tagNameState(type2, stream, state2) {
-        if (type2 == "word") {
-          state2.tagName = stream.current();
-          setStyle = "tag";
-          return attrState;
-        } else if (config.allowMissingTagName && type2 == "endTag") {
-          setStyle = "tag bracket";
-          return attrState(type2, stream, state2);
-        } else {
-          setStyle = "error";
-          return tagNameState;
+      return "string";
+    };
+    closure.isInAttribute = true;
+    return closure;
+  }
+
+  function inBlock(style, terminator) {
+    return function(stream, state) {
+      while (!stream.eol()) {
+        if (stream.match(terminator)) {
+          state.tokenize = inText;
+          break;
         }
+        stream.next();
       }
-      function closeTagNameState(type2, stream, state2) {
-        if (type2 == "word") {
-          var tagName = stream.current();
-          if (state2.context && state2.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(lower(state2.context.tagName)))
-            popContext(state2);
-          if (state2.context && state2.context.tagName == tagName || config.matchClosing === false) {
-            setStyle = "tag";
-            return closeState;
+      return style;
+    }
+  }
+
+  function doctype(depth) {
+    return function(stream, state) {
+      var ch;
+      while ((ch = stream.next()) != null) {
+        if (ch == "<") {
+          state.tokenize = doctype(depth + 1);
+          return state.tokenize(stream, state);
+        } else if (ch == ">") {
+          if (depth == 1) {
+            state.tokenize = inText;
+            break;
           } else {
-            setStyle = "tag error";
-            return closeStateErr;
+            state.tokenize = doctype(depth - 1);
+            return state.tokenize(stream, state);
           }
-        } else if (config.allowMissingTagName && type2 == "endTag") {
-          setStyle = "tag bracket";
-          return closeState(type2, stream, state2);
-        } else {
-          setStyle = "error";
-          return closeStateErr;
         }
       }
-      function closeState(type2, _stream, state2) {
-        if (type2 != "endTag") {
-          setStyle = "error";
-          return closeState;
-        }
-        popContext(state2);
-        return baseState;
-      }
-      function closeStateErr(type2, stream, state2) {
-        setStyle = "error";
-        return closeState(type2, stream, state2);
-      }
-      function attrState(type2, _stream, state2) {
-        if (type2 == "word") {
-          setStyle = "attribute";
-          return attrEqState;
-        } else if (type2 == "endTag" || type2 == "selfcloseTag") {
-          var tagName = state2.tagName, tagStart = state2.tagStart;
-          state2.tagName = state2.tagStart = null;
-          if (type2 == "selfcloseTag" || config.autoSelfClosers.hasOwnProperty(lower(tagName))) {
-            maybePopContext(state2, tagName);
-          } else {
-            maybePopContext(state2, tagName);
-            state2.context = new Context(state2, tagName, tagStart == state2.indented);
-          }
-          return baseState;
-        }
-        setStyle = "error";
-        return attrState;
-      }
-      function attrEqState(type2, stream, state2) {
-        if (type2 == "equals")
-          return attrValueState;
-        if (!config.allowMissing)
-          setStyle = "error";
-        return attrState(type2, stream, state2);
-      }
-      function attrValueState(type2, stream, state2) {
-        if (type2 == "string")
-          return attrContinuedState;
-        if (type2 == "word" && config.allowUnquoted) {
-          setStyle = "string";
-          return attrState;
-        }
-        setStyle = "error";
-        return attrState(type2, stream, state2);
+      return "meta";
+    };
+  }
+
+  function lower(tagName) {
+    return tagName && tagName.toLowerCase();
+  }
+
+  function Context(state, tagName, startOfLine) {
+    this.prev = state.context;
+    this.tagName = tagName || "";
+    this.indent = state.indented;
+    this.startOfLine = startOfLine;
+    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
+      this.noIndent = true;
+  }
+  function popContext(state) {
+    if (state.context) state.context = state.context.prev;
+  }
+  function maybePopContext(state, nextTagName) {
+    var parentTagName;
+    while (true) {
+      if (!state.context) {
+        return;
       }
-      function attrContinuedState(type2, stream, state2) {
-        if (type2 == "string")
-          return attrContinuedState;
-        return attrState(type2, stream, state2);
+      parentTagName = state.context.tagName;
+      if (!config.contextGrabbers.hasOwnProperty(lower(parentTagName)) ||
+          !config.contextGrabbers[lower(parentTagName)].hasOwnProperty(lower(nextTagName))) {
+        return;
       }
-      return {
-        startState: function(baseIndent) {
-          var state2 = {
-            tokenize: inText,
-            state: baseState,
-            indented: baseIndent || 0,
-            tagName: null,
-            tagStart: null,
-            context: null
-          };
-          if (baseIndent != null)
-            state2.baseIndent = baseIndent;
-          return state2;
-        },
-        token: function(stream, state2) {
-          if (!state2.tagName && stream.sol())
-            state2.indented = stream.indentation();
-          if (stream.eatSpace())
-            return null;
-          type = null;
-          var style = state2.tokenize(stream, state2);
-          if ((style || type) && style != "comment") {
-            setStyle = null;
-            state2.state = state2.state(type || style, stream, state2);
-            if (setStyle)
-              style = setStyle == "error" ? style + " error" : setStyle;
-          }
-          return style;
-        },
-        indent: function(state2, textAfter, fullLine) {
-          var context = state2.context;
-          if (state2.tokenize.isInAttribute) {
-            if (state2.tagStart == state2.indented)
-              return state2.stringStartCol + 1;
-            else
-              return state2.indented + indentUnit;
-          }
-          if (context && context.noIndent)
-            return CodeMirror2.Pass;
-          if (state2.tokenize != inTag && state2.tokenize != inText)
-            return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
-          if (state2.tagName) {
-            if (config.multilineTagIndentPastTag !== false)
-              return state2.tagStart + state2.tagName.length + 2;
-            else
-              return state2.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
-          }
-          if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter))
-            return 0;
-          var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
-          if (tagAfter && tagAfter[1]) {
-            while (context) {
-              if (context.tagName == tagAfter[2]) {
-                context = context.prev;
-                break;
-              } else if (config.implicitlyClosed.hasOwnProperty(lower(context.tagName))) {
-                context = context.prev;
-              } else {
-                break;
-              }
-            }
-          } else if (tagAfter) {
-            while (context) {
-              var grabbers = config.contextGrabbers[lower(context.tagName)];
-              if (grabbers && grabbers.hasOwnProperty(lower(tagAfter[2])))
-                context = context.prev;
-              else
-                break;
-            }
+      popContext(state);
+    }
+  }
+
+  function baseState(type, stream, state) {
+    if (type == "openTag") {
+      state.tagStart = stream.column();
+      return tagNameState;
+    } else if (type == "closeTag") {
+      return closeTagNameState;
+    } else {
+      return baseState;
+    }
+  }
+  function tagNameState(type, stream, state) {
+    if (type == "word") {
+      state.tagName = stream.current();
+      setStyle = "tag";
+      return attrState;
+    } else if (config.allowMissingTagName && type == "endTag") {
+      setStyle = "tag bracket";
+      return attrState(type, stream, state);
+    } else {
+      setStyle = "error";
+      return tagNameState;
+    }
+  }
+  function closeTagNameState(type, stream, state) {
+    if (type == "word") {
+      var tagName = stream.current();
+      if (state.context && state.context.tagName != tagName &&
+          config.implicitlyClosed.hasOwnProperty(lower(state.context.tagName)))
+        popContext(state);
+      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
+        setStyle = "tag";
+        return closeState;
+      } else {
+        setStyle = "tag error";
+        return closeStateErr;
+      }
+    } else if (config.allowMissingTagName && type == "endTag") {
+      setStyle = "tag bracket";
+      return closeState(type, stream, state);
+    } else {
+      setStyle = "error";
+      return closeStateErr;
+    }
+  }
+
+  function closeState(type, _stream, state) {
+    if (type != "endTag") {
+      setStyle = "error";
+      return closeState;
+    }
+    popContext(state);
+    return baseState;
+  }
+  function closeStateErr(type, stream, state) {
+    setStyle = "error";
+    return closeState(type, stream, state);
+  }
+
+  function attrState(type, _stream, state) {
+    if (type == "word") {
+      setStyle = "attribute";
+      return attrEqState;
+    } else if (type == "endTag" || type == "selfcloseTag") {
+      var tagName = state.tagName, tagStart = state.tagStart;
+      state.tagName = state.tagStart = null;
+      if (type == "selfcloseTag" ||
+          config.autoSelfClosers.hasOwnProperty(lower(tagName))) {
+        maybePopContext(state, tagName);
+      } else {
+        maybePopContext(state, tagName);
+        state.context = new Context(state, tagName, tagStart == state.indented);
+      }
+      return baseState;
+    }
+    setStyle = "error";
+    return attrState;
+  }
+  function attrEqState(type, stream, state) {
+    if (type == "equals") return attrValueState;
+    if (!config.allowMissing) setStyle = "error";
+    return attrState(type, stream, state);
+  }
+  function attrValueState(type, stream, state) {
+    if (type == "string") return attrContinuedState;
+    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
+    setStyle = "error";
+    return attrState(type, stream, state);
+  }
+  function attrContinuedState(type, stream, state) {
+    if (type == "string") return attrContinuedState;
+    return attrState(type, stream, state);
+  }
+
+  return {
+    startState: function(baseIndent) {
+      var state = {tokenize: inText,
+                   state: baseState,
+                   indented: baseIndent || 0,
+                   tagName: null, tagStart: null,
+                   context: null};
+      if (baseIndent != null) state.baseIndent = baseIndent;
+      return state
+    },
+
+    token: function(stream, state) {
+      if (!state.tagName && stream.sol())
+        state.indented = stream.indentation();
+
+      if (stream.eatSpace()) return null;
+      type = null;
+      var style = state.tokenize(stream, state);
+      if ((style || type) && style != "comment") {
+        setStyle = null;
+        state.state = state.state(type || style, stream, state);
+        if (setStyle)
+          style = setStyle == "error" ? style + " error" : setStyle;
+      }
+      return style;
+    },
+
+    indent: function(state, textAfter, fullLine) {
+      var context = state.context;
+      // Indent multi-line strings (e.g. css).
+      if (state.tokenize.isInAttribute) {
+        if (state.tagStart == state.indented)
+          return state.stringStartCol + 1;
+        else
+          return state.indented + indentUnit;
+      }
+      if (context && context.noIndent) return CodeMirror.Pass;
+      if (state.tokenize != inTag && state.tokenize != inText)
+        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
+      // Indent the starts of attribute names.
+      if (state.tagName) {
+        if (config.multilineTagIndentPastTag !== false)
+          return state.tagStart + state.tagName.length + 2;
+        else
+          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
+      }
+      if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
+      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
+      if (tagAfter && tagAfter[1]) { // Closing tag spotted
+        while (context) {
+          if (context.tagName == tagAfter[2]) {
+            context = context.prev;
+            break;
+          } else if (config.implicitlyClosed.hasOwnProperty(lower(context.tagName))) {
+            context = context.prev;
+          } else {
+            break;
           }
-          while (context && context.prev && !context.startOfLine)
+        }
+      } else if (tagAfter) { // Opening tag spotted
+        while (context) {
+          var grabbers = config.contextGrabbers[lower(context.tagName)];
+          if (grabbers && grabbers.hasOwnProperty(lower(tagAfter[2])))
             context = context.prev;
-          if (context)
-            return context.indent + indentUnit;
           else
-            return state2.baseIndent || 0;
-        },
-        electricInput: /<\/[\s\w:]+>$/,
-        blockCommentStart: "<!--",
-        blockCommentEnd: "-->",
-        configuration: config.htmlMode ? "html" : "xml",
-        helperType: config.htmlMode ? "html" : "xml",
-        skipAttribute: function(state2) {
-          if (state2.state == attrValueState)
-            state2.state = attrState;
-        },
-        xmlCurrentTag: function(state2) {
-          return state2.tagName ? { name: state2.tagName, close: state2.type == "closeTag" } : null;
-        },
-        xmlCurrentContext: function(state2) {
-          var context = [];
-          for (var cx = state2.context; cx; cx = cx.prev)
-            context.push(cx.tagName);
-          return context.reverse();
+            break;
         }
-      };
+      }
+      while (context && context.prev && !context.startOfLine)
+        context = context.prev;
+      if (context) return context.indent + indentUnit;
+      else return state.baseIndent || 0;
+    },
+
+    electricInput: /<\/[\s\w:]+>$/,
+    blockCommentStart: "<!--",
+    blockCommentEnd: "-->",
+
+    configuration: config.htmlMode ? "html" : "xml",
+    helperType: config.htmlMode ? "html" : "xml",
+
+    skipAttribute: function(state) {
+      if (state.state == attrValueState)
+        state.state = attrState;
+    },
+
+    xmlCurrentTag: function(state) {
+      return state.tagName ? {name: state.tagName, close: state.type == "closeTag"} : null
+    },
+
+    xmlCurrentContext: function(state) {
+      var context = [];
+      for (var cx = state.context; cx; cx = cx.prev)
+        context.push(cx.tagName);
+      return context.reverse()
+    }
+  };
+});
+
+CodeMirror.defineMIME("text/xml", "xml");
+CodeMirror.defineMIME("application/xml", "xml");
+if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
+  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});
+
+});
+}());
+
+(function (module, exports) {
+// CodeMirror, copyright (c) by Marijn Haverbeke and others
+// Distributed under an MIT license: https://codemirror.net/LICENSE
+
+(function(mod) {
+  mod(codemirror$1.exports, xml.exports, javascript.exports, css.exports);
+})(function(CodeMirror) {
+
+  var defaultTags = {
+    script: [
+      ["lang", /(javascript|babel)/i, "javascript"],
+      ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
+      ["type", /./, "text/plain"],
+      [null, null, "javascript"]
+    ],
+    style:  [
+      ["lang", /^css$/i, "css"],
+      ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
+      ["type", /./, "text/plain"],
+      [null, null, "css"]
+    ]
+  };
+
+  function maybeBackup(stream, pat, style) {
+    var cur = stream.current(), close = cur.search(pat);
+    if (close > -1) {
+      stream.backUp(cur.length - close);
+    } else if (cur.match(/<\/?$/)) {
+      stream.backUp(cur.length);
+      if (!stream.match(pat, false)) stream.match(cur);
+    }
+    return style;
+  }
+
+  var attrRegexpCache = {};
+  function getAttrRegexp(attr) {
+    var regexp = attrRegexpCache[attr];
+    if (regexp) return regexp;
+    return attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
+  }
+
+  function getAttrValue(text, attr) {
+    var match = text.match(getAttrRegexp(attr));
+    return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : ""
+  }
+
+  function getTagRegexp(tagName, anchored) {
+    return new RegExp((anchored ? "^" : "") + "<\/\\s*" + tagName + "\\s*>", "i");
+  }
+
+  function addTags(from, to) {
+    for (var tag in from) {
+      var dest = to[tag] || (to[tag] = []);
+      var source = from[tag];
+      for (var i = source.length - 1; i >= 0; i--)
+        dest.unshift(source[i]);
+    }
+  }
+
+  function findMatchingMode(tagInfo, tagText) {
+    for (var i = 0; i < tagInfo.length; i++) {
+      var spec = tagInfo[i];
+      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
+    }
+  }
+
+  CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
+    var htmlMode = CodeMirror.getMode(config, {
+      name: "xml",
+      htmlMode: true,
+      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
+      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag,
+      allowMissingTagName: parserConfig.allowMissingTagName,
     });
-    CodeMirror2.defineMIME("text/xml", "xml");
-    CodeMirror2.defineMIME("application/xml", "xml");
-    if (!CodeMirror2.mimeModes.hasOwnProperty("text/html"))
-      CodeMirror2.defineMIME("text/html", { name: "xml", htmlMode: true });
-  });
-})();
-(function(module, exports) {
-  (function(mod) {
-    mod(codemirror$1.exports, xml.exports, javascript.exports, css.exports);
-  })(function(CodeMirror2) {
-    var defaultTags = {
-      script: [
-        ["lang", /(javascript|babel)/i, "javascript"],
-        ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
-        ["type", /./, "text/plain"],
-        [null, null, "javascript"]
-      ],
-      style: [
-        ["lang", /^css$/i, "css"],
-        ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
-        ["type", /./, "text/plain"],
-        [null, null, "css"]
-      ]
-    };
-    function maybeBackup(stream, pat, style) {
-      var cur = stream.current(), close = cur.search(pat);
-      if (close > -1) {
-        stream.backUp(cur.length - close);
-      } else if (cur.match(/<\/?$/)) {
-        stream.backUp(cur.length);
-        if (!stream.match(pat, false))
-          stream.match(cur);
+
+    var tags = {};
+    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
+    addTags(defaultTags, tags);
+    if (configTags) addTags(configTags, tags);
+    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)
+      tags.script.unshift(["type", configScript[i].matches, configScript[i].mode]);
+
+    function html(stream, state) {
+      var style = htmlMode.token(stream, state.htmlState), tag = /\btag\b/.test(style), tagName;
+      if (tag && !/[<>\s\/]/.test(stream.current()) &&
+          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&
+          tags.hasOwnProperty(tagName)) {
+        state.inTag = tagName + " ";
+      } else if (state.inTag && tag && />$/.test(stream.current())) {
+        var inTag = /^([\S]+) (.*)/.exec(state.inTag);
+        state.inTag = null;
+        var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2]);
+        var mode = CodeMirror.getMode(config, modeSpec);
+        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
+        state.token = function (stream, state) {
+          if (stream.match(endTagA, false)) {
+            state.token = html;
+            state.localState = state.localMode = null;
+            return null;
+          }
+          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
+        };
+        state.localMode = mode;
+        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, "", ""));
+      } else if (state.inTag) {
+        state.inTag += stream.current();
+        if (stream.eol()) state.inTag += " ";
       }
       return style;
     }
-    var attrRegexpCache = {};
-    function getAttrRegexp(attr) {
-      var regexp = attrRegexpCache[attr];
-      if (regexp)
-        return regexp;
-      return attrRegexpCache[attr] = new RegExp("\\s+" + attr + `\\s*=\\s*('|")?([^'"]+)('|")?\\s*`);
-    }
-    function getAttrValue(text, attr) {
-      var match2 = text.match(getAttrRegexp(attr));
-      return match2 ? /^\s*(.*?)\s*$/.exec(match2[2])[1] : "";
-    }
-    function getTagRegexp(tagName, anchored) {
-      return new RegExp((anchored ? "^" : "") + "</s*" + tagName + "s*>", "i");
-    }
-    function addTags(from, to) {
-      for (var tag in from) {
-        var dest = to[tag] || (to[tag] = []);
-        var source = from[tag];
-        for (var i = source.length - 1; i >= 0; i--)
-          dest.unshift(source[i]);
-      }
-    }
-    function findMatchingMode(tagInfo, tagText) {
-      for (var i = 0; i < tagInfo.length; i++) {
-        var spec = tagInfo[i];
-        if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0])))
-          return spec[2];
-      }
-    }
-    CodeMirror2.defineMode("htmlmixed", function(config, parserConfig) {
-      var htmlMode = CodeMirror2.getMode(config, {
-        name: "xml",
-        htmlMode: true,
-        multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
-        multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag,
-        allowMissingTagName: parserConfig.allowMissingTagName
-      });
-      var tags = {};
-      var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
-      addTags(defaultTags, tags);
-      if (configTags)
-        addTags(configTags, tags);
-      if (configScript)
-        for (var i = configScript.length - 1; i >= 0; i--)
-          tags.script.unshift(["type", configScript[i].matches, configScript[i].mode]);
-      function html(stream, state2) {
-        var style = htmlMode.token(stream, state2.htmlState), tag = /\btag\b/.test(style), tagName;
-        if (tag && !/[<>\s\/]/.test(stream.current()) && (tagName = state2.htmlState.tagName && state2.htmlState.tagName.toLowerCase()) && tags.hasOwnProperty(tagName)) {
-          state2.inTag = tagName + " ";
-        } else if (state2.inTag && tag && />$/.test(stream.current())) {
-          var inTag = /^([\S]+) (.*)/.exec(state2.inTag);
-          state2.inTag = null;
-          var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2]);
-          var mode = CodeMirror2.getMode(config, modeSpec);
-          var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
-          state2.token = function(stream2, state3) {
-            if (stream2.match(endTagA, false)) {
-              state3.token = html;
-              state3.localState = state3.localMode = null;
-              return null;
-            }
-            return maybeBackup(stream2, endTag, state3.localMode.token(stream2, state3.localState));
-          };
-          state2.localMode = mode;
-          state2.localState = CodeMirror2.startState(mode, htmlMode.indent(state2.htmlState, "", ""));
-        } else if (state2.inTag) {
-          state2.inTag += stream.current();
-          if (stream.eol())
-            state2.inTag += " ";
-        }
-        return style;
-      }
-      return {
-        startState: function() {
-          var state2 = CodeMirror2.startState(htmlMode);
-          return { token: html, inTag: null, localMode: null, localState: null, htmlState: state2 };
-        },
-        copyState: function(state2) {
-          var local;
-          if (state2.localState) {
-            local = CodeMirror2.copyState(state2.localMode, state2.localState);
-          }
-          return {
-            token: state2.token,
-            inTag: state2.inTag,
-            localMode: state2.localMode,
-            localState: local,
-            htmlState: CodeMirror2.copyState(htmlMode, state2.htmlState)
-          };
-        },
-        token: function(stream, state2) {
-          return state2.token(stream, state2);
-        },
-        indent: function(state2, textAfter, line) {
-          if (!state2.localMode || /^\s*<\//.test(textAfter))
-            return htmlMode.indent(state2.htmlState, textAfter, line);
-          else if (state2.localMode.indent)
-            return state2.localMode.indent(state2.localState, textAfter, line);
-          else
-            return CodeMirror2.Pass;
-        },
-        innerMode: function(state2) {
-          return { state: state2.localState || state2.htmlState, mode: state2.localMode || htmlMode };
-        }
-      };
-    }, "xml", "javascript", "css");
-    CodeMirror2.defineMIME("text/html", "htmlmixed");
+    return {
+      startState: function () {
+        var state = CodeMirror.startState(htmlMode);
+        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};
+      },
+
+      copyState: function (state) {
+        var local;
+        if (state.localState) {
+          local = CodeMirror.copyState(state.localMode, state.localState);
+        }
+        return {token: state.token, inTag: state.inTag,
+                localMode: state.localMode, localState: local,
+                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
+      },
+
+      token: function (stream, state) {
+        return state.token(stream, state);
+      },
+
+      indent: function (state, textAfter, line) {
+        if (!state.localMode || /^\s*<\//.test(textAfter))
+          return htmlMode.indent(state.htmlState, textAfter, line);
+        else if (state.localMode.indent)
+          return state.localMode.indent(state.localState, textAfter, line);
+        else
+          return CodeMirror.Pass;
+      },
+
+      innerMode: function (state) {
+        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
+      }
+    };
+  }, "xml", "javascript", "css");
+
+  CodeMirror.defineMIME("text/html", "htmlmixed");
+});
+}());
+
+(function (module, exports) {
+// CodeMirror, copyright (c) by Marijn Haverbeke and others
+// Distributed under an MIT license: https://codemirror.net/LICENSE
+
+(function(mod) {
+  mod(codemirror$1.exports);
+})(function(CodeMirror) {
+  var defaults = {
+    pairs: "()[]{}''\"\"",
+    closeBefore: ")]}'\":;>",
+    triples: "",
+    explode: "[]{}"
+  };
+
+  var Pos = CodeMirror.Pos;
+
+  CodeMirror.defineOption("autoCloseBrackets", false, function(cm, val, old) {
+    if (old && old != CodeMirror.Init) {
+      cm.removeKeyMap(keyMap);
+      cm.state.closeBrackets = null;
+    }
+    if (val) {
+      ensureBound(getOption(val, "pairs"));
+      cm.state.closeBrackets = val;
+      cm.addKeyMap(keyMap);
+    }
   });
-})();
-(function(module, exports) {
-  (function(mod) {
-    mod(codemirror$1.exports);
-  })(function(CodeMirror2) {
-    var defaults = {
-      pairs: `()[]{}''""`,
-      closeBefore: `)]}'":;>`,
-      triples: "",
-      explode: "[]{}"
-    };
-    var Pos = CodeMirror2.Pos;
-    CodeMirror2.defineOption("autoCloseBrackets", false, function(cm, val, old) {
-      if (old && old != CodeMirror2.Init) {
-        cm.removeKeyMap(keyMap);
-        cm.state.closeBrackets = null;
-      }
-      if (val) {
-        ensureBound(getOption(val, "pairs"));
-        cm.state.closeBrackets = val;
-        cm.addKeyMap(keyMap);
-      }
-    });
-    function getOption(conf, name) {
-      if (name == "pairs" && typeof conf == "string")
-        return conf;
-      if (typeof conf == "object" && conf[name] != null)
-        return conf[name];
-      return defaults[name];
-    }
-    var keyMap = { Backspace: handleBackspace, Enter: handleEnter };
-    function ensureBound(chars) {
-      for (var i = 0; i < chars.length; i++) {
-        var ch = chars.charAt(i), key = "'" + ch + "'";
-        if (!keyMap[key])
-          keyMap[key] = handler(ch);
-      }
-    }
-    ensureBound(defaults.pairs + "`");
-    function handler(ch) {
-      return function(cm) {
-        return handleChar(cm, ch);
-      };
+
+  function getOption(conf, name) {
+    if (name == "pairs" && typeof conf == "string") return conf;
+    if (typeof conf == "object" && conf[name] != null) return conf[name];
+    return defaults[name];
+  }
+
+  var keyMap = {Backspace: handleBackspace, Enter: handleEnter};
+  function ensureBound(chars) {
+    for (var i = 0; i < chars.length; i++) {
+      var ch = chars.charAt(i), key = "'" + ch + "'";
+      if (!keyMap[key]) keyMap[key] = handler(ch);
     }
-    function getConfig(cm) {
-      var deflt = cm.state.closeBrackets;
-      if (!deflt || deflt.override)
-        return deflt;
-      var mode = cm.getModeAt(cm.getCursor());
-      return mode.closeBrackets || deflt;
-    }
-    function handleBackspace(cm) {
-      var conf = getConfig(cm);
-      if (!conf || cm.getOption("disableInput"))
-        return CodeMirror2.Pass;
-      var pairs = getOption(conf, "pairs");
-      var ranges = cm.listSelections();
-      for (var i = 0; i < ranges.length; i++) {
-        if (!ranges[i].empty())
-          return CodeMirror2.Pass;
-        var around = charsAround(cm, ranges[i].head);
-        if (!around || pairs.indexOf(around) % 2 != 0)
-          return CodeMirror2.Pass;
-      }
-      for (var i = ranges.length - 1; i >= 0; i--) {
-        var cur = ranges[i].head;
-        cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
-      }
-    }
-    function handleEnter(cm) {
-      var conf = getConfig(cm);
-      var explode = conf && getOption(conf, "explode");
-      if (!explode || cm.getOption("disableInput"))
-        return CodeMirror2.Pass;
-      var ranges = cm.listSelections();
-      for (var i = 0; i < ranges.length; i++) {
-        if (!ranges[i].empty())
-          return CodeMirror2.Pass;
-        var around = charsAround(cm, ranges[i].head);
-        if (!around || explode.indexOf(around) % 2 != 0)
-          return CodeMirror2.Pass;
-      }
-      cm.operation(function() {
-        var linesep = cm.lineSeparator() || "\n";
-        cm.replaceSelection(linesep + linesep, null);
-        moveSel(cm, -1);
-        ranges = cm.listSelections();
-        for (var i2 = 0; i2 < ranges.length; i2++) {
-          var line = ranges[i2].head.line;
-          cm.indentLine(line, null, true);
-          cm.indentLine(line + 1, null, true);
-        }
-      });
+  }
+  ensureBound(defaults.pairs + "`");
+
+  function handler(ch) {
+    return function(cm) { return handleChar(cm, ch); };
+  }
+
+  function getConfig(cm) {
+    var deflt = cm.state.closeBrackets;
+    if (!deflt || deflt.override) return deflt;
+    var mode = cm.getModeAt(cm.getCursor());
+    return mode.closeBrackets || deflt;
+  }
+
+  function handleBackspace(cm) {
+    var conf = getConfig(cm);
+    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;
+
+    var pairs = getOption(conf, "pairs");
+    var ranges = cm.listSelections();
+    for (var i = 0; i < ranges.length; i++) {
+      if (!ranges[i].empty()) return CodeMirror.Pass;
+      var around = charsAround(cm, ranges[i].head);
+      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;
+    }
+    for (var i = ranges.length - 1; i >= 0; i--) {
+      var cur = ranges[i].head;
+      cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
     }
-    function moveSel(cm, dir) {
-      var newRanges = [], ranges = cm.listSelections(), primary = 0;
+  }
+
+  function handleEnter(cm) {
+    var conf = getConfig(cm);
+    var explode = conf && getOption(conf, "explode");
+    if (!explode || cm.getOption("disableInput")) return CodeMirror.Pass;
+
+    var ranges = cm.listSelections();
+    for (var i = 0; i < ranges.length; i++) {
+      if (!ranges[i].empty()) return CodeMirror.Pass;
+      var around = charsAround(cm, ranges[i].head);
+      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;
+    }
+    cm.operation(function() {
+      var linesep = cm.lineSeparator() || "\n";
+      cm.replaceSelection(linesep + linesep, null);
+      moveSel(cm, -1);
+      ranges = cm.listSelections();
       for (var i = 0; i < ranges.length; i++) {
-        var range = ranges[i];
-        if (range.head == cm.getCursor())
-          primary = i;
-        var pos = range.head.ch || dir > 0 ? { line: range.head.line, ch: range.head.ch + dir } : { line: range.head.line - 1 };
-        newRanges.push({ anchor: pos, head: pos });
+        var line = ranges[i].head.line;
+        cm.indentLine(line, null, true);
+        cm.indentLine(line + 1, null, true);
       }
-      cm.setSelections(newRanges, primary);
-    }
-    function contractSelection(sel) {
-      var inverted = CodeMirror2.cmpPos(sel.anchor, sel.head) > 0;
-      return {
-        anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
-        head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))
-      };
+    });
+  }
+
+  function moveSel(cm, dir) {
+    var newRanges = [], ranges = cm.listSelections(), primary = 0;
+    for (var i = 0; i < ranges.length; i++) {
+      var range = ranges[i];
+      if (range.head == cm.getCursor()) primary = i;
+      var pos = range.head.ch || dir > 0 ? {line: range.head.line, ch: range.head.ch + dir} : {line: range.head.line - 1};
+      newRanges.push({anchor: pos, head: pos});
     }
-    function handleChar(cm, ch) {
-      var conf = getConfig(cm);
-      if (!conf || cm.getOption("disableInput"))
-        return CodeMirror2.Pass;
-      var pairs = getOption(conf, "pairs");
-      var pos = pairs.indexOf(ch);
-      if (pos == -1)
-        return CodeMirror2.Pass;
-      var closeBefore = getOption(conf, "closeBefore");
-      var triples = getOption(conf, "triples");
-      var identical = pairs.charAt(pos + 1) == ch;
-      var ranges = cm.listSelections();
-      var opening = pos % 2 == 0;
-      var type;
-      for (var i = 0; i < ranges.length; i++) {
-        var range = ranges[i], cur = range.head, curType;
-        var next2 = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
-        if (opening && !range.empty()) {
-          curType = "surround";
-        } else if ((identical || !opening) && next2 == ch) {
-          if (identical && stringStartsAfter(cm, cur))
-            curType = "both";
-          else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)
-            curType = "skipThree";
-          else
-            curType = "skip";
-        } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 && cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {
-          if (cur.ch > 2 && /\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2))))
-            return CodeMirror2.Pass;
-          curType = "addFour";
-        } else if (identical) {
-          var prev = cur.ch == 0 ? " " : cm.getRange(Pos(cur.line, cur.ch - 1), cur);
-          if (!CodeMirror2.isWordChar(next2) && prev != ch && !CodeMirror2.isWordChar(prev))
-            curType = "both";
-          else
-            return CodeMirror2.Pass;
-        } else if (opening && (next2.length === 0 || /\s/.test(next2) || closeBefore.indexOf(next2) > -1)) {
+    cm.setSelections(newRanges, primary);
+  }
+
+  function contractSelection(sel) {
+    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;
+    return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
+            head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};
+  }
+
+  function handleChar(cm, ch) {
+    var conf = getConfig(cm);
+    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;
+
+    var pairs = getOption(conf, "pairs");
+    var pos = pairs.indexOf(ch);
+    if (pos == -1) return CodeMirror.Pass;
+
+    var closeBefore = getOption(conf,"closeBefore");
+
+    var triples = getOption(conf, "triples");
+
+    var identical = pairs.charAt(pos + 1) == ch;
+    var ranges = cm.listSelections();
+    var opening = pos % 2 == 0;
+
+    var type;
+    for (var i = 0; i < ranges.length; i++) {
+      var range = ranges[i], cur = range.head, curType;
+      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
+      if (opening && !range.empty()) {
+        curType = "surround";
+      } else if ((identical || !opening) && next == ch) {
+        if (identical && stringStartsAfter(cm, cur))
           curType = "both";
-        } else {
-          return CodeMirror2.Pass;
-        }
-        if (!type)
-          type = curType;
-        else if (type != curType)
-          return CodeMirror2.Pass;
-      }
-      var left = pos % 2 ? pairs.charAt(pos - 1) : ch;
-      var right = pos % 2 ? ch : pairs.charAt(pos + 1);
-      cm.operation(function() {
-        if (type == "skip") {
-          moveSel(cm, 1);
-        } else if (type == "skipThree") {
-          moveSel(cm, 3);
-        } else if (type == "surround") {
-          var sels = cm.getSelections();
-          for (var i2 = 0; i2 < sels.length; i2++)
-            sels[i2] = left + sels[i2] + right;
-          cm.replaceSelections(sels, "around");
-          sels = cm.listSelections().slice();
-          for (var i2 = 0; i2 < sels.length; i2++)
-            sels[i2] = contractSelection(sels[i2]);
-          cm.setSelections(sels);
-        } else if (type == "both") {
-          cm.replaceSelection(left + right, null);
-          cm.triggerElectric(left + right);
-          moveSel(cm, -1);
-        } else if (type == "addFour") {
-          cm.replaceSelection(left + left + left + left, "before");
-          moveSel(cm, 1);
-        }
-      });
-    }
-    function charsAround(cm, pos) {
-      var str = cm.getRange(Pos(pos.line, pos.ch - 1), Pos(pos.line, pos.ch + 1));
-      return str.length == 2 ? str : null;
+        else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)
+          curType = "skipThree";
+        else
+          curType = "skip";
+      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&
+                 cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {
+        if (cur.ch > 2 && /\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2)))) return CodeMirror.Pass;
+        curType = "addFour";
+      } else if (identical) {
+        var prev = cur.ch == 0 ? " " : cm.getRange(Pos(cur.line, cur.ch - 1), cur);
+        if (!CodeMirror.isWordChar(next) && prev != ch && !CodeMirror.isWordChar(prev)) curType = "both";
+        else return CodeMirror.Pass;
+      } else if (opening && (next.length === 0 || /\s/.test(next) || closeBefore.indexOf(next) > -1)) {
+        curType = "both";
+      } else {
+        return CodeMirror.Pass;
+      }
+      if (!type) type = curType;
+      else if (type != curType) return CodeMirror.Pass;
     }
-    function stringStartsAfter(cm, pos) {
-      var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1));
-      return /\bstring/.test(token.type) && token.start == pos.ch && (pos.ch == 0 || !/\bstring/.test(cm.getTokenTypeAt(pos)));
+
+    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;
+    var right = pos % 2 ? ch : pairs.charAt(pos + 1);
+    cm.operation(function() {
+      if (type == "skip") {
+        moveSel(cm, 1);
+      } else if (type == "skipThree") {
+        moveSel(cm, 3);
+      } else if (type == "surround") {
+        var sels = cm.getSelections();
+        for (var i = 0; i < sels.length; i++)
+          sels[i] = left + sels[i] + right;
+        cm.replaceSelections(sels, "around");
+        sels = cm.listSelections().slice();
+        for (var i = 0; i < sels.length; i++)
+          sels[i] = contractSelection(sels[i]);
+        cm.setSelections(sels);
+      } else if (type == "both") {
+        cm.replaceSelection(left + right, null);
+        cm.triggerElectric(left + right);
+        moveSel(cm, -1);
+      } else if (type == "addFour") {
+        cm.replaceSelection(left + left + left + left, "before");
+        moveSel(cm, 1);
+      }
+    });
+  }
+
+  function charsAround(cm, pos) {
+    var str = cm.getRange(Pos(pos.line, pos.ch - 1),
+                          Pos(pos.line, pos.ch + 1));
+    return str.length == 2 ? str : null;
+  }
+
+  function stringStartsAfter(cm, pos) {
+    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1));
+    return /\bstring/.test(token.type) && token.start == pos.ch &&
+      (pos.ch == 0 || !/\bstring/.test(cm.getTokenTypeAt(pos)))
+  }
+});
+}());
+
+var xmlFold = {exports: {}};
+
+(function (module, exports) {
+// CodeMirror, copyright (c) by Marijn Haverbeke and others
+// Distributed under an MIT license: https://codemirror.net/LICENSE
+
+(function(mod) {
+  mod(codemirror$1.exports);
+})(function(CodeMirror) {
+
+  var Pos = CodeMirror.Pos;
+  function cmp(a, b) { return a.line - b.line || a.ch - b.ch; }
+
+  var nameStartChar = "A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
+  var nameChar = nameStartChar + "\-\:\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
+  var xmlTagStart = new RegExp("<(/?)([" + nameStartChar + "][" + nameChar + "]*)", "g");
+
+  function Iter(cm, line, ch, range) {
+    this.line = line; this.ch = ch;
+    this.cm = cm; this.text = cm.getLine(line);
+    this.min = range ? Math.max(range.from, cm.firstLine()) : cm.firstLine();
+    this.max = range ? Math.min(range.to - 1, cm.lastLine()) : cm.lastLine();
+  }
+
+  function tagAt(iter, ch) {
+    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));
+    return type && /\btag\b/.test(type);
+  }
+
+  function nextLine(iter) {
+    if (iter.line >= iter.max) return;
+    iter.ch = 0;
+    iter.text = iter.cm.getLine(++iter.line);
+    return true;
+  }
+  function prevLine(iter) {
+    if (iter.line <= iter.min) return;
+    iter.text = iter.cm.getLine(--iter.line);
+    iter.ch = iter.text.length;
+    return true;
+  }
+
+  function toTagEnd(iter) {
+    for (;;) {
+      var gt = iter.text.indexOf(">", iter.ch);
+      if (gt == -1) { if (nextLine(iter)) continue; else return; }
+      if (!tagAt(iter, gt + 1)) { iter.ch = gt + 1; continue; }
+      var lastSlash = iter.text.lastIndexOf("/", gt);
+      var selfClose = lastSlash > -1 && !/\S/.test(iter.text.slice(lastSlash + 1, gt));
+      iter.ch = gt + 1;
+      return selfClose ? "selfClose" : "regular";
+    }
+  }
+  function toTagStart(iter) {
+    for (;;) {
+      var lt = iter.ch ? iter.text.lastIndexOf("<", iter.ch - 1) : -1;
+      if (lt == -1) { if (prevLine(iter)) continue; else return; }
+      if (!tagAt(iter, lt + 1)) { iter.ch = lt; continue; }
+      xmlTagStart.lastIndex = lt;
+      iter.ch = lt;
+      var match = xmlTagStart.exec(iter.text);
+      if (match && match.index == lt) return match;
     }
-  });
-})();
-var xmlFold = { exports: {} };
-(function(module, exports) {
-  (function(mod) {
-    mod(codemirror$1.exports);
-  })(function(CodeMirror2) {
-    var Pos = CodeMirror2.Pos;
-    function cmp(a, b) {
-      return a.line - b.line || a.ch - b.ch;
-    }
-    var nameStartChar = "A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
-    var nameChar = nameStartChar + "-:.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
-    var xmlTagStart = new RegExp("<(/?)([" + nameStartChar + "][" + nameChar + "]*)", "g");
-    function Iter(cm, line, ch, range) {
-      this.line = line;
-      this.ch = ch;
-      this.cm = cm;
-      this.text = cm.getLine(line);
-      this.min = range ? Math.max(range.from, cm.firstLine()) : cm.firstLine();
-      this.max = range ? Math.min(range.to - 1, cm.lastLine()) : cm.lastLine();
-    }
-    function tagAt(iter, ch) {
-      var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));
-      return type && /\btag\b/.test(type);
-    }
-    function nextLine(iter) {
-      if (iter.line >= iter.max)
-        return;
-      iter.ch = 0;
-      iter.text = iter.cm.getLine(++iter.line);
-      return true;
+  }
+
+  function toNextTag(iter) {
+    for (;;) {
+      xmlTagStart.lastIndex = iter.ch;
+      var found = xmlTagStart.exec(iter.text);
+      if (!found) { if (nextLine(iter)) continue; else return; }
+      if (!tagAt(iter, found.index + 1)) { iter.ch = found.index + 1; continue; }
+      iter.ch = found.index + found[0].length;
+      return found;
     }
-    function prevLine(iter) {
-      if (iter.line <= iter.min)
-        return;
-      iter.text = iter.cm.getLine(--iter.line);
-      iter.ch = iter.text.length;
-      return true;
+  }
+  function toPrevTag(iter) {
+    for (;;) {
+      var gt = iter.ch ? iter.text.lastIndexOf(">", iter.ch - 1) : -1;
+      if (gt == -1) { if (prevLine(iter)) continue; else return; }
+      if (!tagAt(iter, gt + 1)) { iter.ch = gt; continue; }
+      var lastSlash = iter.text.lastIndexOf("/", gt);
+      var selfClose = lastSlash > -1 && !/\S/.test(iter.text.slice(lastSlash + 1, gt));
+      iter.ch = gt + 1;
+      return selfClose ? "selfClose" : "regular";
     }
-    function toTagEnd(iter) {
-      for (; ; ) {
-        var gt = iter.text.indexOf(">", iter.ch);
-        if (gt == -1) {
-          if (nextLine(iter))
-            continue;
-          else
-            return;
-        }
-        if (!tagAt(iter, gt + 1)) {
-          iter.ch = gt + 1;
-          continue;
-        }
-        var lastSlash = iter.text.lastIndexOf("/", gt);
-        var selfClose = lastSlash > -1 && !/\S/.test(iter.text.slice(lastSlash + 1, gt));
-        iter.ch = gt + 1;
-        return selfClose ? "selfClose" : "regular";
-      }
-    }
-    function toTagStart(iter) {
-      for (; ; ) {
-        var lt = iter.ch ? iter.text.lastIndexOf("<", iter.ch - 1) : -1;
-        if (lt == -1) {
-          if (prevLine(iter))
-            continue;
-          else
-            return;
-        }
-        if (!tagAt(iter, lt + 1)) {
-          iter.ch = lt;
-          continue;
-        }
-        xmlTagStart.lastIndex = lt;
-        iter.ch = lt;
-        var match2 = xmlTagStart.exec(iter.text);
-        if (match2 && match2.index == lt)
-          return match2;
-      }
-    }
-    function toNextTag(iter) {
-      for (; ; ) {
-        xmlTagStart.lastIndex = iter.ch;
-        var found = xmlTagStart.exec(iter.text);
-        if (!found) {
-          if (nextLine(iter))
-            continue;
-          else
-            return;
+  }
+
+  function findMatchingClose(iter, tag) {
+    var stack = [];
+    for (;;) {
+      var next = toNextTag(iter), end, startLine = iter.line, startCh = iter.ch - (next ? next[0].length : 0);
+      if (!next || !(end = toTagEnd(iter))) return;
+      if (end == "selfClose") continue;
+      if (next[1]) { // closing tag
+        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == next[2]) {
+          stack.length = i;
+          break;
         }
-        if (!tagAt(iter, found.index + 1)) {
-          iter.ch = found.index + 1;
-          continue;
+        if (i < 0 && (!tag || tag == next[2])) return {
+          tag: next[2],
+          from: Pos(startLine, startCh),
+          to: Pos(iter.line, iter.ch)
+        };
+      } else { // opening tag
+        stack.push(next[2]);
+      }
+    }
+  }
+  function findMatchingOpen(iter, tag) {
+    var stack = [];
+    for (;;) {
+      var prev = toPrevTag(iter);
+      if (!prev) return;
+      if (prev == "selfClose") { toTagStart(iter); continue; }
+      var endLine = iter.line, endCh = iter.ch;
+      var start = toTagStart(iter);
+      if (!start) return;
+      if (start[1]) { // closing tag
+        stack.push(start[2]);
+      } else { // opening tag
+        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == start[2]) {
+          stack.length = i;
+          break;
         }
-        iter.ch = found.index + found[0].length;
-        return found;
+        if (i < 0 && (!tag || tag == start[2])) return {
+          tag: start[2],
+          from: Pos(iter.line, iter.ch),
+          to: Pos(endLine, endCh)
+        };
       }
     }
-    function toPrevTag(iter) {
-      for (; ; ) {
-        var gt = iter.ch ? iter.text.lastIndexOf(">", iter.ch - 1) : -1;
-        if (gt == -1) {
-          if (prevLine(iter))
-            continue;
-          else
-            return;
-        }
-        if (!tagAt(iter, gt + 1)) {
-          iter.ch = gt;
-          continue;
-        }
-        var lastSlash = iter.text.lastIndexOf("/", gt);
-        var selfClose = lastSlash > -1 && !/\S/.test(iter.text.slice(lastSlash + 1, gt));
-        iter.ch = gt + 1;
-        return selfClose ? "selfClose" : "regular";
+  }
+
+  CodeMirror.registerHelper("fold", "xml", function(cm, start) {
+    var iter = new Iter(cm, start.line, 0);
+    for (;;) {
+      var openTag = toNextTag(iter);
+      if (!openTag || iter.line != start.line) return
+      var end = toTagEnd(iter);
+      if (!end) return
+      if (!openTag[1] && end != "selfClose") {
+        var startPos = Pos(iter.line, iter.ch);
+        var endPos = findMatchingClose(iter, openTag[2]);
+        return endPos && cmp(endPos.from, startPos) > 0 ? {from: startPos, to: endPos.from} : null
       }
     }
-    function findMatchingClose(iter, tag) {
-      var stack = [];
-      for (; ; ) {
-        var next2 = toNextTag(iter), end, startLine = iter.line, startCh = iter.ch - (next2 ? next2[0].length : 0);
-        if (!next2 || !(end = toTagEnd(iter)))
-          return;
-        if (end == "selfClose")
-          continue;
-        if (next2[1]) {
-          for (var i = stack.length - 1; i >= 0; --i)
-            if (stack[i] == next2[2]) {
-              stack.length = i;
-              break;
-            }
-          if (i < 0 && (!tag || tag == next2[2]))
-            return {
-              tag: next2[2],
-              from: Pos(startLine, startCh),
-              to: Pos(iter.line, iter.ch)
-            };
-        } else {
-          stack.push(next2[2]);
-        }
-      }
+  });
+  CodeMirror.findMatchingTag = function(cm, pos, range) {
+    var iter = new Iter(cm, pos.line, pos.ch, range);
+    if (iter.text.indexOf(">") == -1 && iter.text.indexOf("<") == -1) return;
+    var end = toTagEnd(iter), to = end && Pos(iter.line, iter.ch);
+    var start = end && toTagStart(iter);
+    if (!end || !start || cmp(iter, pos) > 0) return;
+    var here = {from: Pos(iter.line, iter.ch), to: to, tag: start[2]};
+    if (end == "selfClose") return {open: here, close: null, at: "open"};
+
+    if (start[1]) { // closing tag
+      return {open: findMatchingOpen(iter, start[2]), close: here, at: "close"};
+    } else { // opening tag
+      iter = new Iter(cm, to.line, to.ch, range);
+      return {open: here, close: findMatchingClose(iter, start[2]), at: "open"};
     }
-    function findMatchingOpen(iter, tag) {
-      var stack = [];
-      for (; ; ) {
-        var prev = toPrevTag(iter);
-        if (!prev)
-          return;
-        if (prev == "selfClose") {
-          toTagStart(iter);
-          continue;
-        }
-        var endLine = iter.line, endCh = iter.ch;
-        var start = toTagStart(iter);
-        if (!start)
-          return;
-        if (start[1]) {
-          stack.push(start[2]);
-        } else {
-          for (var i = stack.length - 1; i >= 0; --i)
-            if (stack[i] == start[2]) {
-              stack.length = i;
-              break;
-            }
-          if (i < 0 && (!tag || tag == start[2]))
-            return {
-              tag: start[2],
-              from: Pos(iter.line, iter.ch),
-              to: Pos(endLine, endCh)
-            };
-        }
-      }
+  };
+
+  CodeMirror.findEnclosingTag = function(cm, pos, range, tag) {
+    var iter = new Iter(cm, pos.line, pos.ch, range);
+    for (;;) {
+      var open = findMatchingOpen(iter, tag);
+      if (!open) break;
+      var forward = new Iter(cm, pos.line, pos.ch, range);
+      var close = findMatchingClose(forward, open.tag);
+      if (close) return {open: open, close: close};
     }
-    CodeMirror2.registerHelper("fold", "xml", function(cm, start) {
-      var iter = new Iter(cm, start.line, 0);
-      for (; ; ) {
-        var openTag = toNextTag(iter);
-        if (!openTag || iter.line != start.line)
-          return;
-        var end = toTagEnd(iter);
-        if (!end)
-          return;
-        if (!openTag[1] && end != "selfClose") {
-          var startPos = Pos(iter.line, iter.ch);
-          var endPos = findMatchingClose(iter, openTag[2]);
-          return endPos && cmp(endPos.from, startPos) > 0 ? { from: startPos, to: endPos.from } : null;
-        }
-      }
-    });
-    CodeMirror2.findMatchingTag = function(cm, pos, range) {
-      var iter = new Iter(cm, pos.line, pos.ch, range);
-      if (iter.text.indexOf(">") == -1 && iter.text.indexOf("<") == -1)
-        return;
-      var end = toTagEnd(iter), to = end && Pos(iter.line, iter.ch);
-      var start = end && toTagStart(iter);
-      if (!end || !start || cmp(iter, pos) > 0)
-        return;
-      var here = { from: Pos(iter.line, iter.ch), to, tag: start[2] };
-      if (end == "selfClose")
-        return { open: here, close: null, at: "open" };
-      if (start[1]) {
-        return { open: findMatchingOpen(iter, start[2]), close: here, at: "close" };
-      } else {
-        iter = new Iter(cm, to.line, to.ch, range);
-        return { open: here, close: findMatchingClose(iter, start[2]), at: "open" };
-      }
-    };
-    CodeMirror2.findEnclosingTag = function(cm, pos, range, tag) {
-      var iter = new Iter(cm, pos.line, pos.ch, range);
-      for (; ; ) {
-        var open = findMatchingOpen(iter, tag);
-        if (!open)
-          break;
-        var forward = new Iter(cm, pos.line, pos.ch, range);
-        var close = findMatchingClose(forward, open.tag);
-        if (close)
-          return { open, close };
-      }
-    };
-    CodeMirror2.scanForClosingTag = function(cm, pos, name, end) {
-      var iter = new Iter(cm, pos.line, pos.ch, end ? { from: 0, to: end } : null);
-      return findMatchingClose(iter, name);
-    };
+  };
+
+  // Used by addon/edit/closetag.js
+  CodeMirror.scanForClosingTag = function(cm, pos, name, end) {
+    var iter = new Iter(cm, pos.line, pos.ch, end ? {from: 0, to: end} : null);
+    return findMatchingClose(iter, name);
+  };
+});
+}());
+
+(function (module, exports) {
+// CodeMirror, copyright (c) by Marijn Haverbeke and others
+// Distributed under an MIT license: https://codemirror.net/LICENSE
+
+/**
+ * Tag-closer extension for CodeMirror.
+ *
+ * This extension adds an "autoCloseTags" option that can be set to
+ * either true to get the default behavior, or an object to further
+ * configure its behavior.
+ *
+ * These are supported options:
+ *
+ * `whenClosing` (default true)
+ *   Whether to autoclose when the '/' of a closing tag is typed.
+ * `whenOpening` (default true)
+ *   Whether to autoclose the tag when the final '>' of an opening
+ *   tag is typed.
+ * `dontCloseTags` (default is empty tags for HTML, none for XML)
+ *   An array of tag names that should not be autoclosed.
+ * `indentTags` (default is block tags for HTML, none for XML)
+ *   An array of tag names that should, when opened, cause a
+ *   blank line to be added inside the tag, and the blank line and
+ *   closing line to be indented.
+ * `emptyTags` (default is none)
+ *   An array of XML tag names that should be autoclosed with '/>'.
+ *
+ * See demos/closetag.html for a usage example.
+ */
+
+(function(mod) {
+  mod(codemirror$1.exports, xmlFold.exports);
+})(function(CodeMirror) {
+  CodeMirror.defineOption("autoCloseTags", false, function(cm, val, old) {
+    if (old != CodeMirror.Init && old)
+      cm.removeKeyMap("autoCloseTags");
+    if (!val) return;
+    var map = {name: "autoCloseTags"};
+    if (typeof val != "object" || val.whenClosing !== false)
+      map["'/'"] = function(cm) { return autoCloseSlash(cm); };
+    if (typeof val != "object" || val.whenOpening !== false)
+      map["'>'"] = function(cm) { return autoCloseGT(cm); };
+    cm.addKeyMap(map);
   });
-})();
-(function(module, exports) {
-  (function(mod) {
-    mod(codemirror$1.exports, xmlFold.exports);
-  })(function(CodeMirror2) {
-    CodeMirror2.defineOption("autoCloseTags", false, function(cm, val, old) {
-      if (old != CodeMirror2.Init && old)
-        cm.removeKeyMap("autoCloseTags");
-      if (!val)
-        return;
-      var map = { name: "autoCloseTags" };
-      if (typeof val != "object" || val.whenClosing !== false)
-        map["'/'"] = function(cm2) {
-          return autoCloseSlash(cm2);
-        };
-      if (typeof val != "object" || val.whenOpening !== false)
-        map["'>'"] = function(cm2) {
-          return autoCloseGT(cm2);
-        };
-      cm.addKeyMap(map);
-    });
-    var htmlDontClose = [
-      "area",
-      "base",
-      "br",
-      "col",
-      "command",
-      "embed",
-      "hr",
-      "img",
-      "input",
-      "keygen",
-      "link",
-      "meta",
-      "param",
-      "source",
-      "track",
-      "wbr"
-    ];
-    var htmlIndent = [
-      "applet",
-      "blockquote",
-      "body",
-      "button",
-      "div",
-      "dl",
-      "fieldset",
-      "form",
-      "frameset",
-      "h1",
-      "h2",
-      "h3",
-      "h4",
-      "h5",
-      "h6",
-      "head",
-      "html",
-      "iframe",
-      "layer",
-      "legend",
-      "object",
-      "ol",
-      "p",
-      "select",
-      "table",
-      "ul"
-    ];
-    function autoCloseGT(cm) {
-      if (cm.getOption("disableInput"))
-        return CodeMirror2.Pass;
-      var ranges = cm.listSelections(), replacements = [];
-      var opt = cm.getOption("autoCloseTags");
-      for (var i = 0; i < ranges.length; i++) {
-        if (!ranges[i].empty())
-          return CodeMirror2.Pass;
-        var pos = ranges[i].head, tok = cm.getTokenAt(pos);
-        var inner = CodeMirror2.innerMode(cm.getMode(), tok.state), state2 = inner.state;
-        var tagInfo = inner.mode.xmlCurrentTag && inner.mode.xmlCurrentTag(state2);
-        var tagName = tagInfo && tagInfo.name;
-        if (!tagName)
-          return CodeMirror2.Pass;
-        var html = inner.mode.configuration == "html";
-        var dontCloseTags = typeof opt == "object" && opt.dontCloseTags || html && htmlDontClose;
-        var indentTags = typeof opt == "object" && opt.indentTags || html && htmlIndent;
-        if (tok.end > pos.ch)
-          tagName = tagName.slice(0, tagName.length - tok.end + pos.ch);
-        var lowerTagName = tagName.toLowerCase();
-        if (!tagName || tok.type == "string" && (tok.end != pos.ch || !/[\"\']/.test(tok.string.charAt(tok.string.length - 1)) || tok.string.length == 1) || tok.type == "tag" && tagInfo.close || tok.string.indexOf("/") == pos.ch - tok.start - 1 || dontCloseTags && indexOf(dontCloseTags, lowerTagName) > -1 || closingTagExists(cm, inner.mode.xmlCurrentContext && inner.mode.xmlCurrentContext(state2) || [], tagName, pos, true))
-          return CodeMirror2.Pass;
-        var emptyTags = typeof opt == "object" && opt.emptyTags;
-        if (emptyTags && indexOf(emptyTags, tagName) > -1) {
-          replacements[i] = { text: "/>", newPos: CodeMirror2.Pos(pos.line, pos.ch + 2) };
-          continue;
-        }
-        var indent = indentTags && indexOf(indentTags, lowerTagName) > -1;
-        replacements[i] = {
-          indent,
-          text: ">" + (indent ? "\n\n" : "") + "</" + tagName + ">",
-          newPos: indent ? CodeMirror2.Pos(pos.line + 1, 0) : CodeMirror2.Pos(pos.line, pos.ch + 1)
-        };
-      }
-      var dontIndentOnAutoClose = typeof opt == "object" && opt.dontIndentOnAutoClose;
-      for (var i = ranges.length - 1; i >= 0; i--) {
-        var info = replacements[i];
-        cm.replaceRange(info.text, ranges[i].head, ranges[i].anchor, "+insert");
-        var sel = cm.listSelections().slice(0);
-        sel[i] = { head: info.newPos, anchor: info.newPos };
-        cm.setSelections(sel);
-        if (!dontIndentOnAutoClose && info.indent) {
-          cm.indentLine(info.newPos.line, null, true);
-          cm.indentLine(info.newPos.line + 1, null, true);
-        }
+
+  var htmlDontClose = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param",
+                       "source", "track", "wbr"];
+  var htmlIndent = ["applet", "blockquote", "body", "button", "div", "dl", "fieldset", "form", "frameset", "h1", "h2", "h3", "h4",
+                    "h5", "h6", "head", "html", "iframe", "layer", "legend", "object", "ol", "p", "select", "table", "ul"];
+
+  function autoCloseGT(cm) {
+    if (cm.getOption("disableInput")) return CodeMirror.Pass;
+    var ranges = cm.listSelections(), replacements = [];
+    var opt = cm.getOption("autoCloseTags");
+    for (var i = 0; i < ranges.length; i++) {
+      if (!ranges[i].empty()) return CodeMirror.Pass;
+      var pos = ranges[i].head, tok = cm.getTokenAt(pos);
+      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;
+      var tagInfo = inner.mode.xmlCurrentTag && inner.mode.xmlCurrentTag(state);
+      var tagName = tagInfo && tagInfo.name;
+      if (!tagName) return CodeMirror.Pass
+
+      var html = inner.mode.configuration == "html";
+      var dontCloseTags = (typeof opt == "object" && opt.dontCloseTags) || (html && htmlDontClose);
+      var indentTags = (typeof opt == "object" && opt.indentTags) || (html && htmlIndent);
+
+      if (tok.end > pos.ch) tagName = tagName.slice(0, tagName.length - tok.end + pos.ch);
+      var lowerTagName = tagName.toLowerCase();
+      // Don't process the '>' at the end of an end-tag or self-closing tag
+      if (!tagName ||
+          tok.type == "string" && (tok.end != pos.ch || !/[\"\']/.test(tok.string.charAt(tok.string.length - 1)) || tok.string.length == 1) ||
+          tok.type == "tag" && tagInfo.close ||
+          tok.string.indexOf("/") == (pos.ch - tok.start - 1) || // match something like <someTagName />
+          dontCloseTags && indexOf(dontCloseTags, lowerTagName) > -1 ||
+          closingTagExists(cm, inner.mode.xmlCurrentContext && inner.mode.xmlCurrentContext(state) || [], tagName, pos, true))
+        return CodeMirror.Pass;
+
+      var emptyTags = typeof opt == "object" && opt.emptyTags;
+      if (emptyTags && indexOf(emptyTags, tagName) > -1) {
+        replacements[i] = { text: "/>", newPos: CodeMirror.Pos(pos.line, pos.ch + 2) };
+        continue;
       }
+
+      var indent = indentTags && indexOf(indentTags, lowerTagName) > -1;
+      replacements[i] = {indent: indent,
+                         text: ">" + (indent ? "\n\n" : "") + "</" + tagName + ">",
+                         newPos: indent ? CodeMirror.Pos(pos.line + 1, 0) : CodeMirror.Pos(pos.line, pos.ch + 1)};
     }
-    function autoCloseCurrent(cm, typingSlash) {
-      var ranges = cm.listSelections(), replacements = [];
-      var head = typingSlash ? "/" : "</";
-      var opt = cm.getOption("autoCloseTags");
-      var dontIndentOnAutoClose = typeof opt == "object" && opt.dontIndentOnSlash;
-      for (var i = 0; i < ranges.length; i++) {
-        if (!ranges[i].empty())
-          return CodeMirror2.Pass;
-        var pos = ranges[i].head, tok = cm.getTokenAt(pos);
-        var inner = CodeMirror2.innerMode(cm.getMode(), tok.state), state2 = inner.state;
-        if (typingSlash && (tok.type == "string" || tok.string.charAt(0) != "<" || tok.start != pos.ch - 1))
-          return CodeMirror2.Pass;
-        var replacement, mixed = inner.mode.name != "xml" && cm.getMode().name == "htmlmixed";
-        if (mixed && inner.mode.name == "javascript") {
-          replacement = head + "script";
-        } else if (mixed && inner.mode.name == "css") {
-          replacement = head + "style";
-        } else {
-          var context = inner.mode.xmlCurrentContext && inner.mode.xmlCurrentContext(state2);
-          var top = context.length ? context[context.length - 1] : "";
-          if (!context || context.length && closingTagExists(cm, context, top, pos))
-            return CodeMirror2.Pass;
-          replacement = head + top;
-        }
-        if (cm.getLine(pos.line).charAt(tok.end) != ">")
-          replacement += ">";
-        replacements[i] = replacement;
+
+    var dontIndentOnAutoClose = (typeof opt == "object" && opt.dontIndentOnAutoClose);
+    for (var i = ranges.length - 1; i >= 0; i--) {
+      var info = replacements[i];
+      cm.replaceRange(info.text, ranges[i].head, ranges[i].anchor, "+insert");
+      var sel = cm.listSelections().slice(0);
+      sel[i] = {head: info.newPos, anchor: info.newPos};
+      cm.setSelections(sel);
+      if (!dontIndentOnAutoClose && info.indent) {
+        cm.indentLine(info.newPos.line, null, true);
+        cm.indentLine(info.newPos.line + 1, null, true);
       }
-      cm.replaceSelections(replacements);
-      ranges = cm.listSelections();
-      if (!dontIndentOnAutoClose) {
+    }
+  }
+
+  function autoCloseCurrent(cm, typingSlash) {
+    var ranges = cm.listSelections(), replacements = [];
+    var head = typingSlash ? "/" : "</";
+    var opt = cm.getOption("autoCloseTags");
+    var dontIndentOnAutoClose = (typeof opt == "object" && opt.dontIndentOnSlash);
+    for (var i = 0; i < ranges.length; i++) {
+      if (!ranges[i].empty()) return CodeMirror.Pass;
+      var pos = ranges[i].head, tok = cm.getTokenAt(pos);
+      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;
+      if (typingSlash && (tok.type == "string" || tok.string.charAt(0) != "<" ||
+                          tok.start != pos.ch - 1))
+        return CodeMirror.Pass;
+      // Kludge to get around the fact that we are not in XML mode
+      // when completing in JS/CSS snippet in htmlmixed mode. Does not
+      // work for other XML embedded languages (there is no general
+      // way to go from a mixed mode to its current XML state).
+      var replacement, mixed = inner.mode.name != "xml" && cm.getMode().name == "htmlmixed";
+      if (mixed && inner.mode.name == "javascript") {
+        replacement = head + "script";
+      } else if (mixed && inner.mode.name == "css") {
+        replacement = head + "style";
+      } else {
+        var context = inner.mode.xmlCurrentContext && inner.mode.xmlCurrentContext(state);
+        var top = context.length ? context[context.length - 1] : "";
+        if (!context || (context.length && closingTagExists(cm, context, top, pos)))
+          return CodeMirror.Pass;
+        replacement = head + top;
+      }
+      if (cm.getLine(pos.line).charAt(tok.end) != ">") replacement += ">";
+      replacements[i] = replacement;
+    }
+    cm.replaceSelections(replacements);
+    ranges = cm.listSelections();
+    if (!dontIndentOnAutoClose) {
         for (var i = 0; i < ranges.length; i++)
-          if (i == ranges.length - 1 || ranges[i].head.line < ranges[i + 1].head.line)
-            cm.indentLine(ranges[i].head.line);
-      }
+            if (i == ranges.length - 1 || ranges[i].head.line < ranges[i + 1].head.line)
+                cm.indentLine(ranges[i].head.line);
     }
-    function autoCloseSlash(cm) {
-      if (cm.getOption("disableInput"))
-        return CodeMirror2.Pass;
-      return autoCloseCurrent(cm, true);
+  }
+
+  function autoCloseSlash(cm) {
+    if (cm.getOption("disableInput")) return CodeMirror.Pass;
+    return autoCloseCurrent(cm, true);
+  }
+
+  CodeMirror.commands.closeTag = function(cm) { return autoCloseCurrent(cm); };
+
+  function indexOf(collection, elt) {
+    if (collection.indexOf) return collection.indexOf(elt);
+    for (var i = 0, e = collection.length; i < e; ++i)
+      if (collection[i] == elt) return i;
+    return -1;
+  }
+
+  // If xml-fold is loaded, we use its functionality to try and verify
+  // whether a given tag is actually unclosed.
+  function closingTagExists(cm, context, tagName, pos, newTag) {
+    if (!CodeMirror.scanForClosingTag) return false;
+    var end = Math.min(cm.lastLine() + 1, pos.line + 500);
+    var nextClose = CodeMirror.scanForClosingTag(cm, pos, null, end);
+    if (!nextClose || nextClose.tag != tagName) return false;
+    // If the immediate wrapping context contains onCx instances of
+    // the same tag, a closing tag only exists if there are at least
+    // that many closing tags of that type following.
+    var onCx = newTag ? 1 : 0;
+    for (var i = context.length - 1; i >= 0; i--) {
+      if (context[i] == tagName) ++onCx;
+      else break
+    }
+    pos = nextClose.to;
+    for (var i = 1; i < onCx; i++) {
+      var next = CodeMirror.scanForClosingTag(cm, pos, null, end);
+      if (!next || next.tag != tagName) return false;
+      pos = next.to;
     }
-    CodeMirror2.commands.closeTag = function(cm) {
-      return autoCloseCurrent(cm);
-    };
-    function indexOf(collection, elt) {
-      if (collection.indexOf)
-        return collection.indexOf(elt);
-      for (var i = 0, e = collection.length; i < e; ++i)
-        if (collection[i] == elt)
-          return i;
-      return -1;
-    }
-    function closingTagExists(cm, context, tagName, pos, newTag) {
-      if (!CodeMirror2.scanForClosingTag)
-        return false;
-      var end = Math.min(cm.lastLine() + 1, pos.line + 500);
-      var nextClose = CodeMirror2.scanForClosingTag(cm, pos, null, end);
-      if (!nextClose || nextClose.tag != tagName)
-        return false;
-      var onCx = newTag ? 1 : 0;
-      for (var i = context.length - 1; i >= 0; i--) {
-        if (context[i] == tagName)
-          ++onCx;
-        else
-          break;
-      }
-      pos = nextClose.to;
-      for (var i = 1; i < onCx; i++) {
-        var next2 = CodeMirror2.scanForClosingTag(cm, pos, null, end);
-        if (!next2 || next2.tag != tagName)
-          return false;
-        pos = next2.to;
+    return true;
+  }
+});
+}());
+
+(function (module, exports) {
+// CodeMirror, copyright (c) by Marijn Haverbeke and others
+// Distributed under an MIT license: https://codemirror.net/LICENSE
+
+(function(mod) {
+  mod(codemirror$1.exports);
+})(function(CodeMirror) {
+
+  var noOptions = {};
+  var nonWS = /[^\s\u00a0]/;
+  var Pos = CodeMirror.Pos, cmp = CodeMirror.cmpPos;
+
+  function firstNonWS(str) {
+    var found = str.search(nonWS);
+    return found == -1 ? 0 : found;
+  }
+
+  CodeMirror.commands.toggleComment = function(cm) {
+    cm.toggleComment();
+  };
+
+  CodeMirror.defineExtension("toggleComment", function(options) {
+    if (!options) options = noOptions;
+    var cm = this;
+    var minLine = Infinity, ranges = this.listSelections(), mode = null;
+    for (var i = ranges.length - 1; i >= 0; i--) {
+      var from = ranges[i].from(), to = ranges[i].to();
+      if (from.line >= minLine) continue;
+      if (to.line >= minLine) to = Pos(minLine, 0);
+      minLine = from.line;
+      if (mode == null) {
+        if (cm.uncomment(from, to, options)) mode = "un";
+        else { cm.lineComment(from, to, options); mode = "line"; }
+      } else if (mode == "un") {
+        cm.uncomment(from, to, options);
+      } else {
+        cm.lineComment(from, to, options);
       }
-      return true;
     }
   });
-})();
-(function(module, exports) {
-  (function(mod) {
-    mod(codemirror$1.exports);
-  })(function(CodeMirror2) {
-    var noOptions = {};
-    var nonWS = /[^\s\u00a0]/;
-    var Pos = CodeMirror2.Pos, cmp = CodeMirror2.cmpPos;
-    function firstNonWS(str) {
-      var found = str.search(nonWS);
-      return found == -1 ? 0 : found;
-    }
-    CodeMirror2.commands.toggleComment = function(cm) {
-      cm.toggleComment();
-    };
-    CodeMirror2.defineExtension("toggleComment", function(options) {
-      if (!options)
-        options = noOptions;
-      var cm = this;
-      var minLine = Infinity, ranges = this.listSelections(), mode = null;
-      for (var i = ranges.length - 1; i >= 0; i--) {
-        var from = ranges[i].from(), to = ranges[i].to();
-        if (from.line >= minLine)
-          continue;
-        if (to.line >= minLine)
-          to = Pos(minLine, 0);
-        minLine = from.line;
-        if (mode == null) {
-          if (cm.uncomment(from, to, options))
-            mode = "un";
-          else {
-            cm.lineComment(from, to, options);
-            mode = "line";
-          }
-        } else if (mode == "un") {
-          cm.uncomment(from, to, options);
-        } else {
-          cm.lineComment(from, to, options);
-        }
-      }
-    });
-    function probablyInsideString(cm, pos, line) {
-      return /\bstring\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\'\"\`]/.test(line);
-    }
-    function getMode(cm, pos) {
-      var mode = cm.getMode();
-      return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos);
-    }
-    CodeMirror2.defineExtension("lineComment", function(from, to, options) {
-      if (!options)
-        options = noOptions;
-      var self2 = this, mode = getMode(self2, from);
-      var firstLine = self2.getLine(from.line);
-      if (firstLine == null || probablyInsideString(self2, from, firstLine))
-        return;
-      var commentString = options.lineComment || mode.lineComment;
-      if (!commentString) {
-        if (options.blockCommentStart || mode.blockCommentStart) {
-          options.fullLines = true;
-          self2.blockComment(from, to, options);
-        }
-        return;
-      }
-      var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self2.lastLine() + 1);
-      var pad = options.padding == null ? " " : options.padding;
-      var blankLines = options.commentBlankLines || from.line == to.line;
-      self2.operation(function() {
-        if (options.indent) {
-          var baseString = null;
-          for (var i = from.line; i < end; ++i) {
-            var line = self2.getLine(i);
-            var whitespace = line.slice(0, firstNonWS(line));
-            if (baseString == null || baseString.length > whitespace.length) {
-              baseString = whitespace;
-            }
-          }
-          for (var i = from.line; i < end; ++i) {
-            var line = self2.getLine(i), cut = baseString.length;
-            if (!blankLines && !nonWS.test(line))
-              continue;
-            if (line.slice(0, cut) != baseString)
-              cut = firstNonWS(line);
-            self2.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));
-          }
-        } else {
-          for (var i = from.line; i < end; ++i) {
-            if (blankLines || nonWS.test(self2.getLine(i)))
-              self2.replaceRange(commentString + pad, Pos(i, 0));
-          }
-        }
-      });
-    });
-    CodeMirror2.defineExtension("blockComment", function(from, to, options) {
-      if (!options)
-        options = noOptions;
-      var self2 = this, mode = getMode(self2, from);
-      var startString = options.blockCommentStart || mode.blockCommentStart;
-      var endString = options.blockCommentEnd || mode.blockCommentEnd;
-      if (!startString || !endString) {
-        if ((options.lineComment || mode.lineComment) && options.fullLines != false)
-          self2.lineComment(from, to, options);
-        return;
-      }
-      if (/\bcomment\b/.test(self2.getTokenTypeAt(Pos(from.line, 0))))
-        return;
-      var end = Math.min(to.line, self2.lastLine());
-      if (end != from.line && to.ch == 0 && nonWS.test(self2.getLine(end)))
-        --end;
-      var pad = options.padding == null ? " " : options.padding;
-      if (from.line > end)
-        return;
-      self2.operation(function() {
-        if (options.fullLines != false) {
-          var lastLineHasText = nonWS.test(self2.getLine(end));
-          self2.replaceRange(pad + endString, Pos(end));
-          self2.replaceRange(startString + pad, Pos(from.line, 0));
-          var lead = options.blockCommentLead || mode.blockCommentLead;
-          if (lead != null) {
-            for (var i = from.line + 1; i <= end; ++i)
-              if (i != end || lastLineHasText)
-                self2.replaceRange(lead + pad, Pos(i, 0));
-          }
-        } else {
-          var atCursor = cmp(self2.getCursor("to"), to) == 0, empty = !self2.somethingSelected();
-          self2.replaceRange(endString, to);
-          if (atCursor)
-            self2.setSelection(empty ? to : self2.getCursor("from"), to);
-          self2.replaceRange(startString, from);
+
+  // Rough heuristic to try and detect lines that are part of multi-line string
+  function probablyInsideString(cm, pos, line) {
+    return /\bstring\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\'\"\`]/.test(line)
+  }
+
+  function getMode(cm, pos) {
+    var mode = cm.getMode();
+    return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos)
+  }
+
+  CodeMirror.defineExtension("lineComment", function(from, to, options) {
+    if (!options) options = noOptions;
+    var self = this, mode = getMode(self, from);
+    var firstLine = self.getLine(from.line);
+    if (firstLine == null || probablyInsideString(self, from, firstLine)) return;
+
+    var commentString = options.lineComment || mode.lineComment;
+    if (!commentString) {
+      if (options.blockCommentStart || mode.blockCommentStart) {
+        options.fullLines = true;
+        self.blockComment(from, to, options);
+      }
+      return;
+    }
+
+    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);
+    var pad = options.padding == null ? " " : options.padding;
+    var blankLines = options.commentBlankLines || from.line == to.line;
+
+    self.operation(function() {
+      if (options.indent) {
+        var baseString = null;
+        for (var i = from.line; i < end; ++i) {
+          var line = self.getLine(i);
+          var whitespace = line.slice(0, firstNonWS(line));
+          if (baseString == null || baseString.length > whitespace.length) {
+            baseString = whitespace;
+          }
+        }
+        for (var i = from.line; i < end; ++i) {
+          var line = self.getLine(i), cut = baseString.length;
+          if (!blankLines && !nonWS.test(line)) continue;
+          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);
+          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));
         }
-      });
-    });
-    CodeMirror2.defineExtension("uncomment", function(from, to, options) {
-      if (!options)
-        options = noOptions;
-      var self2 = this, mode = getMode(self2, from);
-      var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self2.lastLine()), start = Math.min(from.line, end);
-      var lineString = options.lineComment || mode.lineComment, lines = [];
-      var pad = options.padding == null ? " " : options.padding, didSomething;
-      lineComment: {
-        if (!lineString)
-          break lineComment;
-        for (var i = start; i <= end; ++i) {
-          var line = self2.getLine(i);
-          var found = line.indexOf(lineString);
-          if (found > -1 && !/comment/.test(self2.getTokenTypeAt(Pos(i, found + 1))))
-            found = -1;
-          if (found == -1 && nonWS.test(line))
-            break lineComment;
-          if (found > -1 && nonWS.test(line.slice(0, found)))
-            break lineComment;
-          lines.push(line);
+      } else {
+        for (var i = from.line; i < end; ++i) {
+          if (blankLines || nonWS.test(self.getLine(i)))
+            self.replaceRange(commentString + pad, Pos(i, 0));
         }
-        self2.operation(function() {
-          for (var i2 = start; i2 <= end; ++i2) {
-            var line2 = lines[i2 - start];
-            var pos = line2.indexOf(lineString), endPos = pos + lineString.length;
-            if (pos < 0)
-              continue;
-            if (line2.slice(endPos, endPos + pad.length) == pad)
-              endPos += pad.length;
-            didSomething = true;
-            self2.replaceRange("", Pos(i2, pos), Pos(i2, endPos));
-          }
-        });
-        if (didSomething)
-          return true;
       }
-      var startString = options.blockCommentStart || mode.blockCommentStart;
-      var endString = options.blockCommentEnd || mode.blockCommentEnd;
-      if (!startString || !endString)
-        return false;
-      var lead = options.blockCommentLead || mode.blockCommentLead;
-      var startLine = self2.getLine(start), open = startLine.indexOf(startString);
-      if (open == -1)
-        return false;
-      var endLine = end == start ? startLine : self2.getLine(end);
-      var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);
-      var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1);
-      if (close == -1 || !/comment/.test(self2.getTokenTypeAt(insideStart)) || !/comment/.test(self2.getTokenTypeAt(insideEnd)) || self2.getRange(insideStart, insideEnd, "\n").indexOf(endString) > -1)
-        return false;
-      var lastStart = startLine.lastIndexOf(startString, from.ch);
-      var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);
-      if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch)
-        return false;
-      firstEnd = endLine.indexOf(endString, to.ch);
-      var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);
-      lastStart = firstEnd == -1 || almostLastStart == -1 ? -1 : to.ch + almostLastStart;
-      if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch)
-        return false;
-      self2.operation(function() {
-        self2.replaceRange("", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)), Pos(end, close + endString.length));
-        var openEnd = open + startString.length;
-        if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad)
-          openEnd += pad.length;
-        self2.replaceRange("", Pos(start, open), Pos(start, openEnd));
-        if (lead)
-          for (var i2 = start + 1; i2 <= end; ++i2) {
-            var line2 = self2.getLine(i2), found2 = line2.indexOf(lead);
-            if (found2 == -1 || nonWS.test(line2.slice(0, found2)))
-              continue;
-            var foundEnd = found2 + lead.length;
-            if (pad && line2.slice(foundEnd, foundEnd + pad.length) == pad)
-              foundEnd += pad.length;
-            self2.replaceRange("", Pos(i2, found2), Pos(i2, foundEnd));
-          }
-      });
-      return true;
     });
   });
-})();
-var foldcode = { exports: {} };
-(function(module, exports) {
-  (function(mod) {
-    mod(codemirror$1.exports);
-  })(function(CodeMirror2) {
-    function doFold(cm, pos, options, force) {
-      if (options && options.call) {
-        var finder = options;
-        options = null;
+
+  CodeMirror.defineExtension("blockComment", function(from, to, options) {
+    if (!options) options = noOptions;
+    var self = this, mode = getMode(self, from);
+    var startString = options.blockCommentStart || mode.blockCommentStart;
+    var endString = options.blockCommentEnd || mode.blockCommentEnd;
+    if (!startString || !endString) {
+      if ((options.lineComment || mode.lineComment) && options.fullLines != false)
+        self.lineComment(from, to, options);
+      return;
+    }
+    if (/\bcomment\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return
+
+    var end = Math.min(to.line, self.lastLine());
+    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;
+
+    var pad = options.padding == null ? " " : options.padding;
+    if (from.line > end) return;
+
+    self.operation(function() {
+      if (options.fullLines != false) {
+        var lastLineHasText = nonWS.test(self.getLine(end));
+        self.replaceRange(pad + endString, Pos(end));
+        self.replaceRange(startString + pad, Pos(from.line, 0));
+        var lead = options.blockCommentLead || mode.blockCommentLead;
+        if (lead != null) for (var i = from.line + 1; i <= end; ++i)
+          if (i != end || lastLineHasText)
+            self.replaceRange(lead + pad, Pos(i, 0));
       } else {
-        var finder = getOption(cm, options, "rangeFinder");
-      }
-      if (typeof pos == "number")
-        pos = CodeMirror2.Pos(pos, 0);
-      var minSize = getOption(cm, options, "minFoldSize");
-      function getRange(allowFolded) {
-        var range2 = finder(cm, pos);
-        if (!range2 || range2.to.line - range2.from.line < minSize)
-          return null;
-        if (force === "fold")
-          return range2;
-        var marks = cm.findMarksAt(range2.from);
-        for (var i = 0; i < marks.length; ++i) {
-          if (marks[i].__isFold) {
-            if (!allowFolded)
-              return null;
-            range2.cleared = true;
-            marks[i].clear();
-          }
-        }
-        return range2;
+        var atCursor = cmp(self.getCursor("to"), to) == 0, empty = !self.somethingSelected();
+        self.replaceRange(endString, to);
+        if (atCursor) self.setSelection(empty ? to : self.getCursor("from"), to);
+        self.replaceRange(startString, from);
       }
-      var range = getRange(true);
-      if (getOption(cm, options, "scanUp"))
-        while (!range && pos.line > cm.firstLine()) {
-          pos = CodeMirror2.Pos(pos.line - 1, 0);
-          range = getRange(false);
-        }
-      if (!range || range.cleared || force === "unfold")
-        return;
-      var myWidget = makeWidget(cm, options, range);
-      CodeMirror2.on(myWidget, "mousedown", function(e) {
-        myRange.clear();
-        CodeMirror2.e_preventDefault(e);
-      });
-      var myRange = cm.markText(range.from, range.to, {
-        replacedWith: myWidget,
-        clearOnEnter: getOption(cm, options, "clearOnEnter"),
-        __isFold: true
-      });
-      myRange.on("clear", function(from, to) {
-        CodeMirror2.signal(cm, "unfold", cm, from, to);
-      });
-      CodeMirror2.signal(cm, "fold", cm, range.from, range.to);
-    }
-    function makeWidget(cm, options, range) {
-      var widget = getOption(cm, options, "widget");
-      if (typeof widget == "function") {
-        widget = widget(range.from, range.to);
-      }
-      if (typeof widget == "string") {
-        var text = document.createTextNode(widget);
-        widget = document.createElement("span");
-        widget.appendChild(text);
-        widget.className = "CodeMirror-foldmarker";
-      } else if (widget) {
-        widget = widget.cloneNode(true);
-      }
-      return widget;
-    }
-    CodeMirror2.newFoldFunction = function(rangeFinder, widget) {
-      return function(cm, pos) {
-        doFold(cm, pos, { rangeFinder, widget });
-      };
-    };
-    CodeMirror2.defineExtension("foldCode", function(pos, options, force) {
-      doFold(this, pos, options, force);
-    });
-    CodeMirror2.defineExtension("isFolded", function(pos) {
-      var marks = this.findMarksAt(pos);
-      for (var i = 0; i < marks.length; ++i)
-        if (marks[i].__isFold)
-          return true;
     });
-    CodeMirror2.commands.toggleFold = function(cm) {
-      cm.foldCode(cm.getCursor());
-    };
-    CodeMirror2.commands.fold = function(cm) {
-      cm.foldCode(cm.getCursor(), null, "fold");
-    };
-    CodeMirror2.commands.unfold = function(cm) {
-      cm.foldCode(cm.getCursor(), { scanUp: false }, "unfold");
-    };
-    CodeMirror2.commands.foldAll = function(cm) {
-      cm.operation(function() {
-        for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
-          cm.foldCode(CodeMirror2.Pos(i, 0), { scanUp: false }, "fold");
-      });
-    };
-    CodeMirror2.commands.unfoldAll = function(cm) {
-      cm.operation(function() {
-        for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
-          cm.foldCode(CodeMirror2.Pos(i, 0), { scanUp: false }, "unfold");
-      });
-    };
-    CodeMirror2.registerHelper("fold", "combine", function() {
-      var funcs = Array.prototype.slice.call(arguments, 0);
-      return function(cm, start) {
-        for (var i = 0; i < funcs.length; ++i) {
-          var found = funcs[i](cm, start);
-          if (found)
-            return found;
+  });
+
+  CodeMirror.defineExtension("uncomment", function(from, to, options) {
+    if (!options) options = noOptions;
+    var self = this, mode = getMode(self, from);
+    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);
+
+    // Try finding line comments
+    var lineString = options.lineComment || mode.lineComment, lines = [];
+    var pad = options.padding == null ? " " : options.padding, didSomething;
+    lineComment: {
+      if (!lineString) break lineComment;
+      for (var i = start; i <= end; ++i) {
+        var line = self.getLine(i);
+        var found = line.indexOf(lineString);
+        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;
+        if (found == -1 && nonWS.test(line)) break lineComment;
+        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;
+        lines.push(line);
+      }
+      self.operation(function() {
+        for (var i = start; i <= end; ++i) {
+          var line = lines[i - start];
+          var pos = line.indexOf(lineString), endPos = pos + lineString.length;
+          if (pos < 0) continue;
+          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;
+          didSomething = true;
+          self.replaceRange("", Pos(i, pos), Pos(i, endPos));
         }
-      };
-    });
-    CodeMirror2.registerHelper("fold", "auto", function(cm, start) {
-      var helpers = cm.getHelpers(start, "fold");
-      for (var i = 0; i < helpers.length; i++) {
-        var cur = helpers[i](cm, start);
-        if (cur)
-          return cur;
+      });
+      if (didSomething) return true;
+    }
+
+    // Try block comments
+    var startString = options.blockCommentStart || mode.blockCommentStart;
+    var endString = options.blockCommentEnd || mode.blockCommentEnd;
+    if (!startString || !endString) return false;
+    var lead = options.blockCommentLead || mode.blockCommentLead;
+    var startLine = self.getLine(start), open = startLine.indexOf(startString);
+    if (open == -1) return false
+    var endLine = end == start ? startLine : self.getLine(end);
+    var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);
+    var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1);
+    if (close == -1 ||
+        !/comment/.test(self.getTokenTypeAt(insideStart)) ||
+        !/comment/.test(self.getTokenTypeAt(insideEnd)) ||
+        self.getRange(insideStart, insideEnd, "\n").indexOf(endString) > -1)
+      return false;
+
+    // Avoid killing block comments completely outside the selection.
+    // Positions of the last startString before the start of the selection, and the first endString after it.
+    var lastStart = startLine.lastIndexOf(startString, from.ch);
+    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);
+    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;
+    // Positions of the first endString after the end of the selection, and the last startString before it.
+    firstEnd = endLine.indexOf(endString, to.ch);
+    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);
+    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;
+    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;
+
+    self.operation(function() {
+      self.replaceRange("", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),
+                        Pos(end, close + endString.length));
+      var openEnd = open + startString.length;
+      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;
+      self.replaceRange("", Pos(start, open), Pos(start, openEnd));
+      if (lead) for (var i = start + 1; i <= end; ++i) {
+        var line = self.getLine(i), found = line.indexOf(lead);
+        if (found == -1 || nonWS.test(line.slice(0, found))) continue;
+        var foundEnd = found + lead.length;
+        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;
+        self.replaceRange("", Pos(i, found), Pos(i, foundEnd));
       }
     });
-    var defaultOptions = {
-      rangeFinder: CodeMirror2.fold.auto,
-      widget: "\u2194",
-      minFoldSize: 0,
-      scanUp: false,
-      clearOnEnter: true
-    };
-    CodeMirror2.defineOption("foldOptions", null);
-    function getOption(cm, options, name) {
-      if (options && options[name] !== void 0)
-        return options[name];
-      var editorOptions = cm.options.foldOptions;
-      if (editorOptions && editorOptions[name] !== void 0)
-        return editorOptions[name];
-      return defaultOptions[name];
-    }
-    CodeMirror2.defineExtension("foldOption", function(options, name) {
-      return getOption(this, options, name);
-    });
+    return true;
   });
-})();
-(function(module, exports) {
-  (function(mod) {
-    mod(codemirror$1.exports, foldcode.exports);
-  })(function(CodeMirror2) {
-    CodeMirror2.defineOption("foldGutter", false, function(cm, val, old) {
-      if (old && old != CodeMirror2.Init) {
-        cm.clearGutter(cm.state.foldGutter.options.gutter);
-        cm.state.foldGutter = null;
-        cm.off("gutterClick", onGutterClick);
-        cm.off("changes", onChange);
-        cm.off("viewportChange", onViewportChange);
-        cm.off("fold", onFold);
-        cm.off("unfold", onFold);
-        cm.off("swapDoc", onChange);
-      }
-      if (val) {
-        cm.state.foldGutter = new State2(parseOptions(val));
-        updateInViewport(cm);
-        cm.on("gutterClick", onGutterClick);
-        cm.on("changes", onChange);
-        cm.on("viewportChange", onViewportChange);
-        cm.on("fold", onFold);
-        cm.on("unfold", onFold);
-        cm.on("swapDoc", onChange);
-      }
-    });
-    var Pos = CodeMirror2.Pos;
-    function State2(options) {
-      this.options = options;
-      this.from = this.to = 0;
+});
+}());
+
+var foldcode = {exports: {}};
+
+(function (module, exports) {
+// CodeMirror, copyright (c) by Marijn Haverbeke and others
+// Distributed under an MIT license: https://codemirror.net/LICENSE
+
+(function(mod) {
+  mod(codemirror$1.exports);
+})(function(CodeMirror) {
+
+  function doFold(cm, pos, options, force) {
+    if (options && options.call) {
+      var finder = options;
+      options = null;
+    } else {
+      var finder = getOption(cm, options, "rangeFinder");
     }
-    function parseOptions(opts) {
-      if (opts === true)
-        opts = {};
-      if (opts.gutter == null)
-        opts.gutter = "CodeMirror-foldgutter";
-      if (opts.indicatorOpen == null)
-        opts.indicatorOpen = "CodeMirror-foldgutter-open";
-      if (opts.indicatorFolded == null)
-        opts.indicatorFolded = "CodeMirror-foldgutter-folded";
-      return opts;
-    }
-    function isFolded(cm, line) {
-      var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));
+    if (typeof pos == "number") pos = CodeMirror.Pos(pos, 0);
+    var minSize = getOption(cm, options, "minFoldSize");
+
+    function getRange(allowFolded) {
+      var range = finder(cm, pos);
+      if (!range || range.to.line - range.from.line < minSize) return null;
+      if (force === "fold") return range;
+
+      var marks = cm.findMarksAt(range.from);
       for (var i = 0; i < marks.length; ++i) {
         if (marks[i].__isFold) {
-          var fromPos = marks[i].find(-1);
-          if (fromPos && fromPos.line === line)
-            return marks[i];
+          if (!allowFolded) return null;
+          range.cleared = true;
+          marks[i].clear();
         }
       }
+      return range;
     }
-    function marker(spec) {
-      if (typeof spec == "string") {
-        var elt = document.createElement("div");
-        elt.className = spec + " CodeMirror-guttermarker-subtle";
-        return elt;
-      } else {
-        return spec.cloneNode(true);
-      }
-    }
-    function updateFoldInfo(cm, from, to) {
-      var opts = cm.state.foldGutter.options, cur = from - 1;
-      var minSize = cm.foldOption(opts, "minFoldSize");
-      var func = cm.foldOption(opts, "rangeFinder");
-      var clsFolded = typeof opts.indicatorFolded == "string" && classTest(opts.indicatorFolded);
-      var clsOpen = typeof opts.indicatorOpen == "string" && classTest(opts.indicatorOpen);
-      cm.eachLine(from, to, function(line) {
-        ++cur;
-        var mark = null;
-        var old = line.gutterMarkers;
-        if (old)
-          old = old[opts.gutter];
-        if (isFolded(cm, cur)) {
-          if (clsFolded && old && clsFolded.test(old.className))
-            return;
-          mark = marker(opts.indicatorFolded);
-        } else {
-          var pos = Pos(cur, 0);
-          var range = func && func(cm, pos);
-          if (range && range.to.line - range.from.line >= minSize) {
-            if (clsOpen && old && clsOpen.test(old.className))
-              return;
-            mark = marker(opts.indicatorOpen);
-          }
-        }
-        if (!mark && !old)
-          return;
-        cm.setGutterMarker(line, opts.gutter, mark);
-      });
-    }
-    function classTest(cls) {
-      return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
-    }
-    function updateInViewport(cm) {
-      var vp = cm.getViewport(), state2 = cm.state.foldGutter;
-      if (!state2)
-        return;
-      cm.operation(function() {
-        updateFoldInfo(cm, vp.from, vp.to);
-      });
-      state2.from = vp.from;
-      state2.to = vp.to;
+
+    var range = getRange(true);
+    if (getOption(cm, options, "scanUp")) while (!range && pos.line > cm.firstLine()) {
+      pos = CodeMirror.Pos(pos.line - 1, 0);
+      range = getRange(false);
     }
-    function onGutterClick(cm, line, gutter) {
-      var state2 = cm.state.foldGutter;
-      if (!state2)
-        return;
-      var opts = state2.options;
-      if (gutter != opts.gutter)
-        return;
-      var folded = isFolded(cm, line);
-      if (folded)
-        folded.clear();
-      else
-        cm.foldCode(Pos(line, 0), opts);
+    if (!range || range.cleared || force === "unfold") return;
+
+    var myWidget = makeWidget(cm, options, range);
+    CodeMirror.on(myWidget, "mousedown", function(e) {
+      myRange.clear();
+      CodeMirror.e_preventDefault(e);
+    });
+    var myRange = cm.markText(range.from, range.to, {
+      replacedWith: myWidget,
+      clearOnEnter: getOption(cm, options, "clearOnEnter"),
+      __isFold: true
+    });
+    myRange.on("clear", function(from, to) {
+      CodeMirror.signal(cm, "unfold", cm, from, to);
+    });
+    CodeMirror.signal(cm, "fold", cm, range.from, range.to);
+  }
+
+  function makeWidget(cm, options, range) {
+    var widget = getOption(cm, options, "widget");
+
+    if (typeof widget == "function") {
+      widget = widget(range.from, range.to);
     }
-    function onChange(cm) {
-      var state2 = cm.state.foldGutter;
-      if (!state2)
-        return;
-      var opts = state2.options;
-      state2.from = state2.to = 0;
-      clearTimeout(state2.changeUpdate);
-      state2.changeUpdate = setTimeout(function() {
-        updateInViewport(cm);
-      }, opts.foldOnChangeTimeSpan || 600);
+
+    if (typeof widget == "string") {
+      var text = document.createTextNode(widget);
+      widget = document.createElement("span");
+      widget.appendChild(text);
+      widget.className = "CodeMirror-foldmarker";
+    } else if (widget) {
+      widget = widget.cloneNode(true);
     }
-    function onViewportChange(cm) {
-      var state2 = cm.state.foldGutter;
-      if (!state2)
-        return;
-      var opts = state2.options;
-      clearTimeout(state2.changeUpdate);
-      state2.changeUpdate = setTimeout(function() {
-        var vp = cm.getViewport();
-        if (state2.from == state2.to || vp.from - state2.to > 20 || state2.from - vp.to > 20) {
-          updateInViewport(cm);
-        } else {
-          cm.operation(function() {
-            if (vp.from < state2.from) {
-              updateFoldInfo(cm, vp.from, state2.from);
-              state2.from = vp.from;
-            }
-            if (vp.to > state2.to) {
-              updateFoldInfo(cm, state2.to, vp.to);
-              state2.to = vp.to;
-            }
-          });
-        }
-      }, opts.updateViewportTimeSpan || 400);
+    return widget;
+  }
+
+  // Clumsy backwards-compatible interface
+  CodeMirror.newFoldFunction = function(rangeFinder, widget) {
+    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };
+  };
+
+  // New-style interface
+  CodeMirror.defineExtension("foldCode", function(pos, options, force) {
+    doFold(this, pos, options, force);
+  });
+
+  CodeMirror.defineExtension("isFolded", function(pos) {
+    var marks = this.findMarksAt(pos);
+    for (var i = 0; i < marks.length; ++i)
+      if (marks[i].__isFold) return true;
+  });
+
+  CodeMirror.commands.toggleFold = function(cm) {
+    cm.foldCode(cm.getCursor());
+  };
+  CodeMirror.commands.fold = function(cm) {
+    cm.foldCode(cm.getCursor(), null, "fold");
+  };
+  CodeMirror.commands.unfold = function(cm) {
+    cm.foldCode(cm.getCursor(), { scanUp: false }, "unfold");
+  };
+  CodeMirror.commands.foldAll = function(cm) {
+    cm.operation(function() {
+      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
+        cm.foldCode(CodeMirror.Pos(i, 0), { scanUp: false }, "fold");
+    });
+  };
+  CodeMirror.commands.unfoldAll = function(cm) {
+    cm.operation(function() {
+      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
+        cm.foldCode(CodeMirror.Pos(i, 0), { scanUp: false }, "unfold");
+    });
+  };
+
+  CodeMirror.registerHelper("fold", "combine", function() {
+    var funcs = Array.prototype.slice.call(arguments, 0);
+    return function(cm, start) {
+      for (var i = 0; i < funcs.length; ++i) {
+        var found = funcs[i](cm, start);
+        if (found) return found;
+      }
+    };
+  });
+
+  CodeMirror.registerHelper("fold", "auto", function(cm, start) {
+    var helpers = cm.getHelpers(start, "fold");
+    for (var i = 0; i < helpers.length; i++) {
+      var cur = helpers[i](cm, start);
+      if (cur) return cur;
     }
-    function onFold(cm, from) {
-      var state2 = cm.state.foldGutter;
-      if (!state2)
-        return;
-      var line = from.line;
-      if (line >= state2.from && line < state2.to)
-        updateFoldInfo(cm, line, line + 1);
+  });
+
+  var defaultOptions = {
+    rangeFinder: CodeMirror.fold.auto,
+    widget: "\u2194",
+    minFoldSize: 0,
+    scanUp: false,
+    clearOnEnter: true
+  };
+
+  CodeMirror.defineOption("foldOptions", null);
+
+  function getOption(cm, options, name) {
+    if (options && options[name] !== undefined)
+      return options[name];
+    var editorOptions = cm.options.foldOptions;
+    if (editorOptions && editorOptions[name] !== undefined)
+      return editorOptions[name];
+    return defaultOptions[name];
+  }
+
+  CodeMirror.defineExtension("foldOption", function(options, name) {
+    return getOption(this, options, name);
+  });
+});
+}());
+
+(function (module, exports) {
+// CodeMirror, copyright (c) by Marijn Haverbeke and others
+// Distributed under an MIT license: https://codemirror.net/LICENSE
+
+(function(mod) {
+  mod(codemirror$1.exports, foldcode.exports);
+})(function(CodeMirror) {
+
+  CodeMirror.defineOption("foldGutter", false, function(cm, val, old) {
+    if (old && old != CodeMirror.Init) {
+      cm.clearGutter(cm.state.foldGutter.options.gutter);
+      cm.state.foldGutter = null;
+      cm.off("gutterClick", onGutterClick);
+      cm.off("changes", onChange);
+      cm.off("viewportChange", onViewportChange);
+      cm.off("fold", onFold);
+      cm.off("unfold", onFold);
+      cm.off("swapDoc", onChange);
+    }
+    if (val) {
+      cm.state.foldGutter = new State(parseOptions(val));
+      updateInViewport(cm);
+      cm.on("gutterClick", onGutterClick);
+      cm.on("changes", onChange);
+      cm.on("viewportChange", onViewportChange);
+      cm.on("fold", onFold);
+      cm.on("unfold", onFold);
+      cm.on("swapDoc", onChange);
     }
   });
-})();
-(function(module, exports) {
-  (function(mod) {
-    mod(codemirror$1.exports);
-  })(function(CodeMirror2) {
-    CodeMirror2.registerHelper("fold", "brace", function(cm, start) {
-      var line = start.line, lineText = cm.getLine(line);
-      var tokenType;
-      function findOpening(openCh) {
-        for (var at = start.ch, pass = 0; ; ) {
-          var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);
-          if (found == -1) {
-            if (pass == 1)
-              break;
-            pass = 1;
-            at = lineText.length;
-            continue;
-          }
-          if (pass == 1 && found < start.ch)
-            break;
-          tokenType = cm.getTokenTypeAt(CodeMirror2.Pos(line, found + 1));
-          if (!/^(comment|string)/.test(tokenType))
-            return found + 1;
-          at = found - 1;
-        }
+
+  var Pos = CodeMirror.Pos;
+
+  function State(options) {
+    this.options = options;
+    this.from = this.to = 0;
+  }
+
+  function parseOptions(opts) {
+    if (opts === true) opts = {};
+    if (opts.gutter == null) opts.gutter = "CodeMirror-foldgutter";
+    if (opts.indicatorOpen == null) opts.indicatorOpen = "CodeMirror-foldgutter-open";
+    if (opts.indicatorFolded == null) opts.indicatorFolded = "CodeMirror-foldgutter-folded";
+    return opts;
+  }
+
+  function isFolded(cm, line) {
+    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));
+    for (var i = 0; i < marks.length; ++i) {
+      if (marks[i].__isFold) {
+        var fromPos = marks[i].find(-1);
+        if (fromPos && fromPos.line === line)
+          return marks[i];
       }
-      var startBrace = findOpening("{"), startBracket = findOpening("[");
-      var startToken, endToken, startCh;
-      if (startBrace != null && (startBracket == null || startBracket > startBrace)) {
-        startCh = startBrace;
-        startToken = "{";
-        endToken = "}";
-      } else if (startBracket != null) {
-        startCh = startBracket;
-        startToken = "[";
-        endToken = "]";
+    }
+  }
+
+  function marker(spec) {
+    if (typeof spec == "string") {
+      var elt = document.createElement("div");
+      elt.className = spec + " CodeMirror-guttermarker-subtle";
+      return elt;
+    } else {
+      return spec.cloneNode(true);
+    }
+  }
+
+  function updateFoldInfo(cm, from, to) {
+    var opts = cm.state.foldGutter.options, cur = from - 1;
+    var minSize = cm.foldOption(opts, "minFoldSize");
+    var func = cm.foldOption(opts, "rangeFinder");
+    // we can reuse the built-in indicator element if its className matches the new state
+    var clsFolded = typeof opts.indicatorFolded == "string" && classTest(opts.indicatorFolded);
+    var clsOpen = typeof opts.indicatorOpen == "string" && classTest(opts.indicatorOpen);
+    cm.eachLine(from, to, function(line) {
+      ++cur;
+      var mark = null;
+      var old = line.gutterMarkers;
+      if (old) old = old[opts.gutter];
+      if (isFolded(cm, cur)) {
+        if (clsFolded && old && clsFolded.test(old.className)) return;
+        mark = marker(opts.indicatorFolded);
       } else {
-        return;
-      }
-      var count = 1, lastLine = cm.lastLine(), end, endCh;
-      outer:
-        for (var i = line; i <= lastLine; ++i) {
-          var text = cm.getLine(i), pos = i == line ? startCh : 0;
-          for (; ; ) {
-            var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);
-            if (nextOpen < 0)
-              nextOpen = text.length;
-            if (nextClose < 0)
-              nextClose = text.length;
-            pos = Math.min(nextOpen, nextClose);
-            if (pos == text.length)
-              break;
-            if (cm.getTokenTypeAt(CodeMirror2.Pos(i, pos + 1)) == tokenType) {
-              if (pos == nextOpen)
-                ++count;
-              else if (!--count) {
-                end = i;
-                endCh = pos;
-                break outer;
-              }
-            }
-            ++pos;
-          }
-        }
-      if (end == null || line == end)
-        return;
-      return {
-        from: CodeMirror2.Pos(line, startCh),
-        to: CodeMirror2.Pos(end, endCh)
-      };
-    });
-    CodeMirror2.registerHelper("fold", "import", function(cm, start) {
-      function hasImport(line) {
-        if (line < cm.firstLine() || line > cm.lastLine())
-          return null;
-        var start2 = cm.getTokenAt(CodeMirror2.Pos(line, 1));
-        if (!/\S/.test(start2.string))
-          start2 = cm.getTokenAt(CodeMirror2.Pos(line, start2.end + 1));
-        if (start2.type != "keyword" || start2.string != "import")
-          return null;
-        for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {
-          var text = cm.getLine(i), semi = text.indexOf(";");
-          if (semi != -1)
-            return { startCh: start2.end, end: CodeMirror2.Pos(i, semi) };
+        var pos = Pos(cur, 0);
+        var range = func && func(cm, pos);
+        if (range && range.to.line - range.from.line >= minSize) {
+          if (clsOpen && old && clsOpen.test(old.className)) return;
+          mark = marker(opts.indicatorOpen);
         }
       }
-      var startLine = start.line, has = hasImport(startLine), prev;
-      if (!has || hasImport(startLine - 1) || (prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1)
-        return null;
-      for (var end = has.end; ; ) {
-        var next2 = hasImport(end.line + 1);
-        if (next2 == null)
-          break;
-        end = next2.end;
-      }
-      return { from: cm.clipPos(CodeMirror2.Pos(startLine, has.startCh + 1)), to: end };
+      if (!mark && !old) return;
+      cm.setGutterMarker(line, opts.gutter, mark);
     });
-    CodeMirror2.registerHelper("fold", "include", function(cm, start) {
-      function hasInclude(line) {
-        if (line < cm.firstLine() || line > cm.lastLine())
-          return null;
-        var start2 = cm.getTokenAt(CodeMirror2.Pos(line, 1));
-        if (!/\S/.test(start2.string))
-          start2 = cm.getTokenAt(CodeMirror2.Pos(line, start2.end + 1));
-        if (start2.type == "meta" && start2.string.slice(0, 8) == "#include")
-          return start2.start + 8;
-      }
-      var startLine = start.line, has = hasInclude(startLine);
-      if (has == null || hasInclude(startLine - 1) != null)
-        return null;
-      for (var end = startLine; ; ) {
-        var next2 = hasInclude(end + 1);
-        if (next2 == null)
-          break;
-        ++end;
-      }
-      return {
-        from: CodeMirror2.Pos(startLine, has + 1),
-        to: cm.clipPos(CodeMirror2.Pos(end))
-      };
+  }
+
+  // copied from CodeMirror/src/util/dom.js
+  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }
+
+  function updateInViewport(cm) {
+    var vp = cm.getViewport(), state = cm.state.foldGutter;
+    if (!state) return;
+    cm.operation(function() {
+      updateFoldInfo(cm, vp.from, vp.to);
     });
-  });
-})();
-(function(module, exports) {
-  (function(mod) {
-    mod(codemirror$1.exports);
-  })(function(CodeMirror2) {
-    function lineIndent(cm, lineNo) {
-      var text = cm.getLine(lineNo);
-      var spaceTo = text.search(/\S/);
-      if (spaceTo == -1 || /\bcomment\b/.test(cm.getTokenTypeAt(CodeMirror2.Pos(lineNo, spaceTo + 1))))
-        return -1;
-      return CodeMirror2.countColumn(text, null, cm.getOption("tabSize"));
-    }
-    CodeMirror2.registerHelper("fold", "indent", function(cm, start) {
-      var myIndent = lineIndent(cm, start.line);
-      if (myIndent < 0)
-        return;
-      var lastLineInFold = null;
-      for (var i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {
-        var indent = lineIndent(cm, i);
-        if (indent == -1)
-          ;
-        else if (indent > myIndent) {
-          lastLineInFold = i;
-        } else {
-          break;
-        }
+    state.from = vp.from; state.to = vp.to;
+  }
+
+  function onGutterClick(cm, line, gutter) {
+    var state = cm.state.foldGutter;
+    if (!state) return;
+    var opts = state.options;
+    if (gutter != opts.gutter) return;
+    var folded = isFolded(cm, line);
+    if (folded) folded.clear();
+    else cm.foldCode(Pos(line, 0), opts);
+  }
+
+  function onChange(cm) {
+    var state = cm.state.foldGutter;
+    if (!state) return;
+    var opts = state.options;
+    state.from = state.to = 0;
+    clearTimeout(state.changeUpdate);
+    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);
+  }
+
+  function onViewportChange(cm) {
+    var state = cm.state.foldGutter;
+    if (!state) return;
+    var opts = state.options;
+    clearTimeout(state.changeUpdate);
+    state.changeUpdate = setTimeout(function() {
+      var vp = cm.getViewport();
+      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
+        updateInViewport(cm);
+      } else {
+        cm.operation(function() {
+          if (vp.from < state.from) {
+            updateFoldInfo(cm, vp.from, state.from);
+            state.from = vp.from;
+          }
+          if (vp.to > state.to) {
+            updateFoldInfo(cm, state.to, vp.to);
+            state.to = vp.to;
+          }
+        });
       }
-      if (lastLineInFold)
-        return {
-          from: CodeMirror2.Pos(start.line, cm.getLine(start.line).length),
-          to: CodeMirror2.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)
-        };
-    });
-  });
-})();
-(function(module, exports) {
-  (function(mod) {
-    mod(codemirror$1.exports);
-  })(function(CodeMirror2) {
-    CodeMirror2.registerGlobalHelper("fold", "comment", function(mode) {
-      return mode.blockCommentStart && mode.blockCommentEnd;
-    }, function(cm, start) {
-      var mode = cm.getModeAt(start), startToken = mode.blockCommentStart, endToken = mode.blockCommentEnd;
-      if (!startToken || !endToken)
-        return;
-      var line = start.line, lineText = cm.getLine(line);
-      var startCh;
-      for (var at = start.ch, pass = 0; ; ) {
-        var found = at <= 0 ? -1 : lineText.lastIndexOf(startToken, at - 1);
+    }, opts.updateViewportTimeSpan || 400);
+  }
+
+  function onFold(cm, from) {
+    var state = cm.state.foldGutter;
+    if (!state) return;
+    var line = from.line;
+    if (line >= state.from && line < state.to)
+      updateFoldInfo(cm, line, line + 1);
+  }
+});
+}());
+
+(function (module, exports) {
+// CodeMirror, copyright (c) by Marijn Haverbeke and others
+// Distributed under an MIT license: https://codemirror.net/LICENSE
+
+(function(mod) {
+  mod(codemirror$1.exports);
+})(function(CodeMirror) {
+
+function bracketFolding(pairs) {
+  return function(cm, start) {
+    var line = start.line, lineText = cm.getLine(line);
+
+    function findOpening(pair) {
+      var tokenType;
+      for (var at = start.ch, pass = 0;;) {
+        var found = at <= 0 ? -1 : lineText.lastIndexOf(pair[0], at - 1);
         if (found == -1) {
-          if (pass == 1)
-            return;
+          if (pass == 1) break;
           pass = 1;
           at = lineText.length;
           continue;
         }
-        if (pass == 1 && found < start.ch)
-          return;
-        if (/comment/.test(cm.getTokenTypeAt(CodeMirror2.Pos(line, found + 1))) && (found == 0 || lineText.slice(found - endToken.length, found) == endToken || !/comment/.test(cm.getTokenTypeAt(CodeMirror2.Pos(line, found))))) {
-          startCh = found + startToken.length;
-          break;
-        }
+        if (pass == 1 && found < start.ch) break;
+        tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));
+        if (!/^(comment|string)/.test(tokenType)) return {ch: found + 1, tokenType: tokenType, pair: pair};
         at = found - 1;
       }
-      var depth = 1, lastLine = cm.lastLine(), end, endCh;
-      outer:
-        for (var i = line; i <= lastLine; ++i) {
-          var text = cm.getLine(i), pos = i == line ? startCh : 0;
-          for (; ; ) {
-            var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);
-            if (nextOpen < 0)
-              nextOpen = text.length;
-            if (nextClose < 0)
-              nextClose = text.length;
-            pos = Math.min(nextOpen, nextClose);
-            if (pos == text.length)
-              break;
-            if (pos == nextOpen)
-              ++depth;
-            else if (!--depth) {
-              end = i;
-              endCh = pos;
-              break outer;
-            }
-            ++pos;
-          }
+    }
+
+    function findRange(found) {
+      var count = 1, lastLine = cm.lastLine(), end, startCh = found.ch, endCh;
+      outer: for (var i = line; i <= lastLine; ++i) {
+        var text = cm.getLine(i), pos = i == line ? startCh : 0;
+        for (;;) {
+          var nextOpen = text.indexOf(found.pair[0], pos), nextClose = text.indexOf(found.pair[1], pos);
+          if (nextOpen < 0) nextOpen = text.length;
+          if (nextClose < 0) nextClose = text.length;
+          pos = Math.min(nextOpen, nextClose);
+          if (pos == text.length) break;
+          if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == found.tokenType) {
+            if (pos == nextOpen) ++count;
+            else if (!--count) { end = i; endCh = pos; break outer; }
+          }
+          ++pos;
         }
-      if (end == null || line == end && endCh == startCh)
-        return;
-      return {
-        from: CodeMirror2.Pos(line, startCh),
-        to: CodeMirror2.Pos(end, endCh)
-      };
-    });
-  });
-})();
-var CodeMirror_vue_vue_type_style_index_0_lang = "";
-const _sfc_main$5 = /* @__PURE__ */ defineComponent({
+      }
+
+      if (end == null || line == end) return null
+      return {from: CodeMirror.Pos(line, startCh),
+              to: CodeMirror.Pos(end, endCh)};
+    }
+
+    var found = [];
+    for (var i = 0; i < pairs.length; i++) {
+      var open = findOpening(pairs[i]);
+      if (open) found.push(open);
+    }
+    found.sort(function(a, b) { return a.ch - b.ch });
+    for (var i = 0; i < found.length; i++) {
+      var range = findRange(found[i]);
+      if (range) return range
+    }
+    return null
+  }
+}
+
+CodeMirror.registerHelper("fold", "brace", bracketFolding([["{", "}"], ["[", "]"]]));
+
+CodeMirror.registerHelper("fold", "brace-paren", bracketFolding([["{", "}"], ["[", "]"], ["(", ")"]]));
+
+CodeMirror.registerHelper("fold", "import", function(cm, start) {
+  function hasImport(line) {
+    if (line < cm.firstLine() || line > cm.lastLine()) return null;
+    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
+    if (!/\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));
+    if (start.type != "keyword" || start.string != "import") return null;
+    // Now find closing semicolon, return its position
+    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {
+      var text = cm.getLine(i), semi = text.indexOf(";");
+      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};
+    }
+  }
+
+  var startLine = start.line, has = hasImport(startLine), prev;
+  if (!has || hasImport(startLine - 1) || ((prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1))
+    return null;
+  for (var end = has.end;;) {
+    var next = hasImport(end.line + 1);
+    if (next == null) break;
+    end = next.end;
+  }
+  return {from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end};
+});
+
+CodeMirror.registerHelper("fold", "include", function(cm, start) {
+  function hasInclude(line) {
+    if (line < cm.firstLine() || line > cm.lastLine()) return null;
+    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
+    if (!/\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));
+    if (start.type == "meta" && start.string.slice(0, 8) == "#include") return start.start + 8;
+  }
+
+  var startLine = start.line, has = hasInclude(startLine);
+  if (has == null || hasInclude(startLine - 1) != null) return null;
+  for (var end = startLine;;) {
+    var next = hasInclude(end + 1);
+    if (next == null) break;
+    ++end;
+  }
+  return {from: CodeMirror.Pos(startLine, has + 1),
+          to: cm.clipPos(CodeMirror.Pos(end))};
+});
+
+});
+}());
+
+(function (module, exports) {
+// CodeMirror, copyright (c) by Marijn Haverbeke and others
+// Distributed under an MIT license: https://codemirror.net/LICENSE
+
+(function(mod) {
+  mod(codemirror$1.exports);
+})(function(CodeMirror) {
+
+function lineIndent(cm, lineNo) {
+  var text = cm.getLine(lineNo);
+  var spaceTo = text.search(/\S/);
+  if (spaceTo == -1 || /\bcomment\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, spaceTo + 1))))
+    return -1
+  return CodeMirror.countColumn(text, null, cm.getOption("tabSize"))
+}
+
+CodeMirror.registerHelper("fold", "indent", function(cm, start) {
+  var myIndent = lineIndent(cm, start.line);
+  if (myIndent < 0) return
+  var lastLineInFold = null;
+
+  // Go through lines until we find a line that definitely doesn't belong in
+  // the block we're folding, or to the end.
+  for (var i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {
+    var indent = lineIndent(cm, i);
+    if (indent == -1) ; else if (indent > myIndent) {
+      // Lines with a greater indent are considered part of the block.
+      lastLineInFold = i;
+    } else {
+      // If this line has non-space, non-comment content, and is
+      // indented less or equal to the start line, it is the start of
+      // another block.
+      break;
+    }
+  }
+  if (lastLineInFold) return {
+    from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),
+    to: CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)
+  };
+});
+
+});
+}());
+
+(function (module, exports) {
+// CodeMirror, copyright (c) by Marijn Haverbeke and others
+// Distributed under an MIT license: https://codemirror.net/LICENSE
+
+(function(mod) {
+  mod(codemirror$1.exports);
+})(function(CodeMirror) {
+
+CodeMirror.registerGlobalHelper("fold", "comment", function(mode) {
+  return mode.blockCommentStart && mode.blockCommentEnd;
+}, function(cm, start) {
+  var mode = cm.getModeAt(start), startToken = mode.blockCommentStart, endToken = mode.blockCommentEnd;
+  if (!startToken || !endToken) return;
+  var line = start.line, lineText = cm.getLine(line);
+
+  var startCh;
+  for (var at = start.ch, pass = 0;;) {
+    var found = at <= 0 ? -1 : lineText.lastIndexOf(startToken, at - 1);
+    if (found == -1) {
+      if (pass == 1) return;
+      pass = 1;
+      at = lineText.length;
+      continue;
+    }
+    if (pass == 1 && found < start.ch) return;
+    if (/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1))) &&
+        (found == 0 || lineText.slice(found - endToken.length, found) == endToken ||
+         !/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found))))) {
+      startCh = found + startToken.length;
+      break;
+    }
+    at = found - 1;
+  }
+
+  var depth = 1, lastLine = cm.lastLine(), end, endCh;
+  outer: for (var i = line; i <= lastLine; ++i) {
+    var text = cm.getLine(i), pos = i == line ? startCh : 0;
+    for (;;) {
+      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);
+      if (nextOpen < 0) nextOpen = text.length;
+      if (nextClose < 0) nextClose = text.length;
+      pos = Math.min(nextOpen, nextClose);
+      if (pos == text.length) break;
+      if (pos == nextOpen) ++depth;
+      else if (!--depth) { end = i; endCh = pos; break outer; }
+      ++pos;
+    }
+  }
+  if (end == null || line == end && endCh == startCh) return;
+  return {from: CodeMirror.Pos(line, startCh),
+          to: CodeMirror.Pos(end, endCh)};
+});
+
+});
+}());
+
+var CodeMirror_vue_vue_type_style_index_0_lang = '';
+
+const _sfc_main$5 = defineComponent({
+  name: "CodeMirror",
   props: {
-    mode: { type: String, required: false, default: "htmlmixed" },
-    value: { type: String, required: false, default: "" },
-    readonly: { type: Boolean, required: false, default: false }
+    mode: { default: "htmlmixed" },
+    value: { default: "" },
+    readonly: { type: Boolean, default: false }
   },
   emits: ["change"],
   setup(__props, { emit }) {
@@ -15707,14 +14693,15 @@ const _sfc_main$5 = /* @__PURE__ */ defineComponent({
         foldGutter: true,
         gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"]
       };
-      const editor = CodeMirror(el.value, __spreadValues({
+      const editor = CodeMirror(el.value, {
         value: "",
         mode: props.mode,
         readOnly: props.readonly,
         tabSize: 2,
         lineWrapping: true,
-        lineNumbers: true
-      }, addonOptions));
+        lineNumbers: true,
+        ...addonOptions
+      });
       editor.on("change", () => {
         emit("change", editor.getValue());
       });
@@ -15739,16 +14726,17 @@ const _sfc_main$5 = /* @__PURE__ */ defineComponent({
     return (_ctx, _cache) => {
       return openBlock(), createElementBlock("div", {
         class: "editor",
-        ref: (_value, _refs) => {
-          _refs["el"] = _value;
-          el.value = _value;
-        }
+        ref_key: "el",
+        ref: el
       }, null, 512);
     };
   }
 });
-var Message_vue_vue_type_style_index_0_scoped_true_lang = "";
+
+var Message_vue_vue_type_style_index_0_scoped_true_lang = '';
+
 const _sfc_main$4 = /* @__PURE__ */ defineComponent({
+  name: "Message",
   props: ["err", "warn"],
   setup(__props) {
     const props = __props;
@@ -15787,10 +14775,13 @@ const _sfc_main$4 = /* @__PURE__ */ defineComponent({
     };
   }
 });
-var Message = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-e083996a"]]);
-var Editor_vue_vue_type_style_index_0_scoped_true_lang = "";
+var Message = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-3823ae29"]]);
+
+var Editor_vue_vue_type_style_index_0_scoped_true_lang = '';
+
 const _hoisted_1$2 = { class: "editor-container" };
 const _sfc_main$3 = /* @__PURE__ */ defineComponent({
+  name: "Editor",
   setup(__props) {
     const store = inject("store");
     const onChange = debounce((code) => {
@@ -15818,13 +14809,15 @@ const _sfc_main$3 = /* @__PURE__ */ defineComponent({
   }
 });
 var Editor = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-759ba5e9"]]);
-var srcdoc = "<!doctype html>\n<html>\n	<head>\n		<style>\n			body {\n				font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto,\n				Oxygen, Ubuntu, Cantarell, \"Open Sans\", \"Helvetica Neue\", sans-serif;\n			}\n		</style>\n		<style id=\"__sfc-styles\"></style>\n		<script>\n			(() => {\n				let scriptEls = []\n\n				window.process = { env: {} }\n				window.__modules__ = {}\n\n				window.__export__ = (mod, key, get) => {\n					Object.defineProperty(mod, key, {\n						enumerable: true,\n						configurable: true,\n						get\n					})\n				}\n\n				window.__dynamic_import__ = key => {\n					return Promise.resolve(window.__modules__[key])\n				}\n\n				async function handle_message(ev) {\n					let { action, cmd_id } = ev.data;\n					const send_message = (payload) => parent.postMessage( { ...payload }, ev.origin);\n					const send_reply = (payload) => send_message({ ...payload, cmd_id });\n					const send_ok = () => send_reply({ action: 'cmd_ok' });\n					const send_error = (message, stack) => send_reply({ action: 'cmd_error', message, stack });\n\n					if (action === 'eval') {\n						try {\n							if (scriptEls.length) {\n								scriptEls.forEach(el => {\n									document.head.removeChild(el)\n								})\n								scriptEls.length = 0\n							}\n\n							let { script: scripts } = ev.data.args\n							if (typeof scripts === 'string') scripts = [scripts]\n\n							for (const script of scripts) {\n								const scriptEl = document.createElement('script')\n								scriptEl.setAttribute('type', 'module')\n								// send ok in the module script to ensure sequential evaluation\n								// of multiple proxy.eval() calls\n								const done = new Promise((resolve) => {\n									window.__next__ = resolve\n								})\n								scriptEl.innerHTML = script + `\\nwindow.__next__()`\n								document.head.appendChild(scriptEl)\n								scriptEl.onrror = err => send_error(err.message, err.stack)\n								scriptEls.push(scriptEl)\n								await done\n							}\n							send_ok()\n						} catch (e) {\n							send_error(e.message, e.stack);\n						}\n					}\n\n					if (action === 'catch_clicks') {\n						try {\n							const top_origin = ev.origin;\n							document.body.addEventListener('click', event => {\n								if (event.which !== 1) return;\n								if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n								if (event.defaultPrevented) return;\n\n								// ensure target is a link\n								let el = event.target;\n								while (el && el.nodeName !== 'A') el = el.parentNode;\n								if (!el || el.nodeName !== 'A') return;\n\n								if (el.hasAttribute('download') || el.getAttribute('rel') === 'external' || el.target) return;\n\n								event.preventDefault();\n\n								if (el.href.startsWith(top_origin)) {\n									const url = new URL(el.href);\n									if (url.hash[0] === '#') {\n										window.location.hash = url.hash;\n										return;\n									}\n								}\n\n								window.open(el.href, '_blank');\n							});\n							send_ok();\n						} catch(e) {\n							send_error(e.message, e.stack);\n						}\n					}\n				}\n\n				window.addEventListener('message', handle_message, false);\n\n				window.onerror = function (msg, url, lineNo, columnNo, error) {\n					if (msg.includes('module specifier \u201Cvue\u201D')) {\n						// firefox only error, ignore\n						return false\n					}\n					try {\n						parent.postMessage({ action: 'error', value: error }, '*');\n					} catch (e) {\n						parent.postMessage({ action: 'error', value: msg }, '*');\n					}\n				}\n\n				window.addEventListener(\"unhandledrejection\", event => {\n					if (event.reason.message.includes('Cross-origin')) {\n						event.preventDefault()\n						return\n					}\n					try {\n						parent.postMessage({ action: 'unhandledrejection', value: event.reason }, '*');\n					} catch (e) {\n						parent.postMessage({ action: 'unhandledrejection', value: event.reason.message }, '*');\n					}\n				});\n\n				let previous = { level: null, args: null };\n\n				['clear', 'log', 'info', 'dir', 'warn', 'error', 'table'].forEach((level) => {\n					const original = console[level];\n					console[level] = (...args) => {\n						const msg = String(args[0])\n						if (\n							msg.includes('You are running a development build of Vue') ||\n							msg.includes('You are running the esm-bundler build of Vue')\n						) {\n							return\n						}\n						const stringifiedArgs = stringify(args);\n						if (\n							previous.level === level &&\n							previous.args &&\n							previous.args === stringifiedArgs\n						) {\n							parent.postMessage({ action: 'console', level, duplicate: true }, '*');\n						} else {\n							previous = { level, args: stringifiedArgs };\n\n							try {\n								parent.postMessage({ action: 'console', level, args }, '*');\n							} catch (err) {\n								parent.postMessage({ action: 'console', level, args: args.map(a => {\n									return a instanceof Error ? a.message : String(a)\n								}) }, '*');\n							}\n						}\n\n						original(...args);\n					}\n				});\n\n				[\n					{ method: 'group', action: 'console_group' },\n					{ method: 'groupEnd', action: 'console_group_end' },\n					{ method: 'groupCollapsed', action: 'console_group_collapsed' },\n				].forEach((group_action) => {\n					const original = console[group_action.method];\n					console[group_action.method] = (label) => {\n						parent.postMessage({ action: group_action.action, label }, '*');\n\n						original(label);\n					};\n				});\n\n				const timers = new Map();\n				const original_time = console.time;\n				const original_timelog = console.timeLog;\n				const original_timeend = console.timeEnd;\n\n				console.time = (label = 'default') => {\n					original_time(label);\n					timers.set(label, performance.now());\n				}\n				console.timeLog = (label = 'default') => {\n					original_timelog(label);\n					const now = performance.now();\n					if (timers.has(label)) {\n						parent.postMessage({ action: 'console', level: 'system-log', args: [`${label}: ${now - timers.get(label)}ms`] }, '*');\n					} else {\n						parent.postMessage({ action: 'console', level: 'system-warn', args: [`Timer '${label}' does not exist`] }, '*');\n					}\n				}\n				console.timeEnd = (label = 'default') => {\n					original_timeend(label);\n					const now = performance.now();\n					if (timers.has(label)) {\n						parent.postMessage({ action: 'console', level: 'system-log', args: [`${label}: ${now - timers.get(label)}ms`] }, '*');\n					} else {\n						parent.postMessage({ action: 'console', level: 'system-warn', args: [`Timer '${label}' does not exist`] }, '*');\n					}\n					timers.delete(label);\n				};\n\n				const original_assert = console.assert;\n				console.assert = (condition, ...args) => {\n					if (condition) {\n						const stack = new Error().stack;\n						parent.postMessage({ action: 'console', level: 'assert', args, stack }, '*');\n					}\n					original_assert(condition, ...args);\n				};\n\n				const counter = new Map();\n				const original_count = console.count;\n				const original_countreset = console.countReset;\n\n				console.count = (label = 'default') => {\n					counter.set(label, (counter.get(label) || 0) + 1);\n					parent.postMessage({ action: 'console', level: 'system-log', args: `${label}: ${counter.get(label)}` }, '*');\n					original_count(label);\n				};\n\n				console.countReset = (label = 'default') => {\n					if (counter.has(label)) {\n						counter.set(label, 0);\n					} else {\n						parent.postMessage({ action: 'console', level: 'system-warn', args: `Count for '${label}' does not exist` }, '*');\n					}\n					original_countreset(label);\n				};\n\n				const original_trace = console.trace;\n\n				console.trace = (...args) => {\n					const stack = new Error().stack;\n					parent.postMessage({ action: 'console', level: 'trace', args, stack }, '*');\n					original_trace(...args);\n				};\n\n				function stringify(args) {\n					try {\n						return JSON.stringify(args);\n					} catch (error) {\n						return null;\n					}\n				}\n			})()\n		<\/script>\n\n		<!-- ES Module Shims: Import maps polyfill for modules browsers without import maps support (all except Chrome 89+) -->\n		<script async src=\"https://unpkg.com/es-module-shims@0.10.1/dist/es-module-shims.min.js\"><\/script>\n		<script type=\"importmap\"><!--IMPORT_MAP--><\/script>\n	</head>\n	<body></body>\n</html>";
+
+var srcdoc = "<!doctype html>\n<html>\n\t<head>\n\t\t<style>\n\t\t\tbody {\n\t\t\t\tfont-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto,\n\t\t\t\tOxygen, Ubuntu, Cantarell, \"Open Sans\", \"Helvetica Neue\", sans-serif;\n\t\t\t}\n\t\t</style>\n\t\t<style id=\"__sfc-styles\"></style>\n\t\t<script>\n\t\t\t(() => {\n\t\t\t\tlet scriptEls = []\n\n\t\t\t\twindow.process = { env: {} }\n\t\t\t\twindow.__modules__ = {}\n\n\t\t\t\twindow.__export__ = (mod, key, get) => {\n\t\t\t\t\tObject.defineProperty(mod, key, {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tget\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\twindow.__dynamic_import__ = key => {\n\t\t\t\t\treturn Promise.resolve(window.__modules__[key])\n\t\t\t\t}\n\n\t\t\t\tasync function handle_message(ev) {\n\t\t\t\t\tlet { action, cmd_id } = ev.data;\n\t\t\t\t\tconst send_message = (payload) => parent.postMessage( { ...payload }, ev.origin);\n\t\t\t\t\tconst send_reply = (payload) => send_message({ ...payload, cmd_id });\n\t\t\t\t\tconst send_ok = () => send_reply({ action: 'cmd_ok' });\n\t\t\t\t\tconst send_error = (message, stack) => send_reply({ action: 'cmd_error', message, stack });\n\n\t\t\t\t\tif (action === 'eval') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (scriptEls.length) {\n\t\t\t\t\t\t\t\tscriptEls.forEach(el => {\n\t\t\t\t\t\t\t\t\tdocument.head.removeChild(el)\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\tscriptEls.length = 0\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet { script: scripts } = ev.data.args\n\t\t\t\t\t\t\tif (typeof scripts === 'string') scripts = [scripts]\n\n\t\t\t\t\t\t\tfor (const script of scripts) {\n\t\t\t\t\t\t\t\tconst scriptEl = document.createElement('script')\n\t\t\t\t\t\t\t\tscriptEl.setAttribute('type', 'module')\n\t\t\t\t\t\t\t\t// send ok in the module script to ensure sequential evaluation\n\t\t\t\t\t\t\t\t// of multiple proxy.eval() calls\n\t\t\t\t\t\t\t\tconst done = new Promise((resolve) => {\n\t\t\t\t\t\t\t\t\twindow.__next__ = resolve\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\tscriptEl.innerHTML = script + `\\nwindow.__next__()`\n\t\t\t\t\t\t\t\tdocument.head.appendChild(scriptEl)\n\t\t\t\t\t\t\t\tscriptEl.onerror = err => send_error(err.message, err.stack)\n\t\t\t\t\t\t\t\tscriptEls.push(scriptEl)\n\t\t\t\t\t\t\t\tawait done\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsend_ok()\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tsend_error(e.message, e.stack);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (action === 'catch_clicks') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst top_origin = ev.origin;\n\t\t\t\t\t\t\tdocument.body.addEventListener('click', event => {\n\t\t\t\t\t\t\t\tif (event.which !== 1) return;\n\t\t\t\t\t\t\t\tif (event.metaKey || event.ctrlKey || event.shiftKey) return;\n\t\t\t\t\t\t\t\tif (event.defaultPrevented) return;\n\n\t\t\t\t\t\t\t\t// ensure target is a link\n\t\t\t\t\t\t\t\tlet el = event.target;\n\t\t\t\t\t\t\t\twhile (el && el.nodeName !== 'A') el = el.parentNode;\n\t\t\t\t\t\t\t\tif (!el || el.nodeName !== 'A') return;\n\n\t\t\t\t\t\t\t\tif (el.hasAttribute('download') || el.getAttribute('rel') === 'external' || el.target) return;\n\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\t\t\t\tif (el.href.startsWith(top_origin)) {\n\t\t\t\t\t\t\t\t\tconst url = new URL(el.href);\n\t\t\t\t\t\t\t\t\tif (url.hash[0] === '#') {\n\t\t\t\t\t\t\t\t\t\twindow.location.hash = url.hash;\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\nif(!el.href || el.href.startsWith('javascript'))return;\nwindow.open(el.href, '_blank');\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tsend_ok();\n\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\tsend_error(e.message, e.stack);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twindow.addEventListener('message', handle_message, false);\n\n\t\t\t\twindow.onerror = function (msg, url, lineNo, columnNo, error) {\n\t\t\t\t\tif (msg.includes('module specifier vue')) {\n\t\t\t\t\t\t// firefox only error, ignore\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tparent.postMessage({ action: 'error', value: error }, '*');\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tparent.postMessage({ action: 'error', value: msg }, '*');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twindow.addEventListener(\"unhandledrejection\", event => {\n\t\t\t\t\tif (event.reason.message.includes('Cross-origin')) {\n\t\t\t\t\t\tevent.preventDefault()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tparent.postMessage({ action: 'unhandledrejection', value: event.reason }, '*');\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tparent.postMessage({ action: 'unhandledrejection', value: event.reason.message }, '*');\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tlet previous = { level: null, args: null };\n\n\t\t\t\t['clear', 'log', 'info', 'dir', 'warn', 'error', 'table'].forEach((level) => {\n\t\t\t\t\tconst original = console[level];\n\t\t\t\t\tconsole[level] = (...args) => {\n\t\t\t\t\t\tconst msg = String(args[0])\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tmsg.includes('You are running a development build of Vue') ||\n\t\t\t\t\t\t\tmsg.includes('You are running the esm-bundler build of Vue')\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst stringifiedArgs = stringify(args);\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tprevious.level === level &&\n\t\t\t\t\t\t\tprevious.args &&\n\t\t\t\t\t\t\tprevious.args === stringifiedArgs\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tparent.postMessage({ action: 'console', level, duplicate: true }, '*');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprevious = { level, args: stringifiedArgs };\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tparent.postMessage({ action: 'console', level, args }, '*');\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\tparent.postMessage({ action: 'console', level, args: args.map(a => {\n\t\t\t\t\t\t\t\t\treturn a instanceof Error ? a.message : String(a)\n\t\t\t\t\t\t\t\t}) }, '*');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toriginal(...args);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t[\n\t\t\t\t\t{ method: 'group', action: 'console_group' },\n\t\t\t\t\t{ method: 'groupEnd', action: 'console_group_end' },\n\t\t\t\t\t{ method: 'groupCollapsed', action: 'console_group_collapsed' },\n\t\t\t\t].forEach((group_action) => {\n\t\t\t\t\tconst original = console[group_action.method];\n\t\t\t\t\tconsole[group_action.method] = (label) => {\n\t\t\t\t\t\tparent.postMessage({ action: group_action.action, label }, '*');\n\n\t\t\t\t\t\toriginal(label);\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\tconst timers = new Map();\n\t\t\t\tconst original_time = console.time;\n\t\t\t\tconst original_timelog = console.timeLog;\n\t\t\t\tconst original_timeend = console.timeEnd;\n\n\t\t\t\tconsole.time = (label = 'default') => {\n\t\t\t\t\toriginal_time(label);\n\t\t\t\t\ttimers.set(label, performance.now());\n\t\t\t\t}\n\t\t\t\tconsole.timeLog = (label = 'default') => {\n\t\t\t\t\toriginal_timelog(label);\n\t\t\t\t\tconst now = performance.now();\n\t\t\t\t\tif (timers.has(label)) {\n\t\t\t\t\t\tparent.postMessage({ action: 'console', level: 'system-log', args: [`${label}: ${now - timers.get(label)}ms`] }, '*');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparent.postMessage({ action: 'console', level: 'system-warn', args: [`Timer '${label}' does not exist`] }, '*');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconsole.timeEnd = (label = 'default') => {\n\t\t\t\t\toriginal_timeend(label);\n\t\t\t\t\tconst now = performance.now();\n\t\t\t\t\tif (timers.has(label)) {\n\t\t\t\t\t\tparent.postMessage({ action: 'console', level: 'system-log', args: [`${label}: ${now - timers.get(label)}ms`] }, '*');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparent.postMessage({ action: 'console', level: 'system-warn', args: [`Timer '${label}' does not exist`] }, '*');\n\t\t\t\t\t}\n\t\t\t\t\ttimers.delete(label);\n\t\t\t\t};\n\n\t\t\t\tconst original_assert = console.assert;\n\t\t\t\tconsole.assert = (condition, ...args) => {\n\t\t\t\t\tif (condition) {\n\t\t\t\t\t\tconst stack = new Error().stack;\n\t\t\t\t\t\tparent.postMessage({ action: 'console', level: 'assert', args, stack }, '*');\n\t\t\t\t\t}\n\t\t\t\t\toriginal_assert(condition, ...args);\n\t\t\t\t};\n\n\t\t\t\tconst counter = new Map();\n\t\t\t\tconst original_count = console.count;\n\t\t\t\tconst original_countreset = console.countReset;\n\n\t\t\t\tconsole.count = (label = 'default') => {\n\t\t\t\t\tcounter.set(label, (counter.get(label) || 0) + 1);\n\t\t\t\t\tparent.postMessage({ action: 'console', level: 'system-log', args: `${label}: ${counter.get(label)}` }, '*');\n\t\t\t\t\toriginal_count(label);\n\t\t\t\t};\n\n\t\t\t\tconsole.countReset = (label = 'default') => {\n\t\t\t\t\tif (counter.has(label)) {\n\t\t\t\t\t\tcounter.set(label, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparent.postMessage({ action: 'console', level: 'system-warn', args: `Count for '${label}' does not exist` }, '*');\n\t\t\t\t\t}\n\t\t\t\t\toriginal_countreset(label);\n\t\t\t\t};\n\n\t\t\t\tconst original_trace = console.trace;\n\n\t\t\t\tconsole.trace = (...args) => {\n\t\t\t\t\tconst stack = new Error().stack;\n\t\t\t\t\tparent.postMessage({ action: 'console', level: 'trace', args, stack }, '*');\n\t\t\t\t\toriginal_trace(...args);\n\t\t\t\t};\n\n\t\t\t\tfunction stringify(args) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn JSON.stringify(args);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})()\n\t\t</script>\n\n\t\t<!-- ES Module Shims: Import maps polyfill for modules browsers without import maps support (all except Chrome 89+) -->\n\t\t<script async src=\"https://unpkg.com/es-module-shims@1.5.5/dist/es-module-shims.wasm.js\"></script>\n\t\t<script type=\"importmap\"><!--IMPORT_MAP--></script>\n\t</head>\n\t<body></body>\n</html>\n";
+
 let uid = 1;
 class PreviewProxy {
   constructor(iframe, handlers) {
     this.iframe = iframe;
     this.handlers = handlers;
-    this.pending_cmds = new Map();
+    this.pending_cmds = /* @__PURE__ */ new Map();
     this.handle_event = (e) => this.handle_repl_message(e);
     window.addEventListener("message", this.handle_event, false);
   }
@@ -15859,28 +14852,28 @@ class PreviewProxy {
       ]);
     }
   }
-  handle_repl_message(event2) {
-    if (event2.source !== this.iframe.contentWindow)
+  handle_repl_message(event) {
+    if (event.source !== this.iframe.contentWindow)
       return;
-    const { action, args } = event2.data;
+    const { action, args } = event.data;
     switch (action) {
       case "cmd_error":
       case "cmd_ok":
-        return this.handle_command_message(event2.data);
+        return this.handle_command_message(event.data);
       case "fetch_progress":
         return this.handlers.on_fetch_progress(args.remaining);
       case "error":
-        return this.handlers.on_error(event2.data);
+        return this.handlers.on_error(event.data);
       case "unhandledrejection":
-        return this.handlers.on_unhandled_rejection(event2.data);
+        return this.handlers.on_unhandled_rejection(event.data);
       case "console":
-        return this.handlers.on_console(event2.data);
+        return this.handlers.on_console(event.data);
       case "console_group":
-        return this.handlers.on_console_group(event2.data);
+        return this.handlers.on_console_group(event.data);
       case "console_group_collapsed":
-        return this.handlers.on_console_group_collapsed(event2.data);
+        return this.handlers.on_console_group_collapsed(event.data);
       case "console_group_end":
-        return this.handlers.on_console_group_end(event2.data);
+        return this.handlers.on_console_group_end(event.data);
     }
   }
   eval(script) {
@@ -15890,16 +14883,19 @@ class PreviewProxy {
     return this.iframe_command("catch_clicks", {});
   }
 }
-function compileModulesForPreview(store) {
-  const seen = new Set();
+
+function compileModulesForPreview(store, isSSR = false) {
+  const seen = /* @__PURE__ */ new Set();
   const processed = [];
-  processFile(store, store.state.files[store.state.mainFile], processed, seen);
-  for (const filename in store.state.files) {
-    if (filename.endsWith(".css")) {
-      const file = store.state.files[filename];
-      if (!seen.has(file)) {
-        processed.push(`
+  processFile(store, store.state.files[store.state.mainFile], processed, seen, isSSR);
+  if (!isSSR) {
+    for (const filename in store.state.files) {
+      if (filename.endsWith(".css")) {
+        const file = store.state.files[filename];
+        if (!seen.has(file)) {
+          processed.push(`
 window.__css__ += ${JSON.stringify(file.compiled.css)}`);
+        }
       }
     }
   }
@@ -15909,22 +14905,22 @@ const modulesKey = `__modules__`;
 const exportKey = `__export__`;
 const dynamicImportKey = `__dynamic_import__`;
 const moduleKey = `__module__`;
-function processFile(store, file, processed, seen) {
+function processFile(store, file, processed, seen, isSSR) {
   if (seen.has(file)) {
     return [];
   }
   seen.add(file);
-  if (file.filename.endsWith(".html")) {
+  if (!isSSR && file.filename.endsWith(".html")) {
     return processHtmlFile(store, file.code, file.filename, processed, seen);
   }
-  let [js, importedFiles] = processModule(store, file.compiled.js, file.filename);
-  if (file.compiled.css) {
+  let [js, importedFiles] = processModule(store, isSSR ? file.compiled.ssr : file.compiled.js, file.filename);
+  if (!isSSR && file.compiled.css) {
     js += `
 window.__css__ += ${JSON.stringify(file.compiled.css)}`;
   }
   if (importedFiles.size) {
     for (const imported of importedFiles) {
-      processFile(store, store.state.files[imported], processed, seen);
+      processFile(store, store.state.files[imported], processed, seen, isSSR);
     }
   }
   processed.push(js);
@@ -15935,10 +14931,10 @@ function processModule(store, src, filename) {
     sourceFilename: filename,
     sourceType: "module"
   }).program.body;
-  const idToImportMap = new Map();
-  const declaredConst = new Set();
-  const importedFiles = new Set();
-  const importToIdMap = new Map();
+  const idToImportMap = /* @__PURE__ */ new Map();
+  const declaredConst = /* @__PURE__ */ new Set();
+  const importedFiles = /* @__PURE__ */ new Set();
+  const importToIdMap = /* @__PURE__ */ new Map();
   function defineImport(node, source) {
     const filename2 = source.replace(/^\.\/+/, "");
     if (!(filename2 in store.state.files)) {
@@ -15958,7 +14954,7 @@ function processModule(store, src, filename) {
     s.append(`
 ${exportKey}(${moduleKey}, "${name}", () => ${local})`);
   }
-  s.prepend(`const ${moduleKey} = __modules__[${JSON.stringify(filename)}] = { [Symbol.toStringTag]: "Module" }
+  s.prepend(`const ${moduleKey} = ${modulesKey}[${JSON.stringify(filename)}] = { [Symbol.toStringTag]: "Module" }
 
 `);
   for (const node of ast) {
@@ -16074,7 +15070,7 @@ function processHtmlFile(store, src, filename, processed, seen) {
     const [code, importedFiles] = processModule(store, content, filename);
     if (importedFiles.size) {
       for (const imported of importedFiles) {
-        processFile(store, store.state.files[imported], deps, seen);
+        processFile(store, store.state.files[imported], deps, seen, false);
       }
     }
     jsCode += "\n" + code;
@@ -16087,12 +15083,17 @@ function processHtmlFile(store, src, filename, processed, seen) {
   processed.push(...deps);
   processed.push(jsCode);
 }
-var Preview_vue_vue_type_style_index_0_scoped_true_lang = "";
+
+var Preview_vue_vue_type_style_index_0_scoped_true_lang = '';
+
 const _sfc_main$2 = /* @__PURE__ */ defineComponent({
+  name: "Preview",
   props: {
-    show: { type: Boolean, required: true }
+    show: { type: Boolean },
+    ssr: { type: Boolean }
   },
   setup(__props) {
+    const props = __props;
     const store = inject("store");
     const clearConsole = inject("clear-console");
     const container = ref();
@@ -16149,17 +15150,17 @@ const _sfc_main$2 = /* @__PURE__ */ defineComponent({
       proxy = new PreviewProxy(sandbox, {
         on_fetch_progress: (progress) => {
         },
-        on_error: (event2) => {
-          const msg = event2.value instanceof Error ? event2.value.message : event2.value;
+        on_error: (event) => {
+          const msg = event.value instanceof Error ? event.value.message : event.value;
           if (msg.includes("Failed to resolve module specifier") || msg.includes("Error resolving module specifier")) {
             runtimeError.value = msg.replace(/\. Relative references must.*$/, "") + `.
 Tip: add an "import-map.json" file to specify import paths for dependencies.`;
           } else {
-            runtimeError.value = event2.value;
+            runtimeError.value = event.value;
           }
         },
-        on_unhandled_rejection: (event2) => {
-          let error = event2.value;
+        on_unhandled_rejection: (event) => {
+          let error = event.value;
           if (typeof error === "string") {
             error = { message: error };
           }
@@ -16199,23 +15200,59 @@ Tip: add an "import-map.json" file to specify import paths for dependencies.`;
       }
       runtimeError.value = null;
       runtimeWarning.value = null;
+      let isSSR = props.ssr;
+      if (store.vueVersion) {
+        const [_, minor, patch] = store.vueVersion.split(".");
+        if (parseInt(minor, 10) < 2 || parseInt(patch, 10) < 27) {
+          alert(`The selected version of Vue (${store.vueVersion}) does not support in-browser SSR. Rendering in client mode instead.`);
+          isSSR = false;
+        }
+      }
       try {
+        const mainFile = store.state.mainFile;
+        if (isSSR && mainFile.endsWith(".vue")) {
+          const ssrModules = compileModulesForPreview(store, true);
+          console.log(`[@vue/repl] successfully compiled ${ssrModules.length} modules for SSR.`);
+          await proxy.eval([
+            `const __modules__ = {};`,
+            ...ssrModules,
+            `import { renderToString as _renderToString } from 'vue/server-renderer'
+         import { createSSRApp as _createApp } from 'vue'
+         const AppComponent = __modules__["${mainFile}"].default
+         AppComponent.name = 'Repl'
+         const app = _createApp(AppComponent)
+         app.config.unwrapInjectedRef = true
+         app.config.warnHandler = () => {}
+         window.__ssr_promise__ = _renderToString(app).then(html => {
+           document.body.innerHTML = '<div id="app">' + html + '</div>'
+         }).catch(err => {
+           console.error("SSR Error", err)
+         })
+        `
+          ]);
+        }
         const modules = compileModulesForPreview(store);
         console.log(`[@vue/repl] successfully compiled ${modules.length} modules.`);
         const codeToEval = [
-          `window.__modules__ = {};window.__css__ = '';if (window.__app__) window.__app__.unmount();document.body.innerHTML = '<div id="app"></div>'`,
+          `window.__modules__ = {};window.__css__ = '';if (window.__app__) window.__app__.unmount();` + (isSSR ? `` : `document.body.innerHTML = '<div id="app"></div>'`),
           ...modules,
           `document.getElementById('__sfc-styles').innerHTML = window.__css__`
         ];
-        const mainFile = store.state.mainFile;
         if (mainFile.endsWith(".vue")) {
-          codeToEval.push(`import { createApp as _createApp } from "vue"
-        const AppComponent = __modules__["${mainFile}"].default
-        AppComponent.name = 'Repl'
-        const app = window.__app__ = _createApp(AppComponent)
-        app.config.unwrapInjectedRef = true
-        app.config.errorHandler = e => console.error(e)
-        app.mount('#app')`.trim());
+          codeToEval.push(`import { ${isSSR ? `createSSRApp` : `createApp`} as _createApp } from "vue"
+        const _mount = () => {
+          const AppComponent = __modules__["${mainFile}"].default
+          AppComponent.name = 'Repl'
+          const app = window.__app__ = _createApp(AppComponent)
+          app.config.unwrapInjectedRef = true
+          app.config.errorHandler = e => console.error(e)
+          app.mount('#app')
+        }
+        if (window.__ssr_promise__) {
+          window.__ssr_promise__.then(_mount)
+        } else {
+          _mount()
+        }`);
         }
         await proxy.eval(codeToEval);
       } catch (e) {
@@ -16226,10 +15263,8 @@ Tip: add an "import-map.json" file to specify import paths for dependencies.`;
       return openBlock(), createElementBlock(Fragment, null, [
         withDirectives(createElementVNode("div", {
           class: "iframe-container",
-          ref: (_value, _refs) => {
-            _refs["container"] = _value;
-            container.value = _value;
-          }
+          ref_key: "container",
+          ref: container
         }, null, 512), [
           [vShow, __props.show]
         ]),
@@ -16242,14 +15277,18 @@ Tip: add an "import-map.json" file to specify import paths for dependencies.`;
     };
   }
 });
-var Preview = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-fed14756"]]);
-var Output_vue_vue_type_style_index_0_scoped_true_lang = "";
+var Preview = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-1f12de15"]]);
+
+var Output_vue_vue_type_style_index_0_scoped_true_lang = '';
+
 const _hoisted_1$1 = { class: "tab-buttons" };
 const _hoisted_2 = ["onClick"];
 const _hoisted_3 = { class: "output-container" };
 const _sfc_main$1 = /* @__PURE__ */ defineComponent({
+  name: "Output",
   props: {
-    showCompileOutput: { type: Boolean, required: false }
+    showCompileOutput: { type: Boolean },
+    ssr: { type: Boolean }
   },
   setup(__props) {
     const props = __props;
@@ -16270,8 +15309,9 @@ const _sfc_main$1 = /* @__PURE__ */ defineComponent({
         ]),
         createElementVNode("div", _hoisted_3, [
           createVNode(Preview, {
-            show: mode.value === "preview"
-          }, null, 8, ["show"]),
+            show: mode.value === "preview",
+            ssr: __props.ssr
+          }, null, 8, ["show", "ssr"]),
           mode.value !== "preview" ? (openBlock(), createBlock(_sfc_main$5, {
             key: 0,
             readonly: "",
@@ -16283,316 +15323,170 @@ const _sfc_main$1 = /* @__PURE__ */ defineComponent({
     };
   }
 });
-var Output = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-79065b94"]]);
-var ContextualKeyword;
-(function(ContextualKeyword2) {
-  const NONE = 0;
-  ContextualKeyword2[ContextualKeyword2["NONE"] = NONE] = "NONE";
-  const _abstract = NONE + 1;
-  ContextualKeyword2[ContextualKeyword2["_abstract"] = _abstract] = "_abstract";
-  const _as = _abstract + 1;
-  ContextualKeyword2[ContextualKeyword2["_as"] = _as] = "_as";
-  const _asserts = _as + 1;
-  ContextualKeyword2[ContextualKeyword2["_asserts"] = _asserts] = "_asserts";
-  const _async = _asserts + 1;
-  ContextualKeyword2[ContextualKeyword2["_async"] = _async] = "_async";
-  const _await = _async + 1;
-  ContextualKeyword2[ContextualKeyword2["_await"] = _await] = "_await";
-  const _checks = _await + 1;
-  ContextualKeyword2[ContextualKeyword2["_checks"] = _checks] = "_checks";
-  const _constructor = _checks + 1;
-  ContextualKeyword2[ContextualKeyword2["_constructor"] = _constructor] = "_constructor";
-  const _declare = _constructor + 1;
-  ContextualKeyword2[ContextualKeyword2["_declare"] = _declare] = "_declare";
-  const _enum = _declare + 1;
-  ContextualKeyword2[ContextualKeyword2["_enum"] = _enum] = "_enum";
-  const _exports = _enum + 1;
-  ContextualKeyword2[ContextualKeyword2["_exports"] = _exports] = "_exports";
-  const _from = _exports + 1;
-  ContextualKeyword2[ContextualKeyword2["_from"] = _from] = "_from";
-  const _get = _from + 1;
-  ContextualKeyword2[ContextualKeyword2["_get"] = _get] = "_get";
-  const _global = _get + 1;
-  ContextualKeyword2[ContextualKeyword2["_global"] = _global] = "_global";
-  const _implements = _global + 1;
-  ContextualKeyword2[ContextualKeyword2["_implements"] = _implements] = "_implements";
-  const _infer = _implements + 1;
-  ContextualKeyword2[ContextualKeyword2["_infer"] = _infer] = "_infer";
-  const _interface = _infer + 1;
-  ContextualKeyword2[ContextualKeyword2["_interface"] = _interface] = "_interface";
-  const _is = _interface + 1;
-  ContextualKeyword2[ContextualKeyword2["_is"] = _is] = "_is";
-  const _keyof = _is + 1;
-  ContextualKeyword2[ContextualKeyword2["_keyof"] = _keyof] = "_keyof";
-  const _mixins = _keyof + 1;
-  ContextualKeyword2[ContextualKeyword2["_mixins"] = _mixins] = "_mixins";
-  const _module = _mixins + 1;
-  ContextualKeyword2[ContextualKeyword2["_module"] = _module] = "_module";
-  const _namespace = _module + 1;
-  ContextualKeyword2[ContextualKeyword2["_namespace"] = _namespace] = "_namespace";
-  const _of = _namespace + 1;
-  ContextualKeyword2[ContextualKeyword2["_of"] = _of] = "_of";
-  const _opaque = _of + 1;
-  ContextualKeyword2[ContextualKeyword2["_opaque"] = _opaque] = "_opaque";
-  const _override = _opaque + 1;
-  ContextualKeyword2[ContextualKeyword2["_override"] = _override] = "_override";
-  const _private = _override + 1;
-  ContextualKeyword2[ContextualKeyword2["_private"] = _private] = "_private";
-  const _protected = _private + 1;
-  ContextualKeyword2[ContextualKeyword2["_protected"] = _protected] = "_protected";
-  const _proto = _protected + 1;
-  ContextualKeyword2[ContextualKeyword2["_proto"] = _proto] = "_proto";
-  const _public = _proto + 1;
-  ContextualKeyword2[ContextualKeyword2["_public"] = _public] = "_public";
-  const _readonly = _public + 1;
-  ContextualKeyword2[ContextualKeyword2["_readonly"] = _readonly] = "_readonly";
-  const _require = _readonly + 1;
-  ContextualKeyword2[ContextualKeyword2["_require"] = _require] = "_require";
-  const _set = _require + 1;
-  ContextualKeyword2[ContextualKeyword2["_set"] = _set] = "_set";
-  const _static = _set + 1;
-  ContextualKeyword2[ContextualKeyword2["_static"] = _static] = "_static";
-  const _type = _static + 1;
-  ContextualKeyword2[ContextualKeyword2["_type"] = _type] = "_type";
-  const _unique = _type + 1;
-  ContextualKeyword2[ContextualKeyword2["_unique"] = _unique] = "_unique";
+var Output = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-56582219"]]);
+
+var ContextualKeyword; (function (ContextualKeyword) {
+  const NONE = 0; ContextualKeyword[ContextualKeyword["NONE"] = NONE] = "NONE";
+  const _abstract = NONE + 1; ContextualKeyword[ContextualKeyword["_abstract"] = _abstract] = "_abstract";
+  const _as = _abstract + 1; ContextualKeyword[ContextualKeyword["_as"] = _as] = "_as";
+  const _asserts = _as + 1; ContextualKeyword[ContextualKeyword["_asserts"] = _asserts] = "_asserts";
+  const _async = _asserts + 1; ContextualKeyword[ContextualKeyword["_async"] = _async] = "_async";
+  const _await = _async + 1; ContextualKeyword[ContextualKeyword["_await"] = _await] = "_await";
+  const _checks = _await + 1; ContextualKeyword[ContextualKeyword["_checks"] = _checks] = "_checks";
+  const _constructor = _checks + 1; ContextualKeyword[ContextualKeyword["_constructor"] = _constructor] = "_constructor";
+  const _declare = _constructor + 1; ContextualKeyword[ContextualKeyword["_declare"] = _declare] = "_declare";
+  const _enum = _declare + 1; ContextualKeyword[ContextualKeyword["_enum"] = _enum] = "_enum";
+  const _exports = _enum + 1; ContextualKeyword[ContextualKeyword["_exports"] = _exports] = "_exports";
+  const _from = _exports + 1; ContextualKeyword[ContextualKeyword["_from"] = _from] = "_from";
+  const _get = _from + 1; ContextualKeyword[ContextualKeyword["_get"] = _get] = "_get";
+  const _global = _get + 1; ContextualKeyword[ContextualKeyword["_global"] = _global] = "_global";
+  const _implements = _global + 1; ContextualKeyword[ContextualKeyword["_implements"] = _implements] = "_implements";
+  const _infer = _implements + 1; ContextualKeyword[ContextualKeyword["_infer"] = _infer] = "_infer";
+  const _interface = _infer + 1; ContextualKeyword[ContextualKeyword["_interface"] = _interface] = "_interface";
+  const _is = _interface + 1; ContextualKeyword[ContextualKeyword["_is"] = _is] = "_is";
+  const _keyof = _is + 1; ContextualKeyword[ContextualKeyword["_keyof"] = _keyof] = "_keyof";
+  const _mixins = _keyof + 1; ContextualKeyword[ContextualKeyword["_mixins"] = _mixins] = "_mixins";
+  const _module = _mixins + 1; ContextualKeyword[ContextualKeyword["_module"] = _module] = "_module";
+  const _namespace = _module + 1; ContextualKeyword[ContextualKeyword["_namespace"] = _namespace] = "_namespace";
+  const _of = _namespace + 1; ContextualKeyword[ContextualKeyword["_of"] = _of] = "_of";
+  const _opaque = _of + 1; ContextualKeyword[ContextualKeyword["_opaque"] = _opaque] = "_opaque";
+  const _override = _opaque + 1; ContextualKeyword[ContextualKeyword["_override"] = _override] = "_override";
+  const _private = _override + 1; ContextualKeyword[ContextualKeyword["_private"] = _private] = "_private";
+  const _protected = _private + 1; ContextualKeyword[ContextualKeyword["_protected"] = _protected] = "_protected";
+  const _proto = _protected + 1; ContextualKeyword[ContextualKeyword["_proto"] = _proto] = "_proto";
+  const _public = _proto + 1; ContextualKeyword[ContextualKeyword["_public"] = _public] = "_public";
+  const _readonly = _public + 1; ContextualKeyword[ContextualKeyword["_readonly"] = _readonly] = "_readonly";
+  const _require = _readonly + 1; ContextualKeyword[ContextualKeyword["_require"] = _require] = "_require";
+  const _set = _require + 1; ContextualKeyword[ContextualKeyword["_set"] = _set] = "_set";
+  const _static = _set + 1; ContextualKeyword[ContextualKeyword["_static"] = _static] = "_static";
+  const _type = _static + 1; ContextualKeyword[ContextualKeyword["_type"] = _type] = "_type";
+  const _unique = _type + 1; ContextualKeyword[ContextualKeyword["_unique"] = _unique] = "_unique";
 })(ContextualKeyword || (ContextualKeyword = {}));
-var TokenType;
-(function(TokenType2) {
-  const PRECEDENCE_MASK = 15;
-  TokenType2[TokenType2["PRECEDENCE_MASK"] = PRECEDENCE_MASK] = "PRECEDENCE_MASK";
-  const IS_KEYWORD = 1 << 4;
-  TokenType2[TokenType2["IS_KEYWORD"] = IS_KEYWORD] = "IS_KEYWORD";
-  const IS_ASSIGN = 1 << 5;
-  TokenType2[TokenType2["IS_ASSIGN"] = IS_ASSIGN] = "IS_ASSIGN";
-  const IS_RIGHT_ASSOCIATIVE = 1 << 6;
-  TokenType2[TokenType2["IS_RIGHT_ASSOCIATIVE"] = IS_RIGHT_ASSOCIATIVE] = "IS_RIGHT_ASSOCIATIVE";
-  const IS_PREFIX = 1 << 7;
-  TokenType2[TokenType2["IS_PREFIX"] = IS_PREFIX] = "IS_PREFIX";
-  const IS_POSTFIX = 1 << 8;
-  TokenType2[TokenType2["IS_POSTFIX"] = IS_POSTFIX] = "IS_POSTFIX";
-  const num = 0;
-  TokenType2[TokenType2["num"] = num] = "num";
-  const bigint = 512;
-  TokenType2[TokenType2["bigint"] = bigint] = "bigint";
-  const decimal = 1024;
-  TokenType2[TokenType2["decimal"] = decimal] = "decimal";
-  const regexp = 1536;
-  TokenType2[TokenType2["regexp"] = regexp] = "regexp";
-  const string = 2048;
-  TokenType2[TokenType2["string"] = string] = "string";
-  const name = 2560;
-  TokenType2[TokenType2["name"] = name] = "name";
-  const eof = 3072;
-  TokenType2[TokenType2["eof"] = eof] = "eof";
-  const bracketL = 3584;
-  TokenType2[TokenType2["bracketL"] = bracketL] = "bracketL";
-  const bracketR = 4096;
-  TokenType2[TokenType2["bracketR"] = bracketR] = "bracketR";
-  const braceL = 4608;
-  TokenType2[TokenType2["braceL"] = braceL] = "braceL";
-  const braceBarL = 5120;
-  TokenType2[TokenType2["braceBarL"] = braceBarL] = "braceBarL";
-  const braceR = 5632;
-  TokenType2[TokenType2["braceR"] = braceR] = "braceR";
-  const braceBarR = 6144;
-  TokenType2[TokenType2["braceBarR"] = braceBarR] = "braceBarR";
-  const parenL = 6656;
-  TokenType2[TokenType2["parenL"] = parenL] = "parenL";
-  const parenR = 7168;
-  TokenType2[TokenType2["parenR"] = parenR] = "parenR";
-  const comma = 7680;
-  TokenType2[TokenType2["comma"] = comma] = "comma";
-  const semi = 8192;
-  TokenType2[TokenType2["semi"] = semi] = "semi";
-  const colon = 8704;
-  TokenType2[TokenType2["colon"] = colon] = "colon";
-  const doubleColon = 9216;
-  TokenType2[TokenType2["doubleColon"] = doubleColon] = "doubleColon";
-  const dot = 9728;
-  TokenType2[TokenType2["dot"] = dot] = "dot";
-  const question = 10240;
-  TokenType2[TokenType2["question"] = question] = "question";
-  const questionDot = 10752;
-  TokenType2[TokenType2["questionDot"] = questionDot] = "questionDot";
-  const arrow = 11264;
-  TokenType2[TokenType2["arrow"] = arrow] = "arrow";
-  const template = 11776;
-  TokenType2[TokenType2["template"] = template] = "template";
-  const ellipsis = 12288;
-  TokenType2[TokenType2["ellipsis"] = ellipsis] = "ellipsis";
-  const backQuote = 12800;
-  TokenType2[TokenType2["backQuote"] = backQuote] = "backQuote";
-  const dollarBraceL = 13312;
-  TokenType2[TokenType2["dollarBraceL"] = dollarBraceL] = "dollarBraceL";
-  const at = 13824;
-  TokenType2[TokenType2["at"] = at] = "at";
-  const hash = 14336;
-  TokenType2[TokenType2["hash"] = hash] = "hash";
-  const eq = 14880;
-  TokenType2[TokenType2["eq"] = eq] = "eq";
-  const assign = 15392;
-  TokenType2[TokenType2["assign"] = assign] = "assign";
-  const preIncDec = 16256;
-  TokenType2[TokenType2["preIncDec"] = preIncDec] = "preIncDec";
-  const postIncDec = 16768;
-  TokenType2[TokenType2["postIncDec"] = postIncDec] = "postIncDec";
-  const bang = 17024;
-  TokenType2[TokenType2["bang"] = bang] = "bang";
-  const tilde = 17536;
-  TokenType2[TokenType2["tilde"] = tilde] = "tilde";
-  const pipeline = 17921;
-  TokenType2[TokenType2["pipeline"] = pipeline] = "pipeline";
-  const nullishCoalescing = 18434;
-  TokenType2[TokenType2["nullishCoalescing"] = nullishCoalescing] = "nullishCoalescing";
-  const logicalOR = 18946;
-  TokenType2[TokenType2["logicalOR"] = logicalOR] = "logicalOR";
-  const logicalAND = 19459;
-  TokenType2[TokenType2["logicalAND"] = logicalAND] = "logicalAND";
-  const bitwiseOR = 19972;
-  TokenType2[TokenType2["bitwiseOR"] = bitwiseOR] = "bitwiseOR";
-  const bitwiseXOR = 20485;
-  TokenType2[TokenType2["bitwiseXOR"] = bitwiseXOR] = "bitwiseXOR";
-  const bitwiseAND = 20998;
-  TokenType2[TokenType2["bitwiseAND"] = bitwiseAND] = "bitwiseAND";
-  const equality = 21511;
-  TokenType2[TokenType2["equality"] = equality] = "equality";
-  const lessThan = 22024;
-  TokenType2[TokenType2["lessThan"] = lessThan] = "lessThan";
-  const greaterThan = 22536;
-  TokenType2[TokenType2["greaterThan"] = greaterThan] = "greaterThan";
-  const relationalOrEqual = 23048;
-  TokenType2[TokenType2["relationalOrEqual"] = relationalOrEqual] = "relationalOrEqual";
-  const bitShift = 23561;
-  TokenType2[TokenType2["bitShift"] = bitShift] = "bitShift";
-  const plus = 24202;
-  TokenType2[TokenType2["plus"] = plus] = "plus";
-  const minus = 24714;
-  TokenType2[TokenType2["minus"] = minus] = "minus";
-  const modulo = 25099;
-  TokenType2[TokenType2["modulo"] = modulo] = "modulo";
-  const star = 25611;
-  TokenType2[TokenType2["star"] = star] = "star";
-  const slash = 26123;
-  TokenType2[TokenType2["slash"] = slash] = "slash";
-  const exponent = 26700;
-  TokenType2[TokenType2["exponent"] = exponent] = "exponent";
-  const jsxName = 27136;
-  TokenType2[TokenType2["jsxName"] = jsxName] = "jsxName";
-  const jsxText = 27648;
-  TokenType2[TokenType2["jsxText"] = jsxText] = "jsxText";
-  const jsxTagStart = 28160;
-  TokenType2[TokenType2["jsxTagStart"] = jsxTagStart] = "jsxTagStart";
-  const jsxTagEnd = 28672;
-  TokenType2[TokenType2["jsxTagEnd"] = jsxTagEnd] = "jsxTagEnd";
-  const typeParameterStart = 29184;
-  TokenType2[TokenType2["typeParameterStart"] = typeParameterStart] = "typeParameterStart";
-  const nonNullAssertion = 29696;
-  TokenType2[TokenType2["nonNullAssertion"] = nonNullAssertion] = "nonNullAssertion";
-  const _break = 30224;
-  TokenType2[TokenType2["_break"] = _break] = "_break";
-  const _case = 30736;
-  TokenType2[TokenType2["_case"] = _case] = "_case";
-  const _catch = 31248;
-  TokenType2[TokenType2["_catch"] = _catch] = "_catch";
-  const _continue = 31760;
-  TokenType2[TokenType2["_continue"] = _continue] = "_continue";
-  const _debugger = 32272;
-  TokenType2[TokenType2["_debugger"] = _debugger] = "_debugger";
-  const _default = 32784;
-  TokenType2[TokenType2["_default"] = _default] = "_default";
-  const _do = 33296;
-  TokenType2[TokenType2["_do"] = _do] = "_do";
-  const _else = 33808;
-  TokenType2[TokenType2["_else"] = _else] = "_else";
-  const _finally = 34320;
-  TokenType2[TokenType2["_finally"] = _finally] = "_finally";
-  const _for = 34832;
-  TokenType2[TokenType2["_for"] = _for] = "_for";
-  const _function = 35344;
-  TokenType2[TokenType2["_function"] = _function] = "_function";
-  const _if = 35856;
-  TokenType2[TokenType2["_if"] = _if] = "_if";
-  const _return = 36368;
-  TokenType2[TokenType2["_return"] = _return] = "_return";
-  const _switch = 36880;
-  TokenType2[TokenType2["_switch"] = _switch] = "_switch";
-  const _throw = 37520;
-  TokenType2[TokenType2["_throw"] = _throw] = "_throw";
-  const _try = 37904;
-  TokenType2[TokenType2["_try"] = _try] = "_try";
-  const _var = 38416;
-  TokenType2[TokenType2["_var"] = _var] = "_var";
-  const _let = 38928;
-  TokenType2[TokenType2["_let"] = _let] = "_let";
-  const _const = 39440;
-  TokenType2[TokenType2["_const"] = _const] = "_const";
-  const _while = 39952;
-  TokenType2[TokenType2["_while"] = _while] = "_while";
-  const _with = 40464;
-  TokenType2[TokenType2["_with"] = _with] = "_with";
-  const _new = 40976;
-  TokenType2[TokenType2["_new"] = _new] = "_new";
-  const _this = 41488;
-  TokenType2[TokenType2["_this"] = _this] = "_this";
-  const _super = 42e3;
-  TokenType2[TokenType2["_super"] = _super] = "_super";
-  const _class = 42512;
-  TokenType2[TokenType2["_class"] = _class] = "_class";
-  const _extends = 43024;
-  TokenType2[TokenType2["_extends"] = _extends] = "_extends";
-  const _export = 43536;
-  TokenType2[TokenType2["_export"] = _export] = "_export";
-  const _import = 44048;
-  TokenType2[TokenType2["_import"] = _import] = "_import";
-  const _yield = 44560;
-  TokenType2[TokenType2["_yield"] = _yield] = "_yield";
-  const _null = 45072;
-  TokenType2[TokenType2["_null"] = _null] = "_null";
-  const _true = 45584;
-  TokenType2[TokenType2["_true"] = _true] = "_true";
-  const _false = 46096;
-  TokenType2[TokenType2["_false"] = _false] = "_false";
-  const _in = 46616;
-  TokenType2[TokenType2["_in"] = _in] = "_in";
-  const _instanceof = 47128;
-  TokenType2[TokenType2["_instanceof"] = _instanceof] = "_instanceof";
-  const _typeof = 47760;
-  TokenType2[TokenType2["_typeof"] = _typeof] = "_typeof";
-  const _void = 48272;
-  TokenType2[TokenType2["_void"] = _void] = "_void";
-  const _delete = 48784;
-  TokenType2[TokenType2["_delete"] = _delete] = "_delete";
-  const _async = 49168;
-  TokenType2[TokenType2["_async"] = _async] = "_async";
-  const _get = 49680;
-  TokenType2[TokenType2["_get"] = _get] = "_get";
-  const _set = 50192;
-  TokenType2[TokenType2["_set"] = _set] = "_set";
-  const _declare = 50704;
-  TokenType2[TokenType2["_declare"] = _declare] = "_declare";
-  const _readonly = 51216;
-  TokenType2[TokenType2["_readonly"] = _readonly] = "_readonly";
-  const _abstract = 51728;
-  TokenType2[TokenType2["_abstract"] = _abstract] = "_abstract";
-  const _static = 52240;
-  TokenType2[TokenType2["_static"] = _static] = "_static";
-  const _public = 52752;
-  TokenType2[TokenType2["_public"] = _public] = "_public";
-  const _private = 53264;
-  TokenType2[TokenType2["_private"] = _private] = "_private";
-  const _protected = 53776;
-  TokenType2[TokenType2["_protected"] = _protected] = "_protected";
-  const _override = 54288;
-  TokenType2[TokenType2["_override"] = _override] = "_override";
-  const _as = 54800;
-  TokenType2[TokenType2["_as"] = _as] = "_as";
-  const _enum = 55312;
-  TokenType2[TokenType2["_enum"] = _enum] = "_enum";
-  const _type = 55824;
-  TokenType2[TokenType2["_type"] = _type] = "_type";
-  const _implements = 56336;
-  TokenType2[TokenType2["_implements"] = _implements] = "_implements";
+
+// Generated file, do not edit! Run "yarn generate" to re-generate this file.
+/**
+ * Enum of all token types, with bit fields to signify meaningful properties.
+ */
+var TokenType; (function (TokenType) {
+  // Precedence 0 means not an operator; otherwise it is a positive number up to 12.
+  const PRECEDENCE_MASK = 0xf; TokenType[TokenType["PRECEDENCE_MASK"] = PRECEDENCE_MASK] = "PRECEDENCE_MASK";
+  const IS_KEYWORD = 1 << 4; TokenType[TokenType["IS_KEYWORD"] = IS_KEYWORD] = "IS_KEYWORD";
+  const IS_ASSIGN = 1 << 5; TokenType[TokenType["IS_ASSIGN"] = IS_ASSIGN] = "IS_ASSIGN";
+  const IS_RIGHT_ASSOCIATIVE = 1 << 6; TokenType[TokenType["IS_RIGHT_ASSOCIATIVE"] = IS_RIGHT_ASSOCIATIVE] = "IS_RIGHT_ASSOCIATIVE";
+  const IS_PREFIX = 1 << 7; TokenType[TokenType["IS_PREFIX"] = IS_PREFIX] = "IS_PREFIX";
+  const IS_POSTFIX = 1 << 8; TokenType[TokenType["IS_POSTFIX"] = IS_POSTFIX] = "IS_POSTFIX";
+
+  const num = 0; TokenType[TokenType["num"] = num] = "num"; // num
+  const bigint = 512; TokenType[TokenType["bigint"] = bigint] = "bigint"; // bigint
+  const decimal = 1024; TokenType[TokenType["decimal"] = decimal] = "decimal"; // decimal
+  const regexp = 1536; TokenType[TokenType["regexp"] = regexp] = "regexp"; // regexp
+  const string = 2048; TokenType[TokenType["string"] = string] = "string"; // string
+  const name = 2560; TokenType[TokenType["name"] = name] = "name"; // name
+  const eof = 3072; TokenType[TokenType["eof"] = eof] = "eof"; // eof
+  const bracketL = 3584; TokenType[TokenType["bracketL"] = bracketL] = "bracketL"; // [
+  const bracketR = 4096; TokenType[TokenType["bracketR"] = bracketR] = "bracketR"; // ]
+  const braceL = 4608; TokenType[TokenType["braceL"] = braceL] = "braceL"; // {
+  const braceBarL = 5120; TokenType[TokenType["braceBarL"] = braceBarL] = "braceBarL"; // {|
+  const braceR = 5632; TokenType[TokenType["braceR"] = braceR] = "braceR"; // }
+  const braceBarR = 6144; TokenType[TokenType["braceBarR"] = braceBarR] = "braceBarR"; // |}
+  const parenL = 6656; TokenType[TokenType["parenL"] = parenL] = "parenL"; // (
+  const parenR = 7168; TokenType[TokenType["parenR"] = parenR] = "parenR"; // )
+  const comma = 7680; TokenType[TokenType["comma"] = comma] = "comma"; // ,
+  const semi = 8192; TokenType[TokenType["semi"] = semi] = "semi"; // ;
+  const colon = 8704; TokenType[TokenType["colon"] = colon] = "colon"; // :
+  const doubleColon = 9216; TokenType[TokenType["doubleColon"] = doubleColon] = "doubleColon"; // ::
+  const dot = 9728; TokenType[TokenType["dot"] = dot] = "dot"; // .
+  const question = 10240; TokenType[TokenType["question"] = question] = "question"; // ?
+  const questionDot = 10752; TokenType[TokenType["questionDot"] = questionDot] = "questionDot"; // ?.
+  const arrow = 11264; TokenType[TokenType["arrow"] = arrow] = "arrow"; // =>
+  const template = 11776; TokenType[TokenType["template"] = template] = "template"; // template
+  const ellipsis = 12288; TokenType[TokenType["ellipsis"] = ellipsis] = "ellipsis"; // ...
+  const backQuote = 12800; TokenType[TokenType["backQuote"] = backQuote] = "backQuote"; // `
+  const dollarBraceL = 13312; TokenType[TokenType["dollarBraceL"] = dollarBraceL] = "dollarBraceL"; // ${
+  const at = 13824; TokenType[TokenType["at"] = at] = "at"; // @
+  const hash = 14336; TokenType[TokenType["hash"] = hash] = "hash"; // #
+  const eq = 14880; TokenType[TokenType["eq"] = eq] = "eq"; // = isAssign
+  const assign = 15392; TokenType[TokenType["assign"] = assign] = "assign"; // _= isAssign
+  const preIncDec = 16256; TokenType[TokenType["preIncDec"] = preIncDec] = "preIncDec"; // ++/-- prefix postfix
+  const postIncDec = 16768; TokenType[TokenType["postIncDec"] = postIncDec] = "postIncDec"; // ++/-- prefix postfix
+  const bang = 17024; TokenType[TokenType["bang"] = bang] = "bang"; // ! prefix
+  const tilde = 17536; TokenType[TokenType["tilde"] = tilde] = "tilde"; // ~ prefix
+  const pipeline = 17921; TokenType[TokenType["pipeline"] = pipeline] = "pipeline"; // |> prec:1
+  const nullishCoalescing = 18434; TokenType[TokenType["nullishCoalescing"] = nullishCoalescing] = "nullishCoalescing"; // ?? prec:2
+  const logicalOR = 18946; TokenType[TokenType["logicalOR"] = logicalOR] = "logicalOR"; // || prec:2
+  const logicalAND = 19459; TokenType[TokenType["logicalAND"] = logicalAND] = "logicalAND"; // && prec:3
+  const bitwiseOR = 19972; TokenType[TokenType["bitwiseOR"] = bitwiseOR] = "bitwiseOR"; // | prec:4
+  const bitwiseXOR = 20485; TokenType[TokenType["bitwiseXOR"] = bitwiseXOR] = "bitwiseXOR"; // ^ prec:5
+  const bitwiseAND = 20998; TokenType[TokenType["bitwiseAND"] = bitwiseAND] = "bitwiseAND"; // & prec:6
+  const equality = 21511; TokenType[TokenType["equality"] = equality] = "equality"; // ==/!= prec:7
+  const lessThan = 22024; TokenType[TokenType["lessThan"] = lessThan] = "lessThan"; // < prec:8
+  const greaterThan = 22536; TokenType[TokenType["greaterThan"] = greaterThan] = "greaterThan"; // > prec:8
+  const relationalOrEqual = 23048; TokenType[TokenType["relationalOrEqual"] = relationalOrEqual] = "relationalOrEqual"; // <=/>= prec:8
+  const bitShift = 23561; TokenType[TokenType["bitShift"] = bitShift] = "bitShift"; // <</>> prec:9
+  const plus = 24202; TokenType[TokenType["plus"] = plus] = "plus"; // + prec:10 prefix
+  const minus = 24714; TokenType[TokenType["minus"] = minus] = "minus"; // - prec:10 prefix
+  const modulo = 25099; TokenType[TokenType["modulo"] = modulo] = "modulo"; // % prec:11
+  const star = 25611; TokenType[TokenType["star"] = star] = "star"; // * prec:11
+  const slash = 26123; TokenType[TokenType["slash"] = slash] = "slash"; // / prec:11
+  const exponent = 26700; TokenType[TokenType["exponent"] = exponent] = "exponent"; // ** prec:12 rightAssociative
+  const jsxName = 27136; TokenType[TokenType["jsxName"] = jsxName] = "jsxName"; // jsxName
+  const jsxText = 27648; TokenType[TokenType["jsxText"] = jsxText] = "jsxText"; // jsxText
+  const jsxTagStart = 28160; TokenType[TokenType["jsxTagStart"] = jsxTagStart] = "jsxTagStart"; // jsxTagStart
+  const jsxTagEnd = 28672; TokenType[TokenType["jsxTagEnd"] = jsxTagEnd] = "jsxTagEnd"; // jsxTagEnd
+  const typeParameterStart = 29184; TokenType[TokenType["typeParameterStart"] = typeParameterStart] = "typeParameterStart"; // typeParameterStart
+  const nonNullAssertion = 29696; TokenType[TokenType["nonNullAssertion"] = nonNullAssertion] = "nonNullAssertion"; // nonNullAssertion
+  const _break = 30224; TokenType[TokenType["_break"] = _break] = "_break"; // break keyword
+  const _case = 30736; TokenType[TokenType["_case"] = _case] = "_case"; // case keyword
+  const _catch = 31248; TokenType[TokenType["_catch"] = _catch] = "_catch"; // catch keyword
+  const _continue = 31760; TokenType[TokenType["_continue"] = _continue] = "_continue"; // continue keyword
+  const _debugger = 32272; TokenType[TokenType["_debugger"] = _debugger] = "_debugger"; // debugger keyword
+  const _default = 32784; TokenType[TokenType["_default"] = _default] = "_default"; // default keyword
+  const _do = 33296; TokenType[TokenType["_do"] = _do] = "_do"; // do keyword
+  const _else = 33808; TokenType[TokenType["_else"] = _else] = "_else"; // else keyword
+  const _finally = 34320; TokenType[TokenType["_finally"] = _finally] = "_finally"; // finally keyword
+  const _for = 34832; TokenType[TokenType["_for"] = _for] = "_for"; // for keyword
+  const _function = 35344; TokenType[TokenType["_function"] = _function] = "_function"; // function keyword
+  const _if = 35856; TokenType[TokenType["_if"] = _if] = "_if"; // if keyword
+  const _return = 36368; TokenType[TokenType["_return"] = _return] = "_return"; // return keyword
+  const _switch = 36880; TokenType[TokenType["_switch"] = _switch] = "_switch"; // switch keyword
+  const _throw = 37520; TokenType[TokenType["_throw"] = _throw] = "_throw"; // throw keyword prefix
+  const _try = 37904; TokenType[TokenType["_try"] = _try] = "_try"; // try keyword
+  const _var = 38416; TokenType[TokenType["_var"] = _var] = "_var"; // var keyword
+  const _let = 38928; TokenType[TokenType["_let"] = _let] = "_let"; // let keyword
+  const _const = 39440; TokenType[TokenType["_const"] = _const] = "_const"; // const keyword
+  const _while = 39952; TokenType[TokenType["_while"] = _while] = "_while"; // while keyword
+  const _with = 40464; TokenType[TokenType["_with"] = _with] = "_with"; // with keyword
+  const _new = 40976; TokenType[TokenType["_new"] = _new] = "_new"; // new keyword
+  const _this = 41488; TokenType[TokenType["_this"] = _this] = "_this"; // this keyword
+  const _super = 42000; TokenType[TokenType["_super"] = _super] = "_super"; // super keyword
+  const _class = 42512; TokenType[TokenType["_class"] = _class] = "_class"; // class keyword
+  const _extends = 43024; TokenType[TokenType["_extends"] = _extends] = "_extends"; // extends keyword
+  const _export = 43536; TokenType[TokenType["_export"] = _export] = "_export"; // export keyword
+  const _import = 44048; TokenType[TokenType["_import"] = _import] = "_import"; // import keyword
+  const _yield = 44560; TokenType[TokenType["_yield"] = _yield] = "_yield"; // yield keyword
+  const _null = 45072; TokenType[TokenType["_null"] = _null] = "_null"; // null keyword
+  const _true = 45584; TokenType[TokenType["_true"] = _true] = "_true"; // true keyword
+  const _false = 46096; TokenType[TokenType["_false"] = _false] = "_false"; // false keyword
+  const _in = 46616; TokenType[TokenType["_in"] = _in] = "_in"; // in prec:8 keyword
+  const _instanceof = 47128; TokenType[TokenType["_instanceof"] = _instanceof] = "_instanceof"; // instanceof prec:8 keyword
+  const _typeof = 47760; TokenType[TokenType["_typeof"] = _typeof] = "_typeof"; // typeof keyword prefix
+  const _void = 48272; TokenType[TokenType["_void"] = _void] = "_void"; // void keyword prefix
+  const _delete = 48784; TokenType[TokenType["_delete"] = _delete] = "_delete"; // delete keyword prefix
+  const _async = 49168; TokenType[TokenType["_async"] = _async] = "_async"; // async keyword
+  const _get = 49680; TokenType[TokenType["_get"] = _get] = "_get"; // get keyword
+  const _set = 50192; TokenType[TokenType["_set"] = _set] = "_set"; // set keyword
+  const _declare = 50704; TokenType[TokenType["_declare"] = _declare] = "_declare"; // declare keyword
+  const _readonly = 51216; TokenType[TokenType["_readonly"] = _readonly] = "_readonly"; // readonly keyword
+  const _abstract = 51728; TokenType[TokenType["_abstract"] = _abstract] = "_abstract"; // abstract keyword
+  const _static = 52240; TokenType[TokenType["_static"] = _static] = "_static"; // static keyword
+  const _public = 52752; TokenType[TokenType["_public"] = _public] = "_public"; // public keyword
+  const _private = 53264; TokenType[TokenType["_private"] = _private] = "_private"; // private keyword
+  const _protected = 53776; TokenType[TokenType["_protected"] = _protected] = "_protected"; // protected keyword
+  const _override = 54288; TokenType[TokenType["_override"] = _override] = "_override"; // override keyword
+  const _as = 54800; TokenType[TokenType["_as"] = _as] = "_as"; // as keyword
+  const _enum = 55312; TokenType[TokenType["_enum"] = _enum] = "_enum"; // enum keyword
+  const _type = 55824; TokenType[TokenType["_type"] = _type] = "_type"; // type keyword
+  const _implements = 56336; TokenType[TokenType["_implements"] = _implements] = "_implements"; // implements keyword
 })(TokenType || (TokenType = {}));
 function formatTokenType(tokenType) {
   switch (tokenType) {
@@ -16822,83 +15716,88 @@ function formatTokenType(tokenType) {
       return "";
   }
 }
+
 class Scope {
+  
+  
+  
+
   constructor(startTokenIndex, endTokenIndex, isFunctionScope) {
     this.startTokenIndex = startTokenIndex;
     this.endTokenIndex = endTokenIndex;
     this.isFunctionScope = isFunctionScope;
   }
 }
+
 class StateSnapshot {
-  constructor(potentialArrowAt, noAnonFunctionType, tokensLength, scopesLength, pos, type, contextualKeyword, start, end, isType, scopeDepth, error) {
-    this.potentialArrowAt = potentialArrowAt;
-    this.noAnonFunctionType = noAnonFunctionType;
-    this.tokensLength = tokensLength;
-    this.scopesLength = scopesLength;
-    this.pos = pos;
-    this.type = type;
-    this.contextualKeyword = contextualKeyword;
-    this.start = start;
-    this.end = end;
-    this.isType = isType;
-    this.scopeDepth = scopeDepth;
-    this.error = error;
-  }
+  constructor(
+     potentialArrowAt,
+     noAnonFunctionType,
+     tokensLength,
+     scopesLength,
+     pos,
+     type,
+     contextualKeyword,
+     start,
+     end,
+     isType,
+     scopeDepth,
+     error,
+  ) {this.potentialArrowAt = potentialArrowAt;this.noAnonFunctionType = noAnonFunctionType;this.tokensLength = tokensLength;this.scopesLength = scopesLength;this.pos = pos;this.type = type;this.contextualKeyword = contextualKeyword;this.start = start;this.end = end;this.isType = isType;this.scopeDepth = scopeDepth;this.error = error;}
 }
-class State {
-  constructor() {
-    State.prototype.__init.call(this);
-    State.prototype.__init2.call(this);
-    State.prototype.__init3.call(this);
-    State.prototype.__init4.call(this);
-    State.prototype.__init5.call(this);
-    State.prototype.__init6.call(this);
-    State.prototype.__init7.call(this);
-    State.prototype.__init8.call(this);
-    State.prototype.__init9.call(this);
-    State.prototype.__init10.call(this);
-    State.prototype.__init11.call(this);
-    State.prototype.__init12.call(this);
-  }
-  __init() {
-    this.potentialArrowAt = -1;
-  }
-  __init2() {
-    this.noAnonFunctionType = false;
-  }
-  __init3() {
-    this.tokens = [];
-  }
-  __init4() {
-    this.scopes = [];
-  }
-  __init5() {
-    this.pos = 0;
-  }
-  __init6() {
-    this.type = TokenType.eof;
-  }
-  __init7() {
-    this.contextualKeyword = ContextualKeyword.NONE;
-  }
-  __init8() {
-    this.start = 0;
-  }
-  __init9() {
-    this.end = 0;
-  }
-  __init10() {
-    this.isType = false;
-  }
-  __init11() {
-    this.scopeDepth = 0;
-  }
-  __init12() {
-    this.error = null;
-  }
+
+class State {constructor() { State.prototype.__init.call(this);State.prototype.__init2.call(this);State.prototype.__init3.call(this);State.prototype.__init4.call(this);State.prototype.__init5.call(this);State.prototype.__init6.call(this);State.prototype.__init7.call(this);State.prototype.__init8.call(this);State.prototype.__init9.call(this);State.prototype.__init10.call(this);State.prototype.__init11.call(this);State.prototype.__init12.call(this); }
+  // Used to signify the start of a potential arrow function
+  __init() {this.potentialArrowAt = -1;}
+
+  // Used by Flow to handle an edge case involving function type parsing.
+  __init2() {this.noAnonFunctionType = false;}
+
+  // Token store.
+  __init3() {this.tokens = [];}
+
+  // Array of all observed scopes, ordered by their ending position.
+  __init4() {this.scopes = [];}
+
+  // The current position of the tokenizer in the input.
+  __init5() {this.pos = 0;}
+
+  // Information about the current token.
+  __init6() {this.type = TokenType.eof;}
+  __init7() {this.contextualKeyword = ContextualKeyword.NONE;}
+  __init8() {this.start = 0;}
+  __init9() {this.end = 0;}
+
+  __init10() {this.isType = false;}
+  __init11() {this.scopeDepth = 0;}
+
+  /**
+   * If the parser is in an error state, then the token is always tt.eof and all functions can
+   * keep executing but should be written so they don't get into an infinite loop in this situation.
+   *
+   * This approach, combined with the ability to snapshot and restore state, allows us to implement
+   * backtracking without exceptions and without needing to explicitly propagate error states
+   * everywhere.
+   */
+  __init12() {this.error = null;}
+
   snapshot() {
-    return new StateSnapshot(this.potentialArrowAt, this.noAnonFunctionType, this.tokens.length, this.scopes.length, this.pos, this.type, this.contextualKeyword, this.start, this.end, this.isType, this.scopeDepth, this.error);
+    return new StateSnapshot(
+      this.potentialArrowAt,
+      this.noAnonFunctionType,
+      this.tokens.length,
+      this.scopes.length,
+      this.pos,
+      this.type,
+      this.contextualKeyword,
+      this.start,
+      this.end,
+      this.isType,
+      this.scopeDepth,
+      this.error,
+    );
   }
+
   restoreFromSnapshot(snapshot) {
     this.potentialArrowAt = snapshot.potentialArrowAt;
     this.noAnonFunctionType = snapshot.noAnonFunctionType;
@@ -16914,224 +15813,126 @@ class State {
     this.error = snapshot.error;
   }
 }
-var charCodes;
-(function(charCodes2) {
-  const backSpace = 8;
-  charCodes2[charCodes2["backSpace"] = backSpace] = "backSpace";
-  const lineFeed = 10;
-  charCodes2[charCodes2["lineFeed"] = lineFeed] = "lineFeed";
-  const carriageReturn = 13;
-  charCodes2[charCodes2["carriageReturn"] = carriageReturn] = "carriageReturn";
-  const shiftOut = 14;
-  charCodes2[charCodes2["shiftOut"] = shiftOut] = "shiftOut";
-  const space = 32;
-  charCodes2[charCodes2["space"] = space] = "space";
-  const exclamationMark = 33;
-  charCodes2[charCodes2["exclamationMark"] = exclamationMark] = "exclamationMark";
-  const quotationMark = 34;
-  charCodes2[charCodes2["quotationMark"] = quotationMark] = "quotationMark";
-  const numberSign = 35;
-  charCodes2[charCodes2["numberSign"] = numberSign] = "numberSign";
-  const dollarSign = 36;
-  charCodes2[charCodes2["dollarSign"] = dollarSign] = "dollarSign";
-  const percentSign = 37;
-  charCodes2[charCodes2["percentSign"] = percentSign] = "percentSign";
-  const ampersand = 38;
-  charCodes2[charCodes2["ampersand"] = ampersand] = "ampersand";
-  const apostrophe = 39;
-  charCodes2[charCodes2["apostrophe"] = apostrophe] = "apostrophe";
-  const leftParenthesis = 40;
-  charCodes2[charCodes2["leftParenthesis"] = leftParenthesis] = "leftParenthesis";
-  const rightParenthesis = 41;
-  charCodes2[charCodes2["rightParenthesis"] = rightParenthesis] = "rightParenthesis";
-  const asterisk = 42;
-  charCodes2[charCodes2["asterisk"] = asterisk] = "asterisk";
-  const plusSign = 43;
-  charCodes2[charCodes2["plusSign"] = plusSign] = "plusSign";
-  const comma = 44;
-  charCodes2[charCodes2["comma"] = comma] = "comma";
-  const dash = 45;
-  charCodes2[charCodes2["dash"] = dash] = "dash";
-  const dot = 46;
-  charCodes2[charCodes2["dot"] = dot] = "dot";
-  const slash = 47;
-  charCodes2[charCodes2["slash"] = slash] = "slash";
-  const digit0 = 48;
-  charCodes2[charCodes2["digit0"] = digit0] = "digit0";
-  const digit1 = 49;
-  charCodes2[charCodes2["digit1"] = digit1] = "digit1";
-  const digit2 = 50;
-  charCodes2[charCodes2["digit2"] = digit2] = "digit2";
-  const digit3 = 51;
-  charCodes2[charCodes2["digit3"] = digit3] = "digit3";
-  const digit4 = 52;
-  charCodes2[charCodes2["digit4"] = digit4] = "digit4";
-  const digit5 = 53;
-  charCodes2[charCodes2["digit5"] = digit5] = "digit5";
-  const digit6 = 54;
-  charCodes2[charCodes2["digit6"] = digit6] = "digit6";
-  const digit7 = 55;
-  charCodes2[charCodes2["digit7"] = digit7] = "digit7";
-  const digit8 = 56;
-  charCodes2[charCodes2["digit8"] = digit8] = "digit8";
-  const digit9 = 57;
-  charCodes2[charCodes2["digit9"] = digit9] = "digit9";
-  const colon = 58;
-  charCodes2[charCodes2["colon"] = colon] = "colon";
-  const semicolon2 = 59;
-  charCodes2[charCodes2["semicolon"] = semicolon2] = "semicolon";
-  const lessThan = 60;
-  charCodes2[charCodes2["lessThan"] = lessThan] = "lessThan";
-  const equalsTo = 61;
-  charCodes2[charCodes2["equalsTo"] = equalsTo] = "equalsTo";
-  const greaterThan = 62;
-  charCodes2[charCodes2["greaterThan"] = greaterThan] = "greaterThan";
-  const questionMark = 63;
-  charCodes2[charCodes2["questionMark"] = questionMark] = "questionMark";
-  const atSign = 64;
-  charCodes2[charCodes2["atSign"] = atSign] = "atSign";
-  const uppercaseA = 65;
-  charCodes2[charCodes2["uppercaseA"] = uppercaseA] = "uppercaseA";
-  const uppercaseB = 66;
-  charCodes2[charCodes2["uppercaseB"] = uppercaseB] = "uppercaseB";
-  const uppercaseC = 67;
-  charCodes2[charCodes2["uppercaseC"] = uppercaseC] = "uppercaseC";
-  const uppercaseD = 68;
-  charCodes2[charCodes2["uppercaseD"] = uppercaseD] = "uppercaseD";
-  const uppercaseE = 69;
-  charCodes2[charCodes2["uppercaseE"] = uppercaseE] = "uppercaseE";
-  const uppercaseF = 70;
-  charCodes2[charCodes2["uppercaseF"] = uppercaseF] = "uppercaseF";
-  const uppercaseG = 71;
-  charCodes2[charCodes2["uppercaseG"] = uppercaseG] = "uppercaseG";
-  const uppercaseH = 72;
-  charCodes2[charCodes2["uppercaseH"] = uppercaseH] = "uppercaseH";
-  const uppercaseI = 73;
-  charCodes2[charCodes2["uppercaseI"] = uppercaseI] = "uppercaseI";
-  const uppercaseJ = 74;
-  charCodes2[charCodes2["uppercaseJ"] = uppercaseJ] = "uppercaseJ";
-  const uppercaseK = 75;
-  charCodes2[charCodes2["uppercaseK"] = uppercaseK] = "uppercaseK";
-  const uppercaseL = 76;
-  charCodes2[charCodes2["uppercaseL"] = uppercaseL] = "uppercaseL";
-  const uppercaseM = 77;
-  charCodes2[charCodes2["uppercaseM"] = uppercaseM] = "uppercaseM";
-  const uppercaseN = 78;
-  charCodes2[charCodes2["uppercaseN"] = uppercaseN] = "uppercaseN";
-  const uppercaseO = 79;
-  charCodes2[charCodes2["uppercaseO"] = uppercaseO] = "uppercaseO";
-  const uppercaseP = 80;
-  charCodes2[charCodes2["uppercaseP"] = uppercaseP] = "uppercaseP";
-  const uppercaseQ = 81;
-  charCodes2[charCodes2["uppercaseQ"] = uppercaseQ] = "uppercaseQ";
-  const uppercaseR = 82;
-  charCodes2[charCodes2["uppercaseR"] = uppercaseR] = "uppercaseR";
-  const uppercaseS = 83;
-  charCodes2[charCodes2["uppercaseS"] = uppercaseS] = "uppercaseS";
-  const uppercaseT = 84;
-  charCodes2[charCodes2["uppercaseT"] = uppercaseT] = "uppercaseT";
-  const uppercaseU = 85;
-  charCodes2[charCodes2["uppercaseU"] = uppercaseU] = "uppercaseU";
-  const uppercaseV = 86;
-  charCodes2[charCodes2["uppercaseV"] = uppercaseV] = "uppercaseV";
-  const uppercaseW = 87;
-  charCodes2[charCodes2["uppercaseW"] = uppercaseW] = "uppercaseW";
-  const uppercaseX = 88;
-  charCodes2[charCodes2["uppercaseX"] = uppercaseX] = "uppercaseX";
-  const uppercaseY = 89;
-  charCodes2[charCodes2["uppercaseY"] = uppercaseY] = "uppercaseY";
-  const uppercaseZ = 90;
-  charCodes2[charCodes2["uppercaseZ"] = uppercaseZ] = "uppercaseZ";
-  const leftSquareBracket = 91;
-  charCodes2[charCodes2["leftSquareBracket"] = leftSquareBracket] = "leftSquareBracket";
-  const backslash = 92;
-  charCodes2[charCodes2["backslash"] = backslash] = "backslash";
-  const rightSquareBracket = 93;
-  charCodes2[charCodes2["rightSquareBracket"] = rightSquareBracket] = "rightSquareBracket";
-  const caret = 94;
-  charCodes2[charCodes2["caret"] = caret] = "caret";
-  const underscore = 95;
-  charCodes2[charCodes2["underscore"] = underscore] = "underscore";
-  const graveAccent = 96;
-  charCodes2[charCodes2["graveAccent"] = graveAccent] = "graveAccent";
-  const lowercaseA = 97;
-  charCodes2[charCodes2["lowercaseA"] = lowercaseA] = "lowercaseA";
-  const lowercaseB = 98;
-  charCodes2[charCodes2["lowercaseB"] = lowercaseB] = "lowercaseB";
-  const lowercaseC = 99;
-  charCodes2[charCodes2["lowercaseC"] = lowercaseC] = "lowercaseC";
-  const lowercaseD = 100;
-  charCodes2[charCodes2["lowercaseD"] = lowercaseD] = "lowercaseD";
-  const lowercaseE = 101;
-  charCodes2[charCodes2["lowercaseE"] = lowercaseE] = "lowercaseE";
-  const lowercaseF = 102;
-  charCodes2[charCodes2["lowercaseF"] = lowercaseF] = "lowercaseF";
-  const lowercaseG = 103;
-  charCodes2[charCodes2["lowercaseG"] = lowercaseG] = "lowercaseG";
-  const lowercaseH = 104;
-  charCodes2[charCodes2["lowercaseH"] = lowercaseH] = "lowercaseH";
-  const lowercaseI = 105;
-  charCodes2[charCodes2["lowercaseI"] = lowercaseI] = "lowercaseI";
-  const lowercaseJ = 106;
-  charCodes2[charCodes2["lowercaseJ"] = lowercaseJ] = "lowercaseJ";
-  const lowercaseK = 107;
-  charCodes2[charCodes2["lowercaseK"] = lowercaseK] = "lowercaseK";
-  const lowercaseL = 108;
-  charCodes2[charCodes2["lowercaseL"] = lowercaseL] = "lowercaseL";
-  const lowercaseM = 109;
-  charCodes2[charCodes2["lowercaseM"] = lowercaseM] = "lowercaseM";
-  const lowercaseN = 110;
-  charCodes2[charCodes2["lowercaseN"] = lowercaseN] = "lowercaseN";
-  const lowercaseO = 111;
-  charCodes2[charCodes2["lowercaseO"] = lowercaseO] = "lowercaseO";
-  const lowercaseP = 112;
-  charCodes2[charCodes2["lowercaseP"] = lowercaseP] = "lowercaseP";
-  const lowercaseQ = 113;
-  charCodes2[charCodes2["lowercaseQ"] = lowercaseQ] = "lowercaseQ";
-  const lowercaseR = 114;
-  charCodes2[charCodes2["lowercaseR"] = lowercaseR] = "lowercaseR";
-  const lowercaseS = 115;
-  charCodes2[charCodes2["lowercaseS"] = lowercaseS] = "lowercaseS";
-  const lowercaseT = 116;
-  charCodes2[charCodes2["lowercaseT"] = lowercaseT] = "lowercaseT";
-  const lowercaseU = 117;
-  charCodes2[charCodes2["lowercaseU"] = lowercaseU] = "lowercaseU";
-  const lowercaseV = 118;
-  charCodes2[charCodes2["lowercaseV"] = lowercaseV] = "lowercaseV";
-  const lowercaseW = 119;
-  charCodes2[charCodes2["lowercaseW"] = lowercaseW] = "lowercaseW";
-  const lowercaseX = 120;
-  charCodes2[charCodes2["lowercaseX"] = lowercaseX] = "lowercaseX";
-  const lowercaseY = 121;
-  charCodes2[charCodes2["lowercaseY"] = lowercaseY] = "lowercaseY";
-  const lowercaseZ = 122;
-  charCodes2[charCodes2["lowercaseZ"] = lowercaseZ] = "lowercaseZ";
-  const leftCurlyBrace = 123;
-  charCodes2[charCodes2["leftCurlyBrace"] = leftCurlyBrace] = "leftCurlyBrace";
-  const verticalBar = 124;
-  charCodes2[charCodes2["verticalBar"] = verticalBar] = "verticalBar";
-  const rightCurlyBrace = 125;
-  charCodes2[charCodes2["rightCurlyBrace"] = rightCurlyBrace] = "rightCurlyBrace";
-  const tilde = 126;
-  charCodes2[charCodes2["tilde"] = tilde] = "tilde";
-  const nonBreakingSpace = 160;
-  charCodes2[charCodes2["nonBreakingSpace"] = nonBreakingSpace] = "nonBreakingSpace";
-  const oghamSpaceMark = 5760;
-  charCodes2[charCodes2["oghamSpaceMark"] = oghamSpaceMark] = "oghamSpaceMark";
-  const lineSeparator = 8232;
-  charCodes2[charCodes2["lineSeparator"] = lineSeparator] = "lineSeparator";
-  const paragraphSeparator = 8233;
-  charCodes2[charCodes2["paragraphSeparator"] = paragraphSeparator] = "paragraphSeparator";
+
+var charCodes; (function (charCodes) {
+  const backSpace = 8; charCodes[charCodes["backSpace"] = backSpace] = "backSpace";
+  const lineFeed = 10; charCodes[charCodes["lineFeed"] = lineFeed] = "lineFeed"; //  '\n'
+  const carriageReturn = 13; charCodes[charCodes["carriageReturn"] = carriageReturn] = "carriageReturn"; //  '\r'
+  const shiftOut = 14; charCodes[charCodes["shiftOut"] = shiftOut] = "shiftOut";
+  const space = 32; charCodes[charCodes["space"] = space] = "space";
+  const exclamationMark = 33; charCodes[charCodes["exclamationMark"] = exclamationMark] = "exclamationMark"; //  '!'
+  const quotationMark = 34; charCodes[charCodes["quotationMark"] = quotationMark] = "quotationMark"; //  '"'
+  const numberSign = 35; charCodes[charCodes["numberSign"] = numberSign] = "numberSign"; //  '#'
+  const dollarSign = 36; charCodes[charCodes["dollarSign"] = dollarSign] = "dollarSign"; //  '$'
+  const percentSign = 37; charCodes[charCodes["percentSign"] = percentSign] = "percentSign"; //  '%'
+  const ampersand = 38; charCodes[charCodes["ampersand"] = ampersand] = "ampersand"; //  '&'
+  const apostrophe = 39; charCodes[charCodes["apostrophe"] = apostrophe] = "apostrophe"; //  '''
+  const leftParenthesis = 40; charCodes[charCodes["leftParenthesis"] = leftParenthesis] = "leftParenthesis"; //  '('
+  const rightParenthesis = 41; charCodes[charCodes["rightParenthesis"] = rightParenthesis] = "rightParenthesis"; //  ')'
+  const asterisk = 42; charCodes[charCodes["asterisk"] = asterisk] = "asterisk"; //  '*'
+  const plusSign = 43; charCodes[charCodes["plusSign"] = plusSign] = "plusSign"; //  '+'
+  const comma = 44; charCodes[charCodes["comma"] = comma] = "comma"; //  ','
+  const dash = 45; charCodes[charCodes["dash"] = dash] = "dash"; //  '-'
+  const dot = 46; charCodes[charCodes["dot"] = dot] = "dot"; //  '.'
+  const slash = 47; charCodes[charCodes["slash"] = slash] = "slash"; //  '/'
+  const digit0 = 48; charCodes[charCodes["digit0"] = digit0] = "digit0"; //  '0'
+  const digit1 = 49; charCodes[charCodes["digit1"] = digit1] = "digit1"; //  '1'
+  const digit2 = 50; charCodes[charCodes["digit2"] = digit2] = "digit2"; //  '2'
+  const digit3 = 51; charCodes[charCodes["digit3"] = digit3] = "digit3"; //  '3'
+  const digit4 = 52; charCodes[charCodes["digit4"] = digit4] = "digit4"; //  '4'
+  const digit5 = 53; charCodes[charCodes["digit5"] = digit5] = "digit5"; //  '5'
+  const digit6 = 54; charCodes[charCodes["digit6"] = digit6] = "digit6"; //  '6'
+  const digit7 = 55; charCodes[charCodes["digit7"] = digit7] = "digit7"; //  '7'
+  const digit8 = 56; charCodes[charCodes["digit8"] = digit8] = "digit8"; //  '8'
+  const digit9 = 57; charCodes[charCodes["digit9"] = digit9] = "digit9"; //  '9'
+  const colon = 58; charCodes[charCodes["colon"] = colon] = "colon"; //  ':'
+  const semicolon = 59; charCodes[charCodes["semicolon"] = semicolon] = "semicolon"; //  ';'
+  const lessThan = 60; charCodes[charCodes["lessThan"] = lessThan] = "lessThan"; //  '<'
+  const equalsTo = 61; charCodes[charCodes["equalsTo"] = equalsTo] = "equalsTo"; //  '='
+  const greaterThan = 62; charCodes[charCodes["greaterThan"] = greaterThan] = "greaterThan"; //  '>'
+  const questionMark = 63; charCodes[charCodes["questionMark"] = questionMark] = "questionMark"; //  '?'
+  const atSign = 64; charCodes[charCodes["atSign"] = atSign] = "atSign"; //  '@'
+  const uppercaseA = 65; charCodes[charCodes["uppercaseA"] = uppercaseA] = "uppercaseA"; //  'A'
+  const uppercaseB = 66; charCodes[charCodes["uppercaseB"] = uppercaseB] = "uppercaseB"; //  'B'
+  const uppercaseC = 67; charCodes[charCodes["uppercaseC"] = uppercaseC] = "uppercaseC"; //  'C'
+  const uppercaseD = 68; charCodes[charCodes["uppercaseD"] = uppercaseD] = "uppercaseD"; //  'D'
+  const uppercaseE = 69; charCodes[charCodes["uppercaseE"] = uppercaseE] = "uppercaseE"; //  'E'
+  const uppercaseF = 70; charCodes[charCodes["uppercaseF"] = uppercaseF] = "uppercaseF"; //  'F'
+  const uppercaseG = 71; charCodes[charCodes["uppercaseG"] = uppercaseG] = "uppercaseG"; //  'G'
+  const uppercaseH = 72; charCodes[charCodes["uppercaseH"] = uppercaseH] = "uppercaseH"; //  'H'
+  const uppercaseI = 73; charCodes[charCodes["uppercaseI"] = uppercaseI] = "uppercaseI"; //  'I'
+  const uppercaseJ = 74; charCodes[charCodes["uppercaseJ"] = uppercaseJ] = "uppercaseJ"; //  'J'
+  const uppercaseK = 75; charCodes[charCodes["uppercaseK"] = uppercaseK] = "uppercaseK"; //  'K'
+  const uppercaseL = 76; charCodes[charCodes["uppercaseL"] = uppercaseL] = "uppercaseL"; //  'L'
+  const uppercaseM = 77; charCodes[charCodes["uppercaseM"] = uppercaseM] = "uppercaseM"; //  'M'
+  const uppercaseN = 78; charCodes[charCodes["uppercaseN"] = uppercaseN] = "uppercaseN"; //  'N'
+  const uppercaseO = 79; charCodes[charCodes["uppercaseO"] = uppercaseO] = "uppercaseO"; //  'O'
+  const uppercaseP = 80; charCodes[charCodes["uppercaseP"] = uppercaseP] = "uppercaseP"; //  'P'
+  const uppercaseQ = 81; charCodes[charCodes["uppercaseQ"] = uppercaseQ] = "uppercaseQ"; //  'Q'
+  const uppercaseR = 82; charCodes[charCodes["uppercaseR"] = uppercaseR] = "uppercaseR"; //  'R'
+  const uppercaseS = 83; charCodes[charCodes["uppercaseS"] = uppercaseS] = "uppercaseS"; //  'S'
+  const uppercaseT = 84; charCodes[charCodes["uppercaseT"] = uppercaseT] = "uppercaseT"; //  'T'
+  const uppercaseU = 85; charCodes[charCodes["uppercaseU"] = uppercaseU] = "uppercaseU"; //  'U'
+  const uppercaseV = 86; charCodes[charCodes["uppercaseV"] = uppercaseV] = "uppercaseV"; //  'V'
+  const uppercaseW = 87; charCodes[charCodes["uppercaseW"] = uppercaseW] = "uppercaseW"; //  'W'
+  const uppercaseX = 88; charCodes[charCodes["uppercaseX"] = uppercaseX] = "uppercaseX"; //  'X'
+  const uppercaseY = 89; charCodes[charCodes["uppercaseY"] = uppercaseY] = "uppercaseY"; //  'Y'
+  const uppercaseZ = 90; charCodes[charCodes["uppercaseZ"] = uppercaseZ] = "uppercaseZ"; //  'Z'
+  const leftSquareBracket = 91; charCodes[charCodes["leftSquareBracket"] = leftSquareBracket] = "leftSquareBracket"; //  '['
+  const backslash = 92; charCodes[charCodes["backslash"] = backslash] = "backslash"; //  '\    '
+  const rightSquareBracket = 93; charCodes[charCodes["rightSquareBracket"] = rightSquareBracket] = "rightSquareBracket"; //  ']'
+  const caret = 94; charCodes[charCodes["caret"] = caret] = "caret"; //  '^'
+  const underscore = 95; charCodes[charCodes["underscore"] = underscore] = "underscore"; //  '_'
+  const graveAccent = 96; charCodes[charCodes["graveAccent"] = graveAccent] = "graveAccent"; //  '`'
+  const lowercaseA = 97; charCodes[charCodes["lowercaseA"] = lowercaseA] = "lowercaseA"; //  'a'
+  const lowercaseB = 98; charCodes[charCodes["lowercaseB"] = lowercaseB] = "lowercaseB"; //  'b'
+  const lowercaseC = 99; charCodes[charCodes["lowercaseC"] = lowercaseC] = "lowercaseC"; //  'c'
+  const lowercaseD = 100; charCodes[charCodes["lowercaseD"] = lowercaseD] = "lowercaseD"; //  'd'
+  const lowercaseE = 101; charCodes[charCodes["lowercaseE"] = lowercaseE] = "lowercaseE"; //  'e'
+  const lowercaseF = 102; charCodes[charCodes["lowercaseF"] = lowercaseF] = "lowercaseF"; //  'f'
+  const lowercaseG = 103; charCodes[charCodes["lowercaseG"] = lowercaseG] = "lowercaseG"; //  'g'
+  const lowercaseH = 104; charCodes[charCodes["lowercaseH"] = lowercaseH] = "lowercaseH"; //  'h'
+  const lowercaseI = 105; charCodes[charCodes["lowercaseI"] = lowercaseI] = "lowercaseI"; //  'i'
+  const lowercaseJ = 106; charCodes[charCodes["lowercaseJ"] = lowercaseJ] = "lowercaseJ"; //  'j'
+  const lowercaseK = 107; charCodes[charCodes["lowercaseK"] = lowercaseK] = "lowercaseK"; //  'k'
+  const lowercaseL = 108; charCodes[charCodes["lowercaseL"] = lowercaseL] = "lowercaseL"; //  'l'
+  const lowercaseM = 109; charCodes[charCodes["lowercaseM"] = lowercaseM] = "lowercaseM"; //  'm'
+  const lowercaseN = 110; charCodes[charCodes["lowercaseN"] = lowercaseN] = "lowercaseN"; //  'n'
+  const lowercaseO = 111; charCodes[charCodes["lowercaseO"] = lowercaseO] = "lowercaseO"; //  'o'
+  const lowercaseP = 112; charCodes[charCodes["lowercaseP"] = lowercaseP] = "lowercaseP"; //  'p'
+  const lowercaseQ = 113; charCodes[charCodes["lowercaseQ"] = lowercaseQ] = "lowercaseQ"; //  'q'
+  const lowercaseR = 114; charCodes[charCodes["lowercaseR"] = lowercaseR] = "lowercaseR"; //  'r'
+  const lowercaseS = 115; charCodes[charCodes["lowercaseS"] = lowercaseS] = "lowercaseS"; //  's'
+  const lowercaseT = 116; charCodes[charCodes["lowercaseT"] = lowercaseT] = "lowercaseT"; //  't'
+  const lowercaseU = 117; charCodes[charCodes["lowercaseU"] = lowercaseU] = "lowercaseU"; //  'u'
+  const lowercaseV = 118; charCodes[charCodes["lowercaseV"] = lowercaseV] = "lowercaseV"; //  'v'
+  const lowercaseW = 119; charCodes[charCodes["lowercaseW"] = lowercaseW] = "lowercaseW"; //  'w'
+  const lowercaseX = 120; charCodes[charCodes["lowercaseX"] = lowercaseX] = "lowercaseX"; //  'x'
+  const lowercaseY = 121; charCodes[charCodes["lowercaseY"] = lowercaseY] = "lowercaseY"; //  'y'
+  const lowercaseZ = 122; charCodes[charCodes["lowercaseZ"] = lowercaseZ] = "lowercaseZ"; //  'z'
+  const leftCurlyBrace = 123; charCodes[charCodes["leftCurlyBrace"] = leftCurlyBrace] = "leftCurlyBrace"; //  '{'
+  const verticalBar = 124; charCodes[charCodes["verticalBar"] = verticalBar] = "verticalBar"; //  '|'
+  const rightCurlyBrace = 125; charCodes[charCodes["rightCurlyBrace"] = rightCurlyBrace] = "rightCurlyBrace"; //  '}'
+  const tilde = 126; charCodes[charCodes["tilde"] = tilde] = "tilde"; //  '~'
+  const nonBreakingSpace = 160; charCodes[charCodes["nonBreakingSpace"] = nonBreakingSpace] = "nonBreakingSpace";
+  // eslint-disable-next-line no-irregular-whitespace
+  const oghamSpaceMark = 5760; charCodes[charCodes["oghamSpaceMark"] = oghamSpaceMark] = "oghamSpaceMark"; // ''
+  const lineSeparator = 8232; charCodes[charCodes["lineSeparator"] = lineSeparator] = "lineSeparator";
+  const paragraphSeparator = 8233; charCodes[charCodes["paragraphSeparator"] = paragraphSeparator] = "paragraphSeparator";
 })(charCodes || (charCodes = {}));
+
 let isJSXEnabled;
 let isTypeScriptEnabled;
 let isFlowEnabled;
 let state;
 let input;
 let nextContextId;
+
 function getNextContextId() {
   return nextContextId++;
 }
+
+// eslint-disable-next-line @typescript-eslint/no-explicit-any
 function augmentError(error) {
   if ("pos" in error) {
     const loc = locationForIndex(error.pos);
@@ -17140,12 +15941,16 @@ function augmentError(error) {
   }
   return error;
 }
+
 class Loc {
+  
+  
   constructor(line, column) {
     this.line = line;
     this.column = column;
   }
 }
+
 function locationForIndex(pos) {
   let line = 1;
   let column = 1;
@@ -17159,7 +15964,13 @@ function locationForIndex(pos) {
   }
   return new Loc(line, column);
 }
-function initParser(inputCode, isJSXEnabledArg, isTypeScriptEnabledArg, isFlowEnabledArg) {
+
+function initParser(
+  inputCode,
+  isJSXEnabledArg,
+  isTypeScriptEnabledArg,
+  isFlowEnabledArg,
+) {
   input = inputCode;
   state = new State();
   nextContextId = 1;
@@ -17167,114 +15978,149 @@ function initParser(inputCode, isJSXEnabledArg, isTypeScriptEnabledArg, isFlowEn
   isTypeScriptEnabled = isTypeScriptEnabledArg;
   isFlowEnabled = isFlowEnabledArg;
 }
+
+// ## Parser utilities
+
+// Tests whether parsed token is a contextual keyword.
 function isContextual(contextualKeyword) {
   return state.contextualKeyword === contextualKeyword;
 }
+
 function isLookaheadContextual(contextualKeyword) {
   const l = lookaheadTypeAndKeyword();
   return l.type === TokenType.name && l.contextualKeyword === contextualKeyword;
 }
+
+// Consumes contextual keyword if possible.
 function eatContextual(contextualKeyword) {
   return state.contextualKeyword === contextualKeyword && eat(TokenType.name);
 }
+
+// Asserts that following token is given contextual keyword.
 function expectContextual(contextualKeyword) {
   if (!eatContextual(contextualKeyword)) {
     unexpected();
   }
 }
+
+// Test whether a semicolon can be inserted at the current position.
 function canInsertSemicolon() {
   return match(TokenType.eof) || match(TokenType.braceR) || hasPrecedingLineBreak();
 }
+
 function hasPrecedingLineBreak() {
   const prevToken = state.tokens[state.tokens.length - 1];
   const lastTokEnd = prevToken ? prevToken.end : 0;
   for (let i = lastTokEnd; i < state.start; i++) {
     const code = input.charCodeAt(i);
-    if (code === charCodes.lineFeed || code === charCodes.carriageReturn || code === 8232 || code === 8233) {
+    if (
+      code === charCodes.lineFeed ||
+      code === charCodes.carriageReturn ||
+      code === 0x2028 ||
+      code === 0x2029
+    ) {
       return true;
     }
   }
   return false;
 }
+
 function hasFollowingLineBreak() {
   const nextStart = nextTokenStart();
   for (let i = state.end; i < nextStart; i++) {
     const code = input.charCodeAt(i);
-    if (code === charCodes.lineFeed || code === charCodes.carriageReturn || code === 8232 || code === 8233) {
+    if (
+      code === charCodes.lineFeed ||
+      code === charCodes.carriageReturn ||
+      code === 0x2028 ||
+      code === 0x2029
+    ) {
       return true;
     }
   }
   return false;
 }
+
 function isLineTerminator() {
   return eat(TokenType.semi) || canInsertSemicolon();
 }
+
+// Consume a semicolon, or, failing that, see if we are allowed to
+// pretend that there is a semicolon at this position.
 function semicolon() {
   if (!isLineTerminator()) {
     unexpected('Unexpected token, expected ";"');
   }
 }
+
+// Expect a token of a given type. If found, consume it, otherwise,
+// raise an unexpected token error at given pos.
 function expect(type) {
   const matched = eat(type);
   if (!matched) {
     unexpected(`Unexpected token, expected "${formatTokenType(type)}"`);
   }
 }
+
+/**
+ * Transition the parser to an error state. All code needs to be written to naturally unwind in this
+ * state, which allows us to backtrack without exceptions and without error plumbing everywhere.
+ */
 function unexpected(message = "Unexpected token", pos = state.start) {
   if (state.error) {
     return;
   }
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
   const err = new SyntaxError(message);
   err.pos = pos;
   state.error = err;
   state.pos = input.length;
   finishToken(TokenType.eof);
 }
+
+// https://tc39.github.io/ecma262/#sec-white-space
 const WHITESPACE_CHARS = [
-  9,
-  11,
-  12,
+  0x0009,
+  0x000b,
+  0x000c,
   charCodes.space,
   charCodes.nonBreakingSpace,
   charCodes.oghamSpaceMark,
-  8192,
-  8193,
-  8194,
-  8195,
-  8196,
-  8197,
-  8198,
-  8199,
-  8200,
-  8201,
-  8202,
-  8239,
-  8287,
-  12288,
-  65279
+  0x2000, // EN QUAD
+  0x2001, // EM QUAD
+  0x2002, // EN SPACE
+  0x2003, // EM SPACE
+  0x2004, // THREE-PER-EM SPACE
+  0x2005, // FOUR-PER-EM SPACE
+  0x2006, // SIX-PER-EM SPACE
+  0x2007, // FIGURE SPACE
+  0x2008, // PUNCTUATION SPACE
+  0x2009, // THIN SPACE
+  0x200a, // HAIR SPACE
+  0x202f, // NARROW NO-BREAK SPACE
+  0x205f, // MEDIUM MATHEMATICAL SPACE
+  0x3000, // IDEOGRAPHIC SPACE
+  0xfeff, // ZERO WIDTH NO-BREAK SPACE
 ];
+
 const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
+
 const IS_WHITESPACE = new Uint8Array(65536);
 for (const char of WHITESPACE_CHARS) {
   IS_WHITESPACE[char] = 1;
 }
+
 function computeIsIdentifierChar(code) {
-  if (code < 48)
-    return code === 36;
-  if (code < 58)
-    return true;
-  if (code < 65)
-    return false;
-  if (code < 91)
-    return true;
-  if (code < 97)
-    return code === 95;
-  if (code < 123)
-    return true;
-  if (code < 128)
-    return false;
+  if (code < 48) return code === 36;
+  if (code < 58) return true;
+  if (code < 65) return false;
+  if (code < 91) return true;
+  if (code < 97) return code === 95;
+  if (code < 123) return true;
+  if (code < 128) return false;
   throw new Error("Should not be called with non-ASCII char code.");
 }
+
 const IS_IDENTIFIER_CHAR = new Uint8Array(65536);
 for (let i = 0; i < 128; i++) {
   IS_IDENTIFIER_CHAR[i] = computeIsIdentifierChar(i) ? 1 : 0;
@@ -17282,8279 +16128,644 @@ for (let i = 0; i < 128; i++) {
 for (let i = 128; i < 65536; i++) {
   IS_IDENTIFIER_CHAR[i] = 1;
 }
+// Aside from whitespace and newlines, all characters outside the ASCII space are either
+// identifier characters or invalid. Since we're not performing code validation, we can just
+// treat all invalid characters as identifier characters.
 for (const whitespaceChar of WHITESPACE_CHARS) {
   IS_IDENTIFIER_CHAR[whitespaceChar] = 0;
 }
-IS_IDENTIFIER_CHAR[8232] = 0;
-IS_IDENTIFIER_CHAR[8233] = 0;
+IS_IDENTIFIER_CHAR[0x2028] = 0;
+IS_IDENTIFIER_CHAR[0x2029] = 0;
+
 const IS_IDENTIFIER_START = IS_IDENTIFIER_CHAR.slice();
 for (let numChar = charCodes.digit0; numChar <= charCodes.digit9; numChar++) {
   IS_IDENTIFIER_START[numChar] = 0;
 }
+
+// Generated file, do not edit! Run "yarn generate" to re-generate this file.
+
+// prettier-ignore
 const READ_WORD_TREE = new Int32Array([
-  -1,
-  27,
-  594,
-  729,
-  1566,
-  2187,
-  2673,
-  3294,
-  -1,
-  3510,
-  -1,
-  4428,
-  4563,
-  4644,
-  4941,
-  5319,
-  5697,
-  -1,
-  6237,
-  6696,
-  7155,
-  7587,
-  7749,
-  7911,
-  -1,
-  8127,
-  -1,
-  -1,
-  -1,
-  54,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  243,
-  -1,
-  -1,
-  -1,
-  486,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  81,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  108,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  135,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  162,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  189,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  216,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._abstract << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._as << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  270,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  405,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  297,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  324,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  351,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  378,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._asserts << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  432,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  459,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._async << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  513,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  540,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  567,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._await << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  621,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  648,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  675,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  702,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._break << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  756,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  918,
-  -1,
-  -1,
-  -1,
-  1053,
-  -1,
-  -1,
-  1161,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  783,
-  837,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  810,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._case << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  864,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  891,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._catch << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  945,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  972,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  999,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1026,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._checks << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1080,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1107,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1134,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._class << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1188,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1215,
-  1431,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1242,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._const << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1269,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1296,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1323,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1350,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1377,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1404,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._constructor << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1458,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1485,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1512,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1539,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._continue << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1593,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2160,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1620,
-  1782,
-  -1,
-  -1,
-  1917,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2052,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1647,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1674,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1701,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1728,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1755,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._debugger << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1809,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1836,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1863,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1890,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._declare << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1944,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1971,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  1998,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2025,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._default << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2079,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2106,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2133,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._delete << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._do << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2214,
-  -1,
-  2295,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2376,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2241,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2268,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._else << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2322,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2349,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._enum << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2403,
-  -1,
-  -1,
-  -1,
-  2538,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2430,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2457,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2484,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._export << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2511,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._exports << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2565,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2592,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2619,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2646,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._extends << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2700,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2808,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2970,
-  -1,
-  -1,
-  3024,
-  -1,
-  -1,
-  3105,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2727,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2754,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2781,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._false << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2835,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2862,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2889,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2916,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2943,
-  -1,
-  (TokenType._finally << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  2997,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._for << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3051,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3078,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._from << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3132,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3159,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3186,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3213,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3240,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3267,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._function << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3321,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3375,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3348,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._get << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3402,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3429,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3456,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3483,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._global << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3537,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3564,
-  3888,
-  -1,
-  -1,
-  -1,
-  -1,
-  4401,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._if << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3591,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3618,
-  -1,
-  -1,
-  3807,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3645,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3672,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3699,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3726,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3753,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3780,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._implements << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3834,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3861,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._import << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._in << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3915,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3996,
-  4212,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3942,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  3969,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._infer << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4023,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4050,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4077,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4104,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4131,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4158,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4185,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._instanceof << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4239,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4266,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4293,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4320,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4347,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4374,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._interface << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._is << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4455,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4482,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4509,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4536,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._keyof << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4590,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4617,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._let << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4671,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4806,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4698,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4725,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4752,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4779,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._mixins << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4833,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4860,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4887,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4914,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._module << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4968,
-  -1,
-  -1,
-  -1,
-  5184,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5238,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  4995,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5022,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5049,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5076,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5103,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5130,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5157,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._namespace << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5211,
-  -1,
-  -1,
-  -1,
-  (TokenType._new << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5265,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5292,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._null << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5346,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5373,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5508,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._of << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5400,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5427,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5454,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5481,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._opaque << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5535,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5562,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5589,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5616,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5643,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5670,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._override << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5724,
-  -1,
-  -1,
-  6102,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5751,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5886,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5778,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5805,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5832,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5859,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._private << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5913,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5940,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6075,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5967,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  5994,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6021,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6048,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._protected << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._proto << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6129,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6156,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6183,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6210,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._public << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6264,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6291,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6453,
-  -1,
-  -1,
-  6588,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6318,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6345,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6372,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6399,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6426,
-  -1,
-  ContextualKeyword._readonly << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6480,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6507,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6534,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6561,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._require << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6615,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6642,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6669,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._return << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6723,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6777,
-  6912,
-  -1,
-  7020,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6750,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._set << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6804,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6831,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6858,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6885,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._static << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6939,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6966,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  6993,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._super << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7047,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7074,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7101,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7128,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._switch << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7182,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7344,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7452,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7209,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7263,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7236,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._this << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7290,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7317,
-  -1,
-  -1,
-  -1,
-  (TokenType._throw << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7371,
-  -1,
-  -1,
-  -1,
-  7425,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7398,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._true << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._try << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7479,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7506,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._type << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7533,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7560,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._typeof << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7614,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7641,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7668,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7695,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7722,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  ContextualKeyword._unique << 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7776,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7830,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7803,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._var << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7857,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7884,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._void << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7938,
-  8046,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7965,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  7992,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  8019,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._while << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  8073,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  8100,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._with << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  8154,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  8181,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  8208,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  8235,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  (TokenType._yield << 1) + 1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1,
-  -1
+  // ""
+  -1, 27, 594, 729, 1566, 2187, 2673, 3294, -1, 3510, -1, 4428, 4563, 4644, 4941, 5319, 5697, -1, 6237, 6696, 7155, 7587, 7749, 7911, -1, 8127, -1,
+  // "a"
+  -1, -1, 54, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 243, -1, -1, -1, 486, -1, -1, -1,
+  // "ab"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, -1, -1, -1, -1, -1,
+  // "abs"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, -1, -1, -1, -1, -1, -1,
+  // "abst"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 135, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "abstr"
+  -1, 162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "abstra"
+  -1, -1, -1, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "abstrac"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1, -1, -1, -1, -1,
+  // "abstract"
+  ContextualKeyword._abstract << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "as"
+  ContextualKeyword._as << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 270, -1, -1, -1, -1, -1, 405, -1,
+  // "ass"
+  -1, -1, -1, -1, -1, 297, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "asse"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 324, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "asser"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 351, -1, -1, -1, -1, -1, -1,
+  // "assert"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 378, -1, -1, -1, -1, -1, -1, -1,
+  // "asserts"
+  ContextualKeyword._asserts << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "asy"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 432, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "asyn"
+  -1, -1, -1, 459, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "async"
+  ContextualKeyword._async << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "aw"
+  -1, 513, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "awa"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 540, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "awai"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 567, -1, -1, -1, -1, -1, -1,
+  // "await"
+  ContextualKeyword._await << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "b"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 621, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "br"
+  -1, -1, -1, -1, -1, 648, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "bre"
+  -1, 675, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "brea"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 702, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "break"
+  (TokenType._break << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "c"
+  -1, 756, -1, -1, -1, -1, -1, -1, 918, -1, -1, -1, 1053, -1, -1, 1161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "ca"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 783, 837, -1, -1, -1, -1, -1, -1,
+  // "cas"
+  -1, -1, -1, -1, -1, 810, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "case"
+  (TokenType._case << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "cat"
+  -1, -1, -1, 864, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "catc"
+  -1, -1, -1, -1, -1, -1, -1, -1, 891, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "catch"
+  (TokenType._catch << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "ch"
+  -1, -1, -1, -1, -1, 945, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "che"
+  -1, -1, -1, 972, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "chec"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 999, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "check"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1026, -1, -1, -1, -1, -1, -1, -1,
+  // "checks"
+  ContextualKeyword._checks << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "cl"
+  -1, 1080, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "cla"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1107, -1, -1, -1, -1, -1, -1, -1,
+  // "clas"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1134, -1, -1, -1, -1, -1, -1, -1,
+  // "class"
+  (TokenType._class << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "co"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1188, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "con"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1215, 1431, -1, -1, -1, -1, -1, -1,
+  // "cons"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1242, -1, -1, -1, -1, -1, -1,
+  // "const"
+  (TokenType._const << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1269, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "constr"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1296, -1, -1, -1, -1, -1,
+  // "constru"
+  -1, -1, -1, 1323, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "construc"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1350, -1, -1, -1, -1, -1, -1,
+  // "construct"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1377, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "constructo"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1404, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "constructor"
+  ContextualKeyword._constructor << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "cont"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 1458, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "conti"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1485, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "contin"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1512, -1, -1, -1, -1, -1,
+  // "continu"
+  -1, -1, -1, -1, -1, 1539, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "continue"
+  (TokenType._continue << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "d"
+  -1, -1, -1, -1, -1, 1593, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2160, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "de"
+  -1, -1, 1620, 1782, -1, -1, 1917, -1, -1, -1, -1, -1, 2052, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "deb"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1647, -1, -1, -1, -1, -1,
+  // "debu"
+  -1, -1, -1, -1, -1, -1, -1, 1674, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "debug"
+  -1, -1, -1, -1, -1, -1, -1, 1701, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "debugg"
+  -1, -1, -1, -1, -1, 1728, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "debugge"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1755, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "debugger"
+  (TokenType._debugger << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "dec"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1809, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "decl"
+  -1, 1836, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "decla"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1863, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "declar"
+  -1, -1, -1, -1, -1, 1890, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "declare"
+  ContextualKeyword._declare << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "def"
+  -1, 1944, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "defa"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1971, -1, -1, -1, -1, -1,
+  // "defau"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1998, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "defaul"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2025, -1, -1, -1, -1, -1, -1,
+  // "default"
+  (TokenType._default << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "del"
+  -1, -1, -1, -1, -1, 2079, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "dele"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2106, -1, -1, -1, -1, -1, -1,
+  // "delet"
+  -1, -1, -1, -1, -1, 2133, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "delete"
+  (TokenType._delete << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "do"
+  (TokenType._do << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "e"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2214, -1, 2295, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2376, -1, -1,
+  // "el"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2241, -1, -1, -1, -1, -1, -1, -1,
+  // "els"
+  -1, -1, -1, -1, -1, 2268, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "else"
+  (TokenType._else << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "en"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2322, -1, -1, -1, -1, -1,
+  // "enu"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2349, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "enum"
+  ContextualKeyword._enum << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "ex"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2403, -1, -1, -1, 2538, -1, -1, -1, -1, -1, -1,
+  // "exp"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2430, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "expo"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2457, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "expor"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2484, -1, -1, -1, -1, -1, -1,
+  // "export"
+  (TokenType._export << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2511, -1, -1, -1, -1, -1, -1, -1,
+  // "exports"
+  ContextualKeyword._exports << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "ext"
+  -1, -1, -1, -1, -1, 2565, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "exte"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2592, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "exten"
+  -1, -1, -1, -1, 2619, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "extend"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2646, -1, -1, -1, -1, -1, -1, -1,
+  // "extends"
+  (TokenType._extends << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "f"
+  -1, 2700, -1, -1, -1, -1, -1, -1, -1, 2808, -1, -1, -1, -1, -1, 2970, -1, -1, 3024, -1, -1, 3105, -1, -1, -1, -1, -1,
+  // "fa"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2727, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "fal"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2754, -1, -1, -1, -1, -1, -1, -1,
+  // "fals"
+  -1, -1, -1, -1, -1, 2781, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "false"
+  (TokenType._false << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "fi"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2835, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "fin"
+  -1, 2862, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "fina"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2889, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "final"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2916, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "finall"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2943, -1,
+  // "finally"
+  (TokenType._finally << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "fo"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2997, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "for"
+  (TokenType._for << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "fr"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3051, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "fro"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3078, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "from"
+  ContextualKeyword._from << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "fu"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3132, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "fun"
+  -1, -1, -1, 3159, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "func"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3186, -1, -1, -1, -1, -1, -1,
+  // "funct"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 3213, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "functi"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3240, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "functio"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3267, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "function"
+  (TokenType._function << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "g"
+  -1, -1, -1, -1, -1, 3321, -1, -1, -1, -1, -1, -1, 3375, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "ge"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3348, -1, -1, -1, -1, -1, -1,
+  // "get"
+  ContextualKeyword._get << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "gl"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3402, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "glo"
+  -1, -1, 3429, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "glob"
+  -1, 3456, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "globa"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3483, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "global"
+  ContextualKeyword._global << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "i"
+  -1, -1, -1, -1, -1, -1, 3537, -1, -1, -1, -1, -1, -1, 3564, 3888, -1, -1, -1, -1, 4401, -1, -1, -1, -1, -1, -1, -1,
+  // "if"
+  (TokenType._if << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "im"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3591, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "imp"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3618, -1, -1, 3807, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "impl"
+  -1, -1, -1, -1, -1, 3645, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "imple"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3672, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "implem"
+  -1, -1, -1, -1, -1, 3699, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "impleme"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3726, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "implemen"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3753, -1, -1, -1, -1, -1, -1,
+  // "implement"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3780, -1, -1, -1, -1, -1, -1, -1,
+  // "implements"
+  ContextualKeyword._implements << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "impo"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3834, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "impor"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3861, -1, -1, -1, -1, -1, -1,
+  // "import"
+  (TokenType._import << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "in"
+  (TokenType._in << 1) + 1, -1, -1, -1, -1, -1, 3915, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3996, 4212, -1, -1, -1, -1, -1, -1,
+  // "inf"
+  -1, -1, -1, -1, -1, 3942, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "infe"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3969, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "infer"
+  ContextualKeyword._infer << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "ins"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4023, -1, -1, -1, -1, -1, -1,
+  // "inst"
+  -1, 4050, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "insta"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4077, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "instan"
+  -1, -1, -1, 4104, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "instanc"
+  -1, -1, -1, -1, -1, 4131, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "instance"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4158, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "instanceo"
+  -1, -1, -1, -1, -1, -1, 4185, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "instanceof"
+  (TokenType._instanceof << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "int"
+  -1, -1, -1, -1, -1, 4239, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "inte"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4266, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "inter"
+  -1, -1, -1, -1, -1, -1, 4293, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "interf"
+  -1, 4320, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "interfa"
+  -1, -1, -1, 4347, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "interfac"
+  -1, -1, -1, -1, -1, 4374, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "interface"
+  ContextualKeyword._interface << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "is"
+  ContextualKeyword._is << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "k"
+  -1, -1, -1, -1, -1, 4455, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "ke"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4482, -1,
+  // "key"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4509, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "keyo"
+  -1, -1, -1, -1, -1, -1, 4536, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "keyof"
+  ContextualKeyword._keyof << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "l"
+  -1, -1, -1, -1, -1, 4590, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "le"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4617, -1, -1, -1, -1, -1, -1,
+  // "let"
+  (TokenType._let << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "m"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 4671, -1, -1, -1, -1, -1, 4806, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "mi"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4698, -1, -1,
+  // "mix"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 4725, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "mixi"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4752, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "mixin"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4779, -1, -1, -1, -1, -1, -1, -1,
+  // "mixins"
+  ContextualKeyword._mixins << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "mo"
+  -1, -1, -1, -1, 4833, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "mod"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4860, -1, -1, -1, -1, -1,
+  // "modu"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4887, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "modul"
+  -1, -1, -1, -1, -1, 4914, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "module"
+  ContextualKeyword._module << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "n"
+  -1, 4968, -1, -1, -1, 5184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5238, -1, -1, -1, -1, -1,
+  // "na"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4995, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "nam"
+  -1, -1, -1, -1, -1, 5022, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "name"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5049, -1, -1, -1, -1, -1, -1, -1,
+  // "names"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5076, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "namesp"
+  -1, 5103, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "namespa"
+  -1, -1, -1, 5130, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "namespac"
+  -1, -1, -1, -1, -1, 5157, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "namespace"
+  ContextualKeyword._namespace << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "ne"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5211, -1, -1, -1,
+  // "new"
+  (TokenType._new << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "nu"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "nul"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5292, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "null"
+  (TokenType._null << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "o"
+  -1, -1, -1, -1, -1, -1, 5346, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5373, -1, -1, -1, -1, -1, 5508, -1, -1, -1, -1,
+  // "of"
+  ContextualKeyword._of << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "op"
+  -1, 5400, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "opa"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5427, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "opaq"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5454, -1, -1, -1, -1, -1,
+  // "opaqu"
+  -1, -1, -1, -1, -1, 5481, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "opaque"
+  ContextualKeyword._opaque << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "ov"
+  -1, -1, -1, -1, -1, 5535, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "ove"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5562, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "over"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5589, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "overr"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 5616, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "overri"
+  -1, -1, -1, -1, 5643, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "overrid"
+  -1, -1, -1, -1, -1, 5670, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "override"
+  ContextualKeyword._override << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "p"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5724, -1, -1, 6102, -1, -1, -1, -1, -1,
+  // "pr"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 5751, -1, -1, -1, -1, -1, 5886, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "pri"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5778, -1, -1, -1, -1,
+  // "priv"
+  -1, 5805, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "priva"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5832, -1, -1, -1, -1, -1, -1,
+  // "privat"
+  -1, -1, -1, -1, -1, 5859, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "private"
+  ContextualKeyword._private << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "pro"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5913, -1, -1, -1, -1, -1, -1,
+  // "prot"
+  -1, -1, -1, -1, -1, 5940, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6075, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "prote"
+  -1, -1, -1, 5967, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "protec"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5994, -1, -1, -1, -1, -1, -1,
+  // "protect"
+  -1, -1, -1, -1, -1, 6021, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "protecte"
+  -1, -1, -1, -1, 6048, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "protected"
+  ContextualKeyword._protected << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "proto"
+  ContextualKeyword._proto << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "pu"
+  -1, -1, 6129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "pub"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6156, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "publ"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 6183, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "publi"
+  -1, -1, -1, 6210, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "public"
+  ContextualKeyword._public << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "r"
+  -1, -1, -1, -1, -1, 6264, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "re"
+  -1, 6291, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6453, -1, -1, 6588, -1, -1, -1, -1, -1, -1,
+  // "rea"
+  -1, -1, -1, -1, 6318, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "read"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6345, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "reado"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6372, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "readon"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6399, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "readonl"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6426, -1,
+  // "readonly"
+  ContextualKeyword._readonly << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "req"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6480, -1, -1, -1, -1, -1,
+  // "requ"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 6507, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "requi"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6534, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "requir"
+  -1, -1, -1, -1, -1, 6561, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "require"
+  ContextualKeyword._require << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "ret"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6615, -1, -1, -1, -1, -1,
+  // "retu"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6642, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "retur"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6669, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "return"
+  (TokenType._return << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "s"
+  -1, -1, -1, -1, -1, 6723, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6777, 6912, -1, 7020, -1, -1, -1,
+  // "se"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6750, -1, -1, -1, -1, -1, -1,
+  // "set"
+  ContextualKeyword._set << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "st"
+  -1, 6804, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "sta"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6831, -1, -1, -1, -1, -1, -1,
+  // "stat"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 6858, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "stati"
+  -1, -1, -1, 6885, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "static"
+  ContextualKeyword._static << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "su"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6939, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "sup"
+  -1, -1, -1, -1, -1, 6966, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "supe"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6993, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "super"
+  (TokenType._super << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "sw"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 7047, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "swi"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7074, -1, -1, -1, -1, -1, -1,
+  // "swit"
+  -1, -1, -1, 7101, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "switc"
+  -1, -1, -1, -1, -1, -1, -1, -1, 7128, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "switch"
+  (TokenType._switch << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "t"
+  -1, -1, -1, -1, -1, -1, -1, -1, 7182, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7344, -1, -1, -1, -1, -1, -1, 7452, -1,
+  // "th"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 7209, -1, -1, -1, -1, -1, -1, -1, -1, 7263, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "thi"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7236, -1, -1, -1, -1, -1, -1, -1,
+  // "this"
+  (TokenType._this << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "thr"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7290, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "thro"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7317, -1, -1, -1,
+  // "throw"
+  (TokenType._throw << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "tr"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7371, -1, -1, -1, 7425, -1,
+  // "tru"
+  -1, -1, -1, -1, -1, 7398, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "true"
+  (TokenType._true << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "try"
+  (TokenType._try << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "ty"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7479, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "typ"
+  -1, -1, -1, -1, -1, 7506, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "type"
+  ContextualKeyword._type << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7533, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "typeo"
+  -1, -1, -1, -1, -1, -1, 7560, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "typeof"
+  (TokenType._typeof << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "u"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7614, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "un"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 7641, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "uni"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7668, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "uniq"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7695, -1, -1, -1, -1, -1,
+  // "uniqu"
+  -1, -1, -1, -1, -1, 7722, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "unique"
+  ContextualKeyword._unique << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "v"
+  -1, 7776, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7830, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "va"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7803, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "var"
+  (TokenType._var << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "vo"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 7857, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "voi"
+  -1, -1, -1, -1, 7884, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "void"
+  (TokenType._void << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "w"
+  -1, -1, -1, -1, -1, -1, -1, -1, 7938, 8046, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "wh"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 7965, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "whi"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7992, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "whil"
+  -1, -1, -1, -1, -1, 8019, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "while"
+  (TokenType._while << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "wi"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8073, -1, -1, -1, -1, -1, -1,
+  // "wit"
+  -1, -1, -1, -1, -1, -1, -1, -1, 8100, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "with"
+  (TokenType._with << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "y"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, 8154, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "yi"
+  -1, -1, -1, -1, -1, 8181, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "yie"
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8208, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "yiel"
+  -1, -1, -1, -1, 8235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  // "yield"
+  (TokenType._yield << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 ]);
+
+/**
+ * Read an identifier, producing either a name token or matching on one of the existing keywords.
+ * For performance, we pre-generate big decision tree that we traverse. Each node represents a
+ * prefix and has 27 values, where the first value is the token or contextual token, if any (-1 if
+ * not), and the other 26 values are the transitions to other nodes, or -1 to stop.
+ */
 function readWord() {
   let treePos = 0;
   let code = 0;
@@ -25564,14 +16775,15 @@ function readWord() {
     if (code < charCodes.lowercaseA || code > charCodes.lowercaseZ) {
       break;
     }
-    const next2 = READ_WORD_TREE[treePos + (code - charCodes.lowercaseA) + 1];
-    if (next2 === -1) {
+    const next = READ_WORD_TREE[treePos + (code - charCodes.lowercaseA) + 1];
+    if (next === -1) {
       break;
     } else {
-      treePos = next2;
+      treePos = next;
       pos++;
     }
   }
+
   const keywordValue = READ_WORD_TREE[treePos];
   if (keywordValue > -1 && !IS_IDENTIFIER_CHAR[code]) {
     state.pos = pos;
@@ -25582,11 +16794,13 @@ function readWord() {
     }
     return;
   }
+
   while (pos < input.length) {
     const ch = input.charCodeAt(pos);
     if (IS_IDENTIFIER_CHAR[ch]) {
       pos++;
     } else if (ch === charCodes.backslash) {
+      // \u
       pos += 2;
       if (input.charCodeAt(pos) === charCodes.leftCurlyBrace) {
         while (pos < input.length && input.charCodeAt(pos) !== charCodes.rightCurlyBrace) {
@@ -25603,56 +16817,88 @@ function readWord() {
   state.pos = pos;
   finishToken(TokenType.name);
 }
-var IdentifierRole;
-(function(IdentifierRole2) {
-  const Access = 0;
-  IdentifierRole2[IdentifierRole2["Access"] = Access] = "Access";
-  const ExportAccess = Access + 1;
-  IdentifierRole2[IdentifierRole2["ExportAccess"] = ExportAccess] = "ExportAccess";
-  const TopLevelDeclaration = ExportAccess + 1;
-  IdentifierRole2[IdentifierRole2["TopLevelDeclaration"] = TopLevelDeclaration] = "TopLevelDeclaration";
-  const FunctionScopedDeclaration = TopLevelDeclaration + 1;
-  IdentifierRole2[IdentifierRole2["FunctionScopedDeclaration"] = FunctionScopedDeclaration] = "FunctionScopedDeclaration";
-  const BlockScopedDeclaration = FunctionScopedDeclaration + 1;
-  IdentifierRole2[IdentifierRole2["BlockScopedDeclaration"] = BlockScopedDeclaration] = "BlockScopedDeclaration";
-  const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1;
-  IdentifierRole2[IdentifierRole2["ObjectShorthandTopLevelDeclaration"] = ObjectShorthandTopLevelDeclaration] = "ObjectShorthandTopLevelDeclaration";
-  const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1;
-  IdentifierRole2[IdentifierRole2["ObjectShorthandFunctionScopedDeclaration"] = ObjectShorthandFunctionScopedDeclaration] = "ObjectShorthandFunctionScopedDeclaration";
-  const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1;
-  IdentifierRole2[IdentifierRole2["ObjectShorthandBlockScopedDeclaration"] = ObjectShorthandBlockScopedDeclaration] = "ObjectShorthandBlockScopedDeclaration";
-  const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1;
-  IdentifierRole2[IdentifierRole2["ObjectShorthand"] = ObjectShorthand] = "ObjectShorthand";
-  const ImportDeclaration = ObjectShorthand + 1;
-  IdentifierRole2[IdentifierRole2["ImportDeclaration"] = ImportDeclaration] = "ImportDeclaration";
-  const ObjectKey = ImportDeclaration + 1;
-  IdentifierRole2[IdentifierRole2["ObjectKey"] = ObjectKey] = "ObjectKey";
-  const ImportAccess = ObjectKey + 1;
-  IdentifierRole2[IdentifierRole2["ImportAccess"] = ImportAccess] = "ImportAccess";
+
+/* eslint max-len: 0 */
+
+var IdentifierRole; (function (IdentifierRole) {
+  const Access = 0; IdentifierRole[IdentifierRole["Access"] = Access] = "Access";
+  const ExportAccess = Access + 1; IdentifierRole[IdentifierRole["ExportAccess"] = ExportAccess] = "ExportAccess";
+  const TopLevelDeclaration = ExportAccess + 1; IdentifierRole[IdentifierRole["TopLevelDeclaration"] = TopLevelDeclaration] = "TopLevelDeclaration";
+  const FunctionScopedDeclaration = TopLevelDeclaration + 1; IdentifierRole[IdentifierRole["FunctionScopedDeclaration"] = FunctionScopedDeclaration] = "FunctionScopedDeclaration";
+  const BlockScopedDeclaration = FunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole["BlockScopedDeclaration"] = BlockScopedDeclaration] = "BlockScopedDeclaration";
+  const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1; IdentifierRole[IdentifierRole["ObjectShorthandTopLevelDeclaration"] = ObjectShorthandTopLevelDeclaration] = "ObjectShorthandTopLevelDeclaration";
+  const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1; IdentifierRole[IdentifierRole["ObjectShorthandFunctionScopedDeclaration"] = ObjectShorthandFunctionScopedDeclaration] = "ObjectShorthandFunctionScopedDeclaration";
+  const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole["ObjectShorthandBlockScopedDeclaration"] = ObjectShorthandBlockScopedDeclaration] = "ObjectShorthandBlockScopedDeclaration";
+  const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1; IdentifierRole[IdentifierRole["ObjectShorthand"] = ObjectShorthand] = "ObjectShorthand";
+  // Any identifier bound in an import statement, e.g. both A and b from
+  // `import A, * as b from 'A';`
+  const ImportDeclaration = ObjectShorthand + 1; IdentifierRole[IdentifierRole["ImportDeclaration"] = ImportDeclaration] = "ImportDeclaration";
+  const ObjectKey = ImportDeclaration + 1; IdentifierRole[IdentifierRole["ObjectKey"] = ObjectKey] = "ObjectKey";
+  // The `foo` in `import {foo as bar} from "./abc";`.
+  const ImportAccess = ObjectKey + 1; IdentifierRole[IdentifierRole["ImportAccess"] = ImportAccess] = "ImportAccess";
 })(IdentifierRole || (IdentifierRole = {}));
+
 function isDeclaration(token) {
   const role = token.identifierRole;
-  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
+  return (
+    role === IdentifierRole.TopLevelDeclaration ||
+    role === IdentifierRole.FunctionScopedDeclaration ||
+    role === IdentifierRole.BlockScopedDeclaration ||
+    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||
+    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||
+    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration
+  );
 }
+
 function isNonTopLevelDeclaration(token) {
   const role = token.identifierRole;
-  return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
+  return (
+    role === IdentifierRole.FunctionScopedDeclaration ||
+    role === IdentifierRole.BlockScopedDeclaration ||
+    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||
+    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration
+  );
 }
+
 function isTopLevelDeclaration(token) {
   const role = token.identifierRole;
-  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ImportDeclaration;
+  return (
+    role === IdentifierRole.TopLevelDeclaration ||
+    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||
+    role === IdentifierRole.ImportDeclaration
+  );
 }
+
 function isBlockScopedDeclaration(token) {
   const role = token.identifierRole;
-  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
+  // Treat top-level declarations as block scope since the distinction doesn't matter here.
+  return (
+    role === IdentifierRole.TopLevelDeclaration ||
+    role === IdentifierRole.BlockScopedDeclaration ||
+    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||
+    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration
+  );
 }
+
 function isFunctionScopedDeclaration(token) {
   const role = token.identifierRole;
-  return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
+  return (
+    role === IdentifierRole.FunctionScopedDeclaration ||
+    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration
+  );
 }
+
 function isObjectShorthandDeclaration(token) {
-  return token.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration || token.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration || token.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
+  return (
+    token.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration ||
+    token.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration ||
+    token.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration
+  );
 }
+
+// Object type used to represent tokens. Note that normally, tokens
+// simply exist as properties on the parser object. This is only
+// used for the onToken callback and the external tokenizer.
 class Token {
   constructor() {
     this.type = state.type;
@@ -25674,22 +16920,64 @@ class Token {
     this.subscriptStartIndex = null;
     this.nullishStartIndex = null;
   }
+
+  
+  
+  
+  
+  
+  
+  
+  // Initially false for all tokens, then may be computed in a follow-up step that does scope
+  // analysis.
+  
+  // Initially false for all tokens, but may be set during transform to mark it as containing an
+  // await operation.
+  
+  
+  // For assignments, the index of the RHS. For export tokens, the end of the export.
+  
+  // For class tokens, records if the class is a class expression or a class statement.
+  
+  // Number of times to insert a `nullishCoalesce(` snippet before this token.
+  
+  // Number of times to insert a `)` snippet after this token.
+  
+  // If true, insert an `optionalChain([` snippet before this token.
+  
+  // If true, insert a `])` snippet after this token.
+  
+  // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the "root" token for this
+  // subscript chain. This can be used to determine if this chain is an optional chain.
+  
+  // Tag for `??` operators to denote the root token for this nullish coalescing call.
+  
 }
+
+// ## Tokenizer
+
+// Move to the next token
 function next() {
   state.tokens.push(new Token());
   nextToken();
 }
+
+// Call instead of next when inside a template, since that needs to be handled differently.
 function nextTemplateToken() {
   state.tokens.push(new Token());
   state.start = state.pos;
   readTmplToken();
 }
+
+// The tokenizer never parses regexes by default. Instead, the parser is responsible for
+// instructing it to parse a regex when we see a slash at the start of an expression.
 function retokenizeSlashAsRegex() {
   if (state.type === TokenType.assign) {
     --state.pos;
   }
   readRegexp();
 }
+
 function pushTypeContext(existingTokensInType) {
   for (let i = state.tokens.length - existingTokensInType; i < state.tokens.length; i++) {
     state.tokens[i].isType = true;
@@ -25698,9 +16986,11 @@ function pushTypeContext(existingTokensInType) {
   state.isType = true;
   return oldIsType;
 }
+
 function popTypeContext(oldIsType) {
   state.isType = oldIsType;
 }
+
 function eat(type) {
   if (match(type)) {
     next();
@@ -25709,9 +16999,18 @@ function eat(type) {
     return false;
   }
 }
+
+function eatTypeToken(tokenType) {
+  const oldIsType = state.isType;
+  state.isType = true;
+  eat(tokenType);
+  state.isType = oldIsType;
+}
+
 function match(type) {
   return state.type === type;
 }
+
 function lookaheadType() {
   const snapshot = state.snapshot();
   next();
@@ -25719,12 +17018,16 @@ function lookaheadType() {
   state.restoreFromSnapshot(snapshot);
   return type;
 }
+
 class TypeAndKeyword {
+  
+  
   constructor(type, contextualKeyword) {
     this.type = type;
     this.contextualKeyword = contextualKeyword;
   }
 }
+
 function lookaheadTypeAndKeyword() {
   const snapshot = state.snapshot();
   next();
@@ -25733,23 +17036,36 @@ function lookaheadTypeAndKeyword() {
   state.restoreFromSnapshot(snapshot);
   return new TypeAndKeyword(type, contextualKeyword);
 }
+
 function nextTokenStart() {
   return nextTokenStartSince(state.pos);
 }
+
 function nextTokenStartSince(pos) {
   skipWhiteSpace.lastIndex = pos;
   const skip = skipWhiteSpace.exec(input);
   return pos + skip[0].length;
 }
+
 function lookaheadCharCode() {
   return input.charCodeAt(nextTokenStart());
 }
+
+// Read a single token, updating the parser object's token-related
+// properties.
 function nextToken() {
   skipSpace();
   state.start = state.pos;
   if (state.pos >= input.length) {
     const tokens = state.tokens;
-    if (tokens.length >= 2 && tokens[tokens.length - 1].start >= input.length && tokens[tokens.length - 2].start >= input.length) {
+    // We normally run past the end a bit, but if we're way past the end, avoid an infinite loop.
+    // Also check the token positions rather than the types since sometimes we rewrite the token
+    // type to something else.
+    if (
+      tokens.length >= 2 &&
+      tokens[tokens.length - 1].start >= input.length &&
+      tokens[tokens.length - 2].start >= input.length
+    ) {
       unexpected("Unexpectedly reached the end of input.");
     }
     finishToken(TokenType.eof);
@@ -25757,15 +17073,26 @@ function nextToken() {
   }
   readToken(input.charCodeAt(state.pos));
 }
+
 function readToken(code) {
-  if (IS_IDENTIFIER_START[code] || code === charCodes.backslash || code === charCodes.atSign && input.charCodeAt(state.pos + 1) === charCodes.atSign) {
+  // Identifier or keyword. '\uXXXX' sequences are allowed in
+  // identifiers, so '\' also dispatches to that.
+  if (
+    IS_IDENTIFIER_START[code] ||
+    code === charCodes.backslash ||
+    (code === charCodes.atSign && input.charCodeAt(state.pos + 1) === charCodes.atSign)
+  ) {
     readWord();
   } else {
     getTokenFromCode(code);
   }
 }
+
 function skipBlockComment() {
-  while (input.charCodeAt(state.pos) !== charCodes.asterisk || input.charCodeAt(state.pos + 1) !== charCodes.slash) {
+  while (
+    input.charCodeAt(state.pos) !== charCodes.asterisk ||
+    input.charCodeAt(state.pos + 1) !== charCodes.slash
+  ) {
     state.pos++;
     if (state.pos > input.length) {
       unexpected("Unterminated comment", state.pos - 2);
@@ -25774,14 +17101,24 @@ function skipBlockComment() {
   }
   state.pos += 2;
 }
+
 function skipLineComment(startSkip) {
-  let ch = input.charCodeAt(state.pos += startSkip);
+  let ch = input.charCodeAt((state.pos += startSkip));
   if (state.pos < input.length) {
-    while (ch !== charCodes.lineFeed && ch !== charCodes.carriageReturn && ch !== charCodes.lineSeparator && ch !== charCodes.paragraphSeparator && ++state.pos < input.length) {
+    while (
+      ch !== charCodes.lineFeed &&
+      ch !== charCodes.carriageReturn &&
+      ch !== charCodes.lineSeparator &&
+      ch !== charCodes.paragraphSeparator &&
+      ++state.pos < input.length
+    ) {
       ch = input.charCodeAt(state.pos);
     }
   }
 }
+
+// Called at the start of the parse and after every token. Skips
+// whitespace and comments.
 function skipSpace() {
   while (state.pos < input.length) {
     const ch = input.charCodeAt(state.pos);
@@ -25790,24 +17127,29 @@ function skipSpace() {
         if (input.charCodeAt(state.pos + 1) === charCodes.lineFeed) {
           ++state.pos;
         }
+
       case charCodes.lineFeed:
       case charCodes.lineSeparator:
       case charCodes.paragraphSeparator:
         ++state.pos;
         break;
+
       case charCodes.slash:
         switch (input.charCodeAt(state.pos + 1)) {
           case charCodes.asterisk:
             state.pos += 2;
             skipBlockComment();
             break;
+
           case charCodes.slash:
             skipLineComment(2);
             break;
+
           default:
             return;
         }
         break;
+
       default:
         if (IS_WHITESPACE[ch]) {
           ++state.pos;
@@ -25817,17 +17159,33 @@ function skipSpace() {
     }
   }
 }
-function finishToken(type, contextualKeyword = ContextualKeyword.NONE) {
+
+// Called at the end of every token. Sets various fields, and skips the space after the token, so
+// that the next one's `start` will point at the right position.
+function finishToken(
+  type,
+  contextualKeyword = ContextualKeyword.NONE,
+) {
   state.end = state.pos;
   state.type = type;
   state.contextualKeyword = contextualKeyword;
 }
+
+// ### Token reading
+
+// This is the function that is called to fetch the next token. It
+// is somewhat obscure, because it works in character codes rather
+// than characters, and because operator parsing has been inlined
+// into it.
+//
+// All in the name of speed.
 function readToken_dot() {
   const nextChar = input.charCodeAt(state.pos + 1);
   if (nextChar >= charCodes.digit0 && nextChar <= charCodes.digit9) {
     readNumber(true);
     return;
   }
+
   if (nextChar === charCodes.dot && input.charCodeAt(state.pos + 2) === charCodes.dot) {
     state.pos += 3;
     finishToken(TokenType.ellipsis);
@@ -25836,6 +17194,7 @@ function readToken_dot() {
     finishToken(TokenType.dot);
   }
 }
+
 function readToken_slash() {
   const nextChar = input.charCodeAt(state.pos + 1);
   if (nextChar === charCodes.equalsTo) {
@@ -25844,47 +17203,69 @@ function readToken_slash() {
     finishOp(TokenType.slash, 1);
   }
 }
+
 function readToken_mult_modulo(code) {
+  // '%*'
   let tokenType = code === charCodes.asterisk ? TokenType.star : TokenType.modulo;
   let width = 1;
   let nextChar = input.charCodeAt(state.pos + 1);
+
+  // Exponentiation operator **
   if (code === charCodes.asterisk && nextChar === charCodes.asterisk) {
     width++;
     nextChar = input.charCodeAt(state.pos + 2);
     tokenType = TokenType.exponent;
   }
-  if (nextChar === charCodes.equalsTo && input.charCodeAt(state.pos + 2) !== charCodes.greaterThan) {
+
+  // Match *= or %=, disallowing *=> which can be valid in flow.
+  if (
+    nextChar === charCodes.equalsTo &&
+    input.charCodeAt(state.pos + 2) !== charCodes.greaterThan
+  ) {
     width++;
     tokenType = TokenType.assign;
   }
+
   finishOp(tokenType, width);
 }
+
 function readToken_pipe_amp(code) {
+  // '|&'
   const nextChar = input.charCodeAt(state.pos + 1);
+
   if (nextChar === code) {
     if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {
+      // ||= or &&=
       finishOp(TokenType.assign, 3);
     } else {
+      // || or &&
       finishOp(code === charCodes.verticalBar ? TokenType.logicalOR : TokenType.logicalAND, 2);
     }
     return;
   }
+
   if (code === charCodes.verticalBar) {
+    // '|>'
     if (nextChar === charCodes.greaterThan) {
       finishOp(TokenType.pipeline, 2);
       return;
     } else if (nextChar === charCodes.rightCurlyBrace && isFlowEnabled) {
+      // '|}'
       finishOp(TokenType.braceBarR, 2);
       return;
     }
   }
+
   if (nextChar === charCodes.equalsTo) {
     finishOp(TokenType.assign, 2);
     return;
   }
+
   finishOp(code === charCodes.verticalBar ? TokenType.bitwiseOR : TokenType.bitwiseAND, 1);
 }
+
 function readToken_caret() {
+  // '^'
   const nextChar = input.charCodeAt(state.pos + 1);
   if (nextChar === charCodes.equalsTo) {
     finishOp(TokenType.assign, 2);
@@ -25892,12 +17273,17 @@ function readToken_caret() {
     finishOp(TokenType.bitwiseXOR, 1);
   }
 }
+
 function readToken_plus_min(code) {
+  // '+-'
   const nextChar = input.charCodeAt(state.pos + 1);
+
   if (nextChar === code) {
+    // Tentatively call this a prefix operator, but it might be changed to postfix later.
     finishOp(TokenType.preIncDec, 2);
     return;
   }
+
   if (nextChar === charCodes.equalsTo) {
     finishOp(TokenType.assign, 2);
   } else if (code === charCodes.plusSign) {
@@ -25906,14 +17292,21 @@ function readToken_plus_min(code) {
     finishOp(TokenType.minus, 1);
   }
 }
+
+// '<>'
 function readToken_lt_gt(code) {
   const nextChar = input.charCodeAt(state.pos + 1);
+
   if (nextChar === code) {
-    const size = code === charCodes.greaterThan && input.charCodeAt(state.pos + 2) === charCodes.greaterThan ? 3 : 2;
+    const size =
+      code === charCodes.greaterThan && input.charCodeAt(state.pos + 2) === charCodes.greaterThan
+        ? 3
+        : 2;
     if (input.charCodeAt(state.pos + size) === charCodes.equalsTo) {
       finishOp(TokenType.assign, size + 1);
       return;
     }
+    // Avoid right-shift for things like Array<Array<string>>.
     if (code === charCodes.greaterThan && state.isType) {
       finishOp(TokenType.greaterThan, 1);
       return;
@@ -25921,7 +17314,9 @@ function readToken_lt_gt(code) {
     finishOp(TokenType.bitShift, size);
     return;
   }
+
   if (nextChar === charCodes.equalsTo) {
+    // <= | >=
     finishOp(TokenType.relationalOrEqual, 2);
   } else if (code === charCodes.lessThan) {
     finishOp(TokenType.lessThan, 1);
@@ -25929,29 +17324,40 @@ function readToken_lt_gt(code) {
     finishOp(TokenType.greaterThan, 1);
   }
 }
+
 function readToken_eq_excl(code) {
+  // '=!'
   const nextChar = input.charCodeAt(state.pos + 1);
   if (nextChar === charCodes.equalsTo) {
     finishOp(TokenType.equality, input.charCodeAt(state.pos + 2) === charCodes.equalsTo ? 3 : 2);
     return;
   }
   if (code === charCodes.equalsTo && nextChar === charCodes.greaterThan) {
+    // '=>'
     state.pos += 2;
     finishToken(TokenType.arrow);
     return;
   }
   finishOp(code === charCodes.equalsTo ? TokenType.eq : TokenType.bang, 1);
 }
+
 function readToken_question() {
+  // '?'
   const nextChar = input.charCodeAt(state.pos + 1);
   const nextChar2 = input.charCodeAt(state.pos + 2);
   if (nextChar === charCodes.questionMark && !state.isType) {
     if (nextChar2 === charCodes.equalsTo) {
+      // '??='
       finishOp(TokenType.assign, 3);
     } else {
+      // '??'
       finishOp(TokenType.nullishCoalescing, 2);
     }
-  } else if (nextChar === charCodes.dot && !(nextChar2 >= charCodes.digit0 && nextChar2 <= charCodes.digit9)) {
+  } else if (
+    nextChar === charCodes.dot &&
+    !(nextChar2 >= charCodes.digit0 && nextChar2 <= charCodes.digit9)
+  ) {
+    // '.' not followed by a number
     state.pos += 2;
     finishToken(TokenType.questionDot);
   } else {
@@ -25959,15 +17365,22 @@ function readToken_question() {
     finishToken(TokenType.question);
   }
 }
+
 function getTokenFromCode(code) {
   switch (code) {
     case charCodes.numberSign:
       ++state.pos;
       finishToken(TokenType.hash);
       return;
+
+    // The interpretation of a dot depends on whether it is followed
+    // by a digit or another two dots.
+
     case charCodes.dot:
       readToken_dot();
       return;
+
+    // Punctuation tokens.
     case charCodes.leftParenthesis:
       ++state.pos;
       finishToken(TokenType.parenL);
@@ -25992,6 +17405,7 @@ function getTokenFromCode(code) {
       ++state.pos;
       finishToken(TokenType.bracketR);
       return;
+
     case charCodes.leftCurlyBrace:
       if (isFlowEnabled && input.charCodeAt(state.pos + 1) === charCodes.verticalBar) {
         finishOp(TokenType.braceBarL, 2);
@@ -26000,10 +17414,12 @@ function getTokenFromCode(code) {
         finishToken(TokenType.braceL);
       }
       return;
+
     case charCodes.rightCurlyBrace:
       ++state.pos;
       finishToken(TokenType.braceR);
       return;
+
     case charCodes.colon:
       if (input.charCodeAt(state.pos + 1) === charCodes.colon) {
         finishOp(TokenType.doubleColon, 2);
@@ -26012,6 +17428,7 @@ function getTokenFromCode(code) {
         finishToken(TokenType.colon);
       }
       return;
+
     case charCodes.questionMark:
       readToken_question();
       return;
@@ -26019,17 +17436,29 @@ function getTokenFromCode(code) {
       ++state.pos;
       finishToken(TokenType.at);
       return;
+
     case charCodes.graveAccent:
       ++state.pos;
       finishToken(TokenType.backQuote);
       return;
+
     case charCodes.digit0: {
       const nextChar = input.charCodeAt(state.pos + 1);
-      if (nextChar === charCodes.lowercaseX || nextChar === charCodes.uppercaseX || nextChar === charCodes.lowercaseO || nextChar === charCodes.uppercaseO || nextChar === charCodes.lowercaseB || nextChar === charCodes.uppercaseB) {
+      // '0x', '0X', '0o', '0O', '0b', '0B'
+      if (
+        nextChar === charCodes.lowercaseX ||
+        nextChar === charCodes.uppercaseX ||
+        nextChar === charCodes.lowercaseO ||
+        nextChar === charCodes.uppercaseO ||
+        nextChar === charCodes.lowercaseB ||
+        nextChar === charCodes.uppercaseB
+      ) {
         readRadixNumber();
         return;
       }
     }
+    // Anything else beginning with a digit is an integer, octal
+    // number, or float.
     case charCodes.digit1:
     case charCodes.digit2:
     case charCodes.digit3:
@@ -26041,51 +17470,69 @@ function getTokenFromCode(code) {
     case charCodes.digit9:
       readNumber(false);
       return;
+
+    // Quotes produce strings.
     case charCodes.quotationMark:
     case charCodes.apostrophe:
       readString(code);
       return;
+
+    // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is
+    // often referred to. `finishOp` simply skips the amount of
+    // characters it is given as second argument, and returns a token
+    // of the type given by its first argument.
+
     case charCodes.slash:
       readToken_slash();
       return;
+
     case charCodes.percentSign:
     case charCodes.asterisk:
       readToken_mult_modulo(code);
       return;
+
     case charCodes.verticalBar:
     case charCodes.ampersand:
       readToken_pipe_amp(code);
       return;
+
     case charCodes.caret:
       readToken_caret();
       return;
+
     case charCodes.plusSign:
     case charCodes.dash:
       readToken_plus_min(code);
       return;
+
     case charCodes.lessThan:
     case charCodes.greaterThan:
       readToken_lt_gt(code);
       return;
+
     case charCodes.equalsTo:
     case charCodes.exclamationMark:
       readToken_eq_excl(code);
       return;
+
     case charCodes.tilde:
       finishOp(TokenType.tilde, 1);
       return;
   }
+
   unexpected(`Unexpected character '${String.fromCharCode(code)}'`, state.pos);
 }
+
 function finishOp(type, size) {
   state.pos += size;
   finishToken(type);
 }
+
 function readRegexp() {
   const start = state.pos;
   let escaped = false;
   let inClass = false;
-  for (; ; ) {
+  for (;;) {
     if (state.pos >= input.length) {
       unexpected("Unterminated regular expression", start);
       return;
@@ -26106,24 +17553,37 @@ function readRegexp() {
     ++state.pos;
   }
   ++state.pos;
+  // Need to use `skipWord` because '\uXXXX' sequences are allowed here (don't ask).
   skipWord();
+
   finishToken(TokenType.regexp);
 }
+
+// Read an integer. We allow any valid digit, including hex digits, plus numeric separators, and
+// stop at any other character.
 function readInt() {
   while (true) {
     const code = input.charCodeAt(state.pos);
-    if (code >= charCodes.digit0 && code <= charCodes.digit9 || code >= charCodes.lowercaseA && code <= charCodes.lowercaseF || code >= charCodes.uppercaseA && code <= charCodes.uppercaseF || code === charCodes.underscore) {
+    if (
+      (code >= charCodes.digit0 && code <= charCodes.digit9) ||
+      (code >= charCodes.lowercaseA && code <= charCodes.lowercaseF) ||
+      (code >= charCodes.uppercaseA && code <= charCodes.uppercaseF) ||
+      code === charCodes.underscore
+    ) {
       state.pos++;
     } else {
       break;
     }
   }
 }
+
 function readRadixNumber() {
   let isBigInt = false;
   const start = state.pos;
-  state.pos += 2;
+
+  state.pos += 2; // 0x
   readInt();
+
   const nextChar = input.charCodeAt(state.pos);
   if (nextChar === charCodes.lowercaseN) {
     ++state.pos;
@@ -26131,24 +17591,31 @@ function readRadixNumber() {
   } else if (nextChar === charCodes.lowercaseM) {
     unexpected("Invalid decimal", start);
   }
+
   if (isBigInt) {
     finishToken(TokenType.bigint);
     return;
   }
+
   finishToken(TokenType.num);
 }
+
+// Read an integer, octal integer, or floating-point number.
 function readNumber(startsWithDot) {
   let isBigInt = false;
   let isDecimal = false;
+
   if (!startsWithDot) {
     readInt();
   }
+
   let nextChar = input.charCodeAt(state.pos);
   if (nextChar === charCodes.dot) {
     ++state.pos;
     readInt();
     nextChar = input.charCodeAt(state.pos);
   }
+
   if (nextChar === charCodes.uppercaseE || nextChar === charCodes.lowercaseE) {
     nextChar = input.charCodeAt(++state.pos);
     if (nextChar === charCodes.plusSign || nextChar === charCodes.dash) {
@@ -26157,6 +17624,7 @@ function readNumber(startsWithDot) {
     readInt();
     nextChar = input.charCodeAt(state.pos);
   }
+
   if (nextChar === charCodes.lowercaseN) {
     ++state.pos;
     isBigInt = true;
@@ -26164,19 +17632,23 @@ function readNumber(startsWithDot) {
     ++state.pos;
     isDecimal = true;
   }
+
   if (isBigInt) {
     finishToken(TokenType.bigint);
     return;
   }
+
   if (isDecimal) {
     finishToken(TokenType.decimal);
     return;
   }
+
   finishToken(TokenType.num);
 }
+
 function readString(quote) {
   state.pos++;
-  for (; ; ) {
+  for (;;) {
     if (state.pos >= input.length) {
       unexpected("Unterminated string constant");
       return;
@@ -26192,14 +17664,19 @@ function readString(quote) {
   state.pos++;
   finishToken(TokenType.string);
 }
+
+// Reads template string tokens.
 function readTmplToken() {
-  for (; ; ) {
+  for (;;) {
     if (state.pos >= input.length) {
       unexpected("Unterminated template");
       return;
     }
     const ch = input.charCodeAt(state.pos);
-    if (ch === charCodes.graveAccent || ch === charCodes.dollarSign && input.charCodeAt(state.pos + 1) === charCodes.leftCurlyBrace) {
+    if (
+      ch === charCodes.graveAccent ||
+      (ch === charCodes.dollarSign && input.charCodeAt(state.pos + 1) === charCodes.leftCurlyBrace)
+    ) {
       if (state.pos === state.start && match(TokenType.template)) {
         if (ch === charCodes.dollarSign) {
           state.pos += 2;
@@ -26220,15 +17697,23 @@ function readTmplToken() {
     state.pos++;
   }
 }
+
+// Skip to the end of the current word. Note that this is the same as the snippet at the end of
+// readWord, but calling skipWord from readWord seems to slightly hurt performance from some rough
+// measurements.
 function skipWord() {
   while (state.pos < input.length) {
     const ch = input.charCodeAt(state.pos);
     if (IS_IDENTIFIER_CHAR[ch]) {
       state.pos++;
     } else if (ch === charCodes.backslash) {
+      // \u
       state.pos += 2;
       if (input.charCodeAt(state.pos) === charCodes.leftCurlyBrace) {
-        while (state.pos < input.length && input.charCodeAt(state.pos) !== charCodes.rightCurlyBrace) {
+        while (
+          state.pos < input.length &&
+          input.charCodeAt(state.pos) !== charCodes.rightCurlyBrace
+        ) {
           state.pos++;
         }
         state.pos++;
@@ -26238,108 +17723,109 @@ function skipWord() {
     }
   }
 }
+
 const entities = {
-  quot: '"',
+  quot: "\u0022",
   amp: "&",
-  apos: "'",
+  apos: "\u0027",
   lt: "<",
   gt: ">",
-  nbsp: "\xA0",
-  iexcl: "\xA1",
-  cent: "\xA2",
-  pound: "\xA3",
-  curren: "\xA4",
-  yen: "\xA5",
-  brvbar: "\xA6",
-  sect: "\xA7",
-  uml: "\xA8",
-  copy: "\xA9",
-  ordf: "\xAA",
-  laquo: "\xAB",
-  not: "\xAC",
-  shy: "\xAD",
-  reg: "\xAE",
-  macr: "\xAF",
-  deg: "\xB0",
-  plusmn: "\xB1",
-  sup2: "\xB2",
-  sup3: "\xB3",
-  acute: "\xB4",
-  micro: "\xB5",
-  para: "\xB6",
-  middot: "\xB7",
-  cedil: "\xB8",
-  sup1: "\xB9",
-  ordm: "\xBA",
-  raquo: "\xBB",
-  frac14: "\xBC",
-  frac12: "\xBD",
-  frac34: "\xBE",
-  iquest: "\xBF",
-  Agrave: "\xC0",
-  Aacute: "\xC1",
-  Acirc: "\xC2",
-  Atilde: "\xC3",
-  Auml: "\xC4",
-  Aring: "\xC5",
-  AElig: "\xC6",
-  Ccedil: "\xC7",
-  Egrave: "\xC8",
-  Eacute: "\xC9",
-  Ecirc: "\xCA",
-  Euml: "\xCB",
-  Igrave: "\xCC",
-  Iacute: "\xCD",
-  Icirc: "\xCE",
-  Iuml: "\xCF",
-  ETH: "\xD0",
-  Ntilde: "\xD1",
-  Ograve: "\xD2",
-  Oacute: "\xD3",
-  Ocirc: "\xD4",
-  Otilde: "\xD5",
-  Ouml: "\xD6",
-  times: "\xD7",
-  Oslash: "\xD8",
-  Ugrave: "\xD9",
-  Uacute: "\xDA",
-  Ucirc: "\xDB",
-  Uuml: "\xDC",
-  Yacute: "\xDD",
-  THORN: "\xDE",
-  szlig: "\xDF",
-  agrave: "\xE0",
-  aacute: "\xE1",
-  acirc: "\xE2",
-  atilde: "\xE3",
-  auml: "\xE4",
-  aring: "\xE5",
-  aelig: "\xE6",
-  ccedil: "\xE7",
-  egrave: "\xE8",
-  eacute: "\xE9",
-  ecirc: "\xEA",
-  euml: "\xEB",
-  igrave: "\xEC",
-  iacute: "\xED",
-  icirc: "\xEE",
-  iuml: "\xEF",
-  eth: "\xF0",
-  ntilde: "\xF1",
-  ograve: "\xF2",
-  oacute: "\xF3",
-  ocirc: "\xF4",
-  otilde: "\xF5",
-  ouml: "\xF6",
-  divide: "\xF7",
-  oslash: "\xF8",
-  ugrave: "\xF9",
-  uacute: "\xFA",
-  ucirc: "\xFB",
-  uuml: "\xFC",
-  yacute: "\xFD",
-  thorn: "\xFE",
-  yuml: "\xFF",
+  nbsp: "\u00A0",
+  iexcl: "\u00A1",
+  cent: "\u00A2",
+  pound: "\u00A3",
+  curren: "\u00A4",
+  yen: "\u00A5",
+  brvbar: "\u00A6",
+  sect: "\u00A7",
+  uml: "\u00A8",
+  copy: "\u00A9",
+  ordf: "\u00AA",
+  laquo: "\u00AB",
+  not: "\u00AC",
+  shy: "\u00AD",
+  reg: "\u00AE",
+  macr: "\u00AF",
+  deg: "\u00B0",
+  plusmn: "\u00B1",
+  sup2: "\u00B2",
+  sup3: "\u00B3",
+  acute: "\u00B4",
+  micro: "\u00B5",
+  para: "\u00B6",
+  middot: "\u00B7",
+  cedil: "\u00B8",
+  sup1: "\u00B9",
+  ordm: "\u00BA",
+  raquo: "\u00BB",
+  frac14: "\u00BC",
+  frac12: "\u00BD",
+  frac34: "\u00BE",
+  iquest: "\u00BF",
+  Agrave: "\u00C0",
+  Aacute: "\u00C1",
+  Acirc: "\u00C2",
+  Atilde: "\u00C3",
+  Auml: "\u00C4",
+  Aring: "\u00C5",
+  AElig: "\u00C6",
+  Ccedil: "\u00C7",
+  Egrave: "\u00C8",
+  Eacute: "\u00C9",
+  Ecirc: "\u00CA",
+  Euml: "\u00CB",
+  Igrave: "\u00CC",
+  Iacute: "\u00CD",
+  Icirc: "\u00CE",
+  Iuml: "\u00CF",
+  ETH: "\u00D0",
+  Ntilde: "\u00D1",
+  Ograve: "\u00D2",
+  Oacute: "\u00D3",
+  Ocirc: "\u00D4",
+  Otilde: "\u00D5",
+  Ouml: "\u00D6",
+  times: "\u00D7",
+  Oslash: "\u00D8",
+  Ugrave: "\u00D9",
+  Uacute: "\u00DA",
+  Ucirc: "\u00DB",
+  Uuml: "\u00DC",
+  Yacute: "\u00DD",
+  THORN: "\u00DE",
+  szlig: "\u00DF",
+  agrave: "\u00E0",
+  aacute: "\u00E1",
+  acirc: "\u00E2",
+  atilde: "\u00E3",
+  auml: "\u00E4",
+  aring: "\u00E5",
+  aelig: "\u00E6",
+  ccedil: "\u00E7",
+  egrave: "\u00E8",
+  eacute: "\u00E9",
+  ecirc: "\u00EA",
+  euml: "\u00EB",
+  igrave: "\u00EC",
+  iacute: "\u00ED",
+  icirc: "\u00EE",
+  iuml: "\u00EF",
+  eth: "\u00F0",
+  ntilde: "\u00F1",
+  ograve: "\u00F2",
+  oacute: "\u00F3",
+  ocirc: "\u00F4",
+  otilde: "\u00F5",
+  ouml: "\u00F6",
+  divide: "\u00F7",
+  oslash: "\u00F8",
+  ugrave: "\u00F9",
+  uacute: "\u00FA",
+  ucirc: "\u00FB",
+  uuml: "\u00FC",
+  yacute: "\u00FD",
+  thorn: "\u00FE",
+  yuml: "\u00FF",
   OElig: "\u0152",
   oelig: "\u0153",
   Scaron: "\u0160",
@@ -26491,13 +17977,15 @@ const entities = {
   spades: "\u2660",
   clubs: "\u2663",
   hearts: "\u2665",
-  diams: "\u2666"
+  diams: "\u2666",
 };
+
 function getJSXPragmaInfo(options) {
   const [base, suffix] = splitPragma(options.jsxPragma || "React.createElement");
   const [fragmentBase, fragmentSuffix] = splitPragma(options.jsxFragmentPragma || "React.Fragment");
-  return { base, suffix, fragmentBase, fragmentSuffix };
+  return {base, suffix, fragmentBase, fragmentSuffix};
 }
+
 function splitPragma(pragma) {
   let dotIndex = pragma.indexOf(".");
   if (dotIndex === -1) {
@@ -26505,41 +17993,43 @@ function splitPragma(pragma) {
   }
   return [pragma.slice(0, dotIndex), pragma.slice(dotIndex)];
 }
+
 class Transformer {
+  // Return true if anything was processed, false otherwise.
+  
+
   getPrefixCode() {
     return "";
   }
+
   getHoistedCode() {
     return "";
   }
+
   getSuffixCode() {
     return "";
   }
 }
+
 const HEX_NUMBER = /^[\da-fA-F]+$/;
 const DECIMAL_NUMBER = /^\d+$/;
-class JSXTransformer extends Transformer {
-  __init() {
-    this.lastLineNumber = 1;
-  }
-  __init2() {
-    this.lastIndex = 0;
-  }
-  __init3() {
-    this.filenameVarName = null;
-  }
-  constructor(rootTransformer, tokens, importProcessor, nameManager, options) {
-    super();
-    this.rootTransformer = rootTransformer;
-    this.tokens = tokens;
-    this.importProcessor = importProcessor;
-    this.nameManager = nameManager;
-    this.options = options;
-    JSXTransformer.prototype.__init.call(this);
-    JSXTransformer.prototype.__init2.call(this);
-    JSXTransformer.prototype.__init3.call(this);
-    this.jsxPragmaInfo = getJSXPragmaInfo(options);
+
+class JSXTransformer extends Transformer {
+  __init() {this.lastLineNumber = 1;}
+  __init2() {this.lastIndex = 0;}
+  __init3() {this.filenameVarName = null;}
+  
+
+  constructor(
+     rootTransformer,
+     tokens,
+     importProcessor,
+     nameManager,
+     options,
+  ) {
+    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.options = options;JSXTransformer.prototype.__init.call(this);JSXTransformer.prototype.__init2.call(this);JSXTransformer.prototype.__init3.call(this);    this.jsxPragmaInfo = getJSXPragmaInfo(options);
   }
+
   process() {
     if (this.tokens.matches1(TokenType.jsxTagStart)) {
       this.processJSXTag();
@@ -26547,6 +18037,7 @@ class JSXTransformer extends Transformer {
     }
     return false;
   }
+
   getPrefixCode() {
     if (this.filenameVarName) {
       return `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || "")};`;
@@ -26554,6 +18045,11 @@ class JSXTransformer extends Transformer {
       return "";
     }
   }
+
+  /**
+   * Lazily calculate line numbers to avoid unneeded work. We assume this is always called in
+   * increasing order by index.
+   */
   getLineNumberForIndex(index) {
     const code = this.tokens.code;
     while (this.lastIndex < index && this.lastIndex < code.length) {
@@ -26564,15 +18060,19 @@ class JSXTransformer extends Transformer {
     }
     return this.lastLineNumber;
   }
+
   getFilenameVarName() {
     if (!this.filenameVarName) {
       this.filenameVarName = this.nameManager.claimFreeName("_jsxFileName");
     }
     return this.filenameVarName;
   }
+
   processProps(firstTokenStart) {
     const lineNumber = this.getLineNumberForIndex(firstTokenStart);
-    const devProps = this.options.production ? "" : `__self: this, __source: {fileName: ${this.getFilenameVarName()}, lineNumber: ${lineNumber}}`;
+    const devProps = this.options.production
+      ? ""
+      : `__self: this, __source: {fileName: ${this.getFilenameVarName()}, lineNumber: ${lineNumber}}`;
     if (!this.tokens.matches1(TokenType.jsxName) && !this.tokens.matches1(TokenType.braceL)) {
       if (devProps) {
         this.tokens.appendCode(`, {${devProps}}`);
@@ -26613,6 +18113,7 @@ class JSXTransformer extends Transformer {
       this.tokens.appendCode("}");
     }
   }
+
   processPropKeyName() {
     const keyName = this.tokens.identifierName();
     if (keyName.includes("-")) {
@@ -26621,6 +18122,7 @@ class JSXTransformer extends Transformer {
       this.tokens.copyToken();
     }
   }
+
   processStringPropValue() {
     const token = this.tokens.currentToken();
     const valueCode = this.tokens.code.slice(token.start + 1, token.end - 1);
@@ -26628,9 +18130,26 @@ class JSXTransformer extends Transformer {
     const literalCode = formatJSXStringValueLiteral(valueCode);
     this.tokens.replaceToken(literalCode + replacementCode);
   }
+
+  /**
+   * Process the first part of a tag, before any props.
+   */
   processTagIntro() {
+    // Walk forward until we see one of these patterns:
+    // jsxName to start the first prop, preceded by another jsxName to end the tag name.
+    // jsxName to start the first prop, preceded by greaterThan to end the type argument.
+    // [open brace] to start the first prop.
+    // [jsxTagEnd] to end the open-tag.
+    // [slash, jsxTagEnd] to end the self-closing tag.
     let introEnd = this.tokens.currentIndex() + 1;
-    while (this.tokens.tokens[introEnd].isType || !this.tokens.matches2AtIndex(introEnd - 1, TokenType.jsxName, TokenType.jsxName) && !this.tokens.matches2AtIndex(introEnd - 1, TokenType.greaterThan, TokenType.jsxName) && !this.tokens.matches1AtIndex(introEnd, TokenType.braceL) && !this.tokens.matches1AtIndex(introEnd, TokenType.jsxTagEnd) && !this.tokens.matches2AtIndex(introEnd, TokenType.slash, TokenType.jsxTagEnd)) {
+    while (
+      this.tokens.tokens[introEnd].isType ||
+      (!this.tokens.matches2AtIndex(introEnd - 1, TokenType.jsxName, TokenType.jsxName) &&
+        !this.tokens.matches2AtIndex(introEnd - 1, TokenType.greaterThan, TokenType.jsxName) &&
+        !this.tokens.matches1AtIndex(introEnd, TokenType.braceL) &&
+        !this.tokens.matches1AtIndex(introEnd, TokenType.jsxTagEnd) &&
+        !this.tokens.matches2AtIndex(introEnd, TokenType.slash, TokenType.jsxTagEnd))
+    ) {
       introEnd++;
     }
     if (introEnd === this.tokens.currentIndex() + 1) {
@@ -26643,21 +18162,27 @@ class JSXTransformer extends Transformer {
       this.rootTransformer.processToken();
     }
   }
+
   processChildren() {
     while (true) {
       if (this.tokens.matches2(TokenType.jsxTagStart, TokenType.slash)) {
+        // Closing tag, so no more children.
         return;
       }
       if (this.tokens.matches1(TokenType.braceL)) {
         if (this.tokens.matches2(TokenType.braceL, TokenType.braceR)) {
+          // Empty interpolations and comment-only interpolations are allowed
+          // and don't create an extra child arg.
           this.tokens.replaceToken("");
           this.tokens.replaceToken("");
         } else {
+          // Interpolated expression.
           this.tokens.replaceToken(", ");
           this.rootTransformer.processBalancedCode();
           this.tokens.replaceToken("");
         }
       } else if (this.tokens.matches1(TokenType.jsxTagStart)) {
+        // Child JSX element
         this.tokens.appendCode(", ");
         this.processJSXTag();
       } else if (this.tokens.matches1(TokenType.jsxText)) {
@@ -26667,6 +18192,7 @@ class JSXTransformer extends Transformer {
       }
     }
   }
+
   processChildTextElement() {
     const token = this.tokens.currentToken();
     const valueCode = this.tokens.code.slice(token.start, token.end);
@@ -26678,27 +18204,43 @@ class JSXTransformer extends Transformer {
       this.tokens.replaceToken(`, ${literalCode}${replacementCode}`);
     }
   }
+
   processJSXTag() {
-    const { jsxPragmaInfo } = this;
-    const resolvedPragmaBaseName = this.importProcessor ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.base) || jsxPragmaInfo.base : jsxPragmaInfo.base;
+    const {jsxPragmaInfo} = this;
+    const resolvedPragmaBaseName = this.importProcessor
+      ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.base) || jsxPragmaInfo.base
+      : jsxPragmaInfo.base;
     const firstTokenStart = this.tokens.currentToken().start;
+    // First tag is always jsxTagStart.
     this.tokens.replaceToken(`${resolvedPragmaBaseName}${jsxPragmaInfo.suffix}(`);
+
     if (this.tokens.matches1(TokenType.jsxTagEnd)) {
-      const resolvedFragmentPragmaBaseName = this.importProcessor ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.fragmentBase) || jsxPragmaInfo.fragmentBase : jsxPragmaInfo.fragmentBase;
-      this.tokens.replaceToken(`${resolvedFragmentPragmaBaseName}${jsxPragmaInfo.fragmentSuffix}, null`);
+      // Fragment syntax.
+      const resolvedFragmentPragmaBaseName = this.importProcessor
+        ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.fragmentBase) ||
+          jsxPragmaInfo.fragmentBase
+        : jsxPragmaInfo.fragmentBase;
+      this.tokens.replaceToken(
+        `${resolvedFragmentPragmaBaseName}${jsxPragmaInfo.fragmentSuffix}, null`,
+      );
+      // Tag with children.
       this.processChildren();
       while (!this.tokens.matches1(TokenType.jsxTagEnd)) {
         this.tokens.replaceToken("");
       }
       this.tokens.replaceToken(")");
     } else {
+      // Normal open tag or self-closing tag.
       this.processTagIntro();
       this.processProps(firstTokenStart);
+
       if (this.tokens.matches2(TokenType.slash, TokenType.jsxTagEnd)) {
+        // Self-closing tag.
         this.tokens.replaceToken("");
         this.tokens.replaceToken(")");
       } else if (this.tokens.matches1(TokenType.jsxTagEnd)) {
         this.tokens.replaceToken("");
+        // Tag with children.
         this.processChildren();
         while (!this.tokens.matches1(TokenType.jsxTagEnd)) {
           this.tokens.replaceToken("");
@@ -26710,18 +18252,36 @@ class JSXTransformer extends Transformer {
     }
   }
 }
+
+/**
+ * Spec for identifiers: https://tc39.github.io/ecma262/#prod-IdentifierStart.
+ *
+ * Really only treat anything starting with a-z as tag names.  `_`, `$`, ``
+ * should be treated as copmonent names
+ */
 function startsWithLowerCase(s) {
   const firstChar = s.charCodeAt(0);
   return firstChar >= charCodes.lowercaseA && firstChar <= charCodes.lowercaseZ;
 }
+
+/**
+ * Turn the given jsxText string into a JS string literal. Leading and trailing
+ * whitespace on lines is removed, except immediately after the open-tag and
+ * before the close-tag. Empty lines are completely removed, and spaces are
+ * added between lines after that.
+ *
+ * We use JSON.stringify to introduce escape characters as necessary, and trim
+ * the start and end of each line and remove blank lines.
+ */
 function formatJSXTextLiteral(text) {
   let result = "";
   let whitespace = "";
+
   let isInInitialLineWhitespace = false;
   let seenNonWhitespace = false;
   for (let i = 0; i < text.length; i++) {
     const c = text[i];
-    if (c === " " || c === "	" || c === "\r") {
+    if (c === " " || c === "\t" || c === "\r") {
       if (!isInInitialLineWhitespace) {
         whitespace += c;
       }
@@ -26735,7 +18295,7 @@ function formatJSXTextLiteral(text) {
       result += whitespace;
       whitespace = "";
       if (c === "&") {
-        const { entity, newI } = processEntity(text, i + 1);
+        const {entity, newI} = processEntity(text, i + 1);
         i = newI - 1;
         result += entity;
       } else {
@@ -26750,6 +18310,12 @@ function formatJSXTextLiteral(text) {
   }
   return JSON.stringify(result);
 }
+
+/**
+ * Produce the code that should be printed after the JSX text string literal,
+ * with most content removed, but all newlines preserved and all spacing at the
+ * end preserved.
+ */
 function formatJSXTextReplacement(text) {
   let numNewlines = 0;
   let numSpaces = 0;
@@ -26763,6 +18329,13 @@ function formatJSXTextReplacement(text) {
   }
   return "\n".repeat(numNewlines) + " ".repeat(numSpaces);
 }
+
+/**
+ * Format a string in the value position of a JSX prop.
+ *
+ * Use the same implementation as convertAttribute from
+ * babel-helper-builder-react-jsx.
+ */
 function formatJSXStringValueLiteral(text) {
   let result = "";
   for (let i = 0; i < text.length; i++) {
@@ -26777,7 +18350,7 @@ function formatJSXStringValueLiteral(text) {
         result += "\n";
       }
     } else if (c === "&") {
-      const { entity, newI } = processEntity(text, i + 1);
+      const {entity, newI} = processEntity(text, i + 1);
       result += entity;
       i = newI - 1;
     } else {
@@ -26786,11 +18359,16 @@ function formatJSXStringValueLiteral(text) {
   }
   return JSON.stringify(result);
 }
+
+/**
+ * Modified from jsxReadString in Babylon.
+ */
 function processEntity(text, indexAfterAmpersand) {
   let str = "";
   let count = 0;
   let entity;
   let i = indexAfterAmpersand;
+
   while (i < text.length && count++ < 10) {
     const ch = text[i];
     i++;
@@ -26815,27 +18393,40 @@ function processEntity(text, indexAfterAmpersand) {
     str += ch;
   }
   if (!entity) {
-    return { entity: "&", newI: indexAfterAmpersand };
+    return {entity: "&", newI: indexAfterAmpersand};
   }
-  return { entity, newI: i };
+  return {entity, newI: i};
 }
+
 function getNonTypeIdentifiers(tokens, options) {
   const jsxPragmaInfo = getJSXPragmaInfo(options);
   const nonTypeIdentifiers = new Set();
   for (let i = 0; i < tokens.tokens.length; i++) {
     const token = tokens.tokens[i];
-    if (token.type === TokenType.name && !token.isType && (token.identifierRole === IdentifierRole.Access || token.identifierRole === IdentifierRole.ObjectShorthand || token.identifierRole === IdentifierRole.ExportAccess) && !token.shadowsGlobal) {
+    if (
+      token.type === TokenType.name &&
+      !token.isType &&
+      (token.identifierRole === IdentifierRole.Access ||
+        token.identifierRole === IdentifierRole.ObjectShorthand ||
+        token.identifierRole === IdentifierRole.ExportAccess) &&
+      !token.shadowsGlobal
+    ) {
       nonTypeIdentifiers.add(tokens.identifierNameForToken(token));
     }
     if (token.type === TokenType.jsxTagStart) {
       nonTypeIdentifiers.add(jsxPragmaInfo.base);
     }
-    if (token.type === TokenType.jsxTagStart && i + 1 < tokens.tokens.length && tokens.tokens[i + 1].type === TokenType.jsxTagEnd) {
+    if (
+      token.type === TokenType.jsxTagStart &&
+      i + 1 < tokens.tokens.length &&
+      tokens.tokens[i + 1].type === TokenType.jsxTagEnd
+    ) {
       nonTypeIdentifiers.add(jsxPragmaInfo.base);
       nonTypeIdentifiers.add(jsxPragmaInfo.fragmentBase);
     }
     if (token.type === TokenType.jsxName && token.identifierRole === IdentifierRole.Access) {
       const identifierName = tokens.identifierNameForToken(token);
+      // Lower-case single-component tag names like "div" don't count.
       if (!startsWithLowerCase(identifierName) || tokens.tokens[i + 1].type === TokenType.dot) {
         nonTypeIdentifiers.add(tokens.identifierNameForToken(token));
       }
@@ -26843,66 +18434,79 @@ function getNonTypeIdentifiers(tokens, options) {
   }
   return nonTypeIdentifiers;
 }
+
+/**
+ * Class responsible for preprocessing and bookkeeping import and export declarations within the
+ * file.
+ *
+ * TypeScript uses a simpler mechanism that does not use functions like interopRequireDefault and
+ * interopRequireWildcard, so we also allow that mode for compatibility.
+ */
 class CJSImportProcessor {
-  __init() {
-    this.nonTypeIdentifiers = new Set();
-  }
-  __init2() {
-    this.importInfoByPath = new Map();
-  }
-  __init3() {
-    this.importsToReplace = new Map();
-  }
-  __init4() {
-    this.identifierReplacements = new Map();
-  }
-  __init5() {
-    this.exportBindingsByLocalName = new Map();
-  }
-  constructor(nameManager, tokens, enableLegacyTypeScriptModuleInterop, options, isTypeScriptTransformEnabled, helperManager) {
-    this.nameManager = nameManager;
-    this.tokens = tokens;
-    this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;
-    this.options = options;
-    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
-    this.helperManager = helperManager;
-    CJSImportProcessor.prototype.__init.call(this);
-    CJSImportProcessor.prototype.__init2.call(this);
-    CJSImportProcessor.prototype.__init3.call(this);
-    CJSImportProcessor.prototype.__init4.call(this);
-    CJSImportProcessor.prototype.__init5.call(this);
-  }
+   __init() {this.nonTypeIdentifiers = new Set();}
+   __init2() {this.importInfoByPath = new Map();}
+   __init3() {this.importsToReplace = new Map();}
+   __init4() {this.identifierReplacements = new Map();}
+   __init5() {this.exportBindingsByLocalName = new Map();}
+
+  constructor(
+     nameManager,
+     tokens,
+     enableLegacyTypeScriptModuleInterop,
+     options,
+     isTypeScriptTransformEnabled,
+     helperManager,
+  ) {this.nameManager = nameManager;this.tokens = tokens;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.options = options;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.helperManager = helperManager;CJSImportProcessor.prototype.__init.call(this);CJSImportProcessor.prototype.__init2.call(this);CJSImportProcessor.prototype.__init3.call(this);CJSImportProcessor.prototype.__init4.call(this);CJSImportProcessor.prototype.__init5.call(this);}
+
   preprocessTokens() {
     for (let i = 0; i < this.tokens.tokens.length; i++) {
-      if (this.tokens.matches1AtIndex(i, TokenType._import) && !this.tokens.matches3AtIndex(i, TokenType._import, TokenType.name, TokenType.eq)) {
+      if (
+        this.tokens.matches1AtIndex(i, TokenType._import) &&
+        !this.tokens.matches3AtIndex(i, TokenType._import, TokenType.name, TokenType.eq)
+      ) {
         this.preprocessImportAtIndex(i);
       }
-      if (this.tokens.matches1AtIndex(i, TokenType._export) && !this.tokens.matches2AtIndex(i, TokenType._export, TokenType.eq)) {
+      if (
+        this.tokens.matches1AtIndex(i, TokenType._export) &&
+        !this.tokens.matches2AtIndex(i, TokenType._export, TokenType.eq)
+      ) {
         this.preprocessExportAtIndex(i);
       }
     }
     this.generateImportReplacements();
   }
+
+  /**
+   * In TypeScript, import statements that only import types should be removed. This does not count
+   * bare imports.
+   */
   pruneTypeOnlyImports() {
     this.nonTypeIdentifiers = getNonTypeIdentifiers(this.tokens, this.options);
     for (const [path, importInfo] of this.importInfoByPath.entries()) {
-      if (importInfo.hasBareImport || importInfo.hasStarExport || importInfo.exportStarNames.length > 0 || importInfo.namedExports.length > 0) {
+      if (
+        importInfo.hasBareImport ||
+        importInfo.hasStarExport ||
+        importInfo.exportStarNames.length > 0 ||
+        importInfo.namedExports.length > 0
+      ) {
         continue;
       }
       const names = [
         ...importInfo.defaultNames,
         ...importInfo.wildcardNames,
-        ...importInfo.namedImports.map(({ localName }) => localName)
+        ...importInfo.namedImports.map(({localName}) => localName),
       ];
       if (names.every((name) => this.isTypeName(name))) {
         this.importsToReplace.set(path, "");
       }
     }
   }
+
   isTypeName(name) {
     return this.isTypeScriptTransformEnabled && !this.nonTypeIdentifiers.has(name);
   }
-  generateImportReplacements() {
+
+   generateImportReplacements() {
     for (const [path, importInfo] of this.importInfoByPath.entries()) {
       const {
         defaultNames,
@@ -26910,65 +18514,101 @@ class CJSImportProcessor {
         namedImports,
         namedExports,
         exportStarNames,
-        hasStarExport
+        hasStarExport,
       } = importInfo;
-      if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0 && namedExports.length === 0 && exportStarNames.length === 0 && !hasStarExport) {
+
+      if (
+        defaultNames.length === 0 &&
+        wildcardNames.length === 0 &&
+        namedImports.length === 0 &&
+        namedExports.length === 0 &&
+        exportStarNames.length === 0 &&
+        !hasStarExport
+      ) {
+        // Import is never used, so don't even assign a name.
         this.importsToReplace.set(path, `require('${path}');`);
         continue;
       }
+
       const primaryImportName = this.getFreeIdentifierForPath(path);
       let secondaryImportName;
       if (this.enableLegacyTypeScriptModuleInterop) {
         secondaryImportName = primaryImportName;
       } else {
-        secondaryImportName = wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);
+        secondaryImportName =
+          wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);
       }
       let requireCode = `var ${primaryImportName} = require('${path}');`;
       if (wildcardNames.length > 0) {
         for (const wildcardName of wildcardNames) {
-          const moduleExpr = this.enableLegacyTypeScriptModuleInterop ? primaryImportName : `${this.helperManager.getHelperName("interopRequireWildcard")}(${primaryImportName})`;
+          const moduleExpr = this.enableLegacyTypeScriptModuleInterop
+            ? primaryImportName
+            : `${this.helperManager.getHelperName("interopRequireWildcard")}(${primaryImportName})`;
           requireCode += ` var ${wildcardName} = ${moduleExpr};`;
         }
       } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {
-        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName("interopRequireWildcard")}(${primaryImportName});`;
+        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
+          "interopRequireWildcard",
+        )}(${primaryImportName});`;
       } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {
-        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName("interopRequireDefault")}(${primaryImportName});`;
+        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
+          "interopRequireDefault",
+        )}(${primaryImportName});`;
       }
-      for (const { importedName, localName } of namedExports) {
-        requireCode += ` ${this.helperManager.getHelperName("createNamedExportFrom")}(${primaryImportName}, '${localName}', '${importedName}');`;
+
+      for (const {importedName, localName} of namedExports) {
+        requireCode += ` ${this.helperManager.getHelperName(
+          "createNamedExportFrom",
+        )}(${primaryImportName}, '${localName}', '${importedName}');`;
       }
       for (const exportStarName of exportStarNames) {
         requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;
       }
       if (hasStarExport) {
-        requireCode += ` ${this.helperManager.getHelperName("createStarExport")}(${primaryImportName});`;
+        requireCode += ` ${this.helperManager.getHelperName(
+          "createStarExport",
+        )}(${primaryImportName});`;
       }
+
       this.importsToReplace.set(path, requireCode);
+
       for (const defaultName of defaultNames) {
         this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);
       }
-      for (const { importedName, localName } of namedImports) {
+      for (const {importedName, localName} of namedImports) {
         this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);
       }
     }
   }
-  getFreeIdentifierForPath(path) {
+
+   getFreeIdentifierForPath(path) {
     const components = path.split("/");
     const lastComponent = components[components.length - 1];
     const baseName = lastComponent.replace(/\W/g, "");
     return this.nameManager.claimFreeName(`_${baseName}`);
   }
-  preprocessImportAtIndex(index) {
+
+   preprocessImportAtIndex(index) {
     const defaultNames = [];
     const wildcardNames = [];
     const namedImports = [];
+
     index++;
-    if ((this.tokens.matchesContextualAtIndex(index, ContextualKeyword._type) || this.tokens.matches1AtIndex(index, TokenType._typeof)) && !this.tokens.matches1AtIndex(index + 1, TokenType.comma) && !this.tokens.matchesContextualAtIndex(index + 1, ContextualKeyword._from)) {
+    if (
+      (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._type) ||
+        this.tokens.matches1AtIndex(index, TokenType._typeof)) &&
+      !this.tokens.matches1AtIndex(index + 1, TokenType.comma) &&
+      !this.tokens.matchesContextualAtIndex(index + 1, ContextualKeyword._from)
+    ) {
+      // import type declaration, so no need to process anything.
       return;
     }
+
     if (this.tokens.matches1AtIndex(index, TokenType.parenL)) {
+      // Dynamic import, so nothing to do
       return;
     }
+
     if (this.tokens.matches1AtIndex(index, TokenType.name)) {
       defaultNames.push(this.tokens.identifierNameAtIndex(index));
       index++;
@@ -26976,15 +18616,20 @@ class CJSImportProcessor {
         index++;
       }
     }
+
     if (this.tokens.matches1AtIndex(index, TokenType.star)) {
+      // * as
       index += 2;
       wildcardNames.push(this.tokens.identifierNameAtIndex(index));
       index++;
     }
+
     if (this.tokens.matches1AtIndex(index, TokenType.braceL)) {
       const result = this.getNamedImports(index + 1);
       index = result.newIndex;
+
       for (const namedImport of result.namedImports) {
+        // Treat {default as X} as a default import to ensure usage of require interop helper
         if (namedImport.importedName === "default") {
           defaultNames.push(namedImport.localName);
         } else {
@@ -26992,9 +18637,11 @@ class CJSImportProcessor {
         }
       }
     }
+
     if (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._from)) {
       index++;
     }
+
     if (!this.tokens.matches1AtIndex(index, TokenType.string)) {
       throw new Error("Expected string token at the end of import statement.");
     }
@@ -27007,10 +18654,18 @@ class CJSImportProcessor {
       importInfo.hasBareImport = true;
     }
   }
-  preprocessExportAtIndex(index) {
-    if (this.tokens.matches2AtIndex(index, TokenType._export, TokenType._var) || this.tokens.matches2AtIndex(index, TokenType._export, TokenType._let) || this.tokens.matches2AtIndex(index, TokenType._export, TokenType._const)) {
+
+   preprocessExportAtIndex(index) {
+    if (
+      this.tokens.matches2AtIndex(index, TokenType._export, TokenType._var) ||
+      this.tokens.matches2AtIndex(index, TokenType._export, TokenType._let) ||
+      this.tokens.matches2AtIndex(index, TokenType._export, TokenType._const)
+    ) {
       this.preprocessVarExportAtIndex(index);
-    } else if (this.tokens.matches2AtIndex(index, TokenType._export, TokenType._function) || this.tokens.matches2AtIndex(index, TokenType._export, TokenType._class)) {
+    } else if (
+      this.tokens.matches2AtIndex(index, TokenType._export, TokenType._function) ||
+      this.tokens.matches2AtIndex(index, TokenType._export, TokenType._class)
+    ) {
       const exportName = this.tokens.identifierNameAtIndex(index + 2);
       this.addExportBinding(exportName, exportName);
     } else if (this.tokens.matches3AtIndex(index, TokenType._export, TokenType.name, TokenType._function)) {
@@ -27022,12 +18677,21 @@ class CJSImportProcessor {
       this.preprocessExportStarAtIndex(index);
     }
   }
-  preprocessVarExportAtIndex(index) {
+
+   preprocessVarExportAtIndex(index) {
     let depth = 0;
+    // Handle cases like `export let {x} = y;`, starting at the open-brace in that case.
     for (let i = index + 2; ; i++) {
-      if (this.tokens.matches1AtIndex(i, TokenType.braceL) || this.tokens.matches1AtIndex(i, TokenType.dollarBraceL) || this.tokens.matches1AtIndex(i, TokenType.bracketL)) {
+      if (
+        this.tokens.matches1AtIndex(i, TokenType.braceL) ||
+        this.tokens.matches1AtIndex(i, TokenType.dollarBraceL) ||
+        this.tokens.matches1AtIndex(i, TokenType.bracketL)
+      ) {
         depth++;
-      } else if (this.tokens.matches1AtIndex(i, TokenType.braceR) || this.tokens.matches1AtIndex(i, TokenType.bracketR)) {
+      } else if (
+        this.tokens.matches1AtIndex(i, TokenType.braceR) ||
+        this.tokens.matches1AtIndex(i, TokenType.bracketR)
+      ) {
         depth--;
       } else if (depth === 0 && !this.tokens.matches1AtIndex(i, TokenType.name)) {
         break;
@@ -27046,18 +18710,28 @@ class CJSImportProcessor {
       }
     }
   }
-  preprocessNamedExportAtIndex(index) {
+
+  /**
+   * Walk this export statement just in case it's an export...from statement.
+   * If it is, combine it into the import info for that path. Otherwise, just
+   * bail out; it'll be handled later.
+   */
+   preprocessNamedExportAtIndex(index) {
+    // export {
     index += 2;
-    const { newIndex, namedImports } = this.getNamedImports(index);
+    const {newIndex, namedImports} = this.getNamedImports(index);
     index = newIndex;
+
     if (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._from)) {
       index++;
     } else {
-      for (const { importedName: localName, localName: exportedName } of namedImports) {
+      // Reinterpret "a as b" to be local/exported rather than imported/local.
+      for (const {importedName: localName, localName: exportedName} of namedImports) {
         this.addExportBinding(localName, exportedName);
       }
       return;
     }
+
     if (!this.tokens.matches1AtIndex(index, TokenType.string)) {
       throw new Error("Expected string token at the end of import statement.");
     }
@@ -27065,13 +18739,17 @@ class CJSImportProcessor {
     const importInfo = this.getImportInfo(path);
     importInfo.namedExports.push(...namedImports);
   }
-  preprocessExportStarAtIndex(index) {
+
+   preprocessExportStarAtIndex(index) {
     let exportedName = null;
     if (this.tokens.matches3AtIndex(index, TokenType._export, TokenType.star, TokenType._as)) {
+      // export * as
       index += 3;
       exportedName = this.tokens.identifierNameAtIndex(index);
+      // foo from
       index += 2;
     } else {
+      // export * from
       index += 3;
     }
     if (!this.tokens.matches1AtIndex(index, TokenType.string)) {
@@ -27085,18 +18763,27 @@ class CJSImportProcessor {
       importInfo.hasStarExport = true;
     }
   }
-  getNamedImports(index) {
+
+   getNamedImports(index) {
     const namedImports = [];
     while (true) {
       if (this.tokens.matches1AtIndex(index, TokenType.braceR)) {
         index++;
         break;
       }
+
+      // Flow type imports should just be ignored.
       let isTypeImport = false;
-      if ((this.tokens.matchesContextualAtIndex(index, ContextualKeyword._type) || this.tokens.matches1AtIndex(index, TokenType._typeof)) && this.tokens.matches1AtIndex(index + 1, TokenType.name) && !this.tokens.matchesContextualAtIndex(index + 1, ContextualKeyword._as)) {
+      if (
+        (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._type) ||
+          this.tokens.matches1AtIndex(index, TokenType._typeof)) &&
+        this.tokens.matches1AtIndex(index + 1, TokenType.name) &&
+        !this.tokens.matchesContextualAtIndex(index + 1, ContextualKeyword._as)
+      ) {
         isTypeImport = true;
         index++;
       }
+
       const importedName = this.tokens.identifierNameAtIndex(index);
       let localName;
       index++;
@@ -27108,7 +18795,7 @@ class CJSImportProcessor {
         localName = importedName;
       }
       if (!isTypeImport) {
-        namedImports.push({ importedName, localName });
+        namedImports.push({importedName, localName});
       }
       if (this.tokens.matches2AtIndex(index, TokenType.comma, TokenType.braceR)) {
         index += 2;
@@ -27122,9 +18809,14 @@ class CJSImportProcessor {
         throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index])}`);
       }
     }
-    return { newIndex: index, namedImports };
+    return {newIndex: index, namedImports};
   }
-  getImportInfo(path) {
+
+  /**
+   * Get a mutable import info object for this path, creating one if it doesn't
+   * exist yet.
+   */
+   getImportInfo(path) {
     const existingInfo = this.importInfoByPath.get(path);
     if (existingInfo) {
       return existingInfo;
@@ -27136,25 +18828,36 @@ class CJSImportProcessor {
       namedExports: [],
       hasBareImport: false,
       exportStarNames: [],
-      hasStarExport: false
+      hasStarExport: false,
     };
     this.importInfoByPath.set(path, newInfo);
     return newInfo;
   }
-  addExportBinding(localName, exportedName) {
+
+   addExportBinding(localName, exportedName) {
     if (!this.exportBindingsByLocalName.has(localName)) {
       this.exportBindingsByLocalName.set(localName, []);
     }
     this.exportBindingsByLocalName.get(localName).push(exportedName);
   }
+
+  /**
+   * Return the code to use for the import for this path, or the empty string if
+   * the code has already been "claimed" by a previous import.
+   */
   claimImportCode(importPath) {
     const result = this.importsToReplace.get(importPath);
     this.importsToReplace.set(importPath, "");
     return result || "";
   }
+
   getIdentifierReplacement(identifierName) {
     return this.identifierReplacements.get(identifierName) || null;
   }
+
+  /**
+   * Return a string like `exports.foo = exports.bar`.
+   */
   resolveExportBinding(assignedName) {
     const exportedNames = this.exportBindingsByLocalName.get(assignedName);
     if (!exportedNames || exportedNames.length === 0) {
@@ -27162,14 +18865,27 @@ class CJSImportProcessor {
     }
     return exportedNames.map((exportedName) => `exports.${exportedName}`).join(" = ");
   }
+
+  /**
+   * Return all imported/exported names where we might be interested in whether usages of those
+   * names are shadowed.
+   */
   getGlobalNames() {
     return new Set([
       ...this.identifierReplacements.keys(),
-      ...this.exportBindingsByLocalName.keys()
+      ...this.exportBindingsByLocalName.keys(),
     ]);
   }
 }
-function computeSourceMap(code, filePath, { compiledFilename }) {
+
+/**
+ * Generate a simple source map indicating that each line maps directly to the original line.
+ */
+function computeSourceMap(
+  code,
+  filePath,
+  {compiledFilename},
+) {
   let mappings = "AAAA";
   for (let i = 0; i < code.length; i++) {
     if (code.charCodeAt(i) === charCodes.lineFeed) {
@@ -27181,9 +18897,10 @@ function computeSourceMap(code, filePath, { compiledFilename }) {
     file: compiledFilename || "",
     sources: [filePath],
     mappings,
-    names: []
+    names: [],
   };
 }
+
 const HELPERS = {
   interopRequireWildcard: `
     function interopRequireWildcard(obj) {
@@ -27213,6 +18930,10 @@ const HELPERS = {
       Object.defineProperty(exports, localName, {enumerable: true, get: () => obj[importedName]});
     }
   `,
+  // Note that TypeScript and Babel do this differently; TypeScript does a simple existence
+  // check in the exports object and does a plain assignment, whereas Babel uses
+  // defineProperty and builds an object of explicitly-exported names so that star exports can
+  // always take lower precedence. For now, we do the easier TypeScript thing.
   createStarExport: `
     function createStarExport(obj) {
       Object.keys(obj)
@@ -27300,16 +19021,13 @@ const HELPERS = {
       const result = await ASYNC_OPTIONAL_CHAIN_NAME(ops);
       return result == null ? true : result;
     }
-  `
+  `,
 };
+
 class HelperManager {
-  __init() {
-    this.helperNames = {};
-  }
-  constructor(nameManager) {
-    this.nameManager = nameManager;
-    HelperManager.prototype.__init.call(this);
-  }
+  __init() {this.helperNames = {};}
+  constructor( nameManager) {this.nameManager = nameManager;HelperManager.prototype.__init.call(this);}
+
   getHelperName(baseName) {
     let helperName = this.helperNames[baseName];
     if (helperName) {
@@ -27319,6 +19037,7 @@ class HelperManager {
     this.helperNames[baseName] = helperName;
     return helperName;
   }
+
   emitHelpers() {
     let resultCode = "";
     if (this.helperNames.optionalChainDelete) {
@@ -27333,7 +19052,10 @@ class HelperManager {
       if (baseName === "optionalChainDelete") {
         helperCode = helperCode.replace("OPTIONAL_CHAIN_NAME", this.helperNames.optionalChain);
       } else if (baseName === "asyncOptionalChainDelete") {
-        helperCode = helperCode.replace("ASYNC_OPTIONAL_CHAIN_NAME", this.helperNames.asyncOptionalChain);
+        helperCode = helperCode.replace(
+          "ASYNC_OPTIONAL_CHAIN_NAME",
+          this.helperNames.asyncOptionalChain,
+        );
       }
       if (helperName) {
         resultCode += " ";
@@ -27343,23 +19065,49 @@ class HelperManager {
     return resultCode;
   }
 }
-function identifyShadowedGlobals(tokens, scopes, globalNames) {
+
+/**
+ * Traverse the given tokens and modify them if necessary to indicate that some names shadow global
+ * variables.
+ */
+function identifyShadowedGlobals(
+  tokens,
+  scopes,
+  globalNames,
+) {
   if (!hasShadowedGlobals(tokens, globalNames)) {
     return;
   }
   markShadowedGlobals(tokens, scopes, globalNames);
 }
+
+/**
+ * We can do a fast up-front check to see if there are any declarations to global names. If not,
+ * then there's no point in computing scope assignments.
+ */
+// Exported for testing.
 function hasShadowedGlobals(tokens, globalNames) {
   for (const token of tokens.tokens) {
-    if (token.type === TokenType.name && isNonTopLevelDeclaration(token) && globalNames.has(tokens.identifierNameForToken(token))) {
+    if (
+      token.type === TokenType.name &&
+      isNonTopLevelDeclaration(token) &&
+      globalNames.has(tokens.identifierNameForToken(token))
+    ) {
       return true;
     }
   }
   return false;
 }
-function markShadowedGlobals(tokens, scopes, globalNames) {
+
+function markShadowedGlobals(
+  tokens,
+  scopes,
+  globalNames,
+) {
   const scopeStack = [];
   let scopeIndex = scopes.length - 1;
+  // Scopes were generated at completion time, so they're sorted by end index, so we can maintain a
+  // good stack by going backwards through them.
   for (let i = tokens.tokens.length - 1; ; i--) {
     while (scopeStack.length > 0 && scopeStack[scopeStack.length - 1].startTokenIndex === i + 1) {
       scopeStack.pop();
@@ -27368,9 +19116,11 @@ function markShadowedGlobals(tokens, scopes, globalNames) {
       scopeStack.push(scopes[scopeIndex]);
       scopeIndex--;
     }
+    // Process scopes after the last iteration so we can make sure we pop all of them.
     if (i < 0) {
       break;
     }
+
     const token = tokens.tokens[i];
     const name = tokens.identifierNameForToken(token);
     if (scopeStack.length > 1 && token.type === TokenType.name && globalNames.has(name)) {
@@ -27392,14 +19142,22 @@ function markShadowedGlobals(tokens, scopes, globalNames) {
     throw new Error("Expected empty scope stack after processing file.");
   }
 }
+
 function markShadowedForScope(scope, tokens, name) {
   for (let i = scope.startTokenIndex; i < scope.endTokenIndex; i++) {
     const token = tokens.tokens[i];
-    if ((token.type === TokenType.name || token.type === TokenType.jsxName) && tokens.identifierNameForToken(token) === name) {
+    if (
+      (token.type === TokenType.name || token.type === TokenType.jsxName) &&
+      tokens.identifierNameForToken(token) === name
+    ) {
       token.shadowsGlobal = true;
     }
   }
 }
+
+/**
+ * Get all identifier names in the code, in order, including duplicates.
+ */
 function getIdentifierNames(code, tokens) {
   const names = [];
   for (const token of tokens) {
@@ -27409,19 +19167,20 @@ function getIdentifierNames(code, tokens) {
   }
   return names;
 }
+
 class NameManager {
-  __init() {
-    this.usedNames = new Set();
-  }
-  constructor(code, tokens) {
-    NameManager.prototype.__init.call(this);
+    __init() {this.usedNames = new Set();}
+
+  constructor(code, tokens) {NameManager.prototype.__init.call(this);
     this.usedNames = new Set(getIdentifierNames(code, tokens));
   }
+
   claimFreeName(name) {
     const newName = this.findFreeName(name);
     this.usedNames.add(newName);
     return newName;
   }
+
   findFreeName(name) {
     if (!this.usedNames.has(name)) {
       return name;
@@ -27433,941 +19192,955 @@ class NameManager {
     return name + String(suffixNum);
   }
 }
+
 var dist = {};
+
 var types = {};
+
 var util = {};
-var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
-  var extendStatics = function(d, b) {
-    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
-      d2.__proto__ = b2;
-    } || function(d2, b2) {
-      for (var p in b2)
-        if (b2.hasOwnProperty(p))
-          d2[p] = b2[p];
+
+var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
+    var extendStatics = function (d, b) {
+        extendStatics = Object.setPrototypeOf ||
+            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
+            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
+        return extendStatics(d, b);
     };
-    return extendStatics(d, b);
-  };
-  return function(d, b) {
-    extendStatics(d, b);
-    function __() {
-      this.constructor = d;
-    }
-    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
-  };
-}();
+    return function (d, b) {
+        extendStatics(d, b);
+        function __() { this.constructor = d; }
+        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
+    };
+})();
 Object.defineProperty(util, "__esModule", { value: true });
 util.DetailContext = util.NoopContext = util.VError = void 0;
-var VError = function(_super) {
-  __extends(VError2, _super);
-  function VError2(path, message) {
-    var _this = _super.call(this, message) || this;
-    _this.path = path;
-    Object.setPrototypeOf(_this, VError2.prototype);
-    return _this;
-  }
-  return VError2;
-}(Error);
+/**
+ * Error thrown by validation. Besides an informative message, it includes the path to the
+ * property which triggered the failure.
+ */
+var VError = /** @class */ (function (_super) {
+    __extends(VError, _super);
+    function VError(path, message) {
+        var _this = _super.call(this, message) || this;
+        _this.path = path;
+        // See https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work for info about this workaround.
+        Object.setPrototypeOf(_this, VError.prototype);
+        return _this;
+    }
+    return VError;
+}(Error));
 util.VError = VError;
-var NoopContext = function() {
-  function NoopContext2() {
-  }
-  NoopContext2.prototype.fail = function(relPath, message, score) {
-    return false;
-  };
-  NoopContext2.prototype.unionResolver = function() {
-    return this;
-  };
-  NoopContext2.prototype.createContext = function() {
-    return this;
-  };
-  NoopContext2.prototype.resolveUnion = function(ur) {
-  };
-  return NoopContext2;
-}();
+/**
+ * Fast implementation of IContext used for first-pass validation. If that fails, we can validate
+ * using DetailContext to collect error messages. That's faster for the common case when messages
+ * normally pass validation.
+ */
+var NoopContext = /** @class */ (function () {
+    function NoopContext() {
+    }
+    NoopContext.prototype.fail = function (relPath, message, score) {
+        return false;
+    };
+    NoopContext.prototype.unionResolver = function () { return this; };
+    NoopContext.prototype.createContext = function () { return this; };
+    NoopContext.prototype.resolveUnion = function (ur) { };
+    return NoopContext;
+}());
 util.NoopContext = NoopContext;
-var DetailContext = function() {
-  function DetailContext2() {
-    this._propNames = [""];
-    this._messages = [null];
-    this._score = 0;
-  }
-  DetailContext2.prototype.fail = function(relPath, message, score) {
-    this._propNames.push(relPath);
-    this._messages.push(message);
-    this._score += score;
-    return false;
-  };
-  DetailContext2.prototype.unionResolver = function() {
-    return new DetailUnionResolver();
-  };
-  DetailContext2.prototype.resolveUnion = function(unionResolver) {
-    var _a, _b;
-    var u = unionResolver;
-    var best = null;
-    for (var _i = 0, _c = u.contexts; _i < _c.length; _i++) {
-      var ctx = _c[_i];
-      if (!best || ctx._score >= best._score) {
-        best = ctx;
-      }
-    }
-    if (best && best._score > 0) {
-      (_a = this._propNames).push.apply(_a, best._propNames);
-      (_b = this._messages).push.apply(_b, best._messages);
-    }
-  };
-  DetailContext2.prototype.getError = function(path) {
-    var msgParts = [];
-    for (var i = this._propNames.length - 1; i >= 0; i--) {
-      var p = this._propNames[i];
-      path += typeof p === "number" ? "[" + p + "]" : p ? "." + p : "";
-      var m = this._messages[i];
-      if (m) {
-        msgParts.push(path + " " + m);
-      }
-    }
-    return new VError(path, msgParts.join("; "));
-  };
-  DetailContext2.prototype.getErrorDetail = function(path) {
-    var details = [];
-    for (var i = this._propNames.length - 1; i >= 0; i--) {
-      var p = this._propNames[i];
-      path += typeof p === "number" ? "[" + p + "]" : p ? "." + p : "";
-      var message = this._messages[i];
-      if (message) {
-        details.push({ path, message });
-      }
-    }
-    var detail = null;
-    for (var i = details.length - 1; i >= 0; i--) {
-      if (detail) {
-        details[i].nested = [detail];
-      }
-      detail = details[i];
-    }
-    return detail;
-  };
-  return DetailContext2;
-}();
+/**
+ * Complete implementation of IContext that collects meaningfull errors.
+ */
+var DetailContext = /** @class */ (function () {
+    function DetailContext() {
+        // Stack of property names and associated messages for reporting helpful error messages.
+        this._propNames = [""];
+        this._messages = [null];
+        // Score is used to choose the best union member whose DetailContext to use for reporting.
+        // Higher score means better match (or rather less severe mismatch).
+        this._score = 0;
+    }
+    DetailContext.prototype.fail = function (relPath, message, score) {
+        this._propNames.push(relPath);
+        this._messages.push(message);
+        this._score += score;
+        return false;
+    };
+    DetailContext.prototype.unionResolver = function () {
+        return new DetailUnionResolver();
+    };
+    DetailContext.prototype.resolveUnion = function (unionResolver) {
+        var _a, _b;
+        var u = unionResolver;
+        var best = null;
+        for (var _i = 0, _c = u.contexts; _i < _c.length; _i++) {
+            var ctx = _c[_i];
+            if (!best || ctx._score >= best._score) {
+                best = ctx;
+            }
+        }
+        if (best && best._score > 0) {
+            (_a = this._propNames).push.apply(_a, best._propNames);
+            (_b = this._messages).push.apply(_b, best._messages);
+        }
+    };
+    DetailContext.prototype.getError = function (path) {
+        var msgParts = [];
+        for (var i = this._propNames.length - 1; i >= 0; i--) {
+            var p = this._propNames[i];
+            path += (typeof p === "number") ? "[" + p + "]" : (p ? "." + p : "");
+            var m = this._messages[i];
+            if (m) {
+                msgParts.push(path + " " + m);
+            }
+        }
+        return new VError(path, msgParts.join("; "));
+    };
+    DetailContext.prototype.getErrorDetail = function (path) {
+        var details = [];
+        for (var i = this._propNames.length - 1; i >= 0; i--) {
+            var p = this._propNames[i];
+            path += (typeof p === "number") ? "[" + p + "]" : (p ? "." + p : "");
+            var message = this._messages[i];
+            if (message) {
+                details.push({ path: path, message: message });
+            }
+        }
+        var detail = null;
+        for (var i = details.length - 1; i >= 0; i--) {
+            if (detail) {
+                details[i].nested = [detail];
+            }
+            detail = details[i];
+        }
+        return detail;
+    };
+    return DetailContext;
+}());
 util.DetailContext = DetailContext;
-var DetailUnionResolver = function() {
-  function DetailUnionResolver2() {
-    this.contexts = [];
-  }
-  DetailUnionResolver2.prototype.createContext = function() {
-    var ctx = new DetailContext();
-    this.contexts.push(ctx);
-    return ctx;
-  };
-  return DetailUnionResolver2;
-}();
-(function(exports) {
-  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
-    var extendStatics = function(d, b) {
-      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
-        d2.__proto__ = b2;
-      } || function(d2, b2) {
-        for (var p in b2)
-          if (b2.hasOwnProperty(p))
-            d2[p] = b2[p];
-      };
-      return extendStatics(d, b);
+var DetailUnionResolver = /** @class */ (function () {
+    function DetailUnionResolver() {
+        this.contexts = [];
+    }
+    DetailUnionResolver.prototype.createContext = function () {
+        var ctx = new DetailContext();
+        this.contexts.push(ctx);
+        return ctx;
     };
-    return function(d, b) {
-      extendStatics(d, b);
-      function __() {
-        this.constructor = d;
-      }
-      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
+    return DetailUnionResolver;
+}());
+
+(function (exports) {
+/**
+ * This module defines nodes used to define types and validations for objects and interfaces.
+ */
+// tslint:disable:no-shadowed-variable prefer-for-of
+var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
+    var extendStatics = function (d, b) {
+        extendStatics = Object.setPrototypeOf ||
+            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
+            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
+        return extendStatics(d, b);
     };
-  }();
-  Object.defineProperty(exports, "__esModule", { value: true });
-  exports.basicTypes = exports.BasicType = exports.TParamList = exports.TParam = exports.param = exports.TFunc = exports.func = exports.TProp = exports.TOptional = exports.opt = exports.TIface = exports.iface = exports.TEnumLiteral = exports.enumlit = exports.TEnumType = exports.enumtype = exports.TIntersection = exports.intersection = exports.TUnion = exports.union = exports.TTuple = exports.tuple = exports.TArray = exports.array = exports.TLiteral = exports.lit = exports.TName = exports.name = exports.TType = void 0;
-  var util_1 = util;
-  var TType = function() {
-    function TType2() {
-    }
-    return TType2;
-  }();
-  exports.TType = TType;
-  function parseSpec(typeSpec) {
+    return function (d, b) {
+        extendStatics(d, b);
+        function __() { this.constructor = d; }
+        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
+    };
+})();
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.basicTypes = exports.BasicType = exports.TParamList = exports.TParam = exports.param = exports.TFunc = exports.func = exports.TProp = exports.TOptional = exports.opt = exports.TIface = exports.iface = exports.TEnumLiteral = exports.enumlit = exports.TEnumType = exports.enumtype = exports.TIntersection = exports.intersection = exports.TUnion = exports.union = exports.TTuple = exports.tuple = exports.TArray = exports.array = exports.TLiteral = exports.lit = exports.TName = exports.name = exports.TType = void 0;
+var util_1 = util;
+/** Node that represents a type. */
+var TType = /** @class */ (function () {
+    function TType() {
+    }
+    return TType;
+}());
+exports.TType = TType;
+/** Parses a type spec into a TType node. */
+function parseSpec(typeSpec) {
     return typeof typeSpec === "string" ? name(typeSpec) : typeSpec;
-  }
-  function getNamedType(suite, name2) {
-    var ttype = suite[name2];
+}
+function getNamedType(suite, name) {
+    var ttype = suite[name];
     if (!ttype) {
-      throw new Error("Unknown type " + name2);
+        throw new Error("Unknown type " + name);
     }
     return ttype;
-  }
-  function name(value) {
-    return new TName(value);
-  }
-  exports.name = name;
-  var TName = function(_super) {
-    __extends2(TName2, _super);
-    function TName2(name2) {
-      var _this = _super.call(this) || this;
-      _this.name = name2;
-      _this._failMsg = "is not a " + name2;
-      return _this;
-    }
-    TName2.prototype.getChecker = function(suite, strict, allowedProps) {
-      var _this = this;
-      var ttype = getNamedType(suite, this.name);
-      var checker = ttype.getChecker(suite, strict, allowedProps);
-      if (ttype instanceof BasicType || ttype instanceof TName2) {
-        return checker;
-      }
-      return function(value, ctx) {
-        return checker(value, ctx) ? true : ctx.fail(null, _this._failMsg, 0);
-      };
+}
+/**
+ * Defines a type name, either built-in, or defined in this suite. It can typically be included in
+ * the specs as just a plain string.
+ */
+function name(value) { return new TName(value); }
+exports.name = name;
+var TName = /** @class */ (function (_super) {
+    __extends(TName, _super);
+    function TName(name) {
+        var _this = _super.call(this) || this;
+        _this.name = name;
+        _this._failMsg = "is not a " + name;
+        return _this;
+    }
+    TName.prototype.getChecker = function (suite, strict, allowedProps) {
+        var _this = this;
+        var ttype = getNamedType(suite, this.name);
+        var checker = ttype.getChecker(suite, strict, allowedProps);
+        if (ttype instanceof BasicType || ttype instanceof TName) {
+            return checker;
+        }
+        // For complex types, add an additional "is not a <Type>" message on failure.
+        return function (value, ctx) { return checker(value, ctx) ? true : ctx.fail(null, _this._failMsg, 0); };
     };
-    return TName2;
-  }(TType);
-  exports.TName = TName;
-  function lit(value) {
-    return new TLiteral(value);
-  }
-  exports.lit = lit;
-  var TLiteral = function(_super) {
-    __extends2(TLiteral2, _super);
-    function TLiteral2(value) {
-      var _this = _super.call(this) || this;
-      _this.value = value;
-      _this.name = JSON.stringify(value);
-      _this._failMsg = "is not " + _this.name;
-      return _this;
-    }
-    TLiteral2.prototype.getChecker = function(suite, strict) {
-      var _this = this;
-      return function(value, ctx) {
-        return value === _this.value ? true : ctx.fail(null, _this._failMsg, -1);
-      };
+    return TName;
+}(TType));
+exports.TName = TName;
+/**
+ * Defines a literal value, e.g. lit('hello') or lit(123).
+ */
+function lit(value) { return new TLiteral(value); }
+exports.lit = lit;
+var TLiteral = /** @class */ (function (_super) {
+    __extends(TLiteral, _super);
+    function TLiteral(value) {
+        var _this = _super.call(this) || this;
+        _this.value = value;
+        _this.name = JSON.stringify(value);
+        _this._failMsg = "is not " + _this.name;
+        return _this;
+    }
+    TLiteral.prototype.getChecker = function (suite, strict) {
+        var _this = this;
+        return function (value, ctx) { return (value === _this.value) ? true : ctx.fail(null, _this._failMsg, -1); };
     };
-    return TLiteral2;
-  }(TType);
-  exports.TLiteral = TLiteral;
-  function array(typeSpec) {
-    return new TArray(parseSpec(typeSpec));
-  }
-  exports.array = array;
-  var TArray = function(_super) {
-    __extends2(TArray2, _super);
-    function TArray2(ttype) {
-      var _this = _super.call(this) || this;
-      _this.ttype = ttype;
-      return _this;
-    }
-    TArray2.prototype.getChecker = function(suite, strict) {
-      var itemChecker = this.ttype.getChecker(suite, strict);
-      return function(value, ctx) {
-        if (!Array.isArray(value)) {
-          return ctx.fail(null, "is not an array", 0);
-        }
-        for (var i = 0; i < value.length; i++) {
-          var ok = itemChecker(value[i], ctx);
-          if (!ok) {
-            return ctx.fail(i, null, 1);
-          }
-        }
-        return true;
-      };
+    return TLiteral;
+}(TType));
+exports.TLiteral = TLiteral;
+/**
+ * Defines an array type, e.g. array('number').
+ */
+function array(typeSpec) { return new TArray(parseSpec(typeSpec)); }
+exports.array = array;
+var TArray = /** @class */ (function (_super) {
+    __extends(TArray, _super);
+    function TArray(ttype) {
+        var _this = _super.call(this) || this;
+        _this.ttype = ttype;
+        return _this;
+    }
+    TArray.prototype.getChecker = function (suite, strict) {
+        var itemChecker = this.ttype.getChecker(suite, strict);
+        return function (value, ctx) {
+            if (!Array.isArray(value)) {
+                return ctx.fail(null, "is not an array", 0);
+            }
+            for (var i = 0; i < value.length; i++) {
+                var ok = itemChecker(value[i], ctx);
+                if (!ok) {
+                    return ctx.fail(i, null, 1);
+                }
+            }
+            return true;
+        };
     };
-    return TArray2;
-  }(TType);
-  exports.TArray = TArray;
-  function tuple() {
+    return TArray;
+}(TType));
+exports.TArray = TArray;
+/**
+ * Defines a tuple type, e.g. tuple('string', 'number').
+ */
+function tuple() {
     var typeSpec = [];
-    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
-      typeSpec[_i2] = arguments[_i2];
-    }
-    return new TTuple(typeSpec.map(function(t) {
-      return parseSpec(t);
-    }));
-  }
-  exports.tuple = tuple;
-  var TTuple = function(_super) {
-    __extends2(TTuple2, _super);
-    function TTuple2(ttypes) {
-      var _this = _super.call(this) || this;
-      _this.ttypes = ttypes;
-      return _this;
-    }
-    TTuple2.prototype.getChecker = function(suite, strict) {
-      var itemCheckers = this.ttypes.map(function(t) {
-        return t.getChecker(suite, strict);
-      });
-      var checker = function(value, ctx) {
-        if (!Array.isArray(value)) {
-          return ctx.fail(null, "is not an array", 0);
-        }
-        for (var i = 0; i < itemCheckers.length; i++) {
-          var ok = itemCheckers[i](value[i], ctx);
-          if (!ok) {
-            return ctx.fail(i, null, 1);
-          }
-        }
-        return true;
-      };
-      if (!strict) {
-        return checker;
-      }
-      return function(value, ctx) {
-        if (!checker(value, ctx)) {
-          return false;
+    for (var _i = 0; _i < arguments.length; _i++) {
+        typeSpec[_i] = arguments[_i];
+    }
+    return new TTuple(typeSpec.map(function (t) { return parseSpec(t); }));
+}
+exports.tuple = tuple;
+var TTuple = /** @class */ (function (_super) {
+    __extends(TTuple, _super);
+    function TTuple(ttypes) {
+        var _this = _super.call(this) || this;
+        _this.ttypes = ttypes;
+        return _this;
+    }
+    TTuple.prototype.getChecker = function (suite, strict) {
+        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });
+        var checker = function (value, ctx) {
+            if (!Array.isArray(value)) {
+                return ctx.fail(null, "is not an array", 0);
+            }
+            for (var i = 0; i < itemCheckers.length; i++) {
+                var ok = itemCheckers[i](value[i], ctx);
+                if (!ok) {
+                    return ctx.fail(i, null, 1);
+                }
+            }
+            return true;
+        };
+        if (!strict) {
+            return checker;
         }
-        return value.length <= itemCheckers.length ? true : ctx.fail(itemCheckers.length, "is extraneous", 2);
-      };
+        return function (value, ctx) {
+            if (!checker(value, ctx)) {
+                return false;
+            }
+            return value.length <= itemCheckers.length ? true :
+                ctx.fail(itemCheckers.length, "is extraneous", 2);
+        };
     };
-    return TTuple2;
-  }(TType);
-  exports.TTuple = TTuple;
-  function union() {
+    return TTuple;
+}(TType));
+exports.TTuple = TTuple;
+/**
+ * Defines a union type, e.g. union('number', 'null').
+ */
+function union() {
     var typeSpec = [];
-    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
-      typeSpec[_i2] = arguments[_i2];
-    }
-    return new TUnion(typeSpec.map(function(t) {
-      return parseSpec(t);
-    }));
-  }
-  exports.union = union;
-  var TUnion = function(_super) {
-    __extends2(TUnion2, _super);
-    function TUnion2(ttypes) {
-      var _this = _super.call(this) || this;
-      _this.ttypes = ttypes;
-      var names = ttypes.map(function(t) {
-        return t instanceof TName || t instanceof TLiteral ? t.name : null;
-      }).filter(function(n) {
-        return n;
-      });
-      var otherTypes = ttypes.length - names.length;
-      if (names.length) {
-        if (otherTypes > 0) {
-          names.push(otherTypes + " more");
-        }
-        _this._failMsg = "is none of " + names.join(", ");
-      } else {
-        _this._failMsg = "is none of " + otherTypes + " types";
-      }
-      return _this;
-    }
-    TUnion2.prototype.getChecker = function(suite, strict) {
-      var _this = this;
-      var itemCheckers = this.ttypes.map(function(t) {
-        return t.getChecker(suite, strict);
-      });
-      return function(value, ctx) {
-        var ur = ctx.unionResolver();
-        for (var i = 0; i < itemCheckers.length; i++) {
-          var ok = itemCheckers[i](value, ur.createContext());
-          if (ok) {
-            return true;
-          }
-        }
-        ctx.resolveUnion(ur);
-        return ctx.fail(null, _this._failMsg, 0);
-      };
+    for (var _i = 0; _i < arguments.length; _i++) {
+        typeSpec[_i] = arguments[_i];
+    }
+    return new TUnion(typeSpec.map(function (t) { return parseSpec(t); }));
+}
+exports.union = union;
+var TUnion = /** @class */ (function (_super) {
+    __extends(TUnion, _super);
+    function TUnion(ttypes) {
+        var _this = _super.call(this) || this;
+        _this.ttypes = ttypes;
+        var names = ttypes.map(function (t) { return t instanceof TName || t instanceof TLiteral ? t.name : null; })
+            .filter(function (n) { return n; });
+        var otherTypes = ttypes.length - names.length;
+        if (names.length) {
+            if (otherTypes > 0) {
+                names.push(otherTypes + " more");
+            }
+            _this._failMsg = "is none of " + names.join(", ");
+        }
+        else {
+            _this._failMsg = "is none of " + otherTypes + " types";
+        }
+        return _this;
+    }
+    TUnion.prototype.getChecker = function (suite, strict) {
+        var _this = this;
+        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });
+        return function (value, ctx) {
+            var ur = ctx.unionResolver();
+            for (var i = 0; i < itemCheckers.length; i++) {
+                var ok = itemCheckers[i](value, ur.createContext());
+                if (ok) {
+                    return true;
+                }
+            }
+            ctx.resolveUnion(ur);
+            return ctx.fail(null, _this._failMsg, 0);
+        };
     };
-    return TUnion2;
-  }(TType);
-  exports.TUnion = TUnion;
-  function intersection() {
+    return TUnion;
+}(TType));
+exports.TUnion = TUnion;
+/**
+ * Defines an intersection type, e.g. intersection('number', 'null').
+ */
+function intersection() {
     var typeSpec = [];
-    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
-      typeSpec[_i2] = arguments[_i2];
-    }
-    return new TIntersection(typeSpec.map(function(t) {
-      return parseSpec(t);
-    }));
-  }
-  exports.intersection = intersection;
-  var TIntersection = function(_super) {
-    __extends2(TIntersection2, _super);
-    function TIntersection2(ttypes) {
-      var _this = _super.call(this) || this;
-      _this.ttypes = ttypes;
-      return _this;
-    }
-    TIntersection2.prototype.getChecker = function(suite, strict) {
-      var allowedProps = new Set();
-      var itemCheckers = this.ttypes.map(function(t) {
-        return t.getChecker(suite, strict, allowedProps);
-      });
-      return function(value, ctx) {
-        var ok = itemCheckers.every(function(checker) {
-          return checker(value, ctx);
-        });
-        if (ok) {
-          return true;
-        }
-        return ctx.fail(null, null, 0);
-      };
+    for (var _i = 0; _i < arguments.length; _i++) {
+        typeSpec[_i] = arguments[_i];
+    }
+    return new TIntersection(typeSpec.map(function (t) { return parseSpec(t); }));
+}
+exports.intersection = intersection;
+var TIntersection = /** @class */ (function (_super) {
+    __extends(TIntersection, _super);
+    function TIntersection(ttypes) {
+        var _this = _super.call(this) || this;
+        _this.ttypes = ttypes;
+        return _this;
+    }
+    TIntersection.prototype.getChecker = function (suite, strict) {
+        var allowedProps = new Set();
+        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict, allowedProps); });
+        return function (value, ctx) {
+            var ok = itemCheckers.every(function (checker) { return checker(value, ctx); });
+            if (ok) {
+                return true;
+            }
+            return ctx.fail(null, null, 0);
+        };
     };
-    return TIntersection2;
-  }(TType);
-  exports.TIntersection = TIntersection;
-  function enumtype(values) {
+    return TIntersection;
+}(TType));
+exports.TIntersection = TIntersection;
+/**
+ * Defines an enum type, e.g. enum({'A': 1, 'B': 2}).
+ */
+function enumtype(values) {
     return new TEnumType(values);
-  }
-  exports.enumtype = enumtype;
-  var TEnumType = function(_super) {
-    __extends2(TEnumType2, _super);
-    function TEnumType2(members) {
-      var _this = _super.call(this) || this;
-      _this.members = members;
-      _this.validValues = new Set();
-      _this._failMsg = "is not a valid enum value";
-      _this.validValues = new Set(Object.keys(members).map(function(name2) {
-        return members[name2];
-      }));
-      return _this;
-    }
-    TEnumType2.prototype.getChecker = function(suite, strict) {
-      var _this = this;
-      return function(value, ctx) {
-        return _this.validValues.has(value) ? true : ctx.fail(null, _this._failMsg, 0);
-      };
+}
+exports.enumtype = enumtype;
+var TEnumType = /** @class */ (function (_super) {
+    __extends(TEnumType, _super);
+    function TEnumType(members) {
+        var _this = _super.call(this) || this;
+        _this.members = members;
+        _this.validValues = new Set();
+        _this._failMsg = "is not a valid enum value";
+        _this.validValues = new Set(Object.keys(members).map(function (name) { return members[name]; }));
+        return _this;
+    }
+    TEnumType.prototype.getChecker = function (suite, strict) {
+        var _this = this;
+        return function (value, ctx) {
+            return (_this.validValues.has(value) ? true : ctx.fail(null, _this._failMsg, 0));
+        };
     };
-    return TEnumType2;
-  }(TType);
-  exports.TEnumType = TEnumType;
-  function enumlit(name2, prop) {
-    return new TEnumLiteral(name2, prop);
-  }
-  exports.enumlit = enumlit;
-  var TEnumLiteral = function(_super) {
-    __extends2(TEnumLiteral2, _super);
-    function TEnumLiteral2(enumName, prop) {
-      var _this = _super.call(this) || this;
-      _this.enumName = enumName;
-      _this.prop = prop;
-      _this._failMsg = "is not " + enumName + "." + prop;
-      return _this;
-    }
-    TEnumLiteral2.prototype.getChecker = function(suite, strict) {
-      var _this = this;
-      var ttype = getNamedType(suite, this.enumName);
-      if (!(ttype instanceof TEnumType)) {
-        throw new Error("Type " + this.enumName + " used in enumlit is not an enum type");
-      }
-      var val = ttype.members[this.prop];
-      if (!ttype.members.hasOwnProperty(this.prop)) {
-        throw new Error("Unknown value " + this.enumName + "." + this.prop + " used in enumlit");
-      }
-      return function(value, ctx) {
-        return value === val ? true : ctx.fail(null, _this._failMsg, -1);
-      };
+    return TEnumType;
+}(TType));
+exports.TEnumType = TEnumType;
+/**
+ * Defines a literal enum value, such as Direction.Up, specified as enumlit("Direction", "Up").
+ */
+function enumlit(name, prop) {
+    return new TEnumLiteral(name, prop);
+}
+exports.enumlit = enumlit;
+var TEnumLiteral = /** @class */ (function (_super) {
+    __extends(TEnumLiteral, _super);
+    function TEnumLiteral(enumName, prop) {
+        var _this = _super.call(this) || this;
+        _this.enumName = enumName;
+        _this.prop = prop;
+        _this._failMsg = "is not " + enumName + "." + prop;
+        return _this;
+    }
+    TEnumLiteral.prototype.getChecker = function (suite, strict) {
+        var _this = this;
+        var ttype = getNamedType(suite, this.enumName);
+        if (!(ttype instanceof TEnumType)) {
+            throw new Error("Type " + this.enumName + " used in enumlit is not an enum type");
+        }
+        var val = ttype.members[this.prop];
+        if (!ttype.members.hasOwnProperty(this.prop)) {
+            throw new Error("Unknown value " + this.enumName + "." + this.prop + " used in enumlit");
+        }
+        return function (value, ctx) { return (value === val) ? true : ctx.fail(null, _this._failMsg, -1); };
     };
-    return TEnumLiteral2;
-  }(TType);
-  exports.TEnumLiteral = TEnumLiteral;
-  function makeIfaceProps(props) {
-    return Object.keys(props).map(function(name2) {
-      return makeIfaceProp(name2, props[name2]);
-    });
-  }
-  function makeIfaceProp(name2, prop) {
-    return prop instanceof TOptional ? new TProp(name2, prop.ttype, true) : new TProp(name2, parseSpec(prop), false);
-  }
-  function iface(bases, props) {
+    return TEnumLiteral;
+}(TType));
+exports.TEnumLiteral = TEnumLiteral;
+function makeIfaceProps(props) {
+    return Object.keys(props).map(function (name) { return makeIfaceProp(name, props[name]); });
+}
+function makeIfaceProp(name, prop) {
+    return prop instanceof TOptional ?
+        new TProp(name, prop.ttype, true) :
+        new TProp(name, parseSpec(prop), false);
+}
+/**
+ * Defines an interface. The first argument is an array of interfaces that it extends, and the
+ * second is an array of properties.
+ */
+function iface(bases, props) {
     return new TIface(bases, makeIfaceProps(props));
-  }
-  exports.iface = iface;
-  var TIface = function(_super) {
-    __extends2(TIface2, _super);
-    function TIface2(bases, props) {
-      var _this = _super.call(this) || this;
-      _this.bases = bases;
-      _this.props = props;
-      _this.propSet = new Set(props.map(function(p) {
-        return p.name;
-      }));
-      return _this;
-    }
-    TIface2.prototype.getChecker = function(suite, strict, allowedProps) {
-      var _this = this;
-      var baseCheckers = this.bases.map(function(b) {
-        return getNamedType(suite, b).getChecker(suite, strict);
-      });
-      var propCheckers = this.props.map(function(prop) {
-        return prop.ttype.getChecker(suite, strict);
-      });
-      var testCtx = new util_1.NoopContext();
-      var isPropRequired = this.props.map(function(prop, i) {
-        return !prop.isOpt && !propCheckers[i](void 0, testCtx);
-      });
-      var checker = function(value, ctx) {
-        if (typeof value !== "object" || value === null) {
-          return ctx.fail(null, "is not an object", 0);
-        }
-        for (var i = 0; i < baseCheckers.length; i++) {
-          if (!baseCheckers[i](value, ctx)) {
-            return false;
-          }
-        }
-        for (var i = 0; i < propCheckers.length; i++) {
-          var name_1 = _this.props[i].name;
-          var v = value[name_1];
-          if (v === void 0) {
-            if (isPropRequired[i]) {
-              return ctx.fail(name_1, "is missing", 1);
+}
+exports.iface = iface;
+var TIface = /** @class */ (function (_super) {
+    __extends(TIface, _super);
+    function TIface(bases, props) {
+        var _this = _super.call(this) || this;
+        _this.bases = bases;
+        _this.props = props;
+        _this.propSet = new Set(props.map(function (p) { return p.name; }));
+        return _this;
+    }
+    TIface.prototype.getChecker = function (suite, strict, allowedProps) {
+        var _this = this;
+        var baseCheckers = this.bases.map(function (b) { return getNamedType(suite, b).getChecker(suite, strict); });
+        var propCheckers = this.props.map(function (prop) { return prop.ttype.getChecker(suite, strict); });
+        var testCtx = new util_1.NoopContext();
+        // Consider a prop required if it's not optional AND does not allow for undefined as a value.
+        var isPropRequired = this.props.map(function (prop, i) {
+            return !prop.isOpt && !propCheckers[i](undefined, testCtx);
+        });
+        var checker = function (value, ctx) {
+            if (typeof value !== "object" || value === null) {
+                return ctx.fail(null, "is not an object", 0);
             }
-          } else {
-            var ok = propCheckers[i](v, ctx);
-            if (!ok) {
-              return ctx.fail(name_1, null, 1);
+            for (var i = 0; i < baseCheckers.length; i++) {
+                if (!baseCheckers[i](value, ctx)) {
+                    return false;
+                }
             }
-          }
-        }
-        return true;
-      };
-      if (!strict) {
-        return checker;
-      }
-      var propSet = this.propSet;
-      if (allowedProps) {
-        this.propSet.forEach(function(prop) {
-          return allowedProps.add(prop);
-        });
-        propSet = allowedProps;
-      }
-      return function(value, ctx) {
-        if (!checker(value, ctx)) {
-          return false;
-        }
-        for (var prop in value) {
-          if (!propSet.has(prop)) {
-            return ctx.fail(prop, "is extraneous", 2);
-          }
-        }
-        return true;
-      };
+            for (var i = 0; i < propCheckers.length; i++) {
+                var name_1 = _this.props[i].name;
+                var v = value[name_1];
+                if (v === undefined) {
+                    if (isPropRequired[i]) {
+                        return ctx.fail(name_1, "is missing", 1);
+                    }
+                }
+                else {
+                    var ok = propCheckers[i](v, ctx);
+                    if (!ok) {
+                        return ctx.fail(name_1, null, 1);
+                    }
+                }
+            }
+            return true;
+        };
+        if (!strict) {
+            return checker;
+        }
+        var propSet = this.propSet;
+        if (allowedProps) {
+            this.propSet.forEach(function (prop) { return allowedProps.add(prop); });
+            propSet = allowedProps;
+        }
+        // In strict mode, check also for unknown enumerable properties.
+        return function (value, ctx) {
+            if (!checker(value, ctx)) {
+                return false;
+            }
+            for (var prop in value) {
+                if (!propSet.has(prop)) {
+                    return ctx.fail(prop, "is extraneous", 2);
+                }
+            }
+            return true;
+        };
     };
-    return TIface2;
-  }(TType);
-  exports.TIface = TIface;
-  function opt(typeSpec) {
-    return new TOptional(parseSpec(typeSpec));
-  }
-  exports.opt = opt;
-  var TOptional = function(_super) {
-    __extends2(TOptional2, _super);
-    function TOptional2(ttype) {
-      var _this = _super.call(this) || this;
-      _this.ttype = ttype;
-      return _this;
-    }
-    TOptional2.prototype.getChecker = function(suite, strict) {
-      var itemChecker = this.ttype.getChecker(suite, strict);
-      return function(value, ctx) {
-        return value === void 0 || itemChecker(value, ctx);
-      };
+    return TIface;
+}(TType));
+exports.TIface = TIface;
+/**
+ * Defines an optional property on an interface.
+ */
+function opt(typeSpec) { return new TOptional(parseSpec(typeSpec)); }
+exports.opt = opt;
+var TOptional = /** @class */ (function (_super) {
+    __extends(TOptional, _super);
+    function TOptional(ttype) {
+        var _this = _super.call(this) || this;
+        _this.ttype = ttype;
+        return _this;
+    }
+    TOptional.prototype.getChecker = function (suite, strict) {
+        var itemChecker = this.ttype.getChecker(suite, strict);
+        return function (value, ctx) {
+            return value === undefined || itemChecker(value, ctx);
+        };
     };
-    return TOptional2;
-  }(TType);
-  exports.TOptional = TOptional;
-  var TProp = function() {
-    function TProp2(name2, ttype, isOpt) {
-      this.name = name2;
-      this.ttype = ttype;
-      this.isOpt = isOpt;
-    }
-    return TProp2;
-  }();
-  exports.TProp = TProp;
-  function func(resultSpec) {
+    return TOptional;
+}(TType));
+exports.TOptional = TOptional;
+/**
+ * Defines a property in an interface.
+ */
+var TProp = /** @class */ (function () {
+    function TProp(name, ttype, isOpt) {
+        this.name = name;
+        this.ttype = ttype;
+        this.isOpt = isOpt;
+    }
+    return TProp;
+}());
+exports.TProp = TProp;
+/**
+ * Defines a function. The first argument declares the function's return type, the rest declare
+ * its parameters.
+ */
+function func(resultSpec) {
     var params = [];
-    for (var _i2 = 1; _i2 < arguments.length; _i2++) {
-      params[_i2 - 1] = arguments[_i2];
+    for (var _i = 1; _i < arguments.length; _i++) {
+        params[_i - 1] = arguments[_i];
     }
     return new TFunc(new TParamList(params), parseSpec(resultSpec));
-  }
-  exports.func = func;
-  var TFunc = function(_super) {
-    __extends2(TFunc2, _super);
-    function TFunc2(paramList, result) {
-      var _this = _super.call(this) || this;
-      _this.paramList = paramList;
-      _this.result = result;
-      return _this;
-    }
-    TFunc2.prototype.getChecker = function(suite, strict) {
-      return function(value, ctx) {
-        return typeof value === "function" ? true : ctx.fail(null, "is not a function", 0);
-      };
+}
+exports.func = func;
+var TFunc = /** @class */ (function (_super) {
+    __extends(TFunc, _super);
+    function TFunc(paramList, result) {
+        var _this = _super.call(this) || this;
+        _this.paramList = paramList;
+        _this.result = result;
+        return _this;
+    }
+    TFunc.prototype.getChecker = function (suite, strict) {
+        return function (value, ctx) {
+            return typeof value === "function" ? true : ctx.fail(null, "is not a function", 0);
+        };
     };
-    return TFunc2;
-  }(TType);
-  exports.TFunc = TFunc;
-  function param(name2, typeSpec, isOpt) {
-    return new TParam(name2, parseSpec(typeSpec), Boolean(isOpt));
-  }
-  exports.param = param;
-  var TParam = function() {
-    function TParam2(name2, ttype, isOpt) {
-      this.name = name2;
-      this.ttype = ttype;
-      this.isOpt = isOpt;
-    }
-    return TParam2;
-  }();
-  exports.TParam = TParam;
-  var TParamList = function(_super) {
-    __extends2(TParamList2, _super);
-    function TParamList2(params) {
-      var _this = _super.call(this) || this;
-      _this.params = params;
-      return _this;
-    }
-    TParamList2.prototype.getChecker = function(suite, strict) {
-      var _this = this;
-      var itemCheckers = this.params.map(function(t) {
-        return t.ttype.getChecker(suite, strict);
-      });
-      var testCtx = new util_1.NoopContext();
-      var isParamRequired = this.params.map(function(param2, i) {
-        return !param2.isOpt && !itemCheckers[i](void 0, testCtx);
-      });
-      var checker = function(value, ctx) {
-        if (!Array.isArray(value)) {
-          return ctx.fail(null, "is not an array", 0);
-        }
-        for (var i = 0; i < itemCheckers.length; i++) {
-          var p = _this.params[i];
-          if (value[i] === void 0) {
-            if (isParamRequired[i]) {
-              return ctx.fail(p.name, "is missing", 1);
+    return TFunc;
+}(TType));
+exports.TFunc = TFunc;
+/**
+ * Defines a function parameter.
+ */
+function param(name, typeSpec, isOpt) {
+    return new TParam(name, parseSpec(typeSpec), Boolean(isOpt));
+}
+exports.param = param;
+var TParam = /** @class */ (function () {
+    function TParam(name, ttype, isOpt) {
+        this.name = name;
+        this.ttype = ttype;
+        this.isOpt = isOpt;
+    }
+    return TParam;
+}());
+exports.TParam = TParam;
+/**
+ * Defines a function parameter list.
+ */
+var TParamList = /** @class */ (function (_super) {
+    __extends(TParamList, _super);
+    function TParamList(params) {
+        var _this = _super.call(this) || this;
+        _this.params = params;
+        return _this;
+    }
+    TParamList.prototype.getChecker = function (suite, strict) {
+        var _this = this;
+        var itemCheckers = this.params.map(function (t) { return t.ttype.getChecker(suite, strict); });
+        var testCtx = new util_1.NoopContext();
+        var isParamRequired = this.params.map(function (param, i) {
+            return !param.isOpt && !itemCheckers[i](undefined, testCtx);
+        });
+        var checker = function (value, ctx) {
+            if (!Array.isArray(value)) {
+                return ctx.fail(null, "is not an array", 0);
             }
-          } else {
-            var ok = itemCheckers[i](value[i], ctx);
-            if (!ok) {
-              return ctx.fail(p.name, null, 1);
+            for (var i = 0; i < itemCheckers.length; i++) {
+                var p = _this.params[i];
+                if (value[i] === undefined) {
+                    if (isParamRequired[i]) {
+                        return ctx.fail(p.name, "is missing", 1);
+                    }
+                }
+                else {
+                    var ok = itemCheckers[i](value[i], ctx);
+                    if (!ok) {
+                        return ctx.fail(p.name, null, 1);
+                    }
+                }
             }
-          }
-        }
-        return true;
-      };
-      if (!strict) {
-        return checker;
-      }
-      return function(value, ctx) {
-        if (!checker(value, ctx)) {
-          return false;
+            return true;
+        };
+        if (!strict) {
+            return checker;
         }
-        return value.length <= itemCheckers.length ? true : ctx.fail(itemCheckers.length, "is extraneous", 2);
-      };
+        return function (value, ctx) {
+            if (!checker(value, ctx)) {
+                return false;
+            }
+            return value.length <= itemCheckers.length ? true :
+                ctx.fail(itemCheckers.length, "is extraneous", 2);
+        };
     };
-    return TParamList2;
-  }(TType);
-  exports.TParamList = TParamList;
-  var BasicType = function(_super) {
-    __extends2(BasicType2, _super);
-    function BasicType2(validator, message) {
-      var _this = _super.call(this) || this;
-      _this.validator = validator;
-      _this.message = message;
-      return _this;
-    }
-    BasicType2.prototype.getChecker = function(suite, strict) {
-      var _this = this;
-      return function(value, ctx) {
-        return _this.validator(value) ? true : ctx.fail(null, _this.message, 0);
-      };
+    return TParamList;
+}(TType));
+exports.TParamList = TParamList;
+/**
+ * Single TType implementation for all basic built-in types.
+ */
+var BasicType = /** @class */ (function (_super) {
+    __extends(BasicType, _super);
+    function BasicType(validator, message) {
+        var _this = _super.call(this) || this;
+        _this.validator = validator;
+        _this.message = message;
+        return _this;
+    }
+    BasicType.prototype.getChecker = function (suite, strict) {
+        var _this = this;
+        return function (value, ctx) { return _this.validator(value) ? true : ctx.fail(null, _this.message, 0); };
     };
-    return BasicType2;
-  }(TType);
-  exports.BasicType = BasicType;
-  exports.basicTypes = {
-    any: new BasicType(function(v) {
-      return true;
-    }, "is invalid"),
-    number: new BasicType(function(v) {
-      return typeof v === "number";
-    }, "is not a number"),
-    object: new BasicType(function(v) {
-      return typeof v === "object" && v;
-    }, "is not an object"),
-    boolean: new BasicType(function(v) {
-      return typeof v === "boolean";
-    }, "is not a boolean"),
-    string: new BasicType(function(v) {
-      return typeof v === "string";
-    }, "is not a string"),
-    symbol: new BasicType(function(v) {
-      return typeof v === "symbol";
-    }, "is not a symbol"),
-    void: new BasicType(function(v) {
-      return v == null;
-    }, "is not void"),
-    undefined: new BasicType(function(v) {
-      return v === void 0;
-    }, "is not undefined"),
-    null: new BasicType(function(v) {
-      return v === null;
-    }, "is not null"),
-    never: new BasicType(function(v) {
-      return false;
-    }, "is unexpected"),
+    return BasicType;
+}(TType));
+exports.BasicType = BasicType;
+/**
+ * Defines the suite of basic types.
+ */
+exports.basicTypes = {
+    any: new BasicType(function (v) { return true; }, "is invalid"),
+    number: new BasicType(function (v) { return (typeof v === "number"); }, "is not a number"),
+    object: new BasicType(function (v) { return (typeof v === "object" && v); }, "is not an object"),
+    boolean: new BasicType(function (v) { return (typeof v === "boolean"); }, "is not a boolean"),
+    string: new BasicType(function (v) { return (typeof v === "string"); }, "is not a string"),
+    symbol: new BasicType(function (v) { return (typeof v === "symbol"); }, "is not a symbol"),
+    void: new BasicType(function (v) { return (v == null); }, "is not void"),
+    undefined: new BasicType(function (v) { return (v === undefined); }, "is not undefined"),
+    null: new BasicType(function (v) { return (v === null); }, "is not null"),
+    never: new BasicType(function (v) { return false; }, "is unexpected"),
     Date: new BasicType(getIsNativeChecker("[object Date]"), "is not a Date"),
-    RegExp: new BasicType(getIsNativeChecker("[object RegExp]"), "is not a RegExp")
-  };
-  var nativeToString = Object.prototype.toString;
-  function getIsNativeChecker(tag) {
-    return function(v) {
-      return typeof v === "object" && v && nativeToString.call(v) === tag;
-    };
-  }
-  if (typeof Buffer !== "undefined") {
-    exports.basicTypes.Buffer = new BasicType(function(v) {
-      return Buffer.isBuffer(v);
-    }, "is not a Buffer");
-  }
-  var _loop_1 = function(array_12) {
-    exports.basicTypes[array_12.name] = new BasicType(function(v) {
-      return v instanceof array_12;
-    }, "is not a " + array_12.name);
-  };
-  for (var _i = 0, _a = [
-    Int8Array,
-    Uint8Array,
-    Uint8ClampedArray,
-    Int16Array,
-    Uint16Array,
-    Int32Array,
-    Uint32Array,
-    Float32Array,
-    Float64Array,
-    ArrayBuffer
-  ]; _i < _a.length; _i++) {
+    RegExp: new BasicType(getIsNativeChecker("[object RegExp]"), "is not a RegExp"),
+};
+// This approach for checking native object types mirrors that of lodash. Its advantage over
+// `isinstance` is that it can still return true for native objects created in different JS
+// execution environments.
+var nativeToString = Object.prototype.toString;
+function getIsNativeChecker(tag) {
+    return function (v) { return typeof v === "object" && v && nativeToString.call(v) === tag; };
+}
+if (typeof Buffer !== "undefined") {
+    exports.basicTypes.Buffer = new BasicType(function (v) { return Buffer.isBuffer(v); }, "is not a Buffer");
+}
+var _loop_1 = function (array_1) {
+    exports.basicTypes[array_1.name] = new BasicType(function (v) { return (v instanceof array_1); }, "is not a " + array_1.name);
+};
+// Support typed arrays of various flavors
+for (var _i = 0, _a = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,
+    Int32Array, Uint32Array, Float32Array, Float64Array, ArrayBuffer]; _i < _a.length; _i++) {
     var array_1 = _a[_i];
     _loop_1(array_1);
-  }
-})(types);
-(function(exports) {
-  var __spreadArrays = commonjsGlobal && commonjsGlobal.__spreadArrays || function() {
-    for (var s = 0, i = 0, il = arguments.length; i < il; i++)
-      s += arguments[i].length;
+}
+}(types));
+
+(function (exports) {
+var __spreadArrays = (commonjsGlobal && commonjsGlobal.__spreadArrays) || function () {
+    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
     for (var r = Array(s), k = 0, i = 0; i < il; i++)
-      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
-        r[k] = a[j];
+        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
+            r[k] = a[j];
     return r;
-  };
-  Object.defineProperty(exports, "__esModule", { value: true });
-  exports.Checker = exports.createCheckers = void 0;
-  var types_1 = types;
-  var util_1 = util;
-  var types_2 = types;
-  Object.defineProperty(exports, "TArray", { enumerable: true, get: function() {
-    return types_2.TArray;
-  } });
-  Object.defineProperty(exports, "TEnumType", { enumerable: true, get: function() {
-    return types_2.TEnumType;
-  } });
-  Object.defineProperty(exports, "TEnumLiteral", { enumerable: true, get: function() {
-    return types_2.TEnumLiteral;
-  } });
-  Object.defineProperty(exports, "TFunc", { enumerable: true, get: function() {
-    return types_2.TFunc;
-  } });
-  Object.defineProperty(exports, "TIface", { enumerable: true, get: function() {
-    return types_2.TIface;
-  } });
-  Object.defineProperty(exports, "TLiteral", { enumerable: true, get: function() {
-    return types_2.TLiteral;
-  } });
-  Object.defineProperty(exports, "TName", { enumerable: true, get: function() {
-    return types_2.TName;
-  } });
-  Object.defineProperty(exports, "TOptional", { enumerable: true, get: function() {
-    return types_2.TOptional;
-  } });
-  Object.defineProperty(exports, "TParam", { enumerable: true, get: function() {
-    return types_2.TParam;
-  } });
-  Object.defineProperty(exports, "TParamList", { enumerable: true, get: function() {
-    return types_2.TParamList;
-  } });
-  Object.defineProperty(exports, "TProp", { enumerable: true, get: function() {
-    return types_2.TProp;
-  } });
-  Object.defineProperty(exports, "TTuple", { enumerable: true, get: function() {
-    return types_2.TTuple;
-  } });
-  Object.defineProperty(exports, "TType", { enumerable: true, get: function() {
-    return types_2.TType;
-  } });
-  Object.defineProperty(exports, "TUnion", { enumerable: true, get: function() {
-    return types_2.TUnion;
-  } });
-  Object.defineProperty(exports, "TIntersection", { enumerable: true, get: function() {
-    return types_2.TIntersection;
-  } });
-  Object.defineProperty(exports, "array", { enumerable: true, get: function() {
-    return types_2.array;
-  } });
-  Object.defineProperty(exports, "enumlit", { enumerable: true, get: function() {
-    return types_2.enumlit;
-  } });
-  Object.defineProperty(exports, "enumtype", { enumerable: true, get: function() {
-    return types_2.enumtype;
-  } });
-  Object.defineProperty(exports, "func", { enumerable: true, get: function() {
-    return types_2.func;
-  } });
-  Object.defineProperty(exports, "iface", { enumerable: true, get: function() {
-    return types_2.iface;
-  } });
-  Object.defineProperty(exports, "lit", { enumerable: true, get: function() {
-    return types_2.lit;
-  } });
-  Object.defineProperty(exports, "name", { enumerable: true, get: function() {
-    return types_2.name;
-  } });
-  Object.defineProperty(exports, "opt", { enumerable: true, get: function() {
-    return types_2.opt;
-  } });
-  Object.defineProperty(exports, "param", { enumerable: true, get: function() {
-    return types_2.param;
-  } });
-  Object.defineProperty(exports, "tuple", { enumerable: true, get: function() {
-    return types_2.tuple;
-  } });
-  Object.defineProperty(exports, "union", { enumerable: true, get: function() {
-    return types_2.union;
-  } });
-  Object.defineProperty(exports, "intersection", { enumerable: true, get: function() {
-    return types_2.intersection;
-  } });
-  Object.defineProperty(exports, "BasicType", { enumerable: true, get: function() {
-    return types_2.BasicType;
-  } });
-  var util_2 = util;
-  Object.defineProperty(exports, "VError", { enumerable: true, get: function() {
-    return util_2.VError;
-  } });
-  function createCheckers() {
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.Checker = exports.createCheckers = void 0;
+var types_1 = types;
+var util_1 = util;
+/**
+ * Export functions used to define interfaces.
+ */
+var types_2 = types;
+Object.defineProperty(exports, "TArray", { enumerable: true, get: function () { return types_2.TArray; } });
+Object.defineProperty(exports, "TEnumType", { enumerable: true, get: function () { return types_2.TEnumType; } });
+Object.defineProperty(exports, "TEnumLiteral", { enumerable: true, get: function () { return types_2.TEnumLiteral; } });
+Object.defineProperty(exports, "TFunc", { enumerable: true, get: function () { return types_2.TFunc; } });
+Object.defineProperty(exports, "TIface", { enumerable: true, get: function () { return types_2.TIface; } });
+Object.defineProperty(exports, "TLiteral", { enumerable: true, get: function () { return types_2.TLiteral; } });
+Object.defineProperty(exports, "TName", { enumerable: true, get: function () { return types_2.TName; } });
+Object.defineProperty(exports, "TOptional", { enumerable: true, get: function () { return types_2.TOptional; } });
+Object.defineProperty(exports, "TParam", { enumerable: true, get: function () { return types_2.TParam; } });
+Object.defineProperty(exports, "TParamList", { enumerable: true, get: function () { return types_2.TParamList; } });
+Object.defineProperty(exports, "TProp", { enumerable: true, get: function () { return types_2.TProp; } });
+Object.defineProperty(exports, "TTuple", { enumerable: true, get: function () { return types_2.TTuple; } });
+Object.defineProperty(exports, "TType", { enumerable: true, get: function () { return types_2.TType; } });
+Object.defineProperty(exports, "TUnion", { enumerable: true, get: function () { return types_2.TUnion; } });
+Object.defineProperty(exports, "TIntersection", { enumerable: true, get: function () { return types_2.TIntersection; } });
+Object.defineProperty(exports, "array", { enumerable: true, get: function () { return types_2.array; } });
+Object.defineProperty(exports, "enumlit", { enumerable: true, get: function () { return types_2.enumlit; } });
+Object.defineProperty(exports, "enumtype", { enumerable: true, get: function () { return types_2.enumtype; } });
+Object.defineProperty(exports, "func", { enumerable: true, get: function () { return types_2.func; } });
+Object.defineProperty(exports, "iface", { enumerable: true, get: function () { return types_2.iface; } });
+Object.defineProperty(exports, "lit", { enumerable: true, get: function () { return types_2.lit; } });
+Object.defineProperty(exports, "name", { enumerable: true, get: function () { return types_2.name; } });
+Object.defineProperty(exports, "opt", { enumerable: true, get: function () { return types_2.opt; } });
+Object.defineProperty(exports, "param", { enumerable: true, get: function () { return types_2.param; } });
+Object.defineProperty(exports, "tuple", { enumerable: true, get: function () { return types_2.tuple; } });
+Object.defineProperty(exports, "union", { enumerable: true, get: function () { return types_2.union; } });
+Object.defineProperty(exports, "intersection", { enumerable: true, get: function () { return types_2.intersection; } });
+Object.defineProperty(exports, "BasicType", { enumerable: true, get: function () { return types_2.BasicType; } });
+var util_2 = util;
+Object.defineProperty(exports, "VError", { enumerable: true, get: function () { return util_2.VError; } });
+/**
+ * Takes one of more type suites (e.g. a module generated by `ts-interface-builder`), and combines
+ * them into a suite of interface checkers. If a type is used by name, that name should be present
+ * among the passed-in type suites.
+ *
+ * The returned object maps type names to Checker objects.
+ */
+function createCheckers() {
     var typeSuite = [];
     for (var _i = 0; _i < arguments.length; _i++) {
-      typeSuite[_i] = arguments[_i];
+        typeSuite[_i] = arguments[_i];
     }
     var fullSuite = Object.assign.apply(Object, __spreadArrays([{}, types_1.basicTypes], typeSuite));
     var checkers = {};
     for (var _a = 0, typeSuite_1 = typeSuite; _a < typeSuite_1.length; _a++) {
-      var suite_1 = typeSuite_1[_a];
-      for (var _b = 0, _c = Object.keys(suite_1); _b < _c.length; _b++) {
-        var name = _c[_b];
-        checkers[name] = new Checker(fullSuite, suite_1[name]);
-      }
+        var suite_1 = typeSuite_1[_a];
+        for (var _b = 0, _c = Object.keys(suite_1); _b < _c.length; _b++) {
+            var name = _c[_b];
+            checkers[name] = new Checker(fullSuite, suite_1[name]);
+        }
     }
     return checkers;
-  }
-  exports.createCheckers = createCheckers;
-  var Checker = function() {
-    function Checker2(suite, ttype, _path) {
-      if (_path === void 0) {
-        _path = "value";
-      }
-      this.suite = suite;
-      this.ttype = ttype;
-      this._path = _path;
-      this.props = new Map();
-      if (ttype instanceof types_1.TIface) {
-        for (var _i = 0, _a = ttype.props; _i < _a.length; _i++) {
-          var p = _a[_i];
-          this.props.set(p.name, p.ttype);
+}
+exports.createCheckers = createCheckers;
+/**
+ * Checker implements validation of objects, and also includes accessors to validate method calls.
+ * Checkers should be created using `createCheckers()`.
+ */
+var Checker = /** @class */ (function () {
+    // Create checkers by using `createCheckers()` function.
+    function Checker(suite, ttype, _path) {
+        if (_path === void 0) { _path = 'value'; }
+        this.suite = suite;
+        this.ttype = ttype;
+        this._path = _path;
+        this.props = new Map();
+        if (ttype instanceof types_1.TIface) {
+            for (var _i = 0, _a = ttype.props; _i < _a.length; _i++) {
+                var p = _a[_i];
+                this.props.set(p.name, p.ttype);
+            }
         }
-      }
-      this.checkerPlain = this.ttype.getChecker(suite, false);
-      this.checkerStrict = this.ttype.getChecker(suite, true);
+        this.checkerPlain = this.ttype.getChecker(suite, false);
+        this.checkerStrict = this.ttype.getChecker(suite, true);
     }
-    Checker2.prototype.setReportedPath = function(path) {
-      this._path = path;
+    /**
+     * Set the path to report in errors, instead of the default "value". (E.g. if the Checker is for
+     * a "person" interface, set path to "person" to report e.g. "person.name is not a string".)
+     */
+    Checker.prototype.setReportedPath = function (path) {
+        this._path = path;
     };
-    Checker2.prototype.check = function(value) {
-      return this._doCheck(this.checkerPlain, value);
+    /**
+     * Check that the given value satisfies this checker's type, or throw Error.
+     */
+    Checker.prototype.check = function (value) { return this._doCheck(this.checkerPlain, value); };
+    /**
+     * A fast check for whether or not the given value satisfies this Checker's type. This returns
+     * true or false, does not produce an error message, and is fast both on success and on failure.
+     */
+    Checker.prototype.test = function (value) {
+        return this.checkerPlain(value, new util_1.NoopContext());
     };
-    Checker2.prototype.test = function(value) {
-      return this.checkerPlain(value, new util_1.NoopContext());
+    /**
+     * Returns an error object describing the errors if the given value does not satisfy this
+     * Checker's type, or null if it does.
+     */
+    Checker.prototype.validate = function (value) {
+        return this._doValidate(this.checkerPlain, value);
     };
-    Checker2.prototype.validate = function(value) {
-      return this._doValidate(this.checkerPlain, value);
+    /**
+     * Check that the given value satisfies this checker's type strictly. This checks that objects
+     * and tuples have no extra members. Note that this prevents backward compatibility, so usually
+     * a plain check() is more appropriate.
+     */
+    Checker.prototype.strictCheck = function (value) { return this._doCheck(this.checkerStrict, value); };
+    /**
+     * A fast strict check for whether or not the given value satisfies this Checker's type. Returns
+     * true or false, does not produce an error message, and is fast both on success and on failure.
+     */
+    Checker.prototype.strictTest = function (value) {
+        return this.checkerStrict(value, new util_1.NoopContext());
     };
-    Checker2.prototype.strictCheck = function(value) {
-      return this._doCheck(this.checkerStrict, value);
+    /**
+     * Returns an error object describing the errors if the given value does not satisfy this
+     * Checker's type strictly, or null if it does.
+     */
+    Checker.prototype.strictValidate = function (value) {
+        return this._doValidate(this.checkerStrict, value);
     };
-    Checker2.prototype.strictTest = function(value) {
-      return this.checkerStrict(value, new util_1.NoopContext());
+    /**
+     * If this checker is for an interface, returns a Checker for the type required for the given
+     * property of this interface.
+     */
+    Checker.prototype.getProp = function (prop) {
+        var ttype = this.props.get(prop);
+        if (!ttype) {
+            throw new Error("Type has no property " + prop);
+        }
+        return new Checker(this.suite, ttype, this._path + "." + prop);
     };
-    Checker2.prototype.strictValidate = function(value) {
-      return this._doValidate(this.checkerStrict, value);
+    /**
+     * If this checker is for an interface, returns a Checker for the argument-list required to call
+     * the given method of this interface. E.g. if this Checker is for the interface:
+     *    interface Foo {
+     *      find(s: string, pos?: number): number;
+     *    }
+     * Then methodArgs("find").check(...) will succeed for ["foo"] and ["foo", 3], but not for [17].
+     */
+    Checker.prototype.methodArgs = function (methodName) {
+        var tfunc = this._getMethod(methodName);
+        return new Checker(this.suite, tfunc.paramList);
     };
-    Checker2.prototype.getProp = function(prop) {
-      var ttype = this.props.get(prop);
-      if (!ttype) {
-        throw new Error("Type has no property " + prop);
-      }
-      return new Checker2(this.suite, ttype, this._path + "." + prop);
-    };
-    Checker2.prototype.methodArgs = function(methodName) {
-      var tfunc = this._getMethod(methodName);
-      return new Checker2(this.suite, tfunc.paramList);
+    /**
+     * If this checker is for an interface, returns a Checker for the return value of the given
+     * method of this interface.
+     */
+    Checker.prototype.methodResult = function (methodName) {
+        var tfunc = this._getMethod(methodName);
+        return new Checker(this.suite, tfunc.result);
     };
-    Checker2.prototype.methodResult = function(methodName) {
-      var tfunc = this._getMethod(methodName);
-      return new Checker2(this.suite, tfunc.result);
+    /**
+     * If this checker is for a function, returns a Checker for its argument-list.
+     */
+    Checker.prototype.getArgs = function () {
+        if (!(this.ttype instanceof types_1.TFunc)) {
+            throw new Error("getArgs() applied to non-function");
+        }
+        return new Checker(this.suite, this.ttype.paramList);
     };
-    Checker2.prototype.getArgs = function() {
-      if (!(this.ttype instanceof types_1.TFunc)) {
-        throw new Error("getArgs() applied to non-function");
-      }
-      return new Checker2(this.suite, this.ttype.paramList);
+    /**
+     * If this checker is for a function, returns a Checker for its result.
+     */
+    Checker.prototype.getResult = function () {
+        if (!(this.ttype instanceof types_1.TFunc)) {
+            throw new Error("getResult() applied to non-function");
+        }
+        return new Checker(this.suite, this.ttype.result);
     };
-    Checker2.prototype.getResult = function() {
-      if (!(this.ttype instanceof types_1.TFunc)) {
-        throw new Error("getResult() applied to non-function");
-      }
-      return new Checker2(this.suite, this.ttype.result);
+    /**
+     * Return the type for which this is a checker.
+     */
+    Checker.prototype.getType = function () {
+        return this.ttype;
     };
-    Checker2.prototype.getType = function() {
-      return this.ttype;
+    /**
+     * Actual implementation of check() and strictCheck().
+     */
+    Checker.prototype._doCheck = function (checkerFunc, value) {
+        var noopCtx = new util_1.NoopContext();
+        if (!checkerFunc(value, noopCtx)) {
+            var detailCtx = new util_1.DetailContext();
+            checkerFunc(value, detailCtx);
+            throw detailCtx.getError(this._path);
+        }
     };
-    Checker2.prototype._doCheck = function(checkerFunc, value) {
-      var noopCtx = new util_1.NoopContext();
-      if (!checkerFunc(value, noopCtx)) {
+    Checker.prototype._doValidate = function (checkerFunc, value) {
+        var noopCtx = new util_1.NoopContext();
+        if (checkerFunc(value, noopCtx)) {
+            return null;
+        }
         var detailCtx = new util_1.DetailContext();
         checkerFunc(value, detailCtx);
-        throw detailCtx.getError(this._path);
-      }
+        return detailCtx.getErrorDetail(this._path);
     };
-    Checker2.prototype._doValidate = function(checkerFunc, value) {
-      var noopCtx = new util_1.NoopContext();
-      if (checkerFunc(value, noopCtx)) {
-        return null;
-      }
-      var detailCtx = new util_1.DetailContext();
-      checkerFunc(value, detailCtx);
-      return detailCtx.getErrorDetail(this._path);
-    };
-    Checker2.prototype._getMethod = function(methodName) {
-      var ttype = this.props.get(methodName);
-      if (!ttype) {
-        throw new Error("Type has no property " + methodName);
-      }
-      if (!(ttype instanceof types_1.TFunc)) {
-        throw new Error("Property " + methodName + " is not a method");
-      }
-      return ttype;
+    Checker.prototype._getMethod = function (methodName) {
+        var ttype = this.props.get(methodName);
+        if (!ttype) {
+            throw new Error("Type has no property " + methodName);
+        }
+        if (!(ttype instanceof types_1.TFunc)) {
+            throw new Error("Property " + methodName + " is not a method");
+        }
+        return ttype;
     };
-    return Checker2;
-  }();
-  exports.Checker = Checker;
-})(dist);
-const Transform = dist.union(dist.lit("jsx"), dist.lit("typescript"), dist.lit("flow"), dist.lit("imports"), dist.lit("react-hot-loader"), dist.lit("jest"));
+    return Checker;
+}());
+exports.Checker = Checker;
+}(dist));
+
+/**
+ * This module was automatically generated by `ts-interface-builder`
+ */
+// tslint:disable:object-literal-key-quotes
+
+const Transform = dist.union(
+  dist.lit("jsx"),
+  dist.lit("typescript"),
+  dist.lit("flow"),
+  dist.lit("imports"),
+  dist.lit("react-hot-loader"),
+  dist.lit("jest"),
+);
+
 const SourceMapOptions = dist.iface([], {
-  compiledFilename: "string"
+  compiledFilename: "string",
 });
+
 const Options = dist.iface([], {
   transforms: dist.array("Transform"),
   jsxPragma: dist.opt("string"),
@@ -28377,33 +20150,90 @@ const Options = dist.iface([], {
   sourceMapOptions: dist.opt("SourceMapOptions"),
   filePath: dist.opt("string"),
   production: dist.opt("boolean"),
-  disableESTransforms: dist.opt("boolean")
+  disableESTransforms: dist.opt("boolean"),
 });
+
 const exportedTypeSuite = {
   Transform,
   SourceMapOptions,
-  Options
+  Options,
 };
-const { Options: OptionsChecker } = dist.createCheckers(exportedTypeSuite);
+
+const {Options: OptionsChecker} = dist.createCheckers(exportedTypeSuite);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
 function validateOptions(options) {
   OptionsChecker.strictCheck(options);
 }
+
 function parseSpread() {
   next();
   parseMaybeAssign(false);
 }
+
 function parseRest(isBlockScope) {
   next();
   parseBindingAtom(isBlockScope);
 }
+
 function parseBindingIdentifier(isBlockScope) {
   parseIdentifier();
   markPriorBindingIdentifier(isBlockScope);
 }
+
 function parseImportedIdentifier() {
   parseIdentifier();
   state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;
 }
+
 function markPriorBindingIdentifier(isBlockScope) {
   let identifierRole;
   if (state.scopeDepth === 0) {
@@ -28415,54 +20245,71 @@ function markPriorBindingIdentifier(isBlockScope) {
   }
   state.tokens[state.tokens.length - 1].identifierRole = identifierRole;
 }
+
+// Parses lvalue (assignable) atom.
 function parseBindingAtom(isBlockScope) {
   switch (state.type) {
     case TokenType._this: {
+      // In TypeScript, "this" may be the name of a parameter, so allow it.
       const oldIsType = pushTypeContext(0);
       next();
       popTypeContext(oldIsType);
       return;
     }
+
     case TokenType._yield:
     case TokenType.name: {
       state.type = TokenType.name;
       parseBindingIdentifier(isBlockScope);
       return;
     }
+
     case TokenType.bracketL: {
       next();
-      parseBindingList(TokenType.bracketR, isBlockScope, true);
+      parseBindingList(TokenType.bracketR, isBlockScope, true /* allowEmpty */);
       return;
     }
+
     case TokenType.braceL:
       parseObj(true, isBlockScope);
       return;
+
     default:
       unexpected();
   }
 }
-function parseBindingList(close, isBlockScope, allowEmpty = false, allowModifiers = false, contextId = 0) {
+
+function parseBindingList(
+  close,
+  isBlockScope,
+  allowEmpty = false,
+  allowModifiers = false,
+  contextId = 0,
+) {
   let first = true;
+
   let hasRemovedComma = false;
   const firstItemTokenIndex = state.tokens.length;
+
   while (!eat(close) && !state.error) {
     if (first) {
       first = false;
     } else {
       expect(TokenType.comma);
       state.tokens[state.tokens.length - 1].contextId = contextId;
+      // After a "this" type in TypeScript, we need to set the following comma (if any) to also be
+      // a type token so that it will be removed.
       if (!hasRemovedComma && state.tokens[firstItemTokenIndex].isType) {
         state.tokens[state.tokens.length - 1].isType = true;
         hasRemovedComma = true;
       }
     }
-    if (allowEmpty && match(TokenType.comma))
-      ;
-    else if (eat(close)) {
+    if (allowEmpty && match(TokenType.comma)) ; else if (eat(close)) {
       break;
     } else if (match(TokenType.ellipsis)) {
       parseRest(isBlockScope);
       parseAssignableListItemTypes();
+      // Support rest element trailing commas allowed by TypeScript <2.9.
       eat(TokenType.comma);
       expect(close);
       break;
@@ -28471,6 +20318,7 @@ function parseBindingList(close, isBlockScope, allowEmpty = false, allowModifier
     }
   }
 }
+
 function parseAssignableListItem(allowModifiers, isBlockScope) {
   if (allowModifiers) {
     tsParseModifiers([
@@ -28478,13 +20326,15 @@ function parseAssignableListItem(allowModifiers, isBlockScope) {
       ContextualKeyword._protected,
       ContextualKeyword._private,
       ContextualKeyword._readonly,
-      ContextualKeyword._override
+      ContextualKeyword._override,
     ]);
   }
+
   parseMaybeDefault(isBlockScope);
   parseAssignableListItemTypes();
-  parseMaybeDefault(isBlockScope, true);
+  parseMaybeDefault(isBlockScope, true /* leftAlreadyParsed */);
 }
+
 function parseAssignableListItemTypes() {
   if (isFlowEnabled) {
     flowParseAssignableListItemTypes();
@@ -28492,6 +20342,8 @@ function parseAssignableListItemTypes() {
     tsParseAssignableListItemTypes();
   }
 }
+
+// Parses assignment pattern around given atom if possible.
 function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {
   if (!leftAlreadyParsed) {
     parseBindingAtom(isBlockScope);
@@ -28503,16 +20355,41 @@ function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {
   parseMaybeAssign();
   state.tokens[eqIndex].rhsEndIndex = state.tokens.length;
 }
+
 function tsIsIdentifier() {
+  // TODO: actually a bit more complex in TypeScript, but shouldn't matter.
+  // See https://github.com/Microsoft/TypeScript/issues/15008
   return match(TokenType.name);
 }
+
 function isLiteralPropertyName() {
-  return match(TokenType.name) || Boolean(state.type & TokenType.IS_KEYWORD) || match(TokenType.string) || match(TokenType.num) || match(TokenType.bigint) || match(TokenType.decimal);
+  return (
+    match(TokenType.name) ||
+    Boolean(state.type & TokenType.IS_KEYWORD) ||
+    match(TokenType.string) ||
+    match(TokenType.num) ||
+    match(TokenType.bigint) ||
+    match(TokenType.decimal)
+  );
 }
+
 function tsNextTokenCanFollowModifier() {
+  // Note: TypeScript's implementation is much more complicated because
+  // more things are considered modifiers there.
+  // This implementation only handles modifiers not handled by babylon itself. And "static".
+  // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...
   const snapshot = state.snapshot();
+
   next();
-  const canFollowModifier = (match(TokenType.bracketL) || match(TokenType.braceL) || match(TokenType.star) || match(TokenType.ellipsis) || match(TokenType.hash) || isLiteralPropertyName()) && !hasPrecedingLineBreak();
+  const canFollowModifier =
+    (match(TokenType.bracketL) ||
+      match(TokenType.braceL) ||
+      match(TokenType.star) ||
+      match(TokenType.ellipsis) ||
+      match(TokenType.hash) ||
+      isLiteralPropertyName()) &&
+    !hasPrecedingLineBreak();
+
   if (canFollowModifier) {
     return true;
   } else {
@@ -28520,6 +20397,7 @@ function tsNextTokenCanFollowModifier() {
     return false;
   }
 }
+
 function tsParseModifiers(allowedModifiers) {
   while (true) {
     const modifier = tsParseModifier(allowedModifiers);
@@ -28528,10 +20406,15 @@ function tsParseModifiers(allowedModifiers) {
     }
   }
 }
-function tsParseModifier(allowedModifiers) {
+
+/** Parses a modifier matching one the given modifier names. */
+function tsParseModifier(
+  allowedModifiers,
+) {
   if (!match(TokenType.name)) {
     return null;
   }
+
   const modifier = state.contextualKeyword;
   if (allowedModifiers.indexOf(modifier) !== -1 && tsNextTokenCanFollowModifier()) {
     switch (modifier) {
@@ -28564,25 +20447,30 @@ function tsParseModifier(allowedModifiers) {
   }
   return null;
 }
+
 function tsParseEntityName() {
   parseIdentifier();
   while (eat(TokenType.dot)) {
     parseIdentifier();
   }
 }
+
 function tsParseTypeReference() {
   tsParseEntityName();
   if (!hasPrecedingLineBreak() && match(TokenType.lessThan)) {
     tsParseTypeArguments();
   }
 }
+
 function tsParseThisTypePredicate() {
   next();
   tsParseTypeAnnotation();
 }
+
 function tsParseThisTypeNode() {
   next();
 }
+
 function tsParseTypeQuery() {
   expect(TokenType._typeof);
   if (match(TokenType._import)) {
@@ -28591,6 +20479,7 @@ function tsParseTypeQuery() {
     tsParseEntityName();
   }
 }
+
 function tsParseImportType() {
   expect(TokenType._import);
   expect(TokenType.parenL);
@@ -28603,6 +20492,7 @@ function tsParseImportType() {
     tsParseTypeArguments();
   }
 }
+
 function tsParseTypeParameter() {
   parseIdentifier();
   if (eat(TokenType._extends)) {
@@ -28612,11 +20502,13 @@ function tsParseTypeParameter() {
     tsParseType();
   }
 }
+
 function tsTryParseTypeParameters() {
   if (match(TokenType.lessThan)) {
     tsParseTypeParameters();
   }
 }
+
 function tsParseTypeParameters() {
   const oldIsType = pushTypeContext(0);
   if (match(TokenType.lessThan) || match(TokenType.typeParameterStart)) {
@@ -28624,18 +20516,25 @@ function tsParseTypeParameters() {
   } else {
     unexpected();
   }
+
   while (!eat(TokenType.greaterThan) && !state.error) {
     tsParseTypeParameter();
     eat(TokenType.comma);
   }
   popTypeContext(oldIsType);
 }
+
+// Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,
+// but here it's always false, because this is only used for types.
 function tsFillSignature(returnToken) {
+  // Arrow fns *must* have return token (`=>`). Normal functions can omit it.
   const returnTokenRequired = returnToken === TokenType.arrow;
   tsTryParseTypeParameters();
   expect(TokenType.parenL);
+  // Create a scope even though we're doing type parsing so we don't accidentally
+  // treat params as top-level bindings.
   state.scopeDepth++;
-  tsParseBindingListForSignature(false);
+  tsParseBindingListForSignature(false /* isBlockScope */);
   state.scopeDepth--;
   if (returnTokenRequired) {
     tsParseTypeOrTypePredicateAnnotation(returnToken);
@@ -28643,41 +20542,52 @@ function tsFillSignature(returnToken) {
     tsParseTypeOrTypePredicateAnnotation(returnToken);
   }
 }
+
 function tsParseBindingListForSignature(isBlockScope) {
   parseBindingList(TokenType.parenR, isBlockScope);
 }
+
 function tsParseTypeMemberSemicolon() {
   if (!eat(TokenType.comma)) {
     semicolon();
   }
 }
+
 function tsParseSignatureMember() {
   tsFillSignature(TokenType.colon);
   tsParseTypeMemberSemicolon();
 }
+
 function tsIsUnambiguouslyIndexSignature() {
   const snapshot = state.snapshot();
-  next();
+  next(); // Skip '{'
   const isIndexSignature = eat(TokenType.name) && match(TokenType.colon);
   state.restoreFromSnapshot(snapshot);
   return isIndexSignature;
 }
+
 function tsTryParseIndexSignature() {
   if (!(match(TokenType.bracketL) && tsIsUnambiguouslyIndexSignature())) {
     return false;
   }
+
   const oldIsType = pushTypeContext(0);
+
   expect(TokenType.bracketL);
   parseIdentifier();
   tsParseTypeAnnotation();
   expect(TokenType.bracketR);
+
   tsTryParseTypeAnnotation();
   tsParseTypeMemberSemicolon();
+
   popTypeContext(oldIsType);
   return true;
 }
+
 function tsParsePropertyOrMethodSignature(isReadonly) {
   eat(TokenType.question);
+
   if (!isReadonly && (match(TokenType.parenL) || match(TokenType.lessThan))) {
     tsFillSignature(TokenType.colon);
     tsParseTypeMemberSemicolon();
@@ -28686,14 +20596,17 @@ function tsParsePropertyOrMethodSignature(isReadonly) {
     tsParseTypeMemberSemicolon();
   }
 }
+
 function tsParseTypeMember() {
   if (match(TokenType.parenL) || match(TokenType.lessThan)) {
+    // call signature
     tsParseSignatureMember();
     return;
   }
   if (match(TokenType._new)) {
     next();
     if (match(TokenType.parenL) || match(TokenType.lessThan)) {
+      // constructor signature
       tsParseSignatureMember();
     } else {
       tsParsePropertyOrMethodSignature(false);
@@ -28701,30 +20614,37 @@ function tsParseTypeMember() {
     return;
   }
   const readonly = !!tsParseModifier([ContextualKeyword._readonly]);
+
   const found = tsTryParseIndexSignature();
   if (found) {
     return;
   }
-  if ((isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) && tsNextTokenCanFollowModifier())
-    ;
-  parsePropertyName(-1);
+  if (
+    (isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) &&
+    tsNextTokenCanFollowModifier()
+  ) ;
+  parsePropertyName(-1 /* Types don't need context IDs. */);
   tsParsePropertyOrMethodSignature(readonly);
 }
+
 function tsParseTypeLiteral() {
   tsParseObjectTypeMembers();
 }
+
 function tsParseObjectTypeMembers() {
   expect(TokenType.braceL);
   while (!eat(TokenType.braceR) && !state.error) {
     tsParseTypeMember();
   }
 }
+
 function tsLookaheadIsStartOfMappedType() {
   const snapshot = state.snapshot();
   const isStartOfMappedType = tsIsStartOfMappedType();
   state.restoreFromSnapshot(snapshot);
   return isStartOfMappedType;
 }
+
 function tsIsStartOfMappedType() {
   next();
   if (eat(TokenType.plus) || eat(TokenType.minus)) {
@@ -28743,11 +20663,13 @@ function tsIsStartOfMappedType() {
   next();
   return match(TokenType._in);
 }
+
 function tsParseMappedTypeParameter() {
   parseIdentifier();
   expect(TokenType._in);
   tsParseType();
 }
+
 function tsParseMappedType() {
   expect(TokenType.braceL);
   if (match(TokenType.plus) || match(TokenType.minus)) {
@@ -28772,49 +20694,61 @@ function tsParseMappedType() {
   semicolon();
   expect(TokenType.braceR);
 }
+
 function tsParseTupleType() {
   expect(TokenType.bracketL);
   while (!eat(TokenType.bracketR) && !state.error) {
+    // Do not validate presence of either none or only labeled elements
     tsParseTupleElementType();
     eat(TokenType.comma);
   }
 }
+
 function tsParseTupleElementType() {
+  // parses `...TsType[]`
   if (eat(TokenType.ellipsis)) {
     tsParseType();
   } else {
+    // parses `TsType?`
     tsParseType();
     eat(TokenType.question);
   }
+
+  // The type we parsed above was actually a label
   if (eat(TokenType.colon)) {
+    // Labeled tuple types must affix the label with `...` or `?`, so no need to handle those here
     tsParseType();
   }
 }
+
 function tsParseParenthesizedType() {
   expect(TokenType.parenL);
   tsParseType();
   expect(TokenType.parenR);
 }
+
 function tsParseTemplateLiteralType() {
+  // Finish `, read quasi
   nextTemplateToken();
+  // Finish quasi, read ${
   nextTemplateToken();
   while (!match(TokenType.backQuote) && !state.error) {
     expect(TokenType.dollarBraceL);
     tsParseType();
+    // Finish }, read quasi
     nextTemplateToken();
+    // Finish quasi, read either ${ or `
     nextTemplateToken();
   }
   next();
 }
-var FunctionType;
-(function(FunctionType2) {
-  const TSFunctionType = 0;
-  FunctionType2[FunctionType2["TSFunctionType"] = TSFunctionType] = "TSFunctionType";
-  const TSConstructorType = TSFunctionType + 1;
-  FunctionType2[FunctionType2["TSConstructorType"] = TSConstructorType] = "TSConstructorType";
-  const TSAbstractConstructorType = TSConstructorType + 1;
-  FunctionType2[FunctionType2["TSAbstractConstructorType"] = TSAbstractConstructorType] = "TSAbstractConstructorType";
+
+var FunctionType; (function (FunctionType) {
+  const TSFunctionType = 0; FunctionType[FunctionType["TSFunctionType"] = TSFunctionType] = "TSFunctionType";
+  const TSConstructorType = TSFunctionType + 1; FunctionType[FunctionType["TSConstructorType"] = TSConstructorType] = "TSConstructorType";
+  const TSAbstractConstructorType = TSConstructorType + 1; FunctionType[FunctionType["TSAbstractConstructorType"] = TSAbstractConstructorType] = "TSAbstractConstructorType";
 })(FunctionType || (FunctionType = {}));
+
 function tsParseFunctionOrConstructorType(type) {
   if (type === FunctionType.TSAbstractConstructorType) {
     expectContextual(ContextualKeyword._abstract);
@@ -28824,6 +20758,7 @@ function tsParseFunctionOrConstructorType(type) {
   }
   tsFillSignature(TokenType.arrow);
 }
+
 function tsParseNonArrayType() {
   switch (state.type) {
     case TokenType.name:
@@ -28882,23 +20817,32 @@ function tsParseNonArrayType() {
       }
       break;
   }
+
   unexpected();
 }
+
 function tsParseArrayTypeOrHigher() {
   tsParseNonArrayType();
   while (!hasPrecedingLineBreak() && eat(TokenType.bracketL)) {
     if (!eat(TokenType.bracketR)) {
+      // If we hit ] immediately, this is an array type, otherwise it's an indexed access type.
       tsParseType();
       expect(TokenType.bracketR);
     }
   }
 }
+
 function tsParseInferType() {
   expectContextual(ContextualKeyword._infer);
   parseIdentifier();
 }
+
 function tsParseTypeOperatorOrHigher() {
-  if (isContextual(ContextualKeyword._keyof) || isContextual(ContextualKeyword._unique) || isContextual(ContextualKeyword._readonly)) {
+  if (
+    isContextual(ContextualKeyword._keyof) ||
+    isContextual(ContextualKeyword._unique) ||
+    isContextual(ContextualKeyword._readonly)
+  ) {
     next();
     tsParseTypeOperatorOrHigher();
   } else if (isContextual(ContextualKeyword._infer)) {
@@ -28907,6 +20851,7 @@ function tsParseTypeOperatorOrHigher() {
     tsParseArrayTypeOrHigher();
   }
 }
+
 function tsParseIntersectionTypeOrHigher() {
   eat(TokenType.bitwiseAND);
   tsParseTypeOperatorOrHigher();
@@ -28916,6 +20861,7 @@ function tsParseIntersectionTypeOrHigher() {
     }
   }
 }
+
 function tsParseUnionTypeOrHigher() {
   eat(TokenType.bitwiseOR);
   tsParseIntersectionTypeOrHigher();
@@ -28925,17 +20871,21 @@ function tsParseUnionTypeOrHigher() {
     }
   }
 }
+
 function tsIsStartOfFunctionType() {
   if (match(TokenType.lessThan)) {
     return true;
   }
   return match(TokenType.parenL) && tsLookaheadIsUnambiguouslyStartOfFunctionType();
 }
+
 function tsSkipParameterStart() {
   if (match(TokenType.name) || match(TokenType._this)) {
     next();
     return true;
   }
+  // If this is a possible array/object destructure, walk to the matching bracket/brace.
+  // The next token after will tell us definitively whether this is a function param.
   if (match(TokenType.braceL) || match(TokenType.bracketL)) {
     let depth = 1;
     next();
@@ -28951,30 +20901,40 @@ function tsSkipParameterStart() {
   }
   return false;
 }
+
 function tsLookaheadIsUnambiguouslyStartOfFunctionType() {
   const snapshot = state.snapshot();
   const isUnambiguouslyStartOfFunctionType = tsIsUnambiguouslyStartOfFunctionType();
   state.restoreFromSnapshot(snapshot);
   return isUnambiguouslyStartOfFunctionType;
 }
+
 function tsIsUnambiguouslyStartOfFunctionType() {
   next();
   if (match(TokenType.parenR) || match(TokenType.ellipsis)) {
+    // ( )
+    // ( ...
     return true;
   }
   if (tsSkipParameterStart()) {
     if (match(TokenType.colon) || match(TokenType.comma) || match(TokenType.question) || match(TokenType.eq)) {
+      // ( xxx :
+      // ( xxx ,
+      // ( xxx ?
+      // ( xxx =
       return true;
     }
     if (match(TokenType.parenR)) {
       next();
       if (match(TokenType.arrow)) {
+        // ( xxx ) =>
         return true;
       }
     }
   }
   return false;
 }
+
 function tsParseTypeOrTypePredicateAnnotation(returnToken) {
   const oldIsType = pushTypeContext(0);
   expect(returnToken);
@@ -28984,85 +20944,113 @@ function tsParseTypeOrTypePredicateAnnotation(returnToken) {
   }
   popTypeContext(oldIsType);
 }
+
 function tsTryParseTypeOrTypePredicateAnnotation() {
   if (match(TokenType.colon)) {
     tsParseTypeOrTypePredicateAnnotation(TokenType.colon);
   }
 }
+
 function tsTryParseTypeAnnotation() {
   if (match(TokenType.colon)) {
     tsParseTypeAnnotation();
   }
 }
+
 function tsTryParseType() {
   if (eat(TokenType.colon)) {
     tsParseType();
   }
 }
+
+/**
+ * Detect a few special return syntax cases: `x is T`, `asserts x`, `asserts x is T`,
+ * `asserts this is T`.
+ *
+ * Returns true if we parsed the return type, false if there's still a type to be parsed.
+ */
 function tsParseTypePredicateOrAssertsPrefix() {
   const snapshot = state.snapshot();
   if (isContextual(ContextualKeyword._asserts) && !hasPrecedingLineBreak()) {
+    // Normally this is `asserts x is T`, but at this point, it might be `asserts is T` (a user-
+    // defined type guard on the `asserts` variable) or just a type called `asserts`.
     next();
     if (eatContextual(ContextualKeyword._is)) {
+      // If we see `asserts is`, then this must be of the form `asserts is T`, since
+      // `asserts is is T` isn't valid.
       tsParseType();
       return true;
     } else if (tsIsIdentifier() || match(TokenType._this)) {
       next();
       if (eatContextual(ContextualKeyword._is)) {
+        // If we see `is`, then this is `asserts x is T`. Otherwise, it's `asserts x`.
         tsParseType();
       }
       return true;
     } else {
+      // Regular type, so bail out and start type parsing from scratch.
       state.restoreFromSnapshot(snapshot);
       return false;
     }
   } else if (tsIsIdentifier() || match(TokenType._this)) {
+    // This is a regular identifier, which may or may not have "is" after it.
     next();
     if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {
       next();
       tsParseType();
       return true;
     } else {
+      // Regular type, so bail out and start type parsing from scratch.
       state.restoreFromSnapshot(snapshot);
       return false;
     }
   }
   return false;
 }
+
 function tsParseTypeAnnotation() {
   const oldIsType = pushTypeContext(0);
   expect(TokenType.colon);
   tsParseType();
   popTypeContext(oldIsType);
 }
+
 function tsParseType() {
   tsParseNonConditionalType();
   if (hasPrecedingLineBreak() || !eat(TokenType._extends)) {
     return;
   }
+  // extends type
   tsParseNonConditionalType();
   expect(TokenType.question);
+  // true type
   tsParseType();
   expect(TokenType.colon);
+  // false type
   tsParseType();
 }
+
 function isAbstractConstructorSignature() {
   return isContextual(ContextualKeyword._abstract) && lookaheadType() === TokenType._new;
 }
+
 function tsParseNonConditionalType() {
   if (tsIsStartOfFunctionType()) {
     tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);
     return;
   }
   if (match(TokenType._new)) {
+    // As in `new () => Date`
     tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);
     return;
   } else if (isAbstractConstructorSignature()) {
+    // As in `abstract new () => Date`
     tsParseFunctionOrConstructorType(FunctionType.TSAbstractConstructorType);
     return;
   }
   tsParseUnionTypeOrHigher();
 }
+
 function tsParseTypeAssertion() {
   const oldIsType = pushTypeContext(1);
   tsParseType();
@@ -29070,6 +21058,7 @@ function tsParseTypeAssertion() {
   popTypeContext(oldIsType);
   parseMaybeUnary();
 }
+
 function tsTryParseJSXTypeArgument() {
   if (eat(TokenType.jsxTagStart)) {
     state.tokens[state.tokens.length - 1].type = TokenType.typeParameterStart;
@@ -29078,22 +21067,28 @@ function tsTryParseJSXTypeArgument() {
       tsParseType();
       eat(TokenType.comma);
     }
+    // Process >, but the one after needs to be parsed JSX-style.
     nextJSXTagToken();
     popTypeContext(oldIsType);
   }
 }
+
 function tsParseHeritageClause() {
   while (!match(TokenType.braceL) && !state.error) {
     tsParseExpressionWithTypeArguments();
     eat(TokenType.comma);
   }
 }
+
 function tsParseExpressionWithTypeArguments() {
+  // Note: TS uses parseLeftHandSideExpressionOrHigher,
+  // then has grammar errors later if it's not an EntityName.
   tsParseEntityName();
   if (match(TokenType.lessThan)) {
     tsParseTypeArguments();
   }
 }
+
 function tsParseInterfaceDeclaration() {
   parseBindingIdentifier(false);
   tsTryParseTypeParameters();
@@ -29102,6 +21097,7 @@ function tsParseInterfaceDeclaration() {
   }
   tsParseObjectTypeMembers();
 }
+
 function tsParseTypeAliasDeclaration() {
   parseBindingIdentifier(false);
   tsTryParseTypeParameters();
@@ -29109,7 +21105,9 @@ function tsParseTypeAliasDeclaration() {
   tsParseType();
   semicolon();
 }
+
 function tsParseEnumMember() {
+  // Computed property names are grammar errors in an enum, so accept just string literal or identifier.
   if (match(TokenType.string)) {
     parseLiteral();
   } else {
@@ -29121,6 +21119,7 @@ function tsParseEnumMember() {
     state.tokens[eqIndex].rhsEndIndex = state.tokens.length;
   }
 }
+
 function tsParseEnumDeclaration() {
   parseBindingIdentifier(false);
   expect(TokenType.braceL);
@@ -29129,10 +21128,12 @@ function tsParseEnumDeclaration() {
     eat(TokenType.comma);
   }
 }
+
 function tsParseModuleBlock() {
   expect(TokenType.braceL);
-  parseBlockBody(TokenType.braceR);
+  parseBlockBody(/* end */ TokenType.braceR);
 }
+
 function tsParseModuleOrNamespaceDeclaration() {
   parseBindingIdentifier(false);
   if (eat(TokenType.dot)) {
@@ -29141,6 +21142,7 @@ function tsParseModuleOrNamespaceDeclaration() {
     tsParseModuleBlock();
   }
 }
+
 function tsParseAmbientExternalModuleDeclaration() {
   if (isContextual(ContextualKeyword._global)) {
     parseIdentifier();
@@ -29149,21 +21151,25 @@ function tsParseAmbientExternalModuleDeclaration() {
   } else {
     unexpected();
   }
+
   if (match(TokenType.braceL)) {
     tsParseModuleBlock();
   } else {
     semicolon();
   }
 }
+
 function tsParseImportEqualsDeclaration() {
   parseImportedIdentifier();
   expect(TokenType.eq);
   tsParseModuleReference();
   semicolon();
 }
+
 function tsIsExternalModuleReference() {
   return isContextual(ContextualKeyword._require) && lookaheadType() === TokenType.parenL;
 }
+
 function tsParseModuleReference() {
   if (tsIsExternalModuleReference()) {
     tsParseExternalModuleReference();
@@ -29171,6 +21177,7 @@ function tsParseModuleReference() {
     tsParseEntityName();
   }
 }
+
 function tsParseExternalModuleReference() {
   expectContextual(ContextualKeyword._require);
   expect(TokenType.parenL);
@@ -29180,6 +21187,10 @@ function tsParseExternalModuleReference() {
   parseLiteral();
   expect(TokenType.parenR);
 }
+
+// Utilities
+
+// Returns true if a statement matched.
 function tsTryParseDeclare() {
   if (isLineTerminator()) {
     return false;
@@ -29188,20 +21199,23 @@ function tsTryParseDeclare() {
     case TokenType._function: {
       const oldIsType = pushTypeContext(1);
       next();
+      // We don't need to precisely get the function start here, since it's only used to mark
+      // the function as a type if it's bodiless, and it's already a type here.
       const functionStart = state.start;
-      parseFunction(functionStart, true);
+      parseFunction(functionStart, /* isStatement */ true);
       popTypeContext(oldIsType);
       return true;
     }
     case TokenType._class: {
       const oldIsType = pushTypeContext(1);
-      parseClass(true, false);
+      parseClass(/* isStatement */ true, /* optionalId */ false);
       popTypeContext(oldIsType);
       return true;
     }
     case TokenType._const: {
       if (match(TokenType._const) && isLookaheadContextual(ContextualKeyword._enum)) {
         const oldIsType = pushTypeContext(1);
+        // `const enum = 0;` not allowed because "enum" is a strict mode reserved word.
         expect(TokenType._const);
         expectContextual(ContextualKeyword._enum);
         state.tokens[state.tokens.length - 1].type = TokenType._enum;
@@ -29210,6 +21224,7 @@ function tsTryParseDeclare() {
         return true;
       }
     }
+    // falls through
     case TokenType._var:
     case TokenType._let: {
       const oldIsType = pushTypeContext(1);
@@ -29225,7 +21240,7 @@ function tsTryParseDeclare() {
         tsParseAmbientExternalModuleDeclaration();
         matched = true;
       } else {
-        matched = tsParseDeclaration(contextualKeyword, true);
+        matched = tsParseDeclaration(contextualKeyword, /* isBeforeToken */ true);
       }
       popTypeContext(oldIsType);
       return matched;
@@ -29234,9 +21249,14 @@ function tsTryParseDeclare() {
       return false;
   }
 }
+
+// Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.
+// Returns true if it matched a declaration.
 function tsTryParseExportDeclaration() {
-  return tsParseDeclaration(state.contextualKeyword, true);
+  return tsParseDeclaration(state.contextualKeyword, /* isBeforeToken */ true);
 }
+
+// Returns true if it matched a statement.
 function tsParseExpressionStatement(contextualKeyword) {
   switch (contextualKeyword) {
     case ContextualKeyword._declare: {
@@ -29249,25 +21269,42 @@ function tsParseExpressionStatement(contextualKeyword) {
       break;
     }
     case ContextualKeyword._global:
+      // `global { }` (with no `declare`) may appear inside an ambient module declaration.
+      // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past "global".
       if (match(TokenType.braceL)) {
         tsParseModuleBlock();
         return true;
       }
       break;
+
     default:
-      return tsParseDeclaration(contextualKeyword, false);
+      return tsParseDeclaration(contextualKeyword, /* isBeforeToken */ false);
   }
   return false;
 }
+
+/**
+ * Common code for parsing a declaration.
+ *
+ * isBeforeToken indicates that the current parser state is at the contextual
+ * keyword (and that it is not yet emitted) rather than reading the token after
+ * it. When isBeforeToken is true, we may be preceded by an `export` token and
+ * should include that token in a type context we create, e.g. to handle
+ * `export interface` or `export type`. (This is a bit of a hack and should be
+ * cleaned up at some point.)
+ *
+ * Returns true if it matched a declaration.
+ */
 function tsParseDeclaration(contextualKeyword, isBeforeToken) {
   switch (contextualKeyword) {
     case ContextualKeyword._abstract:
       if (tsCheckLineTerminator(isBeforeToken) && match(TokenType._class)) {
         state.tokens[state.tokens.length - 1].type = TokenType._abstract;
-        parseClass(true, false);
+        parseClass(/* isStatement */ true, /* optionalId */ false);
         return true;
       }
       break;
+
     case ContextualKeyword._enum:
       if (tsCheckLineTerminator(isBeforeToken) && match(TokenType.name)) {
         state.tokens[state.tokens.length - 1].type = TokenType._enum;
@@ -29275,14 +21312,18 @@ function tsParseDeclaration(contextualKeyword, isBeforeToken) {
         return true;
       }
       break;
+
     case ContextualKeyword._interface:
       if (tsCheckLineTerminator(isBeforeToken) && match(TokenType.name)) {
+        // `next` is true in "export" and "declare" contexts, so we want to remove that token
+        // as well.
         const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);
         tsParseInterfaceDeclaration();
         popTypeContext(oldIsType);
         return true;
       }
       break;
+
     case ContextualKeyword._module:
       if (tsCheckLineTerminator(isBeforeToken)) {
         if (match(TokenType.string)) {
@@ -29298,6 +21339,7 @@ function tsParseDeclaration(contextualKeyword, isBeforeToken) {
         }
       }
       break;
+
     case ContextualKeyword._namespace:
       if (tsCheckLineTerminator(isBeforeToken) && match(TokenType.name)) {
         const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);
@@ -29306,6 +21348,7 @@ function tsParseDeclaration(contextualKeyword, isBeforeToken) {
         return true;
       }
       break;
+
     case ContextualKeyword._type:
       if (tsCheckLineTerminator(isBeforeToken) && match(TokenType.name)) {
         const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);
@@ -29317,27 +21360,37 @@ function tsParseDeclaration(contextualKeyword, isBeforeToken) {
   }
   return false;
 }
+
 function tsCheckLineTerminator(isBeforeToken) {
   if (isBeforeToken) {
+    // Babel checks hasFollowingLineBreak here and returns false, but this
+    // doesn't actually come up, e.g. `export interface` can never be on its own
+    // line in valid code.
     next();
     return true;
   } else {
     return !isLineTerminator();
   }
 }
+
+// Returns true if there was a generic async arrow function.
 function tsTryParseGenericAsyncArrowFunction() {
   const snapshot = state.snapshot();
+
   tsParseTypeParameters();
   parseFunctionParams();
   tsTryParseTypeOrTypePredicateAnnotation();
   expect(TokenType.arrow);
+
   if (state.error) {
     state.restoreFromSnapshot(snapshot);
     return false;
   }
+
   parseFunctionBody(true);
   return true;
 }
+
 function tsParseTypeArguments() {
   const oldIsType = pushTypeContext(0);
   expect(TokenType.lessThan);
@@ -29347,6 +21400,7 @@ function tsParseTypeArguments() {
   }
   popTypeContext(oldIsType);
 }
+
 function tsIsDeclarationStart() {
   if (match(TokenType.name)) {
     switch (state.contextualKeyword) {
@@ -29360,30 +21414,59 @@ function tsIsDeclarationStart() {
         return true;
     }
   }
+
   return false;
 }
+
+// ======================================================
+// OVERRIDES
+// ======================================================
+
 function tsParseFunctionBodyAndFinish(functionStart, funcContextId) {
+  // For arrow functions, `parseArrow` handles the return type itself.
   if (match(TokenType.colon)) {
     tsParseTypeOrTypePredicateAnnotation(TokenType.colon);
   }
+
+  // The original code checked the node type to make sure this function type allows a missing
+  // body, but we skip that to avoid sending around the node type. We instead just use the
+  // allowExpressionBody boolean to make sure it's not an arrow function.
   if (!match(TokenType.braceL) && isLineTerminator()) {
+    // Retroactively mark the function declaration as a type.
     let i = state.tokens.length - 1;
-    while (i >= 0 && (state.tokens[i].start >= functionStart || state.tokens[i].type === TokenType._default || state.tokens[i].type === TokenType._export)) {
+    while (
+      i >= 0 &&
+      (state.tokens[i].start >= functionStart ||
+        state.tokens[i].type === TokenType._default ||
+        state.tokens[i].type === TokenType._export)
+    ) {
       state.tokens[i].isType = true;
       i--;
     }
     return;
   }
+
   parseFunctionBody(false, funcContextId);
 }
-function tsParseSubscript(startTokenIndex, noCalls, stopState) {
+
+function tsParseSubscript(
+  startTokenIndex,
+  noCalls,
+  stopState,
+) {
   if (!hasPrecedingLineBreak() && eat(TokenType.bang)) {
     state.tokens[state.tokens.length - 1].type = TokenType.nonNullAssertion;
     return;
   }
+
   if (match(TokenType.lessThan)) {
+    // There are number of things we are going to "maybe" parse, like type arguments on
+    // tagged template expressions. If any of them fail, walk it back and continue.
     const snapshot = state.snapshot();
+
     if (!noCalls && atPossibleAsync()) {
+      // Almost certainly this is a generic async function `async <T>() => ...
+      // But it might be a call with a type argument `async<T>();`
       const asyncArrowFn = tsTryParseGenericAsyncArrowFunction();
       if (asyncArrowFn) {
         return;
@@ -29391,53 +21474,71 @@ function tsParseSubscript(startTokenIndex, noCalls, stopState) {
     }
     tsParseTypeArguments();
     if (!noCalls && eat(TokenType.parenL)) {
+      // With f<T>(), the subscriptStartIndex marker is on the ( token.
       state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
       parseCallExpressionArguments();
     } else if (match(TokenType.backQuote)) {
+      // Tagged template with a type argument.
       parseTemplate();
     } else {
       unexpected();
     }
+
     if (state.error) {
       state.restoreFromSnapshot(snapshot);
     } else {
       return;
     }
   } else if (!noCalls && match(TokenType.questionDot) && lookaheadType() === TokenType.lessThan) {
+    // If we see f?.<, then this must be an optional call with a type argument.
     next();
     state.tokens[startTokenIndex].isOptionalChainStart = true;
+    // With f?.<T>(), the subscriptStartIndex marker is on the ?. token.
     state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
+
     tsParseTypeArguments();
     expect(TokenType.parenL);
     parseCallExpressionArguments();
   }
   baseParseSubscript(startTokenIndex, noCalls, stopState);
 }
+
 function tsStartParseNewArguments() {
   if (match(TokenType.lessThan)) {
+    // 99% certain this is `new C<T>();`. But may be `new C < T;`, which is also legal.
     const snapshot = state.snapshot();
+
     state.type = TokenType.typeParameterStart;
     tsParseTypeArguments();
     if (!match(TokenType.parenL)) {
       unexpected();
     }
+
     if (state.error) {
       state.restoreFromSnapshot(snapshot);
     }
   }
 }
+
 function tsTryParseExport() {
   if (eat(TokenType._import)) {
+    // One of these cases:
+    // export import A = B;
+    // export import type A = require("A");
     if (isContextual(ContextualKeyword._type) && lookaheadType() !== TokenType.eq) {
+      // Eat a `type` token, unless it's actually an identifier name.
       expectContextual(ContextualKeyword._type);
     }
     tsParseImportEqualsDeclaration();
     return true;
   } else if (eat(TokenType.eq)) {
+    // `export = x;`
     parseExpression();
     semicolon();
     return true;
   } else if (eatContextual(ContextualKeyword._as)) {
+    // `export as namespace A;`
+    // See `parseNamespaceExportDeclaration` in TypeScript's own parser
     expectContextual(ContextualKeyword._namespace);
     parseIdentifier();
     semicolon();
@@ -29449,14 +21550,16 @@ function tsTryParseExport() {
     return false;
   }
 }
+
 function tsTryParseExportDefaultExpression() {
   if (isContextual(ContextualKeyword._abstract) && lookaheadType() === TokenType._class) {
     state.type = TokenType._abstract;
-    next();
+    next(); // Skip "abstract"
     parseClass(true, true);
     return true;
   }
   if (isContextual(ContextualKeyword._interface)) {
+    // Make sure "export default" are considered type tokens so the whole thing is removed.
     const oldIsType = pushTypeContext(2);
     tsParseDeclaration(ContextualKeyword._interface, true);
     popTypeContext(oldIsType);
@@ -29464,6 +21567,7 @@ function tsTryParseExportDefaultExpression() {
   }
   return false;
 }
+
 function tsTryParseStatementContent() {
   if (state.type === TokenType._const) {
     const ahead = lookaheadTypeAndKeyword();
@@ -29477,6 +21581,7 @@ function tsTryParseStatementContent() {
   }
   return false;
 }
+
 function tsTryParseClassMemberWithIsStatic(isStatic) {
   const memberStartIndexAfterStatic = state.tokens.length;
   tsParseModifiers([
@@ -29484,12 +21589,18 @@ function tsTryParseClassMemberWithIsStatic(isStatic) {
     ContextualKeyword._readonly,
     ContextualKeyword._declare,
     ContextualKeyword._static,
-    ContextualKeyword._override
+    ContextualKeyword._override,
   ]);
+
   const modifiersEndIndex = state.tokens.length;
   const found = tsTryParseIndexSignature();
   if (found) {
-    const memberStartIndex = isStatic ? memberStartIndexAfterStatic - 1 : memberStartIndexAfterStatic;
+    // Index signatures are type declarations, so set the modifier tokens as
+    // type tokens. Most tokens could be assumed to be type tokens, but `static`
+    // is ambiguous unless we set it explicitly here.
+    const memberStartIndex = isStatic
+      ? memberStartIndexAfterStatic - 1
+      : memberStartIndexAfterStatic;
     for (let i = memberStartIndex; i < modifiersEndIndex; i++) {
       state.tokens[i].isType = true;
     }
@@ -29497,17 +21608,25 @@ function tsTryParseClassMemberWithIsStatic(isStatic) {
   }
   return false;
 }
+
+// Note: The reason we do this in `parseIdentifierStatement` and not `parseStatement`
+// is that e.g. `type()` is valid JS, so we must try parsing that first.
+// If it's really a type, we will parse `type` as the statement, and can correct it here
+// by parsing the rest.
 function tsParseIdentifierStatement(contextualKeyword) {
   const matched = tsParseExpressionStatement(contextualKeyword);
   if (!matched) {
     semicolon();
   }
 }
+
 function tsParseExportDeclaration() {
+  // "export declare" is equivalent to just "export".
   const isDeclare = eatContextual(ContextualKeyword._declare);
   if (isDeclare) {
     state.tokens[state.tokens.length - 1].type = TokenType._declare;
   }
+
   let matchedDeclaration = false;
   if (match(TokenType.name)) {
     if (isDeclare) {
@@ -29528,6 +21647,7 @@ function tsParseExportDeclaration() {
     }
   }
 }
+
 function tsAfterParseClassSuper(hasSuper) {
   if (hasSuper && match(TokenType.lessThan)) {
     tsParseTypeArguments();
@@ -29539,34 +21659,46 @@ function tsAfterParseClassSuper(hasSuper) {
     popTypeContext(oldIsType);
   }
 }
+
 function tsStartParseObjPropValue() {
   tsTryParseTypeParameters();
 }
+
 function tsStartParseFunctionParams() {
   tsTryParseTypeParameters();
 }
+
+// `let x: number;`
 function tsAfterParseVarHead() {
   const oldIsType = pushTypeContext(0);
   eat(TokenType.bang);
   tsTryParseTypeAnnotation();
   popTypeContext(oldIsType);
 }
+
+// parse the return type of an async arrow function - let foo = (async (): number => {});
 function tsStartParseAsyncArrowFromCallExpression() {
   if (match(TokenType.colon)) {
     tsParseTypeAnnotation();
   }
 }
+
+// Returns true if the expression was an arrow function.
 function tsParseMaybeAssign(noIn, isWithinParens) {
+  // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.
   if (isJSXEnabled) {
     return tsParseMaybeAssignWithJSX(noIn, isWithinParens);
   } else {
     return tsParseMaybeAssignWithoutJSX(noIn, isWithinParens);
   }
 }
+
 function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {
   if (!match(TokenType.lessThan)) {
     return baseParseMaybeAssign(noIn, isWithinParens);
   }
+
+  // Prefer to parse JSX if possible. But may be an arrow fn.
   const snapshot = state.snapshot();
   let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
   if (state.error) {
@@ -29574,19 +21706,26 @@ function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {
   } else {
     return wasArrow;
   }
+
+  // Otherwise, try as type-parameterized arrow function.
   state.type = TokenType.typeParameterStart;
+  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.
   tsParseTypeParameters();
   wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
   if (!wasArrow) {
     unexpected();
   }
+
   return wasArrow;
 }
+
 function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {
   if (!match(TokenType.lessThan)) {
     return baseParseMaybeAssign(noIn, isWithinParens);
   }
+
   const snapshot = state.snapshot();
+  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.
   tsParseTypeParameters();
   const wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
   if (!wasArrow) {
@@ -29597,41 +21736,55 @@ function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {
   } else {
     return wasArrow;
   }
+
+  // Try parsing a type cast instead of an arrow function.
+  // This will start with a type assertion (via parseMaybeUnary).
+  // But don't directly call `tsParseTypeAssertion` because we want to handle any binary after it.
   return baseParseMaybeAssign(noIn, isWithinParens);
 }
+
 function tsParseArrow() {
   if (match(TokenType.colon)) {
+    // This is different from how the TS parser does it.
+    // TS uses lookahead. Babylon parses it as a parenthesized expression and converts.
     const snapshot = state.snapshot();
+
     tsParseTypeOrTypePredicateAnnotation(TokenType.colon);
-    if (canInsertSemicolon())
-      unexpected();
-    if (!match(TokenType.arrow))
-      unexpected();
+    if (canInsertSemicolon()) unexpected();
+    if (!match(TokenType.arrow)) unexpected();
+
     if (state.error) {
       state.restoreFromSnapshot(snapshot);
     }
   }
   return eat(TokenType.arrow);
 }
+
+// Allow type annotations inside of a parameter list.
 function tsParseAssignableListItemTypes() {
   const oldIsType = pushTypeContext(0);
   eat(TokenType.question);
   tsTryParseTypeAnnotation();
   popTypeContext(oldIsType);
 }
+
 function tsParseMaybeDecoratorArguments() {
   if (match(TokenType.lessThan)) {
     tsParseTypeArguments();
   }
   baseParseMaybeDecoratorArguments();
 }
+
+// Reads inline JSX contents token.
 function jsxReadToken() {
-  for (; ; ) {
+  for (;;) {
     if (state.pos >= input.length) {
       unexpected("Unterminated JSX contents");
       return;
     }
+
     const ch = input.charCodeAt(state.pos);
+
     switch (ch) {
       case charCodes.lessThan:
       case charCodes.leftCurlyBrace:
@@ -29646,18 +21799,21 @@ function jsxReadToken() {
         }
         finishToken(TokenType.jsxText);
         return;
+
       default:
         state.pos++;
     }
   }
 }
+
 function jsxReadString(quote) {
   state.pos++;
-  for (; ; ) {
+  for (;;) {
     if (state.pos >= input.length) {
       unexpected("Unterminated string constant");
       return;
     }
+
     const ch = input.charCodeAt(state.pos);
     if (ch === quote) {
       state.pos++;
@@ -29667,6 +21823,14 @@ function jsxReadString(quote) {
   }
   finishToken(TokenType.string);
 }
+
+// Read a JSX identifier (valid tag or attribute name).
+//
+// Optimized version since JSX identifiers can't contain
+// escape characters and so can be read as single slice.
+// Also assumes that first character was already checked
+// by isIdentifierStart in readToken.
+
 function jsxReadWord() {
   let ch;
   do {
@@ -29678,17 +21842,26 @@ function jsxReadWord() {
   } while (IS_IDENTIFIER_CHAR[ch] || ch === charCodes.dash);
   finishToken(TokenType.jsxName);
 }
+
+// Parse next token as JSX identifier
 function jsxParseIdentifier() {
   nextJSXTagToken();
 }
+
+// Parse namespaced identifier.
 function jsxParseNamespacedName(identifierRole) {
   jsxParseIdentifier();
   if (!eat(TokenType.colon)) {
+    // Plain identifier, so this is an access.
     state.tokens[state.tokens.length - 1].identifierRole = identifierRole;
     return;
   }
+  // Process the second half of the namespaced name.
   jsxParseIdentifier();
 }
+
+// Parses element name in any form - namespaced, member
+// or single identifier.
 function jsxParseElementName() {
   jsxParseNamespacedName(IdentifierRole.Access);
   while (match(TokenType.dot)) {
@@ -29696,6 +21869,8 @@ function jsxParseElementName() {
     jsxParseIdentifier();
   }
 }
+
+// Parses any type of JSX attribute value.
 function jsxParseAttributeValue() {
   switch (state.type) {
     case TokenType.braceL:
@@ -29703,32 +21878,42 @@ function jsxParseAttributeValue() {
       jsxParseExpressionContainer();
       nextJSXTagToken();
       return;
+
     case TokenType.jsxTagStart:
       jsxParseElement();
       nextJSXTagToken();
       return;
+
     case TokenType.string:
       nextJSXTagToken();
       return;
+
     default:
       unexpected("JSX value should be either an expression or a quoted JSX text");
   }
 }
+
+// Parse JSX spread child, after already processing the {
+// Does not parse the closing }
 function jsxParseSpreadChild() {
   expect(TokenType.ellipsis);
   parseExpression();
 }
+
+// Parses JSX expression enclosed into curly brackets, after already processing the {
+// Does not parse the closing }
 function jsxParseExpressionContainer() {
-  if (match(TokenType.braceR))
-    ;
-  else {
+  if (match(TokenType.braceR)) ; else {
     parseExpression();
   }
 }
+
+// Parses following JSX attribute name-value pair.
 function jsxParseAttribute() {
   if (eat(TokenType.braceL)) {
     expect(TokenType.ellipsis);
     parseMaybeAssign();
+    // }
     nextJSXTagToken();
     return;
   }
@@ -29738,8 +21923,13 @@ function jsxParseAttribute() {
     jsxParseAttributeValue();
   }
 }
+
+// Parses JSX opening tag starting after "<".
+// Returns true if the tag was self-closing.
+// Does not parse the last token.
 function jsxParseOpeningElement() {
   if (match(TokenType.jsxTagEnd)) {
+    // This is an open-fragment.
     return false;
   }
   jsxParseElementName();
@@ -29751,16 +21941,25 @@ function jsxParseOpeningElement() {
   }
   const isSelfClosing = match(TokenType.slash);
   if (isSelfClosing) {
+    // /
     nextJSXTagToken();
   }
   return isSelfClosing;
 }
+
+// Parses JSX closing tag starting after "</".
+// Does not parse the last token.
 function jsxParseClosingElement() {
   if (match(TokenType.jsxTagEnd)) {
+    // Fragment syntax, so we immediately have a tag end.
     return;
   }
   jsxParseElementName();
 }
+
+// Parses entire JSX element, including its opening tag
+// (starting after "<"), attributes, contents and closing tag.
+// Does not parse the last token.
 function jsxParseElementAt() {
   const isSelfClosing = jsxParseOpeningElement();
   if (!isSelfClosing) {
@@ -29777,9 +21976,11 @@ function jsxParseElementAt() {
           jsxParseElementAt();
           nextJSXExprToken();
           break;
+
         case TokenType.jsxText:
           nextJSXExprToken();
           break;
+
         case TokenType.braceL:
           next();
           if (match(TokenType.ellipsis)) {
@@ -29789,7 +21990,10 @@ function jsxParseElementAt() {
             jsxParseExpressionContainer();
             nextJSXExprToken();
           }
+
           break;
+
+        // istanbul ignore next - should never happen
         default:
           unexpected();
           return;
@@ -29797,20 +22001,30 @@ function jsxParseElementAt() {
     }
   }
 }
+
+// Parses entire JSX element from current position.
+// Does not parse the last token.
 function jsxParseElement() {
   nextJSXTagToken();
   jsxParseElementAt();
 }
+
+// ==================================
+// Overrides
+// ==================================
+
 function nextJSXTagToken() {
   state.tokens.push(new Token());
   skipSpace();
   state.start = state.pos;
   const code = input.charCodeAt(state.pos);
+
   if (IS_IDENTIFIER_START[code]) {
     jsxReadWord();
   } else if (code === charCodes.quotationMark || code === charCodes.apostrophe) {
     jsxReadString(code);
   } else {
+    // The following tokens are just one character each.
     ++state.pos;
     switch (code) {
       case charCodes.greaterThan:
@@ -29839,12 +22053,22 @@ function nextJSXTagToken() {
     }
   }
 }
+
 function nextJSXExprToken() {
   state.tokens.push(new Token());
   state.start = state.pos;
   jsxReadToken();
 }
+
+/**
+ * Common parser code for TypeScript and Flow.
+ */
+
+// An apparent conditional expression could actually be an optional parameter in an arrow function.
 function typedParseConditional(noIn) {
+  // If we see ?:, this can't possibly be a valid conditional. typedParseParenItem will be called
+  // later to finish off the arrow parameter. We also need to handle bare ? tokens for optional
+  // parameters without type annotations, i.e. ?, and ?) .
   if (match(TokenType.question)) {
     const nextType = lookaheadType();
     if (nextType === TokenType.colon || nextType === TokenType.comma || nextType === TokenType.parenR) {
@@ -29853,10 +22077,11 @@ function typedParseConditional(noIn) {
   }
   baseParseConditional(noIn);
 }
+
+// Note: These "type casts" are *not* valid TS expressions.
+// But we parse them here and change them when completing the arrow function.
 function typedParseParenItem() {
-  if (eat(TokenType.question)) {
-    state.tokens[state.tokens.length - 1].isType = true;
-  }
+  eatTypeToken(TokenType.question);
   if (match(TokenType.colon)) {
     if (isTypeScriptEnabled) {
       tsParseTypeAnnotation();
@@ -29865,11 +22090,23 @@ function typedParseParenItem() {
     }
   }
 }
+
+/* eslint max-len: 0 */
+
 class StopState {
+  
   constructor(stop) {
     this.stop = stop;
   }
 }
+
+// ### Expression parsing
+
+// These nest, from the most general expression type at the top to
+// 'atomic', nondivisible expression types at the bottom. Most of
+// the functions will simply let the function (s) below them parse,
+// and, *if* the syntactic construct they handle is present, wrap
+// the AST node that the inner parser gave them in another node.
 function parseExpression(noIn = false) {
   parseMaybeAssign(noIn);
   if (match(TokenType.comma)) {
@@ -29878,6 +22115,14 @@ function parseExpression(noIn = false) {
     }
   }
 }
+
+/**
+ * noIn is used when parsing a for loop so that we don't interpret a following "in" as the binary
+ * operatior.
+ * isWithinParens is used to indicate that we're parsing something that might be a comma expression
+ * or might be an arrow function or might be a Flow type assertion (which requires explicit parens).
+ * In these cases, we should allow : and ?: after the initial "left" part.
+ */
 function parseMaybeAssign(noIn = false, isWithinParens = false) {
   if (isTypeScriptEnabled) {
     return tsParseMaybeAssign(noIn, isWithinParens);
@@ -29887,14 +22132,20 @@ function parseMaybeAssign(noIn = false, isWithinParens = false) {
     return baseParseMaybeAssign(noIn, isWithinParens);
   }
 }
+
+// Parse an assignment expression. This includes applications of
+// operators like `+=`.
+// Returns true if the expression was an arrow function.
 function baseParseMaybeAssign(noIn, isWithinParens) {
   if (match(TokenType._yield)) {
     parseYield();
     return false;
   }
+
   if (match(TokenType.parenL) || match(TokenType.name) || match(TokenType._yield)) {
     state.potentialArrowAt = state.start;
   }
+
   const wasArrow = parseMaybeConditional(noIn);
   if (isWithinParens) {
     parseParenItem();
@@ -29906,6 +22157,9 @@ function baseParseMaybeAssign(noIn, isWithinParens) {
   }
   return wasArrow;
 }
+
+// Parse a ternary conditional (`?:`) operator.
+// Returns true if the expression was an arrow function.
 function parseMaybeConditional(noIn) {
   const wasArrow = parseExprOps(noIn);
   if (wasArrow) {
@@ -29914,6 +22168,7 @@ function parseMaybeConditional(noIn) {
   parseConditional(noIn);
   return false;
 }
+
 function parseConditional(noIn) {
   if (isTypeScriptEnabled || isFlowEnabled) {
     typedParseConditional(noIn);
@@ -29921,6 +22176,7 @@ function parseConditional(noIn) {
     baseParseConditional(noIn);
   }
 }
+
 function baseParseConditional(noIn) {
   if (eat(TokenType.question)) {
     parseMaybeAssign();
@@ -29928,6 +22184,9 @@ function baseParseConditional(noIn) {
     parseMaybeAssign(noIn);
   }
 }
+
+// Start the precedence parser.
+// Returns true if this was an arrow function
 function parseExprOps(noIn) {
   const startTokenIndex = state.tokens.length;
   const wasArrow = parseMaybeUnary();
@@ -29937,8 +22196,19 @@ function parseExprOps(noIn) {
   parseExprOp(startTokenIndex, -1, noIn);
   return false;
 }
+
+// Parse binary operators with the operator precedence parsing
+// algorithm. `left` is the left-hand side of the operator.
+// `minPrec` provides context that allows the function to stop and
+// defer further parser to one of its callers when it encounters an
+// operator that has a lower precedence than the set it is parsing.
 function parseExprOp(startTokenIndex, minPrec, noIn) {
-  if (isTypeScriptEnabled && (TokenType._in & TokenType.PRECEDENCE_MASK) > minPrec && !hasPrecedingLineBreak() && eatContextual(ContextualKeyword._as)) {
+  if (
+    isTypeScriptEnabled &&
+    (TokenType._in & TokenType.PRECEDENCE_MASK) > minPrec &&
+    !hasPrecedingLineBreak() &&
+    eatContextual(ContextualKeyword._as)
+  ) {
     state.tokens[state.tokens.length - 1].type = TokenType._as;
     const oldIsType = pushTypeContext(1);
     tsParseType();
@@ -29946,6 +22216,7 @@ function parseExprOp(startTokenIndex, minPrec, noIn) {
     parseExprOp(startTokenIndex, minPrec, noIn);
     return;
   }
+
   const prec = state.type & TokenType.PRECEDENCE_MASK;
   if (prec > 0 && (!noIn || !match(TokenType._in))) {
     if (prec > minPrec) {
@@ -29954,23 +22225,33 @@ function parseExprOp(startTokenIndex, minPrec, noIn) {
       if (op === TokenType.nullishCoalescing) {
         state.tokens[state.tokens.length - 1].nullishStartIndex = startTokenIndex;
       }
+
       const rhsStartTokenIndex = state.tokens.length;
       parseMaybeUnary();
+      // Extend the right operand of this operator if possible.
       parseExprOp(rhsStartTokenIndex, op & TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);
       if (op === TokenType.nullishCoalescing) {
         state.tokens[startTokenIndex].numNullishCoalesceStarts++;
         state.tokens[state.tokens.length - 1].numNullishCoalesceEnds++;
       }
+      // Continue with any future operator holding this expression as the left operand.
       parseExprOp(startTokenIndex, minPrec, noIn);
     }
   }
 }
+
+// Parse unary operators, both prefix and postfix.
+// Returns true if this was an arrow function.
 function parseMaybeUnary() {
   if (isTypeScriptEnabled && !isJSXEnabled && eat(TokenType.lessThan)) {
     tsParseTypeAssertion();
     return false;
   }
-  if (isContextual(ContextualKeyword._module) && lookaheadCharCode() === charCodes.leftCurlyBrace && !hasFollowingLineBreak()) {
+  if (
+    isContextual(ContextualKeyword._module) &&
+    lookaheadCharCode() === charCodes.leftCurlyBrace &&
+    !hasFollowingLineBreak()
+  ) {
     parseModuleExpression();
     return false;
   }
@@ -29979,11 +22260,14 @@ function parseMaybeUnary() {
     parseMaybeUnary();
     return false;
   }
+
   const wasArrow = parseExprSubscripts();
   if (wasArrow) {
     return true;
   }
   while (state.type & TokenType.IS_POSTFIX && !canInsertSemicolon()) {
+    // The tokenizer calls everything a preincrement, so make it a postincrement when
+    // we see it in that context.
     if (state.type === TokenType.preIncDec) {
       state.type = TokenType.postIncDec;
     }
@@ -29991,6 +22275,9 @@ function parseMaybeUnary() {
   }
   return false;
 }
+
+// Parse call, dot, and `[]`-subscript expressions.
+// Returns true if this was an arrow function.
 function parseExprSubscripts() {
   const startTokenIndex = state.tokens.length;
   const wasArrow = parseExprAtom();
@@ -29998,11 +22285,14 @@ function parseExprSubscripts() {
     return true;
   }
   parseSubscripts(startTokenIndex);
+  // If there was any optional chain operation, the start token would be marked
+  // as such, so also mark the end now.
   if (state.tokens.length > startTokenIndex && state.tokens[startTokenIndex].isOptionalChainStart) {
     state.tokens[state.tokens.length - 1].isOptionalChainEnd = true;
   }
   return false;
 }
+
 function parseSubscripts(startTokenIndex, noCalls = false) {
   if (isFlowEnabled) {
     flowParseSubscripts(startTokenIndex, noCalls);
@@ -30010,12 +22300,14 @@ function parseSubscripts(startTokenIndex, noCalls = false) {
     baseParseSubscripts(startTokenIndex, noCalls);
   }
 }
+
 function baseParseSubscripts(startTokenIndex, noCalls = false) {
   const stopState = new StopState(false);
   do {
     parseSubscript(startTokenIndex, noCalls, stopState);
   } while (!stopState.stop && !state.error);
 }
+
 function parseSubscript(startTokenIndex, noCalls, stopState) {
   if (isTypeScriptEnabled) {
     tsParseSubscript(startTokenIndex, noCalls, stopState);
@@ -30025,10 +22317,18 @@ function parseSubscript(startTokenIndex, noCalls, stopState) {
     baseParseSubscript(startTokenIndex, noCalls, stopState);
   }
 }
-function baseParseSubscript(startTokenIndex, noCalls, stopState) {
+
+/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */
+function baseParseSubscript(
+  startTokenIndex,
+  noCalls,
+  stopState,
+) {
   if (!noCalls && eat(TokenType.doubleColon)) {
     parseNoCallExpr();
     stopState.stop = true;
+    // Propagate startTokenIndex so that `a::b?.()` will keep `a` as the first token. We may want
+    // to revisit this in the future when fully supporting bind syntax.
     parseSubscripts(startTokenIndex, noCalls);
   } else if (match(TokenType.questionDot)) {
     state.tokens[startTokenIndex].isOptionalChainStart = true;
@@ -30038,6 +22338,7 @@ function baseParseSubscript(startTokenIndex, noCalls, stopState) {
     }
     next();
     state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
+
     if (eat(TokenType.bracketL)) {
       parseExpression();
       expect(TokenType.bracketR);
@@ -30055,18 +22356,25 @@ function baseParseSubscript(startTokenIndex, noCalls, stopState) {
     expect(TokenType.bracketR);
   } else if (!noCalls && match(TokenType.parenL)) {
     if (atPossibleAsync()) {
+      // We see "async", but it's possible it's a usage of the name "async". Parse as if it's a
+      // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.
       const snapshot = state.snapshot();
       const asyncStartTokenIndex = state.tokens.length;
       next();
       state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
+
       const callContextId = getNextContextId();
+
       state.tokens[state.tokens.length - 1].contextId = callContextId;
       parseCallExpressionArguments();
       state.tokens[state.tokens.length - 1].contextId = callContextId;
+
       if (shouldParseAsyncArrow()) {
+        // We hit an arrow, so backtrack and start again parsing function parameters.
         state.restoreFromSnapshot(snapshot);
         stopState.stop = true;
         state.scopeDepth++;
+
         parseFunctionParams();
         parseAsyncArrowFromCallExpression(asyncStartTokenIndex);
       }
@@ -30079,14 +22387,22 @@ function baseParseSubscript(startTokenIndex, noCalls, stopState) {
       state.tokens[state.tokens.length - 1].contextId = callContextId;
     }
   } else if (match(TokenType.backQuote)) {
+    // Tagged template expression.
     parseTemplate();
   } else {
     stopState.stop = true;
   }
 }
+
 function atPossibleAsync() {
-  return state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async && !canInsertSemicolon();
+  // This was made less strict than the original version to avoid passing around nodes, but it
+  // should be safe to have rare false positives here.
+  return (
+    state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async &&
+    !canInsertSemicolon()
+  );
 }
+
 function parseCallExpressionArguments() {
   let first = true;
   while (!eat(TokenType.parenR) && !state.error) {
@@ -30098,12 +22414,15 @@ function parseCallExpressionArguments() {
         break;
       }
     }
+
     parseExprListItem(false);
   }
 }
+
 function shouldParseAsyncArrow() {
   return match(TokenType.colon) || match(TokenType.arrow);
 }
+
 function parseAsyncArrowFromCallExpression(startTokenIndex) {
   if (isTypeScriptEnabled) {
     tsStartParseAsyncArrowFromCallExpression();
@@ -30113,16 +22432,28 @@ function parseAsyncArrowFromCallExpression(startTokenIndex) {
   expect(TokenType.arrow);
   parseArrowExpression(startTokenIndex);
 }
+
+// Parse a no-call expression (like argument of `new` or `::` operators).
+
 function parseNoCallExpr() {
   const startTokenIndex = state.tokens.length;
   parseExprAtom();
   parseSubscripts(startTokenIndex, true);
 }
+
+// Parse an atomic expression  either a single token that is an
+// expression, an expression started by a keyword like `function` or
+// `new`, or an expression wrapped in punctuation like `()`, `[]`,
+// or `{}`.
+// Returns true if the parsed expression was an arrow function.
 function parseExprAtom() {
   if (eat(TokenType.modulo)) {
+    // V8 intrinsic expression. Just parse the identifier, and the function invocation is parsed
+    // naturally.
     parseIdentifier();
     return false;
   }
+
   if (match(TokenType.jsxText)) {
     parseLiteral();
     return false;
@@ -30132,11 +22463,14 @@ function parseExprAtom() {
     next();
     return false;
   }
+
   const canBeArrow = state.potentialArrowAt === state.start;
   switch (state.type) {
     case TokenType.slash:
     case TokenType.assign:
       retokenizeSlashAsRegex();
+    // Fall through.
+
     case TokenType._super:
     case TokenType._this:
     case TokenType.regexp:
@@ -30149,14 +22483,17 @@ function parseExprAtom() {
     case TokenType._false:
       next();
       return false;
+
     case TokenType._import:
       next();
       if (match(TokenType.dot)) {
+        // import.meta
         state.tokens[state.tokens.length - 1].type = TokenType.name;
         next();
         parseIdentifier();
       }
       return false;
+
     case TokenType.name: {
       const startTokenIndex = state.tokens.length;
       const functionStart = state.start;
@@ -30165,14 +22502,24 @@ function parseExprAtom() {
       if (contextualKeyword === ContextualKeyword._await) {
         parseAwait();
         return false;
-      } else if (contextualKeyword === ContextualKeyword._async && match(TokenType._function) && !canInsertSemicolon()) {
+      } else if (
+        contextualKeyword === ContextualKeyword._async &&
+        match(TokenType._function) &&
+        !canInsertSemicolon()
+      ) {
         next();
         parseFunction(functionStart, false);
         return false;
-      } else if (canBeArrow && contextualKeyword === ContextualKeyword._async && !canInsertSemicolon() && match(TokenType.name)) {
+      } else if (
+        canBeArrow &&
+        contextualKeyword === ContextualKeyword._async &&
+        !canInsertSemicolon() &&
+        match(TokenType.name)
+      ) {
         state.scopeDepth++;
         parseBindingIdentifier(false);
         expect(TokenType.arrow);
+        // let foo = async bar => {};
         parseArrowExpression(startTokenIndex);
         return true;
       } else if (match(TokenType._do) && !canInsertSemicolon()) {
@@ -30180,6 +22527,7 @@ function parseExprAtom() {
         parseBlock();
         return false;
       }
+
       if (canBeArrow && !canInsertSemicolon() && match(TokenType.arrow)) {
         state.scopeDepth++;
         markPriorBindingIdentifier(false);
@@ -30187,44 +22535,57 @@ function parseExprAtom() {
         parseArrowExpression(startTokenIndex);
         return true;
       }
+
       state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.Access;
       return false;
     }
+
     case TokenType._do: {
       next();
       parseBlock();
       return false;
     }
+
     case TokenType.parenL: {
       const wasArrow = parseParenAndDistinguishExpression(canBeArrow);
       return wasArrow;
     }
+
     case TokenType.bracketL:
       next();
       parseExprList(TokenType.bracketR, true);
       return false;
+
     case TokenType.braceL:
       parseObj(false, false);
       return false;
+
     case TokenType._function:
       parseFunctionExpression();
       return false;
+
     case TokenType.at:
       parseDecorators();
+    // Fall through.
+
     case TokenType._class:
       parseClass(false);
       return false;
+
     case TokenType._new:
       parseNew();
       return false;
+
     case TokenType.backQuote:
       parseTemplate();
       return false;
+
     case TokenType.doubleColon: {
       next();
       parseNoCallExpr();
       return false;
     }
+
     case TokenType.hash: {
       const code = lookaheadCharCode();
       if (IS_IDENTIFIER_START[code] || code === charCodes.backslash) {
@@ -30232,38 +22593,52 @@ function parseExprAtom() {
       } else {
         next();
       }
+      // Smart pipeline topic reference.
       return false;
     }
+
     default:
       unexpected();
       return false;
   }
 }
+
 function parseMaybePrivateName() {
   eat(TokenType.hash);
   parseIdentifier();
 }
+
 function parseFunctionExpression() {
   const functionStart = state.start;
   parseIdentifier();
   if (eat(TokenType.dot)) {
+    // function.sent
     parseIdentifier();
   }
   parseFunction(functionStart, false);
 }
+
 function parseLiteral() {
   next();
 }
+
 function parseParenExpression() {
   expect(TokenType.parenL);
   parseExpression();
   expect(TokenType.parenR);
 }
+
+// Returns true if this was an arrow expression.
 function parseParenAndDistinguishExpression(canBeArrow) {
+  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and
+  // start over as a parameter list.
   const snapshot = state.snapshot();
+
   const startTokenIndex = state.tokens.length;
   expect(TokenType.parenL);
+
   let first = true;
+
   while (!match(TokenType.parenR) && !state.error) {
     if (first) {
       first = false;
@@ -30273,31 +22648,41 @@ function parseParenAndDistinguishExpression(canBeArrow) {
         break;
       }
     }
+
     if (match(TokenType.ellipsis)) {
-      parseRest(false);
+      parseRest(false /* isBlockScope */);
       parseParenItem();
       break;
     } else {
       parseMaybeAssign(false, true);
     }
   }
+
   expect(TokenType.parenR);
+
   if (canBeArrow && shouldParseArrow()) {
     const wasArrow = parseArrow();
     if (wasArrow) {
+      // It was an arrow function this whole time, so start over and parse it as params so that we
+      // get proper token annotations.
       state.restoreFromSnapshot(snapshot);
       state.scopeDepth++;
+      // Don't specify a context ID because arrow functions don't need a context ID.
       parseFunctionParams();
       parseArrow();
       parseArrowExpression(startTokenIndex);
       return true;
     }
   }
+
   return false;
 }
+
 function shouldParseArrow() {
   return match(TokenType.colon) || !canInsertSemicolon();
 }
+
+// Returns whether there was an arrow token.
 function parseArrow() {
   if (isTypeScriptEnabled) {
     return tsParseArrow();
@@ -30307,14 +22692,22 @@ function parseArrow() {
     return eat(TokenType.arrow);
   }
 }
+
 function parseParenItem() {
   if (isTypeScriptEnabled || isFlowEnabled) {
     typedParseParenItem();
   }
 }
+
+// New's precedence is slightly tricky. It must allow its argument to
+// be a `[]` or dot subscript expression, but not a call  at least,
+// not without wrapping it in parentheses. Thus, it uses the noCalls
+// argument to parseSubscripts to prevent it from consuming the
+// argument list.
 function parseNew() {
   expect(TokenType._new);
   if (eat(TokenType.dot)) {
+    // new.target
     parseIdentifier();
     return;
   }
@@ -30322,6 +22715,7 @@ function parseNew() {
   eat(TokenType.questionDot);
   parseNewArguments();
 }
+
 function parseNewArguments() {
   if (isTypeScriptEnabled) {
     tsStartParseNewArguments();
@@ -30332,22 +22726,32 @@ function parseNewArguments() {
     parseExprList(TokenType.parenR);
   }
 }
+
 function parseTemplate() {
+  // Finish `, read quasi
   nextTemplateToken();
+  // Finish quasi, read ${
   nextTemplateToken();
   while (!match(TokenType.backQuote) && !state.error) {
     expect(TokenType.dollarBraceL);
     parseExpression();
+    // Finish }, read quasi
     nextTemplateToken();
+    // Finish quasi, read either ${ or `
     nextTemplateToken();
   }
   next();
 }
+
+// Parse an object literal or binding pattern.
 function parseObj(isPattern, isBlockScope) {
+  // Attach a context ID to the object open and close brace and each object key.
   const contextId = getNextContextId();
   let first = true;
+
   next();
   state.tokens[state.tokens.length - 1].contextId = contextId;
+
   while (!eat(TokenType.braceR) && !state.error) {
     if (first) {
       first = false;
@@ -30357,11 +22761,13 @@ function parseObj(isPattern, isBlockScope) {
         break;
       }
     }
+
     let isGenerator = false;
     if (match(TokenType.ellipsis)) {
       const previousIndex = state.tokens.length;
       parseSpread();
       if (isPattern) {
+        // Mark role when the only thing being spread over is an identifier.
         if (state.tokens.length === previousIndex + 2) {
           markPriorBindingIdentifier(isBlockScope);
         }
@@ -30371,16 +22777,22 @@ function parseObj(isPattern, isBlockScope) {
       }
       continue;
     }
+
     if (!isPattern) {
       isGenerator = eat(TokenType.star);
     }
+
     if (!isPattern && isContextual(ContextualKeyword._async)) {
-      if (isGenerator)
-        unexpected();
+      if (isGenerator) unexpected();
+
       parseIdentifier();
-      if (match(TokenType.colon) || match(TokenType.parenL) || match(TokenType.braceR) || match(TokenType.eq) || match(TokenType.comma))
-        ;
-      else {
+      if (
+        match(TokenType.colon) ||
+        match(TokenType.parenL) ||
+        match(TokenType.braceR) ||
+        match(TokenType.eq) ||
+        match(TokenType.comma)
+      ) ; else {
         if (match(TokenType.star)) {
           next();
           isGenerator = true;
@@ -30390,28 +22802,45 @@ function parseObj(isPattern, isBlockScope) {
     } else {
       parsePropertyName(contextId);
     }
+
     parseObjPropValue(isPattern, isBlockScope, contextId);
   }
+
   state.tokens[state.tokens.length - 1].contextId = contextId;
 }
+
 function isGetterOrSetterMethod(isPattern) {
-  return !isPattern && (match(TokenType.string) || match(TokenType.num) || match(TokenType.bracketL) || match(TokenType.name) || !!(state.type & TokenType.IS_KEYWORD));
+  // We go off of the next and don't bother checking if the node key is actually "get" or "set".
+  // This lets us avoid generating a node, and should only make the validation worse.
+  return (
+    !isPattern &&
+    (match(TokenType.string) || // get "string"() {}
+      match(TokenType.num) || // get 1() {}
+      match(TokenType.bracketL) || // get ["string"]() {}
+      match(TokenType.name) || // get foo() {}
+      !!(state.type & TokenType.IS_KEYWORD)) // get debugger() {}
+  );
 }
+
+// Returns true if this was a method.
 function parseObjectMethod(isPattern, objectContextId) {
+  // We don't need to worry about modifiers because object methods can't have optional bodies, so
+  // the start will never be used.
   const functionStart = state.start;
   if (match(TokenType.parenL)) {
-    if (isPattern)
-      unexpected();
-    parseMethod(functionStart, false);
+    if (isPattern) unexpected();
+    parseMethod(functionStart, /* isConstructor */ false);
     return true;
   }
+
   if (isGetterOrSetterMethod(isPattern)) {
     parsePropertyName(objectContextId);
-    parseMethod(functionStart, false);
+    parseMethod(functionStart, /* isConstructor */ false);
     return true;
   }
   return false;
 }
+
 function parseObjectProperty(isPattern, isBlockScope) {
   if (eat(TokenType.colon)) {
     if (isPattern) {
@@ -30421,6 +22850,12 @@ function parseObjectProperty(isPattern, isBlockScope) {
     }
     return;
   }
+
+  // Since there's no colon, we assume this is an object shorthand.
+
+  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so
+  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to
+  // transform it on access, so mark it as a normal object shorthand.
   let identifierRole;
   if (isPattern) {
     if (state.scopeDepth === 0) {
@@ -30434,9 +22869,17 @@ function parseObjectProperty(isPattern, isBlockScope) {
     identifierRole = IdentifierRole.ObjectShorthand;
   }
   state.tokens[state.tokens.length - 1].identifierRole = identifierRole;
+
+  // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow
+  // parsing as if there's a default value.
   parseMaybeDefault(isBlockScope, true);
 }
-function parseObjPropValue(isPattern, isBlockScope, objectContextId) {
+
+function parseObjPropValue(
+  isPattern,
+  isBlockScope,
+  objectContextId,
+) {
   if (isTypeScriptEnabled) {
     tsStartParseObjPropValue();
   } else if (isFlowEnabled) {
@@ -30447,6 +22890,7 @@ function parseObjPropValue(isPattern, isBlockScope, objectContextId) {
     parseObjectProperty(isPattern, isBlockScope);
   }
 }
+
 function parsePropertyName(objectContextId) {
   if (isFlowEnabled) {
     flowParseVariance();
@@ -30462,27 +22906,36 @@ function parsePropertyName(objectContextId) {
     } else {
       parseMaybePrivateName();
     }
+
     state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ObjectKey;
     state.tokens[state.tokens.length - 1].contextId = objectContextId;
   }
 }
+
+// Parse object or class method.
 function parseMethod(functionStart, isConstructor) {
   const funcContextId = getNextContextId();
+
   state.scopeDepth++;
   const startTokenIndex = state.tokens.length;
-  const allowModifiers = isConstructor;
+  const allowModifiers = isConstructor; // For TypeScript parameter properties
   parseFunctionParams(allowModifiers, funcContextId);
   parseFunctionBodyAndFinish(functionStart, funcContextId);
   const endTokenIndex = state.tokens.length;
   state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));
   state.scopeDepth--;
 }
+
+// Parse arrow function expression.
+// If the parameters are provided, they will be converted to an
+// assignable list.
 function parseArrowExpression(startTokenIndex) {
   parseFunctionBody(true);
   const endTokenIndex = state.tokens.length;
   state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));
   state.scopeDepth--;
 }
+
 function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {
   if (isTypeScriptEnabled) {
     tsParseFunctionBodyAndFinish(functionStart, funcContextId);
@@ -30492,14 +22945,23 @@ function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {
     parseFunctionBody(false, funcContextId);
   }
 }
+
 function parseFunctionBody(allowExpression, funcContextId = 0) {
   const isExpression = allowExpression && !match(TokenType.braceL);
+
   if (isExpression) {
     parseMaybeAssign();
   } else {
-    parseBlock(true, funcContextId);
+    parseBlock(true /* isFunctionScope */, funcContextId);
   }
 }
+
+// Parses a comma-separated list of expressions, and returns them as
+// an array. `close` is the token type that ends the list, and
+// `allowEmpty` can be turned on to allow subsequent commas with
+// nothing in between them to be parsed as `null` (which is needed
+// for array literals).
+
 function parseExprList(close, allowEmpty = false) {
   let first = true;
   while (!eat(close) && !state.error) {
@@ -30507,31 +22969,36 @@ function parseExprList(close, allowEmpty = false) {
       first = false;
     } else {
       expect(TokenType.comma);
-      if (eat(close))
-        break;
+      if (eat(close)) break;
     }
     parseExprListItem(allowEmpty);
   }
 }
+
 function parseExprListItem(allowEmpty) {
-  if (allowEmpty && match(TokenType.comma))
-    ;
-  else if (match(TokenType.ellipsis)) {
+  if (allowEmpty && match(TokenType.comma)) ; else if (match(TokenType.ellipsis)) {
     parseSpread();
     parseParenItem();
   } else if (match(TokenType.question)) {
+    // Partial function application proposal.
     next();
   } else {
     parseMaybeAssign(false, true);
   }
 }
+
+// Parse the next token as an identifier.
 function parseIdentifier() {
   next();
   state.tokens[state.tokens.length - 1].type = TokenType.name;
 }
+
+// Parses await expression inside async function.
 function parseAwait() {
   parseMaybeUnary();
 }
+
+// Parses yield expression inside generator.
 function parseYield() {
   next();
   if (!match(TokenType.semi) && !canInsertSemicolon()) {
@@ -30539,20 +23006,33 @@ function parseYield() {
     parseMaybeAssign();
   }
 }
+
+// https://github.com/tc39/proposal-js-module-blocks
 function parseModuleExpression() {
   expectContextual(ContextualKeyword._module);
   expect(TokenType.braceL);
+  // For now, just call parseBlockBody to parse the block. In the future when we
+  // implement full support, we'll want to emit scopes and possibly other
+  // information.
   parseBlockBody(TokenType.braceR);
 }
+
+/* eslint max-len: 0 */
+
 function isMaybeDefaultImport(lookahead) {
-  return (lookahead.type === TokenType.name || !!(lookahead.type & TokenType.IS_KEYWORD)) && lookahead.contextualKeyword !== ContextualKeyword._from;
+  return (
+    (lookahead.type === TokenType.name || !!(lookahead.type & TokenType.IS_KEYWORD)) &&
+    lookahead.contextualKeyword !== ContextualKeyword._from
+  );
 }
+
 function flowParseTypeInitialiser(tok) {
   const oldIsType = pushTypeContext(0);
   expect(tok || TokenType.colon);
   flowParseType();
   popTypeContext(oldIsType);
 }
+
 function flowParsePredicate() {
   expect(TokenType.modulo);
   expectContextual(ContextualKeyword._checks);
@@ -30561,6 +23041,7 @@ function flowParsePredicate() {
     expect(TokenType.parenR);
   }
 }
+
 function flowParseTypeAndPredicateInitialiser() {
   const oldIsType = pushTypeContext(0);
   expect(TokenType.colon);
@@ -30574,22 +23055,29 @@ function flowParseTypeAndPredicateInitialiser() {
   }
   popTypeContext(oldIsType);
 }
+
 function flowParseDeclareClass() {
   next();
-  flowParseInterfaceish(true);
+  flowParseInterfaceish(/* isClass */ true);
 }
+
 function flowParseDeclareFunction() {
   next();
   parseIdentifier();
+
   if (match(TokenType.lessThan)) {
     flowParseTypeParameterDeclaration();
   }
+
   expect(TokenType.parenL);
   flowParseFunctionTypeParams();
   expect(TokenType.parenR);
+
   flowParseTypeAndPredicateInitialiser();
+
   semicolon();
 }
+
 function flowParseDeclare() {
   if (match(TokenType._class)) {
     flowParseDeclareClass();
@@ -30615,17 +23103,20 @@ function flowParseDeclare() {
     unexpected();
   }
 }
+
 function flowParseDeclareVariable() {
   next();
   flowParseTypeAnnotatableIdentifier();
   semicolon();
 }
+
 function flowParseDeclareModule() {
   if (match(TokenType.string)) {
     parseExprAtom();
   } else {
     parseIdentifier();
   }
+
   expect(TokenType.braceL);
   while (!match(TokenType.braceR) && !state.error) {
     if (match(TokenType._import)) {
@@ -30637,112 +23128,156 @@ function flowParseDeclareModule() {
   }
   expect(TokenType.braceR);
 }
+
 function flowParseDeclareExportDeclaration() {
   expect(TokenType._export);
+
   if (eat(TokenType._default)) {
     if (match(TokenType._function) || match(TokenType._class)) {
+      // declare export default class ...
+      // declare export default function ...
       flowParseDeclare();
     } else {
+      // declare export default [type];
       flowParseType();
       semicolon();
     }
-  } else if (match(TokenType._var) || match(TokenType._function) || match(TokenType._class) || isContextual(ContextualKeyword._opaque)) {
+  } else if (
+    match(TokenType._var) || // declare export var ...
+    match(TokenType._function) || // declare export function ...
+    match(TokenType._class) || // declare export class ...
+    isContextual(ContextualKeyword._opaque) // declare export opaque ..
+  ) {
     flowParseDeclare();
-  } else if (match(TokenType.star) || match(TokenType.braceL) || isContextual(ContextualKeyword._interface) || isContextual(ContextualKeyword._type) || isContextual(ContextualKeyword._opaque)) {
+  } else if (
+    match(TokenType.star) || // declare export * from ''
+    match(TokenType.braceL) || // declare export {} ...
+    isContextual(ContextualKeyword._interface) || // declare export interface ...
+    isContextual(ContextualKeyword._type) || // declare export type ...
+    isContextual(ContextualKeyword._opaque) // declare export opaque type ...
+  ) {
     parseExport();
   } else {
     unexpected();
   }
 }
+
 function flowParseDeclareModuleExports() {
   expectContextual(ContextualKeyword._exports);
   flowParseTypeAnnotation();
   semicolon();
 }
+
 function flowParseDeclareTypeAlias() {
   next();
   flowParseTypeAlias();
 }
+
 function flowParseDeclareOpaqueType() {
   next();
   flowParseOpaqueType(true);
 }
+
 function flowParseDeclareInterface() {
   next();
   flowParseInterfaceish();
 }
+
+// Interfaces
+
 function flowParseInterfaceish(isClass = false) {
   flowParseRestrictedIdentifier();
+
   if (match(TokenType.lessThan)) {
     flowParseTypeParameterDeclaration();
   }
+
   if (eat(TokenType._extends)) {
     do {
       flowParseInterfaceExtends();
     } while (!isClass && eat(TokenType.comma));
   }
+
   if (isContextual(ContextualKeyword._mixins)) {
     next();
     do {
       flowParseInterfaceExtends();
     } while (eat(TokenType.comma));
   }
+
   if (isContextual(ContextualKeyword._implements)) {
     next();
     do {
       flowParseInterfaceExtends();
     } while (eat(TokenType.comma));
   }
+
   flowParseObjectType(isClass, false, isClass);
 }
+
 function flowParseInterfaceExtends() {
   flowParseQualifiedTypeIdentifier(false);
   if (match(TokenType.lessThan)) {
     flowParseTypeParameterInstantiation();
   }
 }
+
 function flowParseInterface() {
   flowParseInterfaceish();
 }
+
 function flowParseRestrictedIdentifier() {
   parseIdentifier();
 }
+
 function flowParseTypeAlias() {
   flowParseRestrictedIdentifier();
+
   if (match(TokenType.lessThan)) {
     flowParseTypeParameterDeclaration();
   }
+
   flowParseTypeInitialiser(TokenType.eq);
   semicolon();
 }
+
 function flowParseOpaqueType(declare) {
   expectContextual(ContextualKeyword._type);
   flowParseRestrictedIdentifier();
+
   if (match(TokenType.lessThan)) {
     flowParseTypeParameterDeclaration();
   }
+
+  // Parse the supertype
   if (match(TokenType.colon)) {
     flowParseTypeInitialiser(TokenType.colon);
   }
+
   if (!declare) {
     flowParseTypeInitialiser(TokenType.eq);
   }
   semicolon();
 }
+
 function flowParseTypeParameter() {
   flowParseVariance();
   flowParseTypeAnnotatableIdentifier();
+
   if (eat(TokenType.eq)) {
     flowParseType();
   }
 }
+
 function flowParseTypeParameterDeclaration() {
   const oldIsType = pushTypeContext(0);
+  // istanbul ignore else: this condition is already checked at all call sites
   if (match(TokenType.lessThan) || match(TokenType.typeParameterStart)) {
     next();
   } else {
     unexpected();
   }
+
   do {
     flowParseTypeParameter();
     if (!match(TokenType.greaterThan)) {
@@ -30752,6 +23287,7 @@ function flowParseTypeParameterDeclaration() {
   expect(TokenType.greaterThan);
   popTypeContext(oldIsType);
 }
+
 function flowParseTypeParameterInstantiation() {
   const oldIsType = pushTypeContext(0);
   expect(TokenType.lessThan);
@@ -30764,6 +23300,7 @@ function flowParseTypeParameterInstantiation() {
   expect(TokenType.greaterThan);
   popTypeContext(oldIsType);
 }
+
 function flowParseInterfaceType() {
   expectContextual(ContextualKeyword._interface);
   if (eat(TokenType._extends)) {
@@ -30773,6 +23310,7 @@ function flowParseInterfaceType() {
   }
   flowParseObjectType(false, false, false);
 }
+
 function flowParseObjectPropertyKey() {
   if (match(TokenType.num) || match(TokenType.string)) {
     parseExprAtom();
@@ -30780,7 +23318,9 @@ function flowParseObjectPropertyKey() {
     parseIdentifier();
   }
 }
+
 function flowParseObjectTypeIndexer() {
+  // Note: bracketL has already been consumed
   if (lookaheadType() === TokenType.colon) {
     flowParseObjectPropertyKey();
     flowParseTypeInitialiser();
@@ -30790,7 +23330,9 @@ function flowParseObjectTypeIndexer() {
   expect(TokenType.bracketR);
   flowParseTypeInitialiser();
 }
+
 function flowParseObjectTypeInternalSlot() {
+  // Note: both bracketL have already been consumed
   flowParseObjectPropertyKey();
   expect(TokenType.bracketR);
   expect(TokenType.bracketR);
@@ -30801,10 +23343,12 @@ function flowParseObjectTypeInternalSlot() {
     flowParseTypeInitialiser();
   }
 }
+
 function flowParseObjectTypeMethodish() {
   if (match(TokenType.lessThan)) {
     flowParseTypeParameterDeclaration();
   }
+
   expect(TokenType.parenL);
   while (!match(TokenType.parenR) && !match(TokenType.ellipsis) && !state.error) {
     flowParseFunctionTypeParam();
@@ -30812,15 +23356,18 @@ function flowParseObjectTypeMethodish() {
       expect(TokenType.comma);
     }
   }
+
   if (eat(TokenType.ellipsis)) {
     flowParseFunctionTypeParam();
   }
   expect(TokenType.parenR);
   flowParseTypeInitialiser();
 }
+
 function flowParseObjectTypeCallProperty() {
   flowParseObjectTypeMethodish();
 }
+
 function flowParseObjectType(allowStatic, allowExact, allowProto) {
   let endDelim;
   if (allowExact && match(TokenType.braceBarL)) {
@@ -30830,6 +23377,7 @@ function flowParseObjectType(allowStatic, allowExact, allowProto) {
     expect(TokenType.braceL);
     endDelim = TokenType.braceR;
   }
+
   while (!match(endDelim) && !state.error) {
     if (allowProto && isContextual(ContextualKeyword._proto)) {
       const lookahead = lookaheadType();
@@ -30844,7 +23392,9 @@ function flowParseObjectType(allowStatic, allowExact, allowProto) {
         next();
       }
     }
+
     flowParseVariance();
+
     if (eat(TokenType.bracketL)) {
       if (eat(TokenType.bracketL)) {
         flowParseObjectTypeInternalSlot();
@@ -30860,18 +23410,23 @@ function flowParseObjectType(allowStatic, allowExact, allowProto) {
           next();
         }
       }
+
       flowParseObjectTypeProperty();
     }
+
     flowObjectTypeSemicolon();
   }
+
   expect(endDelim);
 }
+
 function flowParseObjectTypeProperty() {
   if (match(TokenType.ellipsis)) {
     expect(TokenType.ellipsis);
     if (!eat(TokenType.comma)) {
       eat(TokenType.semi);
     }
+    // Explicit inexact object syntax.
     if (match(TokenType.braceR)) {
       return;
     }
@@ -30879,6 +23434,7 @@ function flowParseObjectTypeProperty() {
   } else {
     flowParseObjectPropertyKey();
     if (match(TokenType.lessThan) || match(TokenType.parenL)) {
+      // This is a method property
       flowParseObjectTypeMethodish();
     } else {
       eat(TokenType.question);
@@ -30886,11 +23442,13 @@ function flowParseObjectTypeProperty() {
     }
   }
 }
+
 function flowObjectTypeSemicolon() {
   if (!eat(TokenType.semi) && !eat(TokenType.comma) && !match(TokenType.braceR) && !match(TokenType.braceBarR)) {
     unexpected();
   }
 }
+
 function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
   if (!initialIdAlreadyParsed) {
     parseIdentifier();
@@ -30899,18 +23457,22 @@ function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
     parseIdentifier();
   }
 }
+
 function flowParseGenericType() {
   flowParseQualifiedTypeIdentifier(true);
   if (match(TokenType.lessThan)) {
     flowParseTypeParameterInstantiation();
   }
 }
+
 function flowParseTypeofType() {
   expect(TokenType._typeof);
   flowParsePrimaryType();
 }
+
 function flowParseTupleType() {
   expect(TokenType.bracketL);
+  // We allow trailing commas
   while (state.pos < input.length && !match(TokenType.bracketR)) {
     flowParseType();
     if (match(TokenType.bracketR)) {
@@ -30920,6 +23482,7 @@ function flowParseTupleType() {
   }
   expect(TokenType.bracketR);
 }
+
 function flowParseFunctionTypeParam() {
   const lookahead = lookaheadType();
   if (lookahead === TokenType.colon || lookahead === TokenType.question) {
@@ -30930,6 +23493,7 @@ function flowParseFunctionTypeParam() {
     flowParseType();
   }
 }
+
 function flowParseFunctionTypeParams() {
   while (!match(TokenType.parenR) && !match(TokenType.ellipsis) && !state.error) {
     flowParseFunctionTypeParam();
@@ -30941,9 +23505,14 @@ function flowParseFunctionTypeParams() {
     flowParseFunctionTypeParam();
   }
 }
+
+// The parsing of types roughly parallels the parsing of expressions, and
+// primary types are kind of like primary expressions...they're the
+// primitives with which other types are constructed.
 function flowParsePrimaryType() {
   let isGroupedType = false;
   const oldNoAnonFunctionType = state.noAnonFunctionType;
+
   switch (state.type) {
     case TokenType.name: {
       if (isContextual(ContextualKeyword._interface)) {
@@ -30954,15 +23523,19 @@ function flowParsePrimaryType() {
       flowParseGenericType();
       return;
     }
+
     case TokenType.braceL:
       flowParseObjectType(false, false, false);
       return;
+
     case TokenType.braceBarL:
       flowParseObjectType(false, true, false);
       return;
+
     case TokenType.bracketL:
       flowParseTupleType();
       return;
+
     case TokenType.lessThan:
       flowParseTypeParameterDeclaration();
       expect(TokenType.parenL);
@@ -30971,8 +23544,11 @@ function flowParsePrimaryType() {
       expect(TokenType.arrow);
       flowParseType();
       return;
+
     case TokenType.parenL:
       next();
+
+      // Check to see if this is actually a grouped type
       if (!match(TokenType.parenR) && !match(TokenType.ellipsis)) {
         if (match(TokenType.name)) {
           const token = lookaheadType();
@@ -30981,26 +23557,37 @@ function flowParsePrimaryType() {
           isGroupedType = true;
         }
       }
+
       if (isGroupedType) {
         state.noAnonFunctionType = false;
         flowParseType();
         state.noAnonFunctionType = oldNoAnonFunctionType;
-        if (state.noAnonFunctionType || !(match(TokenType.comma) || match(TokenType.parenR) && lookaheadType() === TokenType.arrow)) {
+
+        // A `,` or a `) =>` means this is an anonymous function type
+        if (
+          state.noAnonFunctionType ||
+          !(match(TokenType.comma) || (match(TokenType.parenR) && lookaheadType() === TokenType.arrow))
+        ) {
           expect(TokenType.parenR);
           return;
         } else {
+          // Eat a comma if there is one
           eat(TokenType.comma);
         }
       }
+
       flowParseFunctionTypeParams();
+
       expect(TokenType.parenR);
       expect(TokenType.arrow);
       flowParseType();
       return;
+
     case TokenType.minus:
       next();
       parseLiteral();
       return;
+
     case TokenType.string:
     case TokenType.num:
     case TokenType._true:
@@ -31011,6 +23598,7 @@ function flowParsePrimaryType() {
     case TokenType.star:
       next();
       return;
+
     default:
       if (state.type === TokenType._typeof) {
         flowParseTypeofType();
@@ -31021,21 +23609,23 @@ function flowParsePrimaryType() {
         return;
       }
   }
+
   unexpected();
 }
+
 function flowParsePostfixType() {
   flowParsePrimaryType();
   while (!canInsertSemicolon() && (match(TokenType.bracketL) || match(TokenType.questionDot))) {
     eat(TokenType.questionDot);
     expect(TokenType.bracketL);
-    if (eat(TokenType.bracketR))
-      ;
-    else {
+    if (eat(TokenType.bracketR)) ; else {
+      // Indexed access type
       flowParseType();
       expect(TokenType.bracketR);
     }
   }
 }
+
 function flowParsePrefixType() {
   if (eat(TokenType.question)) {
     flowParsePrefixType();
@@ -31043,12 +23633,14 @@ function flowParsePrefixType() {
     flowParsePostfixType();
   }
 }
+
 function flowParseAnonFunctionWithoutParens() {
   flowParsePrefixType();
   if (!state.noAnonFunctionType && eat(TokenType.arrow)) {
     flowParseType();
   }
 }
+
 function flowParseIntersectionType() {
   eat(TokenType.bitwiseAND);
   flowParseAnonFunctionWithoutParens();
@@ -31056,6 +23648,7 @@ function flowParseIntersectionType() {
     flowParseAnonFunctionWithoutParens();
   }
 }
+
 function flowParseUnionType() {
   eat(TokenType.bitwiseOR);
   flowParseIntersectionType();
@@ -31063,31 +23656,47 @@ function flowParseUnionType() {
     flowParseIntersectionType();
   }
 }
+
 function flowParseType() {
   flowParseUnionType();
 }
+
 function flowParseTypeAnnotation() {
   flowParseTypeInitialiser();
 }
+
 function flowParseTypeAnnotatableIdentifier() {
   parseIdentifier();
   if (match(TokenType.colon)) {
     flowParseTypeAnnotation();
   }
 }
+
 function flowParseVariance() {
   if (match(TokenType.plus) || match(TokenType.minus)) {
     next();
     state.tokens[state.tokens.length - 1].isType = true;
   }
 }
+
+// ==================================
+// Overrides
+// ==================================
+
 function flowParseFunctionBodyAndFinish(funcContextId) {
+  // For arrow functions, `parseArrow` handles the return type itself.
   if (match(TokenType.colon)) {
     flowParseTypeAndPredicateInitialiser();
   }
+
   parseFunctionBody(false, funcContextId);
 }
-function flowParseSubscript(startTokenIndex, noCalls, stopState) {
+
+function flowParseSubscript(
+  startTokenIndex,
+  noCalls,
+  stopState,
+) {
   if (match(TokenType.questionDot) && lookaheadType() === TokenType.lessThan) {
     if (noCalls) {
       stopState.stop = true;
@@ -31111,6 +23720,7 @@ function flowParseSubscript(startTokenIndex, noCalls, stopState) {
   }
   baseParseSubscript(startTokenIndex, noCalls, stopState);
 }
+
 function flowStartParseNewArguments() {
   if (match(TokenType.lessThan)) {
     const snapshot = state.snapshot();
@@ -31120,6 +23730,8 @@ function flowStartParseNewArguments() {
     }
   }
 }
+
+// interfaces
 function flowTryParseStatement() {
   if (match(TokenType.name) && state.contextualKeyword === ContextualKeyword._interface) {
     const oldIsType = pushTypeContext(0);
@@ -31131,9 +23743,17 @@ function flowTryParseStatement() {
     return false;
   }
 }
+
+// declares, interfaces and type aliases
 function flowParseIdentifierStatement(contextualKeyword) {
   if (contextualKeyword === ContextualKeyword._declare) {
-    if (match(TokenType._class) || match(TokenType.name) || match(TokenType._function) || match(TokenType._var) || match(TokenType._export)) {
+    if (
+      match(TokenType._class) ||
+      match(TokenType.name) ||
+      match(TokenType._function) ||
+      match(TokenType._var) ||
+      match(TokenType._export)
+    ) {
       const oldIsType = pushTypeContext(1);
       flowParseDeclare();
       popTypeContext(oldIsType);
@@ -31155,26 +23775,43 @@ function flowParseIdentifierStatement(contextualKeyword) {
   }
   semicolon();
 }
+
+// export type
 function flowShouldParseExportDeclaration() {
-  return isContextual(ContextualKeyword._type) || isContextual(ContextualKeyword._interface) || isContextual(ContextualKeyword._opaque);
+  return (
+    isContextual(ContextualKeyword._type) ||
+    isContextual(ContextualKeyword._interface) ||
+    isContextual(ContextualKeyword._opaque)
+  );
 }
+
 function flowShouldDisallowExportDefaultSpecifier() {
-  return match(TokenType.name) && (state.contextualKeyword === ContextualKeyword._type || state.contextualKeyword === ContextualKeyword._interface || state.contextualKeyword === ContextualKeyword._opaque);
+  return (
+    match(TokenType.name) &&
+    (state.contextualKeyword === ContextualKeyword._type ||
+      state.contextualKeyword === ContextualKeyword._interface ||
+      state.contextualKeyword === ContextualKeyword._opaque)
+  );
 }
+
 function flowParseExportDeclaration() {
   if (isContextual(ContextualKeyword._type)) {
     const oldIsType = pushTypeContext(1);
     next();
+
     if (match(TokenType.braceL)) {
+      // export type { foo, bar };
       parseExportSpecifiers();
       parseExportFrom();
     } else {
+      // export type Foo = Bar;
       flowParseTypeAlias();
     }
     popTypeContext(oldIsType);
   } else if (isContextual(ContextualKeyword._opaque)) {
     const oldIsType = pushTypeContext(1);
     next();
+    // export opaque type Foo = Bar;
     flowParseOpaqueType(false);
     popTypeContext(oldIsType);
   } else if (isContextual(ContextualKeyword._interface)) {
@@ -31186,9 +23823,11 @@ function flowParseExportDeclaration() {
     parseStatement(true);
   }
 }
+
 function flowShouldParseExportStar() {
-  return match(TokenType.star) || isContextual(ContextualKeyword._type) && lookaheadType() === TokenType.star;
+  return match(TokenType.star) || (isContextual(ContextualKeyword._type) && lookaheadType() === TokenType.star);
 }
+
 function flowParseExportStar() {
   if (eatContextual(ContextualKeyword._type)) {
     const oldIsType = pushTypeContext(2);
@@ -31198,6 +23837,8 @@ function flowParseExportStar() {
     baseParseExportStar();
   }
 }
+
+// parse a the super class type parameters and implements
 function flowAfterParseClassSuper(hasSuper) {
   if (hasSuper && match(TokenType.lessThan)) {
     flowParseTypeParameterInstantiation();
@@ -31215,13 +23856,16 @@ function flowAfterParseClassSuper(hasSuper) {
     popTypeContext(oldIsType);
   }
 }
+
+// parse type parameters for object method shorthand
 function flowStartParseObjPropValue() {
+  // method shorthand
   if (match(TokenType.lessThan)) {
     flowParseTypeParameterDeclaration();
-    if (!match(TokenType.parenL))
-      unexpected();
+    if (!match(TokenType.parenL)) unexpected();
   }
 }
+
 function flowParseAssignableListItemTypes() {
   const oldIsType = pushTypeContext(0);
   eat(TokenType.question);
@@ -31230,6 +23874,8 @@ function flowParseAssignableListItemTypes() {
   }
   popTypeContext(oldIsType);
 }
+
+// parse typeof and type imports
 function flowStartParseImportSpecifiers() {
   if (match(TokenType._typeof) || isContextual(ContextualKeyword._type)) {
     const lh = lookaheadTypeAndKeyword();
@@ -31238,39 +23884,51 @@ function flowStartParseImportSpecifiers() {
     }
   }
 }
+
+// parse import-type/typeof shorthand
 function flowParseImportSpecifier() {
-  const isTypeKeyword = state.contextualKeyword === ContextualKeyword._type || state.type === TokenType._typeof;
+  const isTypeKeyword =
+    state.contextualKeyword === ContextualKeyword._type || state.type === TokenType._typeof;
   if (isTypeKeyword) {
     next();
   } else {
     parseIdentifier();
   }
+
   if (isContextual(ContextualKeyword._as) && !isLookaheadContextual(ContextualKeyword._as)) {
     parseIdentifier();
-    if (isTypeKeyword && !match(TokenType.name) && !(state.type & TokenType.IS_KEYWORD))
-      ;
-    else {
+    if (isTypeKeyword && !match(TokenType.name) && !(state.type & TokenType.IS_KEYWORD)) ; else {
+      // `import {type as foo`
       parseIdentifier();
     }
   } else if (isTypeKeyword && (match(TokenType.name) || !!(state.type & TokenType.IS_KEYWORD))) {
+    // `import {type foo`
     parseIdentifier();
     if (eatContextual(ContextualKeyword._as)) {
       parseIdentifier();
     }
   }
 }
+
+// parse function type parameters - function foo<T>() {}
 function flowStartParseFunctionParams() {
+  // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon
+  // anyway, so don't try to propagate that information.
   if (match(TokenType.lessThan)) {
     const oldIsType = pushTypeContext(0);
     flowParseTypeParameterDeclaration();
     popTypeContext(oldIsType);
   }
 }
+
+// parse flow type annotations on variable declarator heads - let foo: string = bar
 function flowAfterParseVarHead() {
   if (match(TokenType.colon)) {
     flowParseTypeAnnotation();
   }
 }
+
+// parse the return type of an async arrow function - let foo = (async (): number => {});
 function flowStartParseAsyncArrowFromCallExpression() {
   if (match(TokenType.colon)) {
     const oldNoAnonFunctionType = state.noAnonFunctionType;
@@ -31279,6 +23937,17 @@ function flowStartParseAsyncArrowFromCallExpression() {
     state.noAnonFunctionType = oldNoAnonFunctionType;
   }
 }
+
+// We need to support type parameter declarations for arrow functions. This
+// is tricky. There are three situations we need to handle
+//
+// 1. This is either JSX or an arrow function. We'll try JSX first. If that
+//    fails, we'll try an arrow function. If that fails, we'll throw the JSX
+//    error.
+// 2. This is an arrow function. We'll parse the type parameter declaration,
+//    parse the rest, make sure the rest is an arrow function, and go from
+//    there
+// 3. This is neither. Just call the super method
 function flowParseMaybeAssign(noIn, isWithinParens) {
   if (match(TokenType.lessThan)) {
     const snapshot = state.snapshot();
@@ -31289,6 +23958,7 @@ function flowParseMaybeAssign(noIn, isWithinParens) {
     } else {
       return wasArrow;
     }
+
     const oldIsType = pushTypeContext(0);
     flowParseTypeParameterDeclaration();
     popTypeContext(oldIsType);
@@ -31298,20 +23968,24 @@ function flowParseMaybeAssign(noIn, isWithinParens) {
     }
     unexpected();
   }
+
   return baseParseMaybeAssign(noIn, isWithinParens);
 }
+
+// handle return types for arrow functions
 function flowParseArrow() {
   if (match(TokenType.colon)) {
     const oldIsType = pushTypeContext(0);
     const snapshot = state.snapshot();
+
     const oldNoAnonFunctionType = state.noAnonFunctionType;
     state.noAnonFunctionType = true;
     flowParseTypeAndPredicateInitialiser();
     state.noAnonFunctionType = oldNoAnonFunctionType;
-    if (canInsertSemicolon())
-      unexpected();
-    if (!match(TokenType.arrow))
-      unexpected();
+
+    if (canInsertSemicolon()) unexpected();
+    if (!match(TokenType.arrow)) unexpected();
+
     if (state.error) {
       state.restoreFromSnapshot(snapshot);
     }
@@ -31319,8 +23993,12 @@ function flowParseArrow() {
   }
   return eat(TokenType.arrow);
 }
+
 function flowParseSubscripts(startTokenIndex, noCalls = false) {
-  if (state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async && match(TokenType.lessThan)) {
+  if (
+    state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async &&
+    match(TokenType.lessThan)
+  ) {
     const snapshot = state.snapshot();
     const wasArrow = parseAsyncArrowWithTypeParameters();
     if (wasArrow && !state.error) {
@@ -31328,8 +24006,11 @@ function flowParseSubscripts(startTokenIndex, noCalls = false) {
     }
     state.restoreFromSnapshot(snapshot);
   }
+
   baseParseSubscripts(startTokenIndex, noCalls);
 }
+
+// Returns true if there was an arrow function here.
 function parseAsyncArrowWithTypeParameters() {
   state.scopeDepth++;
   const startTokenIndex = state.tokens.length;
@@ -31340,6 +24021,9 @@ function parseAsyncArrowWithTypeParameters() {
   parseArrowExpression(startTokenIndex);
   return true;
 }
+
+/* eslint max-len: 0 */
+
 function parseTopLevel() {
   parseBlockBody(TokenType.eof);
   state.scopes.push(new Scope(0, state.tokens.length, true));
@@ -31348,6 +24032,14 @@ function parseTopLevel() {
   }
   return new File$1(state.tokens, state.scopes);
 }
+
+// Parse a single statement.
+//
+// If expecting a statement and finding a slash operator, parse a
+// regular expression literal. This is to handle cases like
+// `if (foo) /blah/.exec(foo)`, where looking at the previous token
+// does not help.
+
 function parseStatement(declaration) {
   if (isFlowEnabled) {
     if (flowTryParseStatement()) {
@@ -31359,13 +24051,20 @@ function parseStatement(declaration) {
   }
   parseStatementContent(declaration);
 }
+
 function parseStatementContent(declaration) {
   if (isTypeScriptEnabled) {
     if (tsTryParseStatementContent()) {
       return;
     }
   }
+
   const starttype = state.type;
+
+  // Most types of statements are recognized by the keyword they
+  // start with. Many are trivial to parse, some require a bit of
+  // complexity.
+
   switch (starttype) {
     case TokenType._break:
     case TokenType._continue:
@@ -31381,17 +24080,16 @@ function parseStatementContent(declaration) {
       parseForStatement();
       return;
     case TokenType._function:
-      if (lookaheadType() === TokenType.dot)
-        break;
-      if (!declaration)
-        unexpected();
+      if (lookaheadType() === TokenType.dot) break;
+      if (!declaration) unexpected();
       parseFunctionStatement();
       return;
+
     case TokenType._class:
-      if (!declaration)
-        unexpected();
+      if (!declaration) unexpected();
       parseClass(true);
       return;
+
     case TokenType._if:
       parseIfStatement();
       return;
@@ -31407,13 +24105,15 @@ function parseStatementContent(declaration) {
     case TokenType._try:
       parseTryStatement();
       return;
+
     case TokenType._let:
     case TokenType._const:
-      if (!declaration)
-        unexpected();
+      if (!declaration) unexpected(); // NOTE: falls through to _var
+
     case TokenType._var:
       parseVarStatement(starttype);
       return;
+
     case TokenType._while:
       parseWhileStatement();
       return;
@@ -31440,6 +24140,7 @@ function parseStatementContent(declaration) {
     case TokenType.name:
       if (state.contextualKeyword === ContextualKeyword._async) {
         const functionStart = state.start;
+        // peek ahead and see if next token is a function
         const snapshot = state.snapshot();
         next();
         if (match(TokenType._function) && !canInsertSemicolon()) {
@@ -31451,6 +24152,12 @@ function parseStatementContent(declaration) {
         }
       }
   }
+
+  // If the statement does not start with a statement keyword or a
+  // brace, it's an ExpressionStatement or LabeledStatement. We
+  // simply start parsing an expression, and afterwards, if the
+  // next token is a colon and the expression was a simple
+  // Identifier node, we switch to interpreting it as a label.
   const initialTokensLength = state.tokens.length;
   parseExpression();
   let simpleName = null;
@@ -31467,14 +24174,17 @@ function parseStatementContent(declaration) {
   if (eat(TokenType.colon)) {
     parseLabeledStatement();
   } else {
+    // This was an identifier, so we might want to handle flow/typescript-specific cases.
     parseIdentifierStatement(simpleName);
   }
 }
+
 function parseDecorators() {
   while (match(TokenType.at)) {
     parseDecorator();
   }
 }
+
 function parseDecorator() {
   next();
   if (eat(TokenType.parenL)) {
@@ -31488,6 +24198,7 @@ function parseDecorator() {
   }
   parseMaybeDecoratorArguments();
 }
+
 function parseMaybeDecoratorArguments() {
   if (isTypeScriptEnabled) {
     tsParseMaybeDecoratorArguments();
@@ -31495,11 +24206,13 @@ function parseMaybeDecoratorArguments() {
     baseParseMaybeDecoratorArguments();
   }
 }
+
 function baseParseMaybeDecoratorArguments() {
   if (eat(TokenType.parenL)) {
     parseCallExpressionArguments();
   }
 }
+
 function parseBreakContinueStatement() {
   next();
   if (!isLineTerminator()) {
@@ -31507,10 +24220,12 @@ function parseBreakContinueStatement() {
     semicolon();
   }
 }
+
 function parseDebuggerStatement() {
   next();
   semicolon();
 }
+
 function parseDoStatement() {
   next();
   parseStatement(false);
@@ -31518,6 +24233,7 @@ function parseDoStatement() {
   parseParenExpression();
   eat(TokenType.semi);
 }
+
 function parseForStatement() {
   state.scopeDepth++;
   const startTokenIndex = state.tokens.length;
@@ -31526,14 +24242,24 @@ function parseForStatement() {
   state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));
   state.scopeDepth--;
 }
+
+// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
+// loop is non-trivial. Basically, we have to parse the init `var`
+// statement or expression, disallowing the `in` operator (see
+// the second parameter to `parseExpression`), and then check
+// whether the next token is `in` or `of`. When there is no init
+// part (semicolon immediately after the opening parenthesis), it
+// is a regular `for` loop.
 function parseAmbiguousForStatement() {
   next();
+
   let forAwait = false;
   if (isContextual(ContextualKeyword._await)) {
     forAwait = true;
     next();
   }
   expect(TokenType.parenL);
+
   if (match(TokenType.semi)) {
     if (forAwait) {
       unexpected();
@@ -31541,6 +24267,7 @@ function parseAmbiguousForStatement() {
     parseFor();
     return;
   }
+
   if (match(TokenType._var) || match(TokenType._let) || match(TokenType._const)) {
     const varKind = state.type;
     next();
@@ -31552,6 +24279,7 @@ function parseAmbiguousForStatement() {
     parseFor();
     return;
   }
+
   parseExpression(true);
   if (match(TokenType._in) || isContextual(ContextualKeyword._of)) {
     parseForIn(forAwait);
@@ -31562,11 +24290,13 @@ function parseAmbiguousForStatement() {
   }
   parseFor();
 }
+
 function parseFunctionStatement() {
   const functionStart = state.start;
   next();
   parseFunction(functionStart, true);
 }
+
 function parseIfStatement() {
   next();
   parseParenExpression();
@@ -31575,19 +24305,28 @@ function parseIfStatement() {
     parseStatement(false);
   }
 }
+
 function parseReturnStatement() {
   next();
+
+  // In `return` (and `break`/`continue`), the keywords with
+  // optional arguments, we eagerly look for a semicolon or the
+  // possibility to insert one.
+
   if (!isLineTerminator()) {
     parseExpression();
     semicolon();
   }
 }
+
 function parseSwitchStatement() {
   next();
   parseParenExpression();
   state.scopeDepth++;
   const startTokenIndex = state.tokens.length;
   expect(TokenType.braceL);
+
+  // Don't bother validation; just go through any sequence of cases, defaults, and statements.
   while (!match(TokenType.braceR) && !state.error) {
     if (match(TokenType._case) || match(TokenType._default)) {
       const isCase = match(TokenType._case);
@@ -31600,25 +24339,31 @@ function parseSwitchStatement() {
       parseStatement(true);
     }
   }
-  next();
+  next(); // Closing brace
   const endTokenIndex = state.tokens.length;
   state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));
   state.scopeDepth--;
 }
+
 function parseThrowStatement() {
   next();
   parseExpression();
   semicolon();
 }
+
 function parseCatchClauseParam() {
-  parseBindingAtom(true);
+  parseBindingAtom(true /* isBlockScope */);
+
   if (isTypeScriptEnabled) {
     tsTryParseTypeAnnotation();
   }
 }
+
 function parseTryStatement() {
   next();
+
   parseBlock();
+
   if (match(TokenType._catch)) {
     next();
     let catchBindingStartTokenIndex = null;
@@ -31631,6 +24376,8 @@ function parseTryStatement() {
     }
     parseBlock();
     if (catchBindingStartTokenIndex != null) {
+      // We need a special scope for the catch binding which includes the binding itself and the
+      // catch block.
       const endTokenIndex = state.tokens.length;
       state.scopes.push(new Scope(catchBindingStartTokenIndex, endTokenIndex, false));
       state.scopeDepth--;
@@ -31640,22 +24387,31 @@ function parseTryStatement() {
     parseBlock();
   }
 }
+
 function parseVarStatement(kind) {
   next();
   parseVar(false, kind);
   semicolon();
 }
+
 function parseWhileStatement() {
   next();
   parseParenExpression();
   parseStatement(false);
 }
+
 function parseEmptyStatement() {
   next();
 }
+
 function parseLabeledStatement() {
   parseStatement(true);
 }
+
+/**
+ * Parse a statement starting with an identifier of the given name. Subclasses match on the name
+ * to handle statements like "declare".
+ */
 function parseIdentifierStatement(contextualKeyword) {
   if (isTypeScriptEnabled) {
     tsParseIdentifierStatement(contextualKeyword);
@@ -31665,6 +24421,8 @@ function parseIdentifierStatement(contextualKeyword) {
     semicolon();
   }
 }
+
+// Parse a semicolon-enclosed block of statements.
 function parseBlock(isFunctionScope = false, contextId = 0) {
   const startTokenIndex = state.tokens.length;
   state.scopeDepth++;
@@ -31680,11 +24438,17 @@ function parseBlock(isFunctionScope = false, contextId = 0) {
   state.scopes.push(new Scope(startTokenIndex, endTokenIndex, isFunctionScope));
   state.scopeDepth--;
 }
+
 function parseBlockBody(end) {
   while (!eat(end) && !state.error) {
     parseStatement(true);
   }
 }
+
+// Parse a regular `for` loop. The disambiguation code in
+// `parseStatement` will already have parsed the init statement or
+// expression.
+
 function parseFor() {
   expect(TokenType.semi);
   if (!match(TokenType.semi)) {
@@ -31697,6 +24461,10 @@ function parseFor() {
   expect(TokenType.parenR);
   parseStatement(false);
 }
+
+// Parse a `for`/`in` and `for`/`of` loop, which are almost
+// same from parser's perspective.
+
 function parseForIn(forAwait) {
   if (forAwait) {
     eatContextual(ContextualKeyword._of);
@@ -31707,6 +24475,9 @@ function parseForIn(forAwait) {
   expect(TokenType.parenR);
   parseStatement(false);
 }
+
+// Parse a list of variable declarations.
+
 function parseVar(isFor, kind) {
   while (true) {
     const isBlockScope = kind === TokenType._const || kind === TokenType._let;
@@ -31721,6 +24492,7 @@ function parseVar(isFor, kind) {
     }
   }
 }
+
 function parseVarHead(isBlockScope) {
   parseBindingAtom(isBlockScope);
   if (isTypeScriptEnabled) {
@@ -31729,26 +24501,42 @@ function parseVarHead(isBlockScope) {
     flowAfterParseVarHead();
   }
 }
-function parseFunction(functionStart, isStatement, optionalId = false) {
+
+// Parse a function declaration or literal (depending on the
+// `isStatement` parameter).
+
+function parseFunction(
+  functionStart,
+  isStatement,
+  optionalId = false,
+) {
   if (match(TokenType.star)) {
     next();
   }
+
   if (isStatement && !optionalId && !match(TokenType.name) && !match(TokenType._yield)) {
     unexpected();
   }
+
   let nameScopeStartTokenIndex = null;
+
   if (match(TokenType.name)) {
+    // Expression-style functions should limit their name's scope to the function body, so we make
+    // a new function scope to enforce that.
     if (!isStatement) {
       nameScopeStartTokenIndex = state.tokens.length;
       state.scopeDepth++;
     }
     parseBindingIdentifier(false);
   }
+
   const startTokenIndex = state.tokens.length;
   state.scopeDepth++;
   parseFunctionParams();
   parseFunctionBodyAndFinish(functionStart);
   const endTokenIndex = state.tokens.length;
+  // In addition to the block scope of the function body, we need a separate function-style scope
+  // that includes the params.
   state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));
   state.scopeDepth--;
   if (nameScopeStartTokenIndex !== null) {
@@ -31756,26 +24544,47 @@ function parseFunction(functionStart, isStatement, optionalId = false) {
     state.scopeDepth--;
   }
 }
-function parseFunctionParams(allowModifiers = false, funcContextId = 0) {
+
+function parseFunctionParams(
+  allowModifiers = false,
+  funcContextId = 0,
+) {
   if (isTypeScriptEnabled) {
     tsStartParseFunctionParams();
   } else if (isFlowEnabled) {
     flowStartParseFunctionParams();
   }
+
   expect(TokenType.parenL);
   if (funcContextId) {
     state.tokens[state.tokens.length - 1].contextId = funcContextId;
   }
-  parseBindingList(TokenType.parenR, false, false, allowModifiers, funcContextId);
+  parseBindingList(
+    TokenType.parenR,
+    false /* isBlockScope */,
+    false /* allowEmpty */,
+    allowModifiers,
+    funcContextId,
+  );
   if (funcContextId) {
     state.tokens[state.tokens.length - 1].contextId = funcContextId;
   }
 }
+
+// Parse a class declaration or literal (depending on the
+// `isStatement` parameter).
+
 function parseClass(isStatement, optionalId = false) {
+  // Put a context ID on the class keyword, the open-brace, and the close-brace, so that later
+  // code can easily navigate to meaningful points on the class.
   const contextId = getNextContextId();
+
   next();
   state.tokens[state.tokens.length - 1].contextId = contextId;
   state.tokens[state.tokens.length - 1].isExpression = !isStatement;
+  // Like with functions, we declare a special "name scope" from the start of the name to the end
+  // of the class, but only with expression-style classes, to represent the fact that the name is
+  // available to the body of the class but not an outer declaration.
   let nameScopeStartTokenIndex = null;
   if (!isStatement) {
     nameScopeStartTokenIndex = state.tokens.length;
@@ -31796,18 +24605,23 @@ function parseClass(isStatement, optionalId = false) {
     state.scopeDepth--;
   }
 }
+
 function isClassProperty() {
   return match(TokenType.eq) || match(TokenType.semi) || match(TokenType.braceR) || match(TokenType.bang) || match(TokenType.colon);
 }
+
 function isClassMethod() {
   return match(TokenType.parenL) || match(TokenType.lessThan);
 }
+
 function parseClassBody(classContextId) {
   expect(TokenType.braceL);
+
   while (!eat(TokenType.braceR) && !state.error) {
     if (eat(TokenType.semi)) {
       continue;
     }
+
     if (match(TokenType.at)) {
       parseDecorator();
       continue;
@@ -31816,6 +24630,7 @@ function parseClassBody(classContextId) {
     parseClassMember(memberStart, classContextId);
   }
 }
+
 function parseClassMember(memberStart, classContextId) {
   if (isTypeScriptEnabled) {
     tsParseModifiers([
@@ -31823,74 +24638,102 @@ function parseClassMember(memberStart, classContextId) {
       ContextualKeyword._public,
       ContextualKeyword._protected,
       ContextualKeyword._private,
-      ContextualKeyword._override
+      ContextualKeyword._override,
     ]);
   }
   let isStatic = false;
   if (match(TokenType.name) && state.contextualKeyword === ContextualKeyword._static) {
-    parseIdentifier();
+    parseIdentifier(); // eats 'static'
     if (isClassMethod()) {
-      parseClassMethod(memberStart, false);
+      parseClassMethod(memberStart, /* isConstructor */ false);
       return;
     } else if (isClassProperty()) {
       parseClassProperty();
       return;
     }
+    // otherwise something static
     state.tokens[state.tokens.length - 1].type = TokenType._static;
     isStatic = true;
+
     if (match(TokenType.braceL)) {
+      // This is a static block. Mark the word "static" with the class context ID for class element
+      // detection and parse as a regular block.
       state.tokens[state.tokens.length - 1].contextId = classContextId;
       parseBlock();
       return;
     }
   }
+
   parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);
 }
-function parseClassMemberWithIsStatic(memberStart, isStatic, classContextId) {
+
+function parseClassMemberWithIsStatic(
+  memberStart,
+  isStatic,
+  classContextId,
+) {
   if (isTypeScriptEnabled) {
     if (tsTryParseClassMemberWithIsStatic(isStatic)) {
       return;
     }
   }
   if (eat(TokenType.star)) {
+    // a generator
     parseClassPropertyName(classContextId);
-    parseClassMethod(memberStart, false);
+    parseClassMethod(memberStart, /* isConstructor */ false);
     return;
   }
+
+  // Get the identifier name so we can tell if it's actually a keyword like "async", "get", or
+  // "set".
   parseClassPropertyName(classContextId);
   let isConstructor = false;
   const token = state.tokens[state.tokens.length - 1];
+  // We allow "constructor" as either an identifier or a string.
   if (token.contextualKeyword === ContextualKeyword._constructor) {
     isConstructor = true;
   }
   parsePostMemberNameModifiers();
+
   if (isClassMethod()) {
     parseClassMethod(memberStart, isConstructor);
   } else if (isClassProperty()) {
     parseClassProperty();
   } else if (token.contextualKeyword === ContextualKeyword._async && !isLineTerminator()) {
     state.tokens[state.tokens.length - 1].type = TokenType._async;
+    // an async method
     const isGenerator = match(TokenType.star);
     if (isGenerator) {
       next();
     }
+
+    // The so-called parsed name would have been "async": get the real name.
     parseClassPropertyName(classContextId);
     parsePostMemberNameModifiers();
-    parseClassMethod(memberStart, false);
-  } else if ((token.contextualKeyword === ContextualKeyword._get || token.contextualKeyword === ContextualKeyword._set) && !(isLineTerminator() && match(TokenType.star))) {
+    parseClassMethod(memberStart, false /* isConstructor */);
+  } else if (
+    (token.contextualKeyword === ContextualKeyword._get ||
+      token.contextualKeyword === ContextualKeyword._set) &&
+    !(isLineTerminator() && match(TokenType.star))
+  ) {
     if (token.contextualKeyword === ContextualKeyword._get) {
       state.tokens[state.tokens.length - 1].type = TokenType._get;
     } else {
       state.tokens[state.tokens.length - 1].type = TokenType._set;
     }
+    // `get\n*` is an uninitialized property named 'get' followed by a generator.
+    // a getter or setter
+    // The so-called parsed name would have been "get/set": get the real name.
     parseClassPropertyName(classContextId);
-    parseClassMethod(memberStart, false);
+    parseClassMethod(memberStart, /* isConstructor */ false);
   } else if (isLineTerminator()) {
+    // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)
     parseClassProperty();
   } else {
     unexpected();
   }
 }
+
 function parseClassMethod(functionStart, isConstructor) {
   if (isTypeScriptEnabled) {
     tsTryParseTypeParameters();
@@ -31901,9 +24744,12 @@ function parseClassMethod(functionStart, isConstructor) {
   }
   parseMethod(functionStart, isConstructor);
 }
+
+// Return the name of the class property, if it is a simple identifier.
 function parseClassPropertyName(classContextId) {
   parsePropertyName(classContextId);
 }
+
 function parsePostMemberNameModifiers() {
   if (isTypeScriptEnabled) {
     const oldIsType = pushTypeContext(0);
@@ -31911,15 +24757,17 @@ function parsePostMemberNameModifiers() {
     popTypeContext(oldIsType);
   }
 }
+
 function parseClassProperty() {
   if (isTypeScriptEnabled) {
-    eat(TokenType.bang);
+    eatTypeToken(TokenType.bang);
     tsTryParseTypeAnnotation();
   } else if (isFlowEnabled) {
     if (match(TokenType.colon)) {
       flowParseTypeAnnotation();
     }
   }
+
   if (match(TokenType.eq)) {
     const equalsTokenIndex = state.tokens.length;
     next();
@@ -31928,13 +24776,20 @@ function parseClassProperty() {
   }
   semicolon();
 }
+
 function parseClassId(isStatement, optionalId = false) {
-  if (isTypeScriptEnabled && (!isStatement || optionalId) && isContextual(ContextualKeyword._implements)) {
+  if (
+    isTypeScriptEnabled &&
+    (!isStatement || optionalId) &&
+    isContextual(ContextualKeyword._implements)
+  ) {
     return;
   }
+
   if (match(TokenType.name)) {
     parseBindingIdentifier(true);
   }
+
   if (isTypeScriptEnabled) {
     tsTryParseTypeParameters();
   } else if (isFlowEnabled) {
@@ -31943,6 +24798,8 @@ function parseClassId(isStatement, optionalId = false) {
     }
   }
 }
+
+// Returns true if there was a superclass.
 function parseClassSuper() {
   let hasSuper = false;
   if (eat(TokenType._extends)) {
@@ -31957,6 +24814,9 @@ function parseClassSuper() {
     flowAfterParseClassSuper(hasSuper);
   }
 }
+
+// Parses module export declaration.
+
 function parseExport() {
   const exportIndex = state.tokens.length - 1;
   if (isTypeScriptEnabled) {
@@ -31964,9 +24824,11 @@ function parseExport() {
       return;
     }
   }
+  // export * from '...'
   if (shouldParseExportStar()) {
     parseExportStar();
   } else if (isExportDefaultSpecifier()) {
+    // export default from
     parseIdentifier();
     if (match(TokenType.comma) && lookaheadType() === TokenType.star) {
       expect(TokenType.comma);
@@ -31978,15 +24840,18 @@ function parseExport() {
     }
     parseExportFrom();
   } else if (eat(TokenType._default)) {
+    // export default ...
     parseExportDefaultExpression();
   } else if (shouldParseExportDeclaration()) {
     parseExportDeclaration();
   } else {
+    // export { x, y as z } [from '...']
     parseExportSpecifiers();
     parseExportFrom();
   }
   state.tokens[exportIndex].rhsEndIndex = state.tokens.length;
 }
+
 function parseExportDefaultExpression() {
   if (isTypeScriptEnabled) {
     if (tsTryParseExportDefaultExpression()) {
@@ -31997,6 +24862,7 @@ function parseExportDefaultExpression() {
   if (eat(TokenType._function)) {
     parseFunction(functionStart, true, true);
   } else if (isContextual(ContextualKeyword._async) && lookaheadType() === TokenType._function) {
+    // async function declaration
     eatContextual(ContextualKeyword._async);
     eat(TokenType._function);
     parseFunction(functionStart, true, true);
@@ -32010,6 +24876,7 @@ function parseExportDefaultExpression() {
     semicolon();
   }
 }
+
 function parseExportDeclaration() {
   if (isTypeScriptEnabled) {
     tsParseExportDeclaration();
@@ -32019,6 +24886,7 @@ function parseExportDeclaration() {
     parseStatement(true);
   }
 }
+
 function isExportDefaultSpecifier() {
   if (isTypeScriptEnabled && tsIsDeclarationStart()) {
     return false;
@@ -32028,32 +24896,39 @@ function isExportDefaultSpecifier() {
   if (match(TokenType.name)) {
     return state.contextualKeyword !== ContextualKeyword._async;
   }
+
   if (!match(TokenType._default)) {
     return false;
   }
+
   const _next = nextTokenStart();
   const lookahead = lookaheadTypeAndKeyword();
-  const hasFrom = lookahead.type === TokenType.name && lookahead.contextualKeyword === ContextualKeyword._from;
+  const hasFrom =
+    lookahead.type === TokenType.name && lookahead.contextualKeyword === ContextualKeyword._from;
   if (lookahead.type === TokenType.comma) {
     return true;
   }
+  // lookahead again when `export default from` is seen
   if (hasFrom) {
     const nextAfterFrom = input.charCodeAt(nextTokenStartSince(_next + 4));
     return nextAfterFrom === charCodes.quotationMark || nextAfterFrom === charCodes.apostrophe;
   }
   return false;
 }
+
 function parseExportSpecifiersMaybe() {
   if (eat(TokenType.comma)) {
     parseExportSpecifiers();
   }
 }
+
 function parseExportFrom() {
   if (eatContextual(ContextualKeyword._from)) {
     parseExprAtom();
   }
   semicolon();
 }
+
 function shouldParseExportStar() {
   if (isFlowEnabled) {
     return flowShouldParseExportStar();
@@ -32061,6 +24936,7 @@ function shouldParseExportStar() {
     return match(TokenType.star);
   }
 }
+
 function parseExportStar() {
   if (isFlowEnabled) {
     flowParseExportStar();
@@ -32068,14 +24944,17 @@ function parseExportStar() {
     baseParseExportStar();
   }
 }
+
 function baseParseExportStar() {
   expect(TokenType.star);
+
   if (isContextual(ContextualKeyword._as)) {
     parseExportNamespace();
   } else {
     parseExportFrom();
   }
 }
+
 function parseExportNamespace() {
   next();
   state.tokens[state.tokens.length - 1].type = TokenType._as;
@@ -32083,12 +24962,28 @@ function parseExportNamespace() {
   parseExportSpecifiersMaybe();
   parseExportFrom();
 }
+
 function shouldParseExportDeclaration() {
-  return isTypeScriptEnabled && tsIsDeclarationStart() || isFlowEnabled && flowShouldParseExportDeclaration() || state.type === TokenType._var || state.type === TokenType._const || state.type === TokenType._let || state.type === TokenType._function || state.type === TokenType._class || isContextual(ContextualKeyword._async) || match(TokenType.at);
+  return (
+    (isTypeScriptEnabled && tsIsDeclarationStart()) ||
+    (isFlowEnabled && flowShouldParseExportDeclaration()) ||
+    state.type === TokenType._var ||
+    state.type === TokenType._const ||
+    state.type === TokenType._let ||
+    state.type === TokenType._function ||
+    state.type === TokenType._class ||
+    isContextual(ContextualKeyword._async) ||
+    match(TokenType.at)
+  );
 }
+
+// Parses a comma-separated list of module exports.
 function parseExportSpecifiers() {
   let first = true;
+
+  // export { x, y as z } [from '...']
   expect(TokenType.braceL);
+
   while (!eat(TokenType.braceR) && !state.error) {
     if (first) {
       first = false;
@@ -32098,6 +24993,7 @@ function parseExportSpecifiers() {
         break;
       }
     }
+
     parseIdentifier();
     state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;
     if (eatContextual(ContextualKeyword._as)) {
@@ -32105,6 +25001,9 @@ function parseExportSpecifiers() {
     }
   }
 }
+
+// Parses import declaration.
+
 function parseImport() {
   if (isTypeScriptEnabled && match(TokenType.name) && lookaheadType() === TokenType.eq) {
     tsParseImportEqualsDeclaration();
@@ -32113,15 +25012,27 @@ function parseImport() {
   if (isTypeScriptEnabled && isContextual(ContextualKeyword._type)) {
     const lookahead = lookaheadType();
     if (lookahead === TokenType.name) {
+      // One of these `import type` cases:
+      // import type T = require('T');
+      // import type A from 'A';
       expectContextual(ContextualKeyword._type);
       if (lookaheadType() === TokenType.eq) {
         tsParseImportEqualsDeclaration();
         return;
       }
+      // If this is an `import type...from` statement, then we already ate the
+      // type token, so proceed to the regular import parser.
     } else if (lookahead === TokenType.star || lookahead === TokenType.braceL) {
+      // One of these `import type` cases, in which case we can eat the type token
+      // and proceed as normal:
+      // import type * as A from 'A';
+      // import type {a} from 'A';
       expectContextual(ContextualKeyword._type);
     }
+    // Otherwise, we are importing the name "type".
   }
+
+  // import '...'
   if (match(TokenType.string)) {
     parseExprAtom();
   } else {
@@ -32131,44 +25042,61 @@ function parseImport() {
   }
   semicolon();
 }
+
+// eslint-disable-next-line no-unused-vars
 function shouldParseDefaultImport() {
   return match(TokenType.name);
 }
+
 function parseImportSpecifierLocal() {
   parseImportedIdentifier();
 }
+
+// Parses a comma-separated list of module imports.
 function parseImportSpecifiers() {
   if (isFlowEnabled) {
     flowStartParseImportSpecifiers();
   }
+
   let first = true;
   if (shouldParseDefaultImport()) {
+    // import defaultObj, { x, y as z } from '...'
     parseImportSpecifierLocal();
-    if (!eat(TokenType.comma))
-      return;
+
+    if (!eat(TokenType.comma)) return;
   }
+
   if (match(TokenType.star)) {
     next();
     expectContextual(ContextualKeyword._as);
+
     parseImportSpecifierLocal();
+
     return;
   }
+
   expect(TokenType.braceL);
   while (!eat(TokenType.braceR) && !state.error) {
     if (first) {
       first = false;
     } else {
+      // Detect an attempt to deep destructure
       if (eat(TokenType.colon)) {
-        unexpected("ES2015 named imports do not destructure. Use another statement for destructuring after the import.");
+        unexpected(
+          "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
+        );
       }
+
       expect(TokenType.comma);
       if (eat(TokenType.braceR)) {
         break;
       }
     }
+
     parseImportSpecifier();
   }
 }
+
 function parseImportSpecifier() {
   if (isFlowEnabled) {
     flowParseImportSpecifier();
@@ -32181,30 +25109,56 @@ function parseImportSpecifier() {
     parseImportedIdentifier();
   }
 }
+
 function parseFile() {
-  if (state.pos === 0 && input.charCodeAt(0) === charCodes.numberSign && input.charCodeAt(1) === charCodes.exclamationMark) {
+  // If enabled, skip leading hashbang line.
+  if (
+    state.pos === 0 &&
+    input.charCodeAt(0) === charCodes.numberSign &&
+    input.charCodeAt(1) === charCodes.exclamationMark
+  ) {
     skipLineComment(2);
   }
   nextToken();
   return parseTopLevel();
 }
+
 class File$1 {
+  
+  
+
   constructor(tokens, scopes) {
     this.tokens = tokens;
     this.scopes = scopes;
   }
 }
-function parse(input2, isJSXEnabled2, isTypeScriptEnabled2, isFlowEnabled2) {
-  if (isFlowEnabled2 && isTypeScriptEnabled2) {
+
+function parse(
+  input,
+  isJSXEnabled,
+  isTypeScriptEnabled,
+  isFlowEnabled,
+) {
+  if (isFlowEnabled && isTypeScriptEnabled) {
     throw new Error("Cannot combine flow and typescript plugins.");
   }
-  initParser(input2, isJSXEnabled2, isTypeScriptEnabled2, isFlowEnabled2);
+  initParser(input, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled);
   const result = parseFile();
   if (state.error) {
     throw augmentError(state.error);
   }
   return result;
 }
+
+/**
+ * Determine whether this optional chain or nullish coalescing operation has any await statements in
+ * it. If so, we'll need to transpile to an async operation.
+ *
+ * We compute this by walking the length of the operation and returning true if we see an await
+ * keyword used as a real await (rather than an object key or property access). Nested optional
+ * chain/nullish operations need to be tracked but don't silence await, but a nested async function
+ * (or any other nested scope) will make the await not count.
+ */
 function isAsyncOperation(tokens) {
   let index = tokens.currentIndex();
   let depth = 0;
@@ -32219,104 +25173,162 @@ function isAsyncOperation(tokens) {
     }
     depth += token.numNullishCoalesceStarts;
     depth -= token.numNullishCoalesceEnds;
-    if (token.contextualKeyword === ContextualKeyword._await && token.identifierRole == null && token.scopeDepth === startToken.scopeDepth) {
+
+    if (
+      token.contextualKeyword === ContextualKeyword._await &&
+      token.identifierRole == null &&
+      token.scopeDepth === startToken.scopeDepth
+    ) {
       return true;
     }
     index += 1;
   } while (depth > 0 && index < tokens.tokens.length);
   return false;
 }
+
 class TokenProcessor {
-  __init() {
-    this.resultCode = "";
-  }
-  __init2() {
-    this.tokenIndex = 0;
-  }
-  constructor(code, tokens, isFlowEnabled2, disableESTransforms, helperManager) {
-    this.code = code;
-    this.tokens = tokens;
-    this.isFlowEnabled = isFlowEnabled2;
-    this.disableESTransforms = disableESTransforms;
-    this.helperManager = helperManager;
-    TokenProcessor.prototype.__init.call(this);
-    TokenProcessor.prototype.__init2.call(this);
-  }
+   __init() {this.resultCode = "";}
+   __init2() {this.tokenIndex = 0;}
+
+  constructor(
+     code,
+     tokens,
+     isFlowEnabled,
+     disableESTransforms,
+     helperManager,
+  ) {this.code = code;this.tokens = tokens;this.isFlowEnabled = isFlowEnabled;this.disableESTransforms = disableESTransforms;this.helperManager = helperManager;TokenProcessor.prototype.__init.call(this);TokenProcessor.prototype.__init2.call(this);}
+
+  /**
+   * Make a new TokenProcessor for things like lookahead.
+   */
   snapshot() {
-    return { resultCode: this.resultCode, tokenIndex: this.tokenIndex };
+    return {resultCode: this.resultCode, tokenIndex: this.tokenIndex};
   }
+
   restoreToSnapshot(snapshot) {
     this.resultCode = snapshot.resultCode;
     this.tokenIndex = snapshot.tokenIndex;
   }
+
   getResultCodeIndex() {
     return this.resultCode.length;
   }
+
   reset() {
     this.resultCode = "";
     this.tokenIndex = 0;
   }
+
   matchesContextualAtIndex(index, contextualKeyword) {
-    return this.matches1AtIndex(index, TokenType.name) && this.tokens[index].contextualKeyword === contextualKeyword;
+    return (
+      this.matches1AtIndex(index, TokenType.name) &&
+      this.tokens[index].contextualKeyword === contextualKeyword
+    );
   }
+
   identifierNameAtIndex(index) {
+    // TODO: We need to process escapes since technically you can have unicode escapes in variable
+    // names.
     return this.identifierNameForToken(this.tokens[index]);
   }
+
   identifierName() {
     return this.identifierNameForToken(this.currentToken());
   }
+
   identifierNameForToken(token) {
     return this.code.slice(token.start, token.end);
   }
+
   rawCodeForToken(token) {
     return this.code.slice(token.start, token.end);
   }
+
   stringValueAtIndex(index) {
     return this.stringValueForToken(this.tokens[index]);
   }
+
   stringValue() {
     return this.stringValueForToken(this.currentToken());
   }
+
   stringValueForToken(token) {
+    // This is used to identify when two imports are the same and to resolve TypeScript enum keys.
+    // Ideally we'd process escapes within the strings, but for now we pretty much take the raw
+    // code.
     return this.code.slice(token.start + 1, token.end - 1);
   }
+
   matches1AtIndex(index, t1) {
     return this.tokens[index].type === t1;
   }
+
   matches2AtIndex(index, t1, t2) {
     return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2;
   }
+
   matches3AtIndex(index, t1, t2, t3) {
-    return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2 && this.tokens[index + 2].type === t3;
+    return (
+      this.tokens[index].type === t1 &&
+      this.tokens[index + 1].type === t2 &&
+      this.tokens[index + 2].type === t3
+    );
   }
+
   matches1(t1) {
     return this.tokens[this.tokenIndex].type === t1;
   }
+
   matches2(t1, t2) {
     return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2;
   }
+
   matches3(t1, t2, t3) {
-    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3;
+    return (
+      this.tokens[this.tokenIndex].type === t1 &&
+      this.tokens[this.tokenIndex + 1].type === t2 &&
+      this.tokens[this.tokenIndex + 2].type === t3
+    );
   }
+
   matches4(t1, t2, t3, t4) {
-    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3 && this.tokens[this.tokenIndex + 3].type === t4;
+    return (
+      this.tokens[this.tokenIndex].type === t1 &&
+      this.tokens[this.tokenIndex + 1].type === t2 &&
+      this.tokens[this.tokenIndex + 2].type === t3 &&
+      this.tokens[this.tokenIndex + 3].type === t4
+    );
   }
+
   matches5(t1, t2, t3, t4, t5) {
-    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3 && this.tokens[this.tokenIndex + 3].type === t4 && this.tokens[this.tokenIndex + 4].type === t5;
+    return (
+      this.tokens[this.tokenIndex].type === t1 &&
+      this.tokens[this.tokenIndex + 1].type === t2 &&
+      this.tokens[this.tokenIndex + 2].type === t3 &&
+      this.tokens[this.tokenIndex + 3].type === t4 &&
+      this.tokens[this.tokenIndex + 4].type === t5
+    );
   }
+
   matchesContextual(contextualKeyword) {
     return this.matchesContextualAtIndex(this.tokenIndex, contextualKeyword);
   }
+
   matchesContextIdAndLabel(type, contextId) {
     return this.matches1(type) && this.currentToken().contextId === contextId;
   }
+
   previousWhitespaceAndComments() {
-    let whitespaceAndComments = this.code.slice(this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0, this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length);
+    let whitespaceAndComments = this.code.slice(
+      this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0,
+      this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length,
+    );
     if (this.isFlowEnabled) {
       whitespaceAndComments = whitespaceAndComments.replace(/@flow/g, "");
     }
     return whitespaceAndComments;
   }
+
   replaceToken(newCode) {
     this.resultCode += this.previousWhitespaceAndComments();
     this.appendTokenPrefix();
@@ -32324,6 +25336,7 @@ class TokenProcessor {
     this.appendTokenSuffix();
     this.tokenIndex++;
   }
+
   replaceTokenTrimmingLeftWhitespace(newCode) {
     this.resultCode += this.previousWhitespaceAndComments().replace(/[^\r\n]/g, "");
     this.appendTokenPrefix();
@@ -32331,34 +25344,46 @@ class TokenProcessor {
     this.appendTokenSuffix();
     this.tokenIndex++;
   }
+
   removeInitialToken() {
     this.replaceToken("");
   }
+
   removeToken() {
     this.replaceTokenTrimmingLeftWhitespace("");
   }
+
   copyExpectedToken(tokenType) {
     if (this.tokens[this.tokenIndex].type !== tokenType) {
       throw new Error(`Expected token ${tokenType}`);
     }
     this.copyToken();
   }
+
   copyToken() {
     this.resultCode += this.previousWhitespaceAndComments();
     this.appendTokenPrefix();
-    this.resultCode += this.code.slice(this.tokens[this.tokenIndex].start, this.tokens[this.tokenIndex].end);
+    this.resultCode += this.code.slice(
+      this.tokens[this.tokenIndex].start,
+      this.tokens[this.tokenIndex].end,
+    );
     this.appendTokenSuffix();
     this.tokenIndex++;
   }
+
   copyTokenWithPrefix(prefix) {
     this.resultCode += this.previousWhitespaceAndComments();
     this.appendTokenPrefix();
     this.resultCode += prefix;
-    this.resultCode += this.code.slice(this.tokens[this.tokenIndex].start, this.tokens[this.tokenIndex].end);
+    this.resultCode += this.code.slice(
+      this.tokens[this.tokenIndex].start,
+      this.tokens[this.tokenIndex].end,
+    );
     this.appendTokenSuffix();
     this.tokenIndex++;
   }
-  appendTokenPrefix() {
+
+   appendTokenPrefix() {
     const token = this.currentToken();
     if (token.numNullishCoalesceStarts || token.isOptionalChainStart) {
       token.isAsyncOperation = isAsyncOperation(this);
@@ -32395,7 +25420,8 @@ class TokenProcessor {
       this.resultCode += "([";
     }
   }
-  appendTokenSuffix() {
+
+   appendTokenSuffix() {
     const token = this.currentToken();
     if (token.isOptionalChainEnd && !this.disableESTransforms) {
       this.resultCode += "])";
@@ -32406,31 +25432,43 @@ class TokenProcessor {
       }
     }
   }
+
   appendCode(code) {
     this.resultCode += code;
   }
+
   currentToken() {
     return this.tokens[this.tokenIndex];
   }
+
   currentTokenCode() {
     const token = this.currentToken();
     return this.code.slice(token.start, token.end);
   }
+
   tokenAtRelativeIndex(relativeIndex) {
     return this.tokens[this.tokenIndex + relativeIndex];
   }
+
   currentIndex() {
     return this.tokenIndex;
   }
+
+  /**
+   * Move to the next token. Only suitable in preprocessing steps. When
+   * generating new code, you should use copyToken or removeToken.
+   */
   nextToken() {
     if (this.tokenIndex === this.tokens.length) {
       throw new Error("Unexpectedly reached end of input.");
     }
     this.tokenIndex++;
   }
+
   previousToken() {
     this.tokenIndex--;
   }
+
   finish() {
     if (this.tokenIndex !== this.tokens.length) {
       throw new Error("Tried to finish processing tokens before reaching the end.");
@@ -32438,35 +25476,51 @@ class TokenProcessor {
     this.resultCode += this.previousWhitespaceAndComments();
     return this.resultCode;
   }
+
   isAtEnd() {
     return this.tokenIndex === this.tokens.length;
   }
 }
-function getClassInfo(rootTransformer, tokens, nameManager, disableESTransforms) {
+
+/**
+ * Get information about the class fields for this class, given a token processor pointing to the
+ * open-brace at the start of the class.
+ */
+function getClassInfo(
+  rootTransformer,
+  tokens,
+  nameManager,
+  disableESTransforms,
+) {
   const snapshot = tokens.snapshot();
+
   const headerInfo = processClassHeader(tokens);
+
   let constructorInitializerStatements = [];
   const instanceInitializerNames = [];
   const staticInitializerNames = [];
   let constructorInsertPos = null;
   const fields = [];
   const rangesToRemove = [];
+
   const classContextId = tokens.currentToken().contextId;
   if (classContextId == null) {
     throw new Error("Expected non-null class context ID on class open-brace.");
   }
+
   tokens.nextToken();
   while (!tokens.matchesContextIdAndLabel(TokenType.braceR, classContextId)) {
     if (tokens.matchesContextual(ContextualKeyword._constructor) && !tokens.currentToken().isType) {
-      ({ constructorInitializerStatements, constructorInsertPos } = processConstructor(tokens));
+      ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));
     } else if (tokens.matches1(TokenType.semi)) {
       if (!disableESTransforms) {
-        rangesToRemove.push({ start: tokens.currentIndex(), end: tokens.currentIndex() + 1 });
+        rangesToRemove.push({start: tokens.currentIndex(), end: tokens.currentIndex() + 1});
       }
       tokens.nextToken();
     } else if (tokens.currentToken().isType) {
       tokens.nextToken();
     } else {
+      // Either a method or a field. Skip to the identifier part.
       const statementStartIndex = tokens.currentIndex();
       let isStatic = false;
       let isESPrivate = false;
@@ -32484,28 +25538,37 @@ function getClassInfo(rootTransformer, tokens, nameManager, disableESTransforms)
         tokens.nextToken();
       }
       if (isStatic && tokens.matches1(TokenType.braceL)) {
+        // This is a static block, so don't process it in any special way.
         skipToNextClassElement(tokens, classContextId);
         continue;
       }
       if (isESPrivate) {
+        // Sucrase doesn't attempt to transpile private fields; just leave them as-is.
         skipToNextClassElement(tokens, classContextId);
         continue;
       }
-      if (tokens.matchesContextual(ContextualKeyword._constructor) && !tokens.currentToken().isType) {
-        ({ constructorInitializerStatements, constructorInsertPos } = processConstructor(tokens));
+      if (
+        tokens.matchesContextual(ContextualKeyword._constructor) &&
+        !tokens.currentToken().isType
+      ) {
+        ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));
         continue;
       }
+
       const nameStartIndex = tokens.currentIndex();
       skipFieldName(tokens);
       if (tokens.matches1(TokenType.lessThan) || tokens.matches1(TokenType.parenL)) {
+        // This is a method, so nothing to process.
         skipToNextClassElement(tokens, classContextId);
         continue;
       }
+      // There might be a type annotation that we need to skip.
       while (tokens.currentToken().isType) {
         tokens.nextToken();
       }
       if (tokens.matches1(TokenType.eq)) {
         const equalsIndex = tokens.currentIndex();
+        // This is an initializer, so we need to wrap in an initializer method.
         const valueEnd = tokens.currentToken().rhsEndIndex;
         if (valueEnd == null) {
           throw new Error("Expected rhsEndIndex on class field assignment.");
@@ -32522,19 +25585,34 @@ function getClassInfo(rootTransformer, tokens, nameManager, disableESTransforms)
           initializerName = nameManager.claimFreeName("__init");
           instanceInitializerNames.push(initializerName);
         }
+        // Fields start at the name, so `static x = 1;` has a field range of `x = 1;`.
         fields.push({
           initializerName,
           equalsIndex,
           start: nameStartIndex,
-          end: tokens.currentIndex()
+          end: tokens.currentIndex(),
         });
       } else if (!disableESTransforms || isDeclare) {
-        rangesToRemove.push({ start: statementStartIndex, end: tokens.currentIndex() });
+        // This is a regular field declaration, like `x;`. With the class transform enabled, we just
+        // remove the line so that no output is produced. With the class transform disabled, we
+        // usually want to preserve the declaration (but still strip types), but if the `declare`
+        // keyword is specified, we should remove the line to avoid initializing the value to
+        // undefined.
+        rangesToRemove.push({start: statementStartIndex, end: tokens.currentIndex()});
       }
     }
   }
+
   tokens.restoreToSnapshot(snapshot);
   if (disableESTransforms) {
+    // With ES transforms disabled, we don't want to transform regular class
+    // field declarations, and we don't need to do any additional tricks to
+    // reference the constructor for static init, but we still need to transform
+    // TypeScript field initializers defined as constructor parameters and we
+    // still need to remove `declare` fields. For now, we run the same code
+    // path but omit any field information, as if the class had no field
+    // declarations. In the future, when we fully drop the class fields
+    // transform, we can simplify this code significantly.
     return {
       headerInfo,
       constructorInitializerStatements,
@@ -32542,7 +25620,7 @@ function getClassInfo(rootTransformer, tokens, nameManager, disableESTransforms)
       staticInitializerNames: [],
       constructorInsertPos,
       fields: [],
-      rangesToRemove
+      rangesToRemove,
     };
   } else {
     return {
@@ -32552,10 +25630,18 @@ function getClassInfo(rootTransformer, tokens, nameManager, disableESTransforms)
       staticInitializerNames,
       constructorInsertPos,
       fields,
-      rangesToRemove
+      rangesToRemove,
     };
   }
 }
+
+/**
+ * Move the token processor to the next method/field in the class.
+ *
+ * To do that, we seek forward to the next start of a class name (either an open
+ * bracket or an identifier, or the closing curly brace), then seek backward to
+ * include any access modifiers.
+ */
 function skipToNextClassElement(tokens, classContextId) {
   tokens.nextToken();
   while (tokens.currentToken().contextId !== classContextId) {
@@ -32565,6 +25651,7 @@ function skipToNextClassElement(tokens, classContextId) {
     tokens.previousToken();
   }
 }
+
 function processClassHeader(tokens) {
   const classToken = tokens.currentToken();
   const contextId = classToken.contextId;
@@ -32582,22 +25669,37 @@ function processClassHeader(tokens) {
     className = tokens.identifierName();
   }
   while (!tokens.matchesContextIdAndLabel(TokenType.braceL, contextId)) {
+    // If this has a superclass, there will always be an `extends` token. If it doesn't have a
+    // superclass, only type parameters and `implements` clauses can show up here, all of which
+    // consist only of type tokens. A declaration like `class A<B extends C> {` should *not* count
+    // as having a superclass.
     if (tokens.matches1(TokenType._extends) && !tokens.currentToken().isType) {
       hasSuperclass = true;
     }
     tokens.nextToken();
   }
-  return { isExpression, className, hasSuperclass };
+  return {isExpression, className, hasSuperclass};
 }
-function processConstructor(tokens) {
+
+/**
+ * Extract useful information out of a constructor, starting at the "constructor" name.
+ */
+function processConstructor(tokens)
+
+
+ {
   const constructorInitializerStatements = [];
+
   tokens.nextToken();
   const constructorContextId = tokens.currentToken().contextId;
   if (constructorContextId == null) {
     throw new Error("Expected context ID on open-paren starting constructor params.");
   }
+  // Advance through parameters looking for access modifiers.
   while (!tokens.matchesContextIdAndLabel(TokenType.parenR, constructorContextId)) {
     if (tokens.currentToken().contextId === constructorContextId) {
+      // Current token is an open paren or comma just before a param, so check
+      // that param for access modifiers.
       tokens.nextToken();
       if (isAccessModifier(tokens.currentToken())) {
         tokens.nextToken();
@@ -32615,8 +25717,11 @@ function processConstructor(tokens) {
       tokens.nextToken();
     }
   }
+  // )
   tokens.nextToken();
   let constructorInsertPos = tokens.currentIndex();
+
+  // Advance through body looking for a super call.
   let foundSuperCall = false;
   while (!tokens.matchesContextIdAndLabel(TokenType.braceR, constructorContextId)) {
     if (!foundSuperCall && tokens.matches2(TokenType._super, TokenType.parenL)) {
@@ -32633,9 +25738,15 @@ function processConstructor(tokens) {
     }
     tokens.nextToken();
   }
+  // }
   tokens.nextToken();
-  return { constructorInitializerStatements, constructorInsertPos };
+
+  return {constructorInitializerStatements, constructorInsertPos};
 }
+
+/**
+ * Determine if this is any token that can go before the name in a method/field.
+ */
 function isAccessModifier(token) {
   return [
     TokenType._async,
@@ -32652,9 +25763,14 @@ function isAccessModifier(token) {
     TokenType._abstract,
     TokenType.star,
     TokenType._declare,
-    TokenType.hash
+    TokenType.hash,
   ].includes(token.type);
 }
+
+/**
+ * The next token or set of tokens is either an identifier or an expression in square brackets, for
+ * a method or field name.
+ */
 function skipFieldName(tokens) {
   if (tokens.matches1(TokenType.bracketL)) {
     const startToken = tokens.currentToken();
@@ -32670,26 +25786,50 @@ function skipFieldName(tokens) {
     tokens.nextToken();
   }
 }
+
 function elideImportEquals(tokens) {
+  // import
   tokens.removeInitialToken();
+  // name
   tokens.removeToken();
+  // =
   tokens.removeToken();
+  // name or require
   tokens.removeToken();
+  // Handle either `import A = require('A')` or `import A = B.C.D`.
   if (tokens.matches1(TokenType.parenL)) {
+    // (
     tokens.removeToken();
+    // path string
     tokens.removeToken();
+    // )
     tokens.removeToken();
   } else {
     while (tokens.matches1(TokenType.dot)) {
+      // .
       tokens.removeToken();
+      // name
       tokens.removeToken();
     }
   }
 }
+
 const EMPTY_DECLARATION_INFO = {
   typeDeclarations: new Set(),
-  valueDeclarations: new Set()
+  valueDeclarations: new Set(),
 };
+
+/**
+ * Get all top-level identifiers that should be preserved when exported in TypeScript.
+ *
+ * Examples:
+ * - If an identifier is declared as `const x`, then `export {x}` should be preserved.
+ * - If it's declared as `type x`, then `export {x}` should be removed.
+ * - If it's declared as both `const x` and `type x`, then the export should be preserved.
+ * - Classes and enums should be preserved (even though they also introduce types).
+ * - Imported identifiers should be preserved since we don't have enough information to
+ *   rule them out. --isolatedModules disallows re-exports, which catches errors here.
+ */
 function getDeclarationInfo(tokens) {
   const typeDeclarations = new Set();
   const valueDeclarations = new Set();
@@ -32703,9 +25843,17 @@ function getDeclarationInfo(tokens) {
       }
     }
   }
-  return { typeDeclarations, valueDeclarations };
+  return {typeDeclarations, valueDeclarations};
 }
-function shouldElideDefaultExport(isTypeScriptTransformEnabled, tokens, declarationInfo) {
+
+/**
+ * Common method sharing code between CJS and ESM cases, since they're the same here.
+ */
+function shouldElideDefaultExport(
+  isTypeScriptTransformEnabled,
+  tokens,
+  declarationInfo,
+) {
   if (!isTypeScriptTransformEnabled) {
     return false;
   }
@@ -32713,8 +25861,12 @@ function shouldElideDefaultExport(isTypeScriptTransformEnabled, tokens, declarat
   if (exportToken.rhsEndIndex == null) {
     throw new Error("Expected non-null rhsEndIndex on export token.");
   }
+  // The export must be of the form `export default a` or `export default a;`.
   const numTokens = exportToken.rhsEndIndex - tokens.currentIndex();
-  if (numTokens !== 3 && !(numTokens === 4 && tokens.matches1AtIndex(exportToken.rhsEndIndex - 1, TokenType.semi))) {
+  if (
+    numTokens !== 3 &&
+    !(numTokens === 4 && tokens.matches1AtIndex(exportToken.rhsEndIndex - 1, TokenType.semi))
+  ) {
     return false;
   }
   const identifierToken = tokens.tokenAtRelativeIndex(2);
@@ -32722,32 +25874,35 @@ function shouldElideDefaultExport(isTypeScriptTransformEnabled, tokens, declarat
     return false;
   }
   const exportedName = tokens.identifierNameForToken(identifierToken);
-  return declarationInfo.typeDeclarations.has(exportedName) && !declarationInfo.valueDeclarations.has(exportedName);
+  return (
+    declarationInfo.typeDeclarations.has(exportedName) &&
+    !declarationInfo.valueDeclarations.has(exportedName)
+  );
 }
+
+/**
+ * Class for editing import statements when we are transforming to commonjs.
+ */
 class CJSImportTransformer extends Transformer {
-  __init() {
-    this.hadExport = false;
-  }
-  __init2() {
-    this.hadNamedExport = false;
-  }
-  __init3() {
-    this.hadDefaultExport = false;
-  }
-  constructor(rootTransformer, tokens, importProcessor, nameManager, reactHotLoaderTransformer, enableLegacyBabel5ModuleInterop, isTypeScriptTransformEnabled) {
-    super();
-    this.rootTransformer = rootTransformer;
-    this.tokens = tokens;
-    this.importProcessor = importProcessor;
-    this.nameManager = nameManager;
-    this.reactHotLoaderTransformer = reactHotLoaderTransformer;
-    this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;
-    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
-    CJSImportTransformer.prototype.__init.call(this);
-    CJSImportTransformer.prototype.__init2.call(this);
-    CJSImportTransformer.prototype.__init3.call(this);
-    this.declarationInfo = isTypeScriptTransformEnabled ? getDeclarationInfo(tokens) : EMPTY_DECLARATION_INFO;
+   __init() {this.hadExport = false;}
+   __init2() {this.hadNamedExport = false;}
+   __init3() {this.hadDefaultExport = false;}
+  
+
+  constructor(
+     rootTransformer,
+     tokens,
+     importProcessor,
+     nameManager,
+     reactHotLoaderTransformer,
+     enableLegacyBabel5ModuleInterop,
+     isTypeScriptTransformEnabled,
+  ) {
+    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;CJSImportTransformer.prototype.__init.call(this);CJSImportTransformer.prototype.__init2.call(this);CJSImportTransformer.prototype.__init3.call(this);    this.declarationInfo = isTypeScriptTransformEnabled
+      ? getDeclarationInfo(tokens)
+      : EMPTY_DECLARATION_INFO;
   }
+
   getPrefixCode() {
     let prefix = "";
     if (this.hadExport) {
@@ -32755,13 +25910,16 @@ class CJSImportTransformer extends Transformer {
     }
     return prefix;
   }
+
   getSuffixCode() {
     if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {
       return "\nmodule.exports = exports.default;\n";
     }
     return "";
   }
+
   process() {
+    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
     if (this.tokens.matches3(TokenType._import, TokenType.name, TokenType.eq)) {
       return this.processImportEquals();
     }
@@ -32778,6 +25936,7 @@ class CJSImportTransformer extends Transformer {
       return this.processExport();
     }
     if (this.tokens.matches2(TokenType.name, TokenType.postIncDec)) {
+      // Fall through to normal identifier matching if this doesn't apply.
       if (this.processPostIncDec()) {
         return true;
       }
@@ -32796,16 +25955,29 @@ class CJSImportTransformer extends Transformer {
     }
     return false;
   }
-  processImportEquals() {
+
+   processImportEquals() {
     const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
     if (this.importProcessor.isTypeName(importName)) {
+      // If this name is only used as a type, elide the whole import.
       elideImportEquals(this.tokens);
     } else {
+      // Otherwise, switch `import` to `const`.
       this.tokens.replaceToken("const");
     }
     return true;
   }
-  processImport() {
+
+  /**
+   * Transform this:
+   * import foo, {bar} from 'baz';
+   * into
+   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);
+   *
+   * The import code was already generated in the import preprocessing step, so
+   * we just need to look it up.
+   */
+   processImport() {
     if (this.tokens.matches2(TokenType._import, TokenType.parenL)) {
       this.tokens.replaceToken("Promise.resolve().then(() => require");
       const contextId = this.tokens.currentToken().contextId;
@@ -32819,7 +25991,9 @@ class CJSImportTransformer extends Transformer {
       this.tokens.replaceToken("))");
       return;
     }
+
     const wasOnlyTypes = this.removeImportAndDetectIfType();
+
     if (wasOnlyTypes) {
       this.tokens.removeToken();
     } else {
@@ -32831,24 +26005,49 @@ class CJSImportTransformer extends Transformer {
       this.tokens.removeToken();
     }
   }
-  removeImportAndDetectIfType() {
+
+  /**
+   * Erase this import, and return true if it was either of the form "import type" or contained only
+   * "type" named imports. Such imports should not even do a side-effect import.
+   *
+   * The position should end at the import string.
+   */
+   removeImportAndDetectIfType() {
     this.tokens.removeInitialToken();
-    if (this.tokens.matchesContextual(ContextualKeyword._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)) {
+    if (
+      this.tokens.matchesContextual(ContextualKeyword._type) &&
+      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.comma) &&
+      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)
+    ) {
+      // This is an "import type" statement, so exit early.
       this.removeRemainingImport();
       return true;
     }
+
     if (this.tokens.matches1(TokenType.name) || this.tokens.matches1(TokenType.star)) {
+      // We have a default import or namespace import, so there must be some
+      // non-type import.
       this.removeRemainingImport();
       return false;
     }
+
     if (this.tokens.matches1(TokenType.string)) {
+      // This is a bare import, so we should proceed with the import.
       return false;
     }
+
     let foundNonType = false;
     while (!this.tokens.matches1(TokenType.string)) {
-      if (!foundNonType && this.tokens.matches1(TokenType.braceL) || this.tokens.matches1(TokenType.comma)) {
+      // Check if any named imports are of the form "foo" or "foo as bar", with
+      // no leading "type".
+      if ((!foundNonType && this.tokens.matches1(TokenType.braceL)) || this.tokens.matches1(TokenType.comma)) {
         this.tokens.removeToken();
-        if (this.tokens.matches2(TokenType.name, TokenType.comma) || this.tokens.matches2(TokenType.name, TokenType.braceR) || this.tokens.matches4(TokenType.name, TokenType.name, TokenType.name, TokenType.comma) || this.tokens.matches4(TokenType.name, TokenType.name, TokenType.name, TokenType.braceR)) {
+        if (
+          this.tokens.matches2(TokenType.name, TokenType.comma) ||
+          this.tokens.matches2(TokenType.name, TokenType.braceR) ||
+          this.tokens.matches4(TokenType.name, TokenType.name, TokenType.name, TokenType.comma) ||
+          this.tokens.matches4(TokenType.name, TokenType.name, TokenType.name, TokenType.braceR)
+        ) {
           foundNonType = true;
         }
       }
@@ -32856,37 +26055,58 @@ class CJSImportTransformer extends Transformer {
     }
     return !foundNonType;
   }
-  removeRemainingImport() {
+
+   removeRemainingImport() {
     while (!this.tokens.matches1(TokenType.string)) {
       this.tokens.removeToken();
     }
   }
-  processIdentifier() {
+
+   processIdentifier() {
     const token = this.tokens.currentToken();
     if (token.shadowsGlobal) {
       return false;
     }
+
     if (token.identifierRole === IdentifierRole.ObjectShorthand) {
       return this.processObjectShorthand();
     }
+
     if (token.identifierRole !== IdentifierRole.Access) {
       return false;
     }
-    const replacement = this.importProcessor.getIdentifierReplacement(this.tokens.identifierNameForToken(token));
+    const replacement = this.importProcessor.getIdentifierReplacement(
+      this.tokens.identifierNameForToken(token),
+    );
     if (!replacement) {
       return false;
     }
+    // Tolerate any number of closing parens while looking for an opening paren
+    // that indicates a function call.
     let possibleOpenParenIndex = this.tokens.currentIndex() + 1;
-    while (possibleOpenParenIndex < this.tokens.tokens.length && this.tokens.tokens[possibleOpenParenIndex].type === TokenType.parenR) {
+    while (
+      possibleOpenParenIndex < this.tokens.tokens.length &&
+      this.tokens.tokens[possibleOpenParenIndex].type === TokenType.parenR
+    ) {
       possibleOpenParenIndex++;
     }
+    // Avoid treating imported functions as methods of their `exports` object
+    // by using `(0, f)` when the identifier is in a paren expression. Else
+    // use `Function.prototype.call` when the identifier is a guaranteed
+    // function call. When using `call`, pass undefined as the context.
     if (this.tokens.tokens[possibleOpenParenIndex].type === TokenType.parenL) {
-      if (this.tokens.tokenAtRelativeIndex(1).type === TokenType.parenL && this.tokens.tokenAtRelativeIndex(-1).type !== TokenType._new) {
+      if (
+        this.tokens.tokenAtRelativeIndex(1).type === TokenType.parenL &&
+        this.tokens.tokenAtRelativeIndex(-1).type !== TokenType._new
+      ) {
         this.tokens.replaceToken(`${replacement}.call(void 0, `);
+        // Remove the old paren.
         this.tokens.removeToken();
+        // Balance out the new paren.
         this.rootTransformer.processBalancedCode();
         this.tokens.copyExpectedToken(TokenType.parenR);
       } else {
+        // See here: http://2ality.com/2015/12/references.html
         this.tokens.replaceToken(`(0, ${replacement})`);
       }
     } else {
@@ -32894,6 +26114,7 @@ class CJSImportTransformer extends Transformer {
     }
     return true;
   }
+
   processObjectShorthand() {
     const identifier = this.tokens.identifierName();
     const replacement = this.importProcessor.getIdentifierReplacement(identifier);
@@ -32903,8 +26124,13 @@ class CJSImportTransformer extends Transformer {
     this.tokens.replaceToken(`${identifier}: ${replacement}`);
     return true;
   }
+
   processExport() {
-    if (this.tokens.matches2(TokenType._export, TokenType._enum) || this.tokens.matches3(TokenType._export, TokenType._const, TokenType._enum)) {
+    if (
+      this.tokens.matches2(TokenType._export, TokenType._enum) ||
+      this.tokens.matches3(TokenType._export, TokenType._const, TokenType._enum)
+    ) {
+      // Let the TypeScript transform handle it.
       return false;
     }
     if (this.tokens.matches2(TokenType._export, TokenType._default)) {
@@ -32913,13 +26139,24 @@ class CJSImportTransformer extends Transformer {
       return true;
     }
     this.hadNamedExport = true;
-    if (this.tokens.matches2(TokenType._export, TokenType._var) || this.tokens.matches2(TokenType._export, TokenType._let) || this.tokens.matches2(TokenType._export, TokenType._const)) {
+    if (
+      this.tokens.matches2(TokenType._export, TokenType._var) ||
+      this.tokens.matches2(TokenType._export, TokenType._let) ||
+      this.tokens.matches2(TokenType._export, TokenType._const)
+    ) {
       this.processExportVar();
       return true;
-    } else if (this.tokens.matches2(TokenType._export, TokenType._function) || this.tokens.matches3(TokenType._export, TokenType.name, TokenType._function)) {
+    } else if (
+      this.tokens.matches2(TokenType._export, TokenType._function) ||
+      // export async function
+      this.tokens.matches3(TokenType._export, TokenType.name, TokenType._function)
+    ) {
       this.processExportFunction();
       return true;
-    } else if (this.tokens.matches2(TokenType._export, TokenType._class) || this.tokens.matches3(TokenType._export, TokenType._abstract, TokenType._class)) {
+    } else if (
+      this.tokens.matches2(TokenType._export, TokenType._class) ||
+      this.tokens.matches3(TokenType._export, TokenType._abstract, TokenType._class)
+    ) {
       this.processExportClass();
       return true;
     } else if (this.tokens.matches2(TokenType._export, TokenType.braceL)) {
@@ -32928,13 +26165,22 @@ class CJSImportTransformer extends Transformer {
     } else if (this.tokens.matches2(TokenType._export, TokenType.star)) {
       this.processExportStar();
       return true;
-    } else if (this.tokens.matches3(TokenType._export, TokenType.name, TokenType.braceL) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)) {
+    } else if (
+      this.tokens.matches3(TokenType._export, TokenType.name, TokenType.braceL) &&
+      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
+    ) {
+      // TS `export type {` case: just remove the export entirely.
       this.tokens.removeInitialToken();
       while (!this.tokens.matches1(TokenType.braceR)) {
         this.tokens.removeToken();
       }
       this.tokens.removeToken();
-      if (this.tokens.matchesContextual(ContextualKeyword._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.string)) {
+
+      // Remove type re-export `... } from './T'`
+      if (
+        this.tokens.matchesContextual(ContextualKeyword._from) &&
+        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.string)
+      ) {
         this.tokens.removeToken();
         this.tokens.removeToken();
       }
@@ -32943,9 +26189,12 @@ class CJSImportTransformer extends Transformer {
       throw new Error("Unrecognized export syntax.");
     }
   }
-  processAssignment() {
+
+   processAssignment() {
     const index = this.tokens.currentIndex();
     const identifierToken = this.tokens.tokens[index - 1];
+    // If the LHS is a type identifier, this must be a declaration like `let a: b = c;`,
+    // with `b` as the identifier, so nothing needs to be done in that case.
     if (identifierToken.isType || identifierToken.type !== TokenType.name) {
       return false;
     }
@@ -32956,9 +26205,14 @@ class CJSImportTransformer extends Transformer {
       return false;
     }
     if (index >= 2 && [TokenType._var, TokenType._let, TokenType._const].includes(this.tokens.tokens[index - 2].type)) {
+      // Declarations don't need an extra assignment. This doesn't avoid the
+      // assignment for comma-separated declarations, but it's still correct
+      // since the assignment is just redundant.
       return false;
     }
-    const assignmentSnippet = this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(identifierToken));
+    const assignmentSnippet = this.importProcessor.resolveExportBinding(
+      this.tokens.identifierNameForToken(identifierToken),
+    );
     if (!assignmentSnippet) {
       return false;
     }
@@ -32966,7 +26220,11 @@ class CJSImportTransformer extends Transformer {
     this.tokens.appendCode(` ${assignmentSnippet} =`);
     return true;
   }
-  processComplexAssignment() {
+
+  /**
+   * Process something like `a += 3`, where `a` might be an exported value.
+   */
+   processComplexAssignment() {
     const index = this.tokens.currentIndex();
     const identifierToken = this.tokens.tokens[index - 1];
     if (identifierToken.type !== TokenType.name) {
@@ -32978,7 +26236,9 @@ class CJSImportTransformer extends Transformer {
     if (index >= 2 && this.tokens.matches1AtIndex(index - 2, TokenType.dot)) {
       return false;
     }
-    const assignmentSnippet = this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(identifierToken));
+    const assignmentSnippet = this.importProcessor.resolveExportBinding(
+      this.tokens.identifierNameForToken(identifierToken),
+    );
     if (!assignmentSnippet) {
       return false;
     }
@@ -32986,7 +26246,11 @@ class CJSImportTransformer extends Transformer {
     this.tokens.copyToken();
     return true;
   }
-  processPreIncDec() {
+
+  /**
+   * Process something like `++a`, where `a` might be an exported value.
+   */
+   processPreIncDec() {
     const index = this.tokens.currentIndex();
     const identifierToken = this.tokens.tokens[index + 1];
     if (identifierToken.type !== TokenType.name) {
@@ -32995,7 +26259,13 @@ class CJSImportTransformer extends Transformer {
     if (identifierToken.shadowsGlobal) {
       return false;
     }
-    if (index + 2 < this.tokens.tokens.length && (this.tokens.matches1AtIndex(index + 2, TokenType.dot) || this.tokens.matches1AtIndex(index + 2, TokenType.bracketL) || this.tokens.matches1AtIndex(index + 2, TokenType.parenL))) {
+    // Ignore things like ++a.b and ++a[b] and ++a().b.
+    if (
+      index + 2 < this.tokens.tokens.length &&
+      (this.tokens.matches1AtIndex(index + 2, TokenType.dot) ||
+        this.tokens.matches1AtIndex(index + 2, TokenType.bracketL) ||
+        this.tokens.matches1AtIndex(index + 2, TokenType.parenL))
+    ) {
       return false;
     }
     const identifierName = this.tokens.identifierNameForToken(identifierToken);
@@ -33007,7 +26277,12 @@ class CJSImportTransformer extends Transformer {
     this.tokens.copyToken();
     return true;
   }
-  processPostIncDec() {
+
+  /**
+   * Process something like `a++`, where `a` might be an exported value.
+   * This starts at the `a`, not at the `++`.
+   */
+   processPostIncDec() {
     const index = this.tokens.currentIndex();
     const identifierToken = this.tokens.tokens[index];
     const operatorToken = this.tokens.tokens[index + 1];
@@ -33026,6 +26301,8 @@ class CJSImportTransformer extends Transformer {
       return false;
     }
     const operatorCode = this.tokens.rawCodeForToken(operatorToken);
+    // We might also replace the identifier with something like exports.x, so
+    // do that replacement here as well.
     const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;
     if (operatorCode === "++") {
       this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);
@@ -33037,13 +26314,27 @@ class CJSImportTransformer extends Transformer {
     this.tokens.removeToken();
     return true;
   }
-  processExportDefault() {
-    if (this.tokens.matches4(TokenType._export, TokenType._default, TokenType._function, TokenType.name) || this.tokens.matches5(TokenType._export, TokenType._default, TokenType.name, TokenType._function, TokenType.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._async)) {
+
+   processExportDefault() {
+    if (
+      this.tokens.matches4(TokenType._export, TokenType._default, TokenType._function, TokenType.name) ||
+      // export default async function
+      (this.tokens.matches5(TokenType._export, TokenType._default, TokenType.name, TokenType._function, TokenType.name) &&
+        this.tokens.matchesContextualAtIndex(
+          this.tokens.currentIndex() + 2,
+          ContextualKeyword._async,
+        ))
+    ) {
       this.tokens.removeInitialToken();
       this.tokens.removeToken();
+      // Named function export case: change it to a top-level function
+      // declaration followed by exports statement.
       const name = this.processNamedFunction();
       this.tokens.appendCode(` exports.default = ${name};`);
-    } else if (this.tokens.matches4(TokenType._export, TokenType._default, TokenType._class, TokenType.name) || this.tokens.matches5(TokenType._export, TokenType._default, TokenType._abstract, TokenType._class, TokenType.name)) {
+    } else if (
+      this.tokens.matches4(TokenType._export, TokenType._default, TokenType._class, TokenType.name) ||
+      this.tokens.matches5(TokenType._export, TokenType._default, TokenType._abstract, TokenType._class, TokenType.name)
+    ) {
       this.tokens.removeInitialToken();
       this.tokens.removeToken();
       if (this.tokens.matches1(TokenType._abstract)) {
@@ -33053,32 +26344,53 @@ class CJSImportTransformer extends Transformer {
       this.tokens.appendCode(` exports.default = ${name};`);
     } else if (this.tokens.matches3(TokenType._export, TokenType._default, TokenType.at)) {
       throw new Error("Export default statements with decorators are not yet supported.");
-    } else if (shouldElideDefaultExport(this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)) {
+      // After this point, this is a plain "export default E" statement.
+    } else if (
+      shouldElideDefaultExport(this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)
+    ) {
+      // If the exported value is just an identifier and should be elided by TypeScript
+      // rules, then remove it entirely. It will always have the form `export default e`,
+      // where `e` is an identifier.
       this.tokens.removeInitialToken();
       this.tokens.removeToken();
       this.tokens.removeToken();
     } else if (this.reactHotLoaderTransformer) {
+      // We need to assign E to a variable. Change "export default E" to
+      // "let _default; exports.default = _default = E"
       const defaultVarName = this.nameManager.claimFreeName("_default");
       this.tokens.replaceToken(`let ${defaultVarName}; exports.`);
       this.tokens.copyToken();
       this.tokens.appendCode(` = ${defaultVarName} =`);
       this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);
     } else {
+      // Change "export default E" to "exports.default = E"
       this.tokens.replaceToken("exports.");
       this.tokens.copyToken();
       this.tokens.appendCode(" =");
     }
   }
-  processExportVar() {
+
+  /**
+   * Transform a declaration like `export var`, `export let`, or `export const`.
+   */
+   processExportVar() {
     if (this.isSimpleExportVar()) {
       this.processSimpleExportVar();
     } else {
       this.processComplexExportVar();
     }
   }
-  isSimpleExportVar() {
+
+  /**
+   * Determine if the export is of the form:
+   * export var/let/const [varName] = [expr];
+   * In other words, determine if function name inference might apply.
+   */
+   isSimpleExportVar() {
     let tokenIndex = this.tokens.currentIndex();
+    // export
     tokenIndex++;
+    // var/let/const
     tokenIndex++;
     if (!this.tokens.matches1AtIndex(tokenIndex, TokenType.name)) {
       return false;
@@ -33092,10 +26404,27 @@ class CJSImportTransformer extends Transformer {
     }
     return true;
   }
-  processSimpleExportVar() {
+
+  /**
+   * Transform an `export var` declaration initializing a single variable.
+   *
+   * For example, this:
+   * export const f = () => {};
+   * becomes this:
+   * const f = () => {}; exports.f = f;
+   *
+   * The variable is unused (e.g. exports.f has the true value of the export).
+   * We need to produce an assignment of this form so that the function will
+   * have an inferred name of "f", which wouldn't happen in the more general
+   * case below.
+   */
+   processSimpleExportVar() {
+    // export
     this.tokens.removeInitialToken();
+    // var/let/const
     this.tokens.copyToken();
     const varName = this.tokens.identifierName();
+    // x: number  ->  x
     while (!this.tokens.matches1(TokenType.eq)) {
       this.rootTransformer.processToken();
     }
@@ -33108,24 +26437,43 @@ class CJSImportTransformer extends Transformer {
     }
     this.tokens.appendCode(`; exports.${varName} = ${varName}`);
   }
-  processComplexExportVar() {
+
+  /**
+   * Transform normal declaration exports, including handling destructuring.
+   * For example, this:
+   * export const {x: [a = 2, b], c} = d;
+   * becomes this:
+   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)
+   */
+   processComplexExportVar() {
     this.tokens.removeInitialToken();
     this.tokens.removeToken();
     const needsParens = this.tokens.matches1(TokenType.braceL);
     if (needsParens) {
       this.tokens.appendCode("(");
     }
+
     let depth = 0;
     while (true) {
-      if (this.tokens.matches1(TokenType.braceL) || this.tokens.matches1(TokenType.dollarBraceL) || this.tokens.matches1(TokenType.bracketL)) {
+      if (
+        this.tokens.matches1(TokenType.braceL) ||
+        this.tokens.matches1(TokenType.dollarBraceL) ||
+        this.tokens.matches1(TokenType.bracketL)
+      ) {
         depth++;
         this.tokens.copyToken();
       } else if (this.tokens.matches1(TokenType.braceR) || this.tokens.matches1(TokenType.bracketR)) {
         depth--;
         this.tokens.copyToken();
-      } else if (depth === 0 && !this.tokens.matches1(TokenType.name) && !this.tokens.currentToken().isType) {
+      } else if (
+        depth === 0 &&
+        !this.tokens.matches1(TokenType.name) &&
+        !this.tokens.currentToken().isType
+      ) {
         break;
       } else if (this.tokens.matches1(TokenType.eq)) {
+        // Default values might have assignments in the RHS that we want to ignore, so skip past
+        // them.
         const endIndex = this.tokens.currentToken().rhsEndIndex;
         if (endIndex == null) {
           throw new Error("Expected = token with an end index.");
@@ -33150,7 +26498,9 @@ class CJSImportTransformer extends Transformer {
         }
       }
     }
+
     if (needsParens) {
+      // Seek to the end of the RHS.
       const endIndex = this.tokens.currentToken().rhsEndIndex;
       if (endIndex == null) {
         throw new Error("Expected = token with an end index.");
@@ -33161,12 +26511,23 @@ class CJSImportTransformer extends Transformer {
       this.tokens.appendCode(")");
     }
   }
-  processExportFunction() {
+
+  /**
+   * Transform this:
+   * export function foo() {}
+   * into this:
+   * function foo() {} exports.foo = foo;
+   */
+   processExportFunction() {
     this.tokens.replaceToken("");
     const name = this.processNamedFunction();
     this.tokens.appendCode(` exports.${name} = ${name};`);
   }
-  processNamedFunction() {
+
+  /**
+   * Skip past a function with a name and return that name.
+   */
+   processNamedFunction() {
     if (this.tokens.matches1(TokenType._function)) {
       this.tokens.copyToken();
     } else if (this.tokens.matches2(TokenType.name, TokenType._function)) {
@@ -33199,7 +26560,14 @@ class CJSImportTransformer extends Transformer {
     this.tokens.copyExpectedToken(TokenType.braceR);
     return name;
   }
-  processExportClass() {
+
+  /**
+   * Transform this:
+   * export class A {}
+   * into this:
+   * class A {} exports.A = A;
+   */
+   processExportClass() {
     this.tokens.removeInitialToken();
     if (this.tokens.matches1(TokenType._abstract)) {
       this.tokens.removeToken();
@@ -33207,15 +26575,33 @@ class CJSImportTransformer extends Transformer {
     const name = this.rootTransformer.processNamedClass();
     this.tokens.appendCode(` exports.${name} = ${name};`);
   }
-  processExportBindings() {
+
+  /**
+   * Transform this:
+   * export {a, b as c};
+   * into this:
+   * exports.a = a; exports.c = b;
+   *
+   * OR
+   *
+   * Transform this:
+   * export {a, b as c} from './foo';
+   * into the pre-generated Object.defineProperty code from the ImportProcessor.
+   *
+   * For the first case, if the TypeScript transform is enabled, we need to skip
+   * exports that are only defined as types.
+   */
+   processExportBindings() {
     this.tokens.removeInitialToken();
     this.tokens.removeToken();
+
     const exportStatements = [];
     while (true) {
       if (this.tokens.matches1(TokenType.braceR)) {
         this.tokens.removeToken();
         break;
       }
+
       const localName = this.tokens.identifierName();
       let exportedName;
       this.tokens.removeToken();
@@ -33230,6 +26616,7 @@ class CJSImportTransformer extends Transformer {
         const newLocalName = this.importProcessor.getIdentifierReplacement(localName);
         exportStatements.push(`exports.${exportedName} = ${newLocalName || localName};`);
       }
+
       if (this.tokens.matches1(TokenType.braceR)) {
         this.tokens.removeToken();
         break;
@@ -33244,18 +26631,24 @@ class CJSImportTransformer extends Transformer {
         throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);
       }
     }
+
     if (this.tokens.matchesContextual(ContextualKeyword._from)) {
+      // This is an export...from, so throw away the normal named export code
+      // and use the Object.defineProperty code from ImportProcessor.
       this.tokens.removeToken();
       const path = this.tokens.stringValue();
       this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
     } else {
+      // This is a normal named export, so use that.
       this.tokens.appendCode(exportStatements.join(" "));
     }
+
     if (this.tokens.matches1(TokenType.semi)) {
       this.tokens.removeToken();
     }
   }
-  processExportStar() {
+
+   processExportStar() {
     this.tokens.removeInitialToken();
     while (!this.tokens.matches1(TokenType.string)) {
       this.tokens.removeToken();
@@ -33266,26 +26659,47 @@ class CJSImportTransformer extends Transformer {
       this.tokens.removeToken();
     }
   }
-  shouldElideExportedIdentifier(name) {
+
+   shouldElideExportedIdentifier(name) {
     return this.isTypeScriptTransformEnabled && !this.declarationInfo.valueDeclarations.has(name);
   }
 }
+
+/**
+ * Class for editing import statements when we are keeping the code as ESM. We still need to remove
+ * type-only imports in TypeScript and Flow.
+ */
 class ESMImportTransformer extends Transformer {
-  constructor(tokens, nameManager, reactHotLoaderTransformer, isTypeScriptTransformEnabled, options) {
-    super();
-    this.tokens = tokens;
-    this.nameManager = nameManager;
-    this.reactHotLoaderTransformer = reactHotLoaderTransformer;
-    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
-    this.nonTypeIdentifiers = isTypeScriptTransformEnabled ? getNonTypeIdentifiers(tokens, options) : new Set();
-    this.declarationInfo = isTypeScriptTransformEnabled ? getDeclarationInfo(tokens) : EMPTY_DECLARATION_INFO;
+  
+  
+
+  constructor(
+     tokens,
+     nameManager,
+     reactHotLoaderTransformer,
+     isTypeScriptTransformEnabled,
+    options,
+  ) {
+    super();this.tokens = tokens;this.nameManager = nameManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;    this.nonTypeIdentifiers = isTypeScriptTransformEnabled
+      ? getNonTypeIdentifiers(tokens, options)
+      : new Set();
+    this.declarationInfo = isTypeScriptTransformEnabled
+      ? getDeclarationInfo(tokens)
+      : EMPTY_DECLARATION_INFO;
   }
+
   process() {
+    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
     if (this.tokens.matches3(TokenType._import, TokenType.name, TokenType.eq)) {
       return this.processImportEquals();
     }
-    if (this.tokens.matches4(TokenType._import, TokenType.name, TokenType.name, TokenType.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)) {
+    if (
+      this.tokens.matches4(TokenType._import, TokenType.name, TokenType.name, TokenType.eq) &&
+      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
+    ) {
+      // import type T = require('T')
       this.tokens.removeInitialToken();
+      // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.
       for (let i = 0; i < 7; i++) {
         this.tokens.removeToken();
       }
@@ -33295,8 +26709,13 @@ class ESMImportTransformer extends Transformer {
       this.tokens.replaceToken("module.exports");
       return true;
     }
-    if (this.tokens.matches5(TokenType._export, TokenType._import, TokenType.name, TokenType.name, TokenType.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._type)) {
+    if (
+      this.tokens.matches5(TokenType._export, TokenType._import, TokenType.name, TokenType.name, TokenType.eq) &&
+      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._type)
+    ) {
+      // export import type T = require('T')
       this.tokens.removeInitialToken();
+      // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.
       for (let i = 0; i < 8; i++) {
         this.tokens.removeToken();
       }
@@ -33311,13 +26730,22 @@ class ESMImportTransformer extends Transformer {
     if (this.tokens.matches2(TokenType._export, TokenType.braceL)) {
       return this.processNamedExports();
     }
-    if (this.tokens.matches3(TokenType._export, TokenType.name, TokenType.braceL) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)) {
+    if (
+      this.tokens.matches3(TokenType._export, TokenType.name, TokenType.braceL) &&
+      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
+    ) {
+      // TS `export type {` case: just remove the export entirely.
       this.tokens.removeInitialToken();
       while (!this.tokens.matches1(TokenType.braceR)) {
         this.tokens.removeToken();
       }
       this.tokens.removeToken();
-      if (this.tokens.matchesContextual(ContextualKeyword._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.string)) {
+
+      // Remove type re-export `... } from './T'`
+      if (
+        this.tokens.matchesContextual(ContextualKeyword._from) &&
+        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.string)
+      ) {
         this.tokens.removeToken();
         this.tokens.removeToken();
       }
@@ -33325,19 +26753,25 @@ class ESMImportTransformer extends Transformer {
     }
     return false;
   }
-  processImportEquals() {
+
+   processImportEquals() {
     const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
     if (this.isTypeName(importName)) {
+      // If this name is only used as a type, elide the whole import.
       elideImportEquals(this.tokens);
     } else {
+      // Otherwise, switch `import` to `const`.
       this.tokens.replaceToken("const");
     }
     return true;
   }
-  processImport() {
+
+   processImport() {
     if (this.tokens.matches2(TokenType._import, TokenType.parenL)) {
+      // Dynamic imports don't need to be transformed.
       return false;
     }
+
     const snapshot = this.tokens.snapshot();
     const allImportsRemoved = this.removeImportTypeBindings();
     if (allImportsRemoved) {
@@ -33352,16 +26786,32 @@ class ESMImportTransformer extends Transformer {
     }
     return true;
   }
-  removeImportTypeBindings() {
+
+  /**
+   * Remove type bindings from this import, leaving the rest of the import intact.
+   *
+   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out
+   * of the replacement operation, so we can return early here.
+   */
+   removeImportTypeBindings() {
     this.tokens.copyExpectedToken(TokenType._import);
-    if (this.tokens.matchesContextual(ContextualKeyword._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)) {
+    if (
+      this.tokens.matchesContextual(ContextualKeyword._type) &&
+      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.comma) &&
+      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)
+    ) {
+      // This is an "import type" statement, so exit early.
       return true;
     }
+
     if (this.tokens.matches1(TokenType.string)) {
+      // This is a bare import, so we should proceed with the import.
       this.tokens.copyToken();
       return false;
     }
+
     let foundNonTypeImport = false;
+
     if (this.tokens.matches1(TokenType.name)) {
       if (this.isTypeName(this.tokens.identifierName())) {
         this.tokens.removeToken();
@@ -33376,6 +26826,7 @@ class ESMImportTransformer extends Transformer {
         }
       }
     }
+
     if (this.tokens.matches1(TokenType.star)) {
       if (this.isTypeName(this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2))) {
         this.tokens.removeToken();
@@ -33390,13 +26841,21 @@ class ESMImportTransformer extends Transformer {
     } else if (this.tokens.matches1(TokenType.braceL)) {
       this.tokens.copyToken();
       while (!this.tokens.matches1(TokenType.braceR)) {
-        if (this.tokens.matches3(TokenType.name, TokenType.name, TokenType.comma) || this.tokens.matches3(TokenType.name, TokenType.name, TokenType.braceR)) {
+        if (
+          this.tokens.matches3(TokenType.name, TokenType.name, TokenType.comma) ||
+          this.tokens.matches3(TokenType.name, TokenType.name, TokenType.braceR)
+        ) {
+          // type foo
           this.tokens.removeToken();
           this.tokens.removeToken();
           if (this.tokens.matches1(TokenType.comma)) {
             this.tokens.removeToken();
           }
-        } else if (this.tokens.matches5(TokenType.name, TokenType.name, TokenType.name, TokenType.name, TokenType.comma) || this.tokens.matches5(TokenType.name, TokenType.name, TokenType.name, TokenType.name, TokenType.braceR)) {
+        } else if (
+          this.tokens.matches5(TokenType.name, TokenType.name, TokenType.name, TokenType.name, TokenType.comma) ||
+          this.tokens.matches5(TokenType.name, TokenType.name, TokenType.name, TokenType.name, TokenType.braceR)
+        ) {
+          // type foo as bar
           this.tokens.removeToken();
           this.tokens.removeToken();
           this.tokens.removeToken();
@@ -33404,7 +26863,11 @@ class ESMImportTransformer extends Transformer {
           if (this.tokens.matches1(TokenType.comma)) {
             this.tokens.removeToken();
           }
-        } else if (this.tokens.matches2(TokenType.name, TokenType.comma) || this.tokens.matches2(TokenType.name, TokenType.braceR)) {
+        } else if (
+          this.tokens.matches2(TokenType.name, TokenType.comma) ||
+          this.tokens.matches2(TokenType.name, TokenType.braceR)
+        ) {
+          // foo
           if (this.isTypeName(this.tokens.identifierName())) {
             this.tokens.removeToken();
             if (this.tokens.matches1(TokenType.comma)) {
@@ -33417,7 +26880,11 @@ class ESMImportTransformer extends Transformer {
               this.tokens.copyToken();
             }
           }
-        } else if (this.tokens.matches4(TokenType.name, TokenType.name, TokenType.name, TokenType.comma) || this.tokens.matches4(TokenType.name, TokenType.name, TokenType.name, TokenType.braceR)) {
+        } else if (
+          this.tokens.matches4(TokenType.name, TokenType.name, TokenType.name, TokenType.comma) ||
+          this.tokens.matches4(TokenType.name, TokenType.name, TokenType.name, TokenType.braceR)
+        ) {
+          // foo as bar
           if (this.isTypeName(this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2))) {
             this.tokens.removeToken();
             this.tokens.removeToken();
@@ -33440,20 +26907,41 @@ class ESMImportTransformer extends Transformer {
       }
       this.tokens.copyExpectedToken(TokenType.braceR);
     }
+
     return !foundNonTypeImport;
   }
-  isTypeName(name) {
+
+   isTypeName(name) {
     return this.isTypeScriptTransformEnabled && !this.nonTypeIdentifiers.has(name);
   }
-  processExportDefault() {
-    if (shouldElideDefaultExport(this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)) {
+
+   processExportDefault() {
+    if (
+      shouldElideDefaultExport(this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)
+    ) {
+      // If the exported value is just an identifier and should be elided by TypeScript
+      // rules, then remove it entirely. It will always have the form `export default e`,
+      // where `e` is an identifier.
       this.tokens.removeInitialToken();
       this.tokens.removeToken();
       this.tokens.removeToken();
       return true;
     }
-    const alreadyHasName = this.tokens.matches4(TokenType._export, TokenType._default, TokenType._function, TokenType.name) || this.tokens.matches5(TokenType._export, TokenType._default, TokenType.name, TokenType._function, TokenType.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._async) || this.tokens.matches4(TokenType._export, TokenType._default, TokenType._class, TokenType.name) || this.tokens.matches5(TokenType._export, TokenType._default, TokenType._abstract, TokenType._class, TokenType.name);
+
+    const alreadyHasName =
+      this.tokens.matches4(TokenType._export, TokenType._default, TokenType._function, TokenType.name) ||
+      // export default async function
+      (this.tokens.matches5(TokenType._export, TokenType._default, TokenType.name, TokenType._function, TokenType.name) &&
+        this.tokens.matchesContextualAtIndex(
+          this.tokens.currentIndex() + 2,
+          ContextualKeyword._async,
+        )) ||
+      this.tokens.matches4(TokenType._export, TokenType._default, TokenType._class, TokenType.name) ||
+      this.tokens.matches5(TokenType._export, TokenType._default, TokenType._abstract, TokenType._class, TokenType.name);
+
     if (!alreadyHasName && this.reactHotLoaderTransformer) {
+      // This is a plain "export default E" statement and we need to assign E to a variable.
+      // Change "export default E" to "let _default; export default _default = E"
       const defaultVarName = this.nameManager.claimFreeName("_default");
       this.tokens.replaceToken(`let ${defaultVarName}; export`);
       this.tokens.copyToken();
@@ -33463,25 +26951,39 @@ class ESMImportTransformer extends Transformer {
     }
     return false;
   }
-  processNamedExports() {
+
+  /**
+   * In TypeScript, we need to remove named exports that were never declared or only declared as a
+   * type.
+   */
+   processNamedExports() {
     if (!this.isTypeScriptTransformEnabled) {
       return false;
     }
     this.tokens.copyExpectedToken(TokenType._export);
     this.tokens.copyExpectedToken(TokenType.braceL);
+
     while (!this.tokens.matches1(TokenType.braceR)) {
       if (!this.tokens.matches1(TokenType.name)) {
         throw new Error("Expected identifier at the start of named export.");
       }
       if (this.shouldElideExportedName(this.tokens.identifierName())) {
-        while (!this.tokens.matches1(TokenType.comma) && !this.tokens.matches1(TokenType.braceR) && !this.tokens.isAtEnd()) {
+        while (
+          !this.tokens.matches1(TokenType.comma) &&
+          !this.tokens.matches1(TokenType.braceR) &&
+          !this.tokens.isAtEnd()
+        ) {
           this.tokens.removeToken();
         }
         if (this.tokens.matches1(TokenType.comma)) {
           this.tokens.removeToken();
         }
       } else {
-        while (!this.tokens.matches1(TokenType.comma) && !this.tokens.matches1(TokenType.braceR) && !this.tokens.isAtEnd()) {
+        while (
+          !this.tokens.matches1(TokenType.comma) &&
+          !this.tokens.matches1(TokenType.braceR) &&
+          !this.tokens.isAtEnd()
+        ) {
           this.tokens.copyToken();
         }
         if (this.tokens.matches1(TokenType.comma)) {
@@ -33492,77 +26994,107 @@ class ESMImportTransformer extends Transformer {
     this.tokens.copyExpectedToken(TokenType.braceR);
     return true;
   }
-  shouldElideExportedName(name) {
-    return this.isTypeScriptTransformEnabled && this.declarationInfo.typeDeclarations.has(name) && !this.declarationInfo.valueDeclarations.has(name);
+
+  /**
+   * ESM elides all imports with the rule that we only elide if we see that it's
+   * a type and never see it as a value. This is in contract to CJS, which
+   * elides imports that are completely unknown.
+   */
+   shouldElideExportedName(name) {
+    return (
+      this.isTypeScriptTransformEnabled &&
+      this.declarationInfo.typeDeclarations.has(name) &&
+      !this.declarationInfo.valueDeclarations.has(name)
+    );
   }
 }
+
 class FlowTransformer extends Transformer {
-  constructor(rootTransformer, tokens) {
-    super();
-    this.rootTransformer = rootTransformer;
-    this.tokens = tokens;
-  }
+  constructor( rootTransformer,  tokens) {
+    super();this.rootTransformer = rootTransformer;this.tokens = tokens;  }
+
   process() {
-    return this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange();
-  }
-}
-function _optionalChain(ops) {
-  let lastAccessLHS = void 0;
-  let value = ops[0];
-  let i = 1;
-  while (i < ops.length) {
-    const op = ops[i];
-    const fn = ops[i + 1];
-    i += 2;
-    if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
-      return void 0;
-    }
-    if (op === "access" || op === "optionalAccess") {
-      lastAccessLHS = value;
-      value = fn(value);
-    } else if (op === "call" || op === "optionalCall") {
-      value = fn((...args) => value.call(lastAccessLHS, ...args));
-      lastAccessLHS = void 0;
-    }
+    return (
+      this.rootTransformer.processPossibleArrowParamEnd() ||
+      this.rootTransformer.processPossibleAsyncArrowWithTypeParams() ||
+      this.rootTransformer.processPossibleTypeRange()
+    );
   }
-  return value;
 }
+
+function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
+
 const JEST_GLOBAL_NAME = "jest";
 const HOISTED_METHODS = ["mock", "unmock", "enableAutomock", "disableAutomock"];
+
+/**
+ * Implementation of babel-plugin-jest-hoist, which hoists up some jest method
+ * calls above the imports to allow them to override other imports.
+ *
+ * To preserve line numbers, rather than directly moving the jest.mock code, we
+ * wrap each invocation in a function statement and then call the function from
+ * the top of the file.
+ */
 class JestHoistTransformer extends Transformer {
-  __init() {
-    this.hoistedFunctionNames = [];
-  }
-  constructor(rootTransformer, tokens, nameManager, importProcessor) {
-    super();
-    this.rootTransformer = rootTransformer;
-    this.tokens = tokens;
-    this.nameManager = nameManager;
-    this.importProcessor = importProcessor;
-    JestHoistTransformer.prototype.__init.call(this);
-  }
+    __init() {this.hoistedFunctionNames = [];}
+
+  constructor(
+     rootTransformer,
+     tokens,
+     nameManager,
+     importProcessor,
+  ) {
+    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.nameManager = nameManager;this.importProcessor = importProcessor;JestHoistTransformer.prototype.__init.call(this);  }
+
   process() {
-    if (this.tokens.currentToken().scopeDepth === 0 && this.tokens.matches4(TokenType.name, TokenType.dot, TokenType.name, TokenType.parenL) && this.tokens.identifierName() === JEST_GLOBAL_NAME) {
-      if (_optionalChain([this, "access", (_) => _.importProcessor, "optionalAccess", (_2) => _2.getGlobalNames, "call", (_3) => _3(), "optionalAccess", (_4) => _4.has, "call", (_5) => _5(JEST_GLOBAL_NAME)])) {
+    if (
+      this.tokens.currentToken().scopeDepth === 0 &&
+      this.tokens.matches4(TokenType.name, TokenType.dot, TokenType.name, TokenType.parenL) &&
+      this.tokens.identifierName() === JEST_GLOBAL_NAME
+    ) {
+      // TODO: This only works if imports transform is active, which it will be for jest.
+      //       But if jest adds module support and we no longer need the import transform, this needs fixing.
+      if (_optionalChain([this, 'access', _ => _.importProcessor, 'optionalAccess', _2 => _2.getGlobalNames, 'call', _3 => _3(), 'optionalAccess', _4 => _4.has, 'call', _5 => _5(JEST_GLOBAL_NAME)])) {
         return false;
       }
       return this.extractHoistedCalls();
     }
+
     return false;
   }
+
   getHoistedCode() {
     if (this.hoistedFunctionNames.length > 0) {
+      // This will be placed before module interop code, but that's fine since
+      // imports aren't allowed in module mock factories.
       return this.hoistedFunctionNames.map((name) => `${name}();`).join("");
     }
     return "";
   }
-  extractHoistedCalls() {
+
+  /**
+   * Extracts any methods calls on the jest-object that should be hoisted.
+   *
+   * According to the jest docs, https://jestjs.io/docs/en/jest-object#jestmockmodulename-factory-options,
+   * mock, unmock, enableAutomock, disableAutomock, are the methods that should be hoisted.
+   *
+   * We do not apply the same checks of the arguments as babel-plugin-jest-hoist does.
+   */
+   extractHoistedCalls() {
+    // We're handling a chain of calls where `jest` may or may not need to be inserted for each call
+    // in the chain, so remove the initial `jest` to make the loop implementation cleaner.
     this.tokens.removeToken();
+    // Track some state so that multiple non-hoisted chained calls in a row keep their chaining
+    // syntax.
     let followsNonHoistedJestCall = false;
+
+    // Iterate through all chained calls on the jest object.
     while (this.tokens.matches3(TokenType.dot, TokenType.name, TokenType.parenL)) {
       const methodName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
       const shouldHoist = HOISTED_METHODS.includes(methodName);
       if (shouldHoist) {
+        // We've matched e.g. `.mock(...)` or similar call.
+        // Replace the initial `.` with `function __jestHoist(){jest.`
         const hoistedFunctionName = this.nameManager.claimFreeName("__jestHoist");
         this.hoistedFunctionNames.push(hoistedFunctionName);
         this.tokens.replaceToken(`function ${hoistedFunctionName}(){${JEST_GLOBAL_NAME}.`);
@@ -33573,9 +27105,15 @@ class JestHoistTransformer extends Transformer {
         this.tokens.appendCode(";}");
         followsNonHoistedJestCall = false;
       } else {
+        // This is a non-hoisted method, so just transform the code as usual.
         if (followsNonHoistedJestCall) {
+          // If we didn't hoist the previous call, we can leave the code as-is to chain off of the
+          // previous method call. It's important to preserve the code here because we don't know
+          // for sure that the method actually returned the jest object for chaining.
           this.tokens.copyToken();
         } else {
+          // If we hoisted the previous call, we know it returns the jest object back, so we insert
+          // the identifier `jest` to continue the chain.
           this.tokens.replaceToken(`${JEST_GLOBAL_NAME}.`);
         }
         this.tokens.copyToken();
@@ -33585,14 +27123,15 @@ class JestHoistTransformer extends Transformer {
         followsNonHoistedJestCall = true;
       }
     }
+
     return true;
   }
 }
+
 class NumericSeparatorTransformer extends Transformer {
-  constructor(tokens) {
-    super();
-    this.tokens = tokens;
-  }
+  constructor( tokens) {
+    super();this.tokens = tokens;  }
+
   process() {
     if (this.tokens.matches1(TokenType.num)) {
       const code = this.tokens.currentTokenCode();
@@ -33604,12 +27143,11 @@ class NumericSeparatorTransformer extends Transformer {
     return false;
   }
 }
+
 class OptionalCatchBindingTransformer extends Transformer {
-  constructor(tokens, nameManager) {
-    super();
-    this.tokens = tokens;
-    this.nameManager = nameManager;
-  }
+  constructor( tokens,  nameManager) {
+    super();this.tokens = tokens;this.nameManager = nameManager;  }
+
   process() {
     if (this.tokens.matches2(TokenType._catch, TokenType.braceL)) {
       this.tokens.copyToken();
@@ -33619,16 +27157,24 @@ class OptionalCatchBindingTransformer extends Transformer {
     return false;
   }
 }
+
+/**
+ * Transformer supporting the optional chaining and nullish coalescing operators.
+ *
+ * Tech plan here:
+ * https://github.com/alangpierce/sucrase/wiki/Sucrase-Optional-Chaining-and-Nullish-Coalescing-Technical-Plan
+ *
+ * The prefix and suffix code snippets are handled by TokenProcessor, and this transformer handles
+ * the operators themselves.
+ */
 class OptionalChainingNullishTransformer extends Transformer {
-  constructor(tokens, nameManager) {
-    super();
-    this.tokens = tokens;
-    this.nameManager = nameManager;
-  }
+  constructor( tokens,  nameManager) {
+    super();this.tokens = tokens;this.nameManager = nameManager;  }
+
   process() {
     if (this.tokens.matches1(TokenType.nullishCoalescing)) {
-      const token2 = this.tokens.currentToken();
-      if (this.tokens.tokens[token2.nullishStartIndex].isAsyncOperation) {
+      const token = this.tokens.currentToken();
+      if (this.tokens.tokens[token.nullishStartIndex].isAsyncOperation) {
         this.tokens.replaceTokenTrimmingLeftWhitespace(", async () => (");
       } else {
         this.tokens.replaceTokenTrimmingLeftWhitespace(", () => (");
@@ -33636,18 +27182,31 @@ class OptionalChainingNullishTransformer extends Transformer {
       return true;
     }
     if (this.tokens.matches1(TokenType._delete)) {
-      const nextToken2 = this.tokens.tokenAtRelativeIndex(1);
-      if (nextToken2.isOptionalChainStart) {
+      const nextToken = this.tokens.tokenAtRelativeIndex(1);
+      if (nextToken.isOptionalChainStart) {
         this.tokens.removeInitialToken();
         return true;
       }
     }
     const token = this.tokens.currentToken();
     const chainStart = token.subscriptStartIndex;
-    if (chainStart != null && this.tokens.tokens[chainStart].isOptionalChainStart && this.tokens.tokenAtRelativeIndex(-1).type !== TokenType._super) {
+    if (
+      chainStart != null &&
+      this.tokens.tokens[chainStart].isOptionalChainStart &&
+      // Super subscripts can't be optional (since super is never null/undefined), and the syntax
+      // relies on the subscript being intact, so leave this token alone.
+      this.tokens.tokenAtRelativeIndex(-1).type !== TokenType._super
+    ) {
       const param = this.nameManager.claimFreeName("_");
       let arrowStartSnippet;
-      if (chainStart > 0 && this.tokens.matches1AtIndex(chainStart - 1, TokenType._delete) && this.isLastSubscriptInChain()) {
+      if (
+        chainStart > 0 &&
+        this.tokens.matches1AtIndex(chainStart - 1, TokenType._delete) &&
+        this.isLastSubscriptInChain()
+      ) {
+        // Delete operations are special: we already removed the delete keyword, and to still
+        // perform a delete, we need to insert a delete in the very last part of the chain, which
+        // in correct code will always be a property access.
         arrowStartSnippet = `${param} => delete ${param}`;
       } else {
         arrowStartSnippet = `${param} => ${param}`;
@@ -33655,7 +27214,10 @@ class OptionalChainingNullishTransformer extends Transformer {
       if (this.tokens.tokens[chainStart].isAsyncOperation) {
         arrowStartSnippet = `async ${arrowStartSnippet}`;
       }
-      if (this.tokens.matches2(TokenType.questionDot, TokenType.parenL) || this.tokens.matches2(TokenType.questionDot, TokenType.lessThan)) {
+      if (
+        this.tokens.matches2(TokenType.questionDot, TokenType.parenL) ||
+        this.tokens.matches2(TokenType.questionDot, TokenType.lessThan)
+      ) {
         if (this.justSkippedSuper()) {
           this.tokens.appendCode(".bind(this)");
         }
@@ -33680,6 +27242,16 @@ class OptionalChainingNullishTransformer extends Transformer {
     }
     return false;
   }
+
+  /**
+   * Determine if the current token is the last of its chain, so that we know whether it's eligible
+   * to have a delete op inserted.
+   *
+   * We can do this by walking forward until we determine one way or another. Each
+   * isOptionalChainStart token must be paired with exactly one isOptionalChainEnd token after it in
+   * a nesting way, so we can track depth and walk to the end of the chain (the point where the
+   * depth goes negative) and see if any other subscript token is after us in the chain.
+   */
   isLastSubscriptInChain() {
     let depth = 0;
     for (let i = this.tokens.currentIndex() + 1; ; i++) {
@@ -33694,17 +27266,29 @@ class OptionalChainingNullishTransformer extends Transformer {
       if (depth < 0) {
         return true;
       }
+
+      // This subscript token is a later one in the same chain.
       if (depth === 0 && this.tokens.tokens[i].subscriptStartIndex != null) {
         return false;
       }
     }
   }
+
+  /**
+   * Determine if we are the open-paren in an expression like super.a()?.b.
+   *
+   * We can do this by walking backward to find the previous subscript. If that subscript was
+   * preceded by a super, then we must be the subscript after it, so if this is a call expression,
+   * we'll need to attach the right context.
+   */
   justSkippedSuper() {
     let depth = 0;
     let index = this.tokens.currentIndex() - 1;
     while (true) {
       if (index < 0) {
-        throw new Error("Reached the start of the code while finding the start of the access chain.");
+        throw new Error(
+          "Reached the start of the code while finding the start of the access chain.",
+        );
       }
       if (this.tokens.tokens[index].isOptionalChainStart) {
         depth--;
@@ -33714,6 +27298,8 @@ class OptionalChainingNullishTransformer extends Transformer {
       if (depth < 0) {
         return false;
       }
+
+      // This subscript token is a later one in the same chain.
       if (depth === 0 && this.tokens.tokens[index].subscriptStartIndex != null) {
         return this.tokens.tokens[index - 1].type === TokenType._super;
       }
@@ -33721,18 +27307,25 @@ class OptionalChainingNullishTransformer extends Transformer {
     }
   }
 }
+
+/**
+ * Implementation of babel-plugin-transform-react-display-name, which adds a
+ * display name to usages of React.createClass and createReactClass.
+ */
 class ReactDisplayNameTransformer extends Transformer {
-  constructor(rootTransformer, tokens, importProcessor, options) {
-    super();
-    this.rootTransformer = rootTransformer;
-    this.tokens = tokens;
-    this.importProcessor = importProcessor;
-    this.options = options;
-  }
+  constructor(
+     rootTransformer,
+     tokens,
+     importProcessor,
+     options,
+  ) {
+    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.options = options;  }
+
   process() {
     const startIndex = this.tokens.currentIndex();
     if (this.tokens.identifierName() === "createReactClass") {
-      const newName = this.importProcessor && this.importProcessor.getIdentifierReplacement("createReactClass");
+      const newName =
+        this.importProcessor && this.importProcessor.getIdentifierReplacement("createReactClass");
       if (newName) {
         this.tokens.replaceToken(`(0, ${newName})`);
       } else {
@@ -33741,8 +27334,14 @@ class ReactDisplayNameTransformer extends Transformer {
       this.tryProcessCreateClassCall(startIndex);
       return true;
     }
-    if (this.tokens.matches3(TokenType.name, TokenType.dot, TokenType.name) && this.tokens.identifierName() === "React" && this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2) === "createClass") {
-      const newName = this.importProcessor ? this.importProcessor.getIdentifierReplacement("React") || "React" : "React";
+    if (
+      this.tokens.matches3(TokenType.name, TokenType.dot, TokenType.name) &&
+      this.tokens.identifierName() === "React" &&
+      this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2) === "createClass"
+    ) {
+      const newName = this.importProcessor
+        ? this.importProcessor.getIdentifierReplacement("React") || "React"
+        : "React";
       if (newName) {
         this.tokens.replaceToken(newName);
         this.tokens.copyToken();
@@ -33757,11 +27356,16 @@ class ReactDisplayNameTransformer extends Transformer {
     }
     return false;
   }
-  tryProcessCreateClassCall(startIndex) {
+
+  /**
+   * This is called with the token position at the open-paren.
+   */
+   tryProcessCreateClassCall(startIndex) {
     const displayName = this.findDisplayName(startIndex);
     if (!displayName) {
       return;
     }
+
     if (this.classNeedsDisplayName()) {
       this.tokens.copyExpectedToken(TokenType.parenL);
       this.tokens.copyExpectedToken(TokenType.braceL);
@@ -33771,14 +27375,21 @@ class ReactDisplayNameTransformer extends Transformer {
       this.tokens.copyExpectedToken(TokenType.parenR);
     }
   }
-  findDisplayName(startIndex) {
+
+   findDisplayName(startIndex) {
     if (startIndex < 2) {
       return null;
     }
     if (this.tokens.matches2AtIndex(startIndex - 2, TokenType.name, TokenType.eq)) {
+      // This is an assignment (or declaration) and the LHS is either an identifier or a member
+      // expression ending in an identifier, so use that identifier name.
       return this.tokens.identifierNameAtIndex(startIndex - 2);
     }
-    if (startIndex >= 2 && this.tokens.tokens[startIndex - 2].identifierRole === IdentifierRole.ObjectKey) {
+    if (
+      startIndex >= 2 &&
+      this.tokens.tokens[startIndex - 2].identifierRole === IdentifierRole.ObjectKey
+    ) {
+      // This is an object literal value.
       return this.tokens.identifierNameAtIndex(startIndex - 2);
     }
     if (this.tokens.matches2AtIndex(startIndex - 2, TokenType._export, TokenType._default)) {
@@ -33786,7 +27397,8 @@ class ReactDisplayNameTransformer extends Transformer {
     }
     return null;
   }
-  getDisplayNameFromFilename() {
+
+   getDisplayNameFromFilename() {
     const filePath = this.options.filePath || "unknown";
     const pathSegments = filePath.split("/");
     const filename = pathSegments[pathSegments.length - 1];
@@ -33798,67 +27410,95 @@ class ReactDisplayNameTransformer extends Transformer {
       return baseFilename;
     }
   }
-  classNeedsDisplayName() {
+
+  /**
+   * We only want to add a display name when this is a function call containing
+   * one argument, which is an object literal without `displayName` as an
+   * existing key.
+   */
+   classNeedsDisplayName() {
     let index = this.tokens.currentIndex();
     if (!this.tokens.matches2(TokenType.parenL, TokenType.braceL)) {
       return false;
     }
+    // The block starts on the {, and we expect any displayName key to be in
+    // that context. We need to ignore other other contexts to avoid matching
+    // nested displayName keys.
     const objectStartIndex = index + 1;
     const objectContextId = this.tokens.tokens[objectStartIndex].contextId;
     if (objectContextId == null) {
       throw new Error("Expected non-null context ID on object open-brace.");
     }
+
     for (; index < this.tokens.tokens.length; index++) {
       const token = this.tokens.tokens[index];
       if (token.type === TokenType.braceR && token.contextId === objectContextId) {
         index++;
         break;
       }
-      if (this.tokens.identifierNameAtIndex(index) === "displayName" && this.tokens.tokens[index].identifierRole === IdentifierRole.ObjectKey && token.contextId === objectContextId) {
+
+      if (
+        this.tokens.identifierNameAtIndex(index) === "displayName" &&
+        this.tokens.tokens[index].identifierRole === IdentifierRole.ObjectKey &&
+        token.contextId === objectContextId
+      ) {
+        // We found a displayName key, so bail out.
         return false;
       }
     }
+
     if (index === this.tokens.tokens.length) {
       throw new Error("Unexpected end of input when processing React class.");
     }
-    return this.tokens.matches1AtIndex(index, TokenType.parenR) || this.tokens.matches2AtIndex(index, TokenType.comma, TokenType.parenR);
+
+    // If we got this far, we know we have createClass with an object with no
+    // display name, so we want to proceed as long as that was the only argument.
+    return (
+      this.tokens.matches1AtIndex(index, TokenType.parenR) ||
+      this.tokens.matches2AtIndex(index, TokenType.comma, TokenType.parenR)
+    );
   }
 }
+
 class ReactHotLoaderTransformer extends Transformer {
-  __init() {
-    this.extractedDefaultExportName = null;
-  }
-  constructor(tokens, filePath) {
-    super();
-    this.tokens = tokens;
-    this.filePath = filePath;
-    ReactHotLoaderTransformer.prototype.__init.call(this);
-  }
+   __init() {this.extractedDefaultExportName = null;}
+
+  constructor( tokens,  filePath) {
+    super();this.tokens = tokens;this.filePath = filePath;ReactHotLoaderTransformer.prototype.__init.call(this);  }
+
   setExtractedDefaultExportName(extractedDefaultExportName) {
     this.extractedDefaultExportName = extractedDefaultExportName;
   }
+
   getPrefixCode() {
     return `
       (function () {
         var enterModule = require('react-hot-loader').enterModule;
         enterModule && enterModule(module);
-      })();`.replace(/\s+/g, " ").trim();
+      })();`
+      .replace(/\s+/g, " ")
+      .trim();
   }
+
   getSuffixCode() {
     const topLevelNames = new Set();
     for (const token of this.tokens.tokens) {
-      if (!token.isType && isTopLevelDeclaration(token) && token.identifierRole !== IdentifierRole.ImportDeclaration) {
+      if (
+        !token.isType &&
+        isTopLevelDeclaration(token) &&
+        token.identifierRole !== IdentifierRole.ImportDeclaration
+      ) {
         topLevelNames.add(this.tokens.identifierNameForToken(token));
       }
     }
     const namesToRegister = Array.from(topLevelNames).map((name) => ({
       variableName: name,
-      uniqueLocalName: name
+      uniqueLocalName: name,
     }));
     if (this.extractedDefaultExportName) {
       namesToRegister.push({
         variableName: this.extractedDefaultExportName,
-        uniqueLocalName: "default"
+        uniqueLocalName: "default",
       });
     }
     return `
@@ -33868,15 +27508,31 @@ class ReactHotLoaderTransformer extends Transformer {
   if (!reactHotLoader) {
     return;
   }
-${namesToRegister.map(({ variableName, uniqueLocalName }) => `  reactHotLoader.register(${variableName}, "${uniqueLocalName}", ${JSON.stringify(this.filePath || "")});`).join("\n")}
+${namesToRegister
+  .map(
+    ({variableName, uniqueLocalName}) =>
+      `  reactHotLoader.register(${variableName}, "${uniqueLocalName}", ${JSON.stringify(
+        this.filePath || "",
+      )});`,
+  )
+  .join("\n")}
   leaveModule(module);
 })();`;
   }
+
   process() {
     return false;
   }
 }
+
+// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar
+// Hard-code a list of reserved words rather than trying to use keywords or contextual keywords
+// from the parser, since currently there are various exceptions, like `package` being reserved
+// but unused and various contextual keywords being reserved. Note that we assume that all code
+// compiled by Sucrase is in a module, so strict mode words and await are all considered reserved
+// here.
 const RESERVED_WORDS = new Set([
+  // Reserved keywords as of ECMAScript 2015
   "break",
   "case",
   "catch",
@@ -33910,6 +27566,7 @@ const RESERVED_WORDS = new Set([
   "while",
   "with",
   "yield",
+  // Future reserved keywords
   "enum",
   "implements",
   "interface",
@@ -33919,8 +27576,20 @@ const RESERVED_WORDS = new Set([
   "protected",
   "public",
   "static",
-  "await"
+  "await",
+  // Literals that cannot be used as identifiers
+  "false",
+  "null",
+  "true",
 ]);
+
+/**
+ * Determine if the given name is a legal variable name.
+ *
+ * This is needed when transforming TypeScript enums; if an enum key is a valid
+ * variable name, it might be referenced later in the enum, so we need to
+ * declare a variable.
+ */
 function isIdentifier(name) {
   if (name.length === 0) {
     return false;
@@ -33935,18 +27604,32 @@ function isIdentifier(name) {
   }
   return !RESERVED_WORDS.has(name);
 }
+
 class TypeScriptTransformer extends Transformer {
-  constructor(rootTransformer, tokens, isImportsTransformEnabled) {
-    super();
-    this.rootTransformer = rootTransformer;
-    this.tokens = tokens;
-    this.isImportsTransformEnabled = isImportsTransformEnabled;
-  }
+  constructor(
+     rootTransformer,
+     tokens,
+     isImportsTransformEnabled,
+  ) {
+    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.isImportsTransformEnabled = isImportsTransformEnabled;  }
+
   process() {
-    if (this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange()) {
+    if (
+      this.rootTransformer.processPossibleArrowParamEnd() ||
+      this.rootTransformer.processPossibleAsyncArrowWithTypeParams() ||
+      this.rootTransformer.processPossibleTypeRange()
+    ) {
       return true;
     }
-    if (this.tokens.matches1(TokenType._public) || this.tokens.matches1(TokenType._protected) || this.tokens.matches1(TokenType._private) || this.tokens.matches1(TokenType._abstract) || this.tokens.matches1(TokenType._readonly) || this.tokens.matches1(TokenType._override) || this.tokens.matches1(TokenType.nonNullAssertion)) {
+    if (
+      this.tokens.matches1(TokenType._public) ||
+      this.tokens.matches1(TokenType._protected) ||
+      this.tokens.matches1(TokenType._private) ||
+      this.tokens.matches1(TokenType._abstract) ||
+      this.tokens.matches1(TokenType._readonly) ||
+      this.tokens.matches1(TokenType._override) ||
+      this.tokens.matches1(TokenType.nonNullAssertion)
+    ) {
       this.tokens.removeInitialToken();
       return true;
     }
@@ -33954,13 +27637,18 @@ class TypeScriptTransformer extends Transformer {
       this.processEnum();
       return true;
     }
-    if (this.tokens.matches2(TokenType._export, TokenType._enum) || this.tokens.matches3(TokenType._export, TokenType._const, TokenType._enum)) {
+    if (
+      this.tokens.matches2(TokenType._export, TokenType._enum) ||
+      this.tokens.matches3(TokenType._export, TokenType._const, TokenType._enum)
+    ) {
       this.processEnum(true);
       return true;
     }
     return false;
   }
+
   processEnum(isExport = false) {
+    // We might have "export const enum", so just remove all relevant tokens.
     this.tokens.removeInitialToken();
     while (this.tokens.matches1(TokenType._const) || this.tokens.matches1(TokenType._enum)) {
       this.tokens.removeToken();
@@ -33980,24 +27668,44 @@ class TypeScriptTransformer extends Transformer {
       this.tokens.appendCode(`)(${enumName} || (${enumName} = {}));`);
     }
   }
+
+  /**
+   * Transform an enum into equivalent JS. This has complexity in a few places:
+   * - TS allows string enums, numeric enums, and a mix of the two styles within an enum.
+   * - Enum keys are allowed to be referenced in later enum values.
+   * - Enum keys are allowed to be strings.
+   * - When enum values are omitted, they should follow an auto-increment behavior.
+   */
   processEnumBody(enumName) {
+    // Code that can be used to reference the previous enum member, or null if this is the first
+    // enum member.
     let previousValueCode = null;
     while (true) {
       if (this.tokens.matches1(TokenType.braceR)) {
         break;
       }
-      const { nameStringCode, variableName } = this.extractEnumKeyInfo(this.tokens.currentToken());
+      const {nameStringCode, variableName} = this.extractEnumKeyInfo(this.tokens.currentToken());
       this.tokens.removeInitialToken();
-      if (this.tokens.matches3(TokenType.eq, TokenType.string, TokenType.comma) || this.tokens.matches3(TokenType.eq, TokenType.string, TokenType.braceR)) {
+
+      if (
+        this.tokens.matches3(TokenType.eq, TokenType.string, TokenType.comma) ||
+        this.tokens.matches3(TokenType.eq, TokenType.string, TokenType.braceR)
+      ) {
         this.processStringLiteralEnumMember(enumName, nameStringCode, variableName);
       } else if (this.tokens.matches1(TokenType.eq)) {
         this.processExplicitValueEnumMember(enumName, nameStringCode, variableName);
       } else {
-        this.processImplicitValueEnumMember(enumName, nameStringCode, variableName, previousValueCode);
+        this.processImplicitValueEnumMember(
+          enumName,
+          nameStringCode,
+          variableName,
+          previousValueCode,
+        );
       }
       if (this.tokens.matches1(TokenType.comma)) {
         this.tokens.removeToken();
       }
+
       if (variableName != null) {
         previousValueCode = variableName;
       } else {
@@ -34005,48 +27713,128 @@ class TypeScriptTransformer extends Transformer {
       }
     }
   }
+
+  /**
+   * Detect name information about this enum key, which will be used to determine which code to emit
+   * and whether we should declare a variable as part of this declaration.
+   *
+   * Some cases to keep in mind:
+   * - Enum keys can be implicitly referenced later, e.g. `X = 1, Y = X`. In Sucrase, we implement
+   *   this by declaring a variable `X` so that later expressions can use it.
+   * - In addition to the usual identifier key syntax, enum keys are allowed to be string literals,
+   *   e.g. `"hello world" = 3,`. Template literal syntax is NOT allowed.
+   * - Even if the enum key is defined as a string literal, it may still be referenced by identifier
+   *   later, e.g. `"X" = 1, Y = X`. That means that we need to detect whether or not a string
+   *   literal is identifier-like and emit a variable if so, even if the declaration did not use an
+   *   identifier.
+   * - Reserved keywords like `break` are valid enum keys, but are not valid to be referenced later
+   *   and would be a syntax error if we emitted a variable, so we need to skip the variable
+   *   declaration in those cases.
+   *
+   * The variableName return value captures these nuances: if non-null, we can and must emit a
+   * variable declaration, and if null, we can't and shouldn't.
+   */
   extractEnumKeyInfo(nameToken) {
     if (nameToken.type === TokenType.name) {
       const name = this.tokens.identifierNameForToken(nameToken);
       return {
         nameStringCode: `"${name}"`,
-        variableName: isIdentifier(name) ? name : null
+        variableName: isIdentifier(name) ? name : null,
       };
     } else if (nameToken.type === TokenType.string) {
       const name = this.tokens.stringValueForToken(nameToken);
       return {
         nameStringCode: this.tokens.code.slice(nameToken.start, nameToken.end),
-        variableName: isIdentifier(name) ? name : null
+        variableName: isIdentifier(name) ? name : null,
       };
     } else {
       throw new Error("Expected name or string at beginning of enum element.");
     }
   }
-  processStringLiteralEnumMember(enumName, nameStringCode, variableName) {
+
+  /**
+   * Handle an enum member where the RHS is just a string literal (not omitted, not a number, and
+   * not a complex expression). This is the typical form for TS string enums, and in this case, we
+   * do *not* create a reverse mapping.
+   *
+   * This is called after deleting the key token, when the token processor is at the equals sign.
+   *
+   * Example 1:
+   * someKey = "some value"
+   * ->
+   * const someKey = "some value"; MyEnum["someKey"] = someKey;
+   *
+   * Example 2:
+   * "some key" = "some value"
+   * ->
+   * MyEnum["some key"] = "some value";
+   */
+  processStringLiteralEnumMember(
+    enumName,
+    nameStringCode,
+    variableName,
+  ) {
     if (variableName != null) {
       this.tokens.appendCode(`const ${variableName}`);
+      // =
       this.tokens.copyToken();
+      // value string
       this.tokens.copyToken();
       this.tokens.appendCode(`; ${enumName}[${nameStringCode}] = ${variableName};`);
     } else {
       this.tokens.appendCode(`${enumName}[${nameStringCode}]`);
+      // =
       this.tokens.copyToken();
+      // value string
       this.tokens.copyToken();
       this.tokens.appendCode(";");
     }
   }
-  processExplicitValueEnumMember(enumName, nameStringCode, variableName) {
+
+  /**
+   * Handle an enum member initialized with an expression on the right-hand side (other than a
+   * string literal). In these cases, we should transform the expression and emit code that sets up
+   * a reverse mapping.
+   *
+   * The TypeScript implementation of this operation distinguishes between expressions that can be
+   * "constant folded" at compile time (i.e. consist of number literals and simple math operations
+   * on those numbers) and ones that are dynamic. For constant expressions, it emits the resolved
+   * numeric value, and auto-incrementing is only allowed in that case. Evaluating expressions at
+   * compile time would add significant complexity to Sucrase, so Sucrase instead leaves the
+   * expression as-is, and will later emit something like `MyEnum["previousKey"] + 1` to implement
+   * auto-incrementing.
+   *
+   * This is called after deleting the key token, when the token processor is at the equals sign.
+   *
+   * Example 1:
+   * someKey = 1 + 1
+   * ->
+   * const someKey = 1 + 1; MyEnum[MyEnum["someKey"] = someKey] = "someKey";
+   *
+   * Example 2:
+   * "some key" = 1 + 1
+   * ->
+   * MyEnum[MyEnum["some key"] = 1 + 1] = "some key";
+   */
+  processExplicitValueEnumMember(
+    enumName,
+    nameStringCode,
+    variableName,
+  ) {
     const rhsEndIndex = this.tokens.currentToken().rhsEndIndex;
     if (rhsEndIndex == null) {
       throw new Error("Expected rhsEndIndex on enum assign.");
     }
+
     if (variableName != null) {
       this.tokens.appendCode(`const ${variableName}`);
       this.tokens.copyToken();
       while (this.tokens.currentIndex() < rhsEndIndex) {
         this.rootTransformer.processToken();
       }
-      this.tokens.appendCode(`; ${enumName}[${enumName}[${nameStringCode}] = ${variableName}] = ${nameStringCode};`);
+      this.tokens.appendCode(
+        `; ${enumName}[${enumName}[${nameStringCode}] = ${variableName}] = ${nameStringCode};`,
+      );
     } else {
       this.tokens.appendCode(`${enumName}[${enumName}[${nameStringCode}]`);
       this.tokens.copyToken();
@@ -34056,41 +27844,80 @@ class TypeScriptTransformer extends Transformer {
       this.tokens.appendCode(`] = ${nameStringCode};`);
     }
   }
-  processImplicitValueEnumMember(enumName, nameStringCode, variableName, previousValueCode) {
+
+  /**
+   * Handle an enum member with no right-hand side expression. In this case, the value is the
+   * previous value plus 1, or 0 if there was no previous value. We should also always emit a
+   * reverse mapping.
+   *
+   * Example 1:
+   * someKey2
+   * ->
+   * const someKey2 = someKey1 + 1; MyEnum[MyEnum["someKey2"] = someKey2] = "someKey2";
+   *
+   * Example 2:
+   * "some key 2"
+   * ->
+   * MyEnum[MyEnum["some key 2"] = someKey1 + 1] = "some key 2";
+   */
+  processImplicitValueEnumMember(
+    enumName,
+    nameStringCode,
+    variableName,
+    previousValueCode,
+  ) {
     let valueCode = previousValueCode != null ? `${previousValueCode} + 1` : "0";
     if (variableName != null) {
       this.tokens.appendCode(`const ${variableName} = ${valueCode}; `);
       valueCode = variableName;
     }
-    this.tokens.appendCode(`${enumName}[${enumName}[${nameStringCode}] = ${valueCode}] = ${nameStringCode};`);
+    this.tokens.appendCode(
+      `${enumName}[${enumName}[${nameStringCode}] = ${valueCode}] = ${nameStringCode};`,
+    );
   }
 }
+
 class RootTransformer {
-  __init() {
-    this.transformers = [];
-  }
-  __init2() {
-    this.generatedVariables = [];
-  }
-  constructor(sucraseContext, transforms, enableLegacyBabel5ModuleInterop, options) {
-    RootTransformer.prototype.__init.call(this);
-    RootTransformer.prototype.__init2.call(this);
+   __init() {this.transformers = [];}
+  
+  
+   __init2() {this.generatedVariables = [];}
+  
+  
+  
+  
+
+  constructor(
+    sucraseContext,
+    transforms,
+    enableLegacyBabel5ModuleInterop,
+    options,
+  ) {RootTransformer.prototype.__init.call(this);RootTransformer.prototype.__init2.call(this);
     this.nameManager = sucraseContext.nameManager;
     this.helperManager = sucraseContext.helperManager;
-    const { tokenProcessor, importProcessor } = sucraseContext;
+    const {tokenProcessor, importProcessor} = sucraseContext;
     this.tokens = tokenProcessor;
     this.isImportsTransformEnabled = transforms.includes("imports");
     this.isReactHotLoaderTransformEnabled = transforms.includes("react-hot-loader");
     this.disableESTransforms = Boolean(options.disableESTransforms);
+
     if (!options.disableESTransforms) {
-      this.transformers.push(new OptionalChainingNullishTransformer(tokenProcessor, this.nameManager));
+      this.transformers.push(
+        new OptionalChainingNullishTransformer(tokenProcessor, this.nameManager),
+      );
       this.transformers.push(new NumericSeparatorTransformer(tokenProcessor));
       this.transformers.push(new OptionalCatchBindingTransformer(tokenProcessor, this.nameManager));
     }
+
     if (transforms.includes("jsx")) {
-      this.transformers.push(new JSXTransformer(this, tokenProcessor, importProcessor, this.nameManager, options));
-      this.transformers.push(new ReactDisplayNameTransformer(this, tokenProcessor, importProcessor, options));
+      this.transformers.push(
+        new JSXTransformer(this, tokenProcessor, importProcessor, this.nameManager, options),
+      );
+      this.transformers.push(
+        new ReactDisplayNameTransformer(this, tokenProcessor, importProcessor, options),
+      );
     }
+
     let reactHotLoaderTransformer = null;
     if (transforms.includes("react-hot-loader")) {
       if (!options.filePath) {
@@ -34099,28 +27926,57 @@ class RootTransformer {
       reactHotLoaderTransformer = new ReactHotLoaderTransformer(tokenProcessor, options.filePath);
       this.transformers.push(reactHotLoaderTransformer);
     }
+
+    // Note that we always want to enable the imports transformer, even when the import transform
+    // itself isn't enabled, since we need to do type-only import pruning for both Flow and
+    // TypeScript.
     if (transforms.includes("imports")) {
       if (importProcessor === null) {
         throw new Error("Expected non-null importProcessor with imports transform enabled.");
       }
-      this.transformers.push(new CJSImportTransformer(this, tokenProcessor, importProcessor, this.nameManager, reactHotLoaderTransformer, enableLegacyBabel5ModuleInterop, transforms.includes("typescript")));
+      this.transformers.push(
+        new CJSImportTransformer(
+          this,
+          tokenProcessor,
+          importProcessor,
+          this.nameManager,
+          reactHotLoaderTransformer,
+          enableLegacyBabel5ModuleInterop,
+          transforms.includes("typescript"),
+        ),
+      );
     } else {
-      this.transformers.push(new ESMImportTransformer(tokenProcessor, this.nameManager, reactHotLoaderTransformer, transforms.includes("typescript"), options));
+      this.transformers.push(
+        new ESMImportTransformer(
+          tokenProcessor,
+          this.nameManager,
+          reactHotLoaderTransformer,
+          transforms.includes("typescript"),
+          options,
+        ),
+      );
     }
+
     if (transforms.includes("flow")) {
       this.transformers.push(new FlowTransformer(this, tokenProcessor));
     }
     if (transforms.includes("typescript")) {
-      this.transformers.push(new TypeScriptTransformer(this, tokenProcessor, transforms.includes("imports")));
+      this.transformers.push(
+        new TypeScriptTransformer(this, tokenProcessor, transforms.includes("imports")),
+      );
     }
     if (transforms.includes("jest")) {
-      this.transformers.push(new JestHoistTransformer(this, tokenProcessor, this.nameManager, importProcessor));
+      this.transformers.push(
+        new JestHoistTransformer(this, tokenProcessor, this.nameManager, importProcessor),
+      );
     }
   }
+
   transform() {
     this.tokens.reset();
     this.processBalancedCode();
     const shouldAddUseStrict = this.isImportsTransformEnabled;
+    // "use strict" always needs to be first, so override the normal transformer order.
     let prefix = shouldAddUseStrict ? '"use strict";' : "";
     for (const transformer of this.transformers) {
       prefix += transformer.getPrefixCode();
@@ -34146,6 +28002,7 @@ class RootTransformer {
       return prefix + this.tokens.finish() + suffix;
     }
   }
+
   processBalancedCode() {
     let braceDepth = 0;
     let parenDepth = 0;
@@ -34169,6 +28026,7 @@ class RootTransformer {
       this.processToken();
     }
   }
+
   processToken() {
     if (this.tokens.matches1(TokenType._class)) {
       this.processClass();
@@ -34182,6 +28040,10 @@ class RootTransformer {
     }
     this.tokens.copyToken();
   }
+
+  /**
+   * Skip past a class with a name and return that name.
+   */
   processNamedClass() {
     if (!this.tokens.matches2(TokenType._class, TokenType.name)) {
       throw new Error("Expected identifier for exported class name.");
@@ -34190,15 +28052,23 @@ class RootTransformer {
     this.processClass();
     return name;
   }
+
   processClass() {
     const classInfo = getClassInfo(this, this.tokens, this.nameManager, this.disableESTransforms);
-    const needsCommaExpression = (classInfo.headerInfo.isExpression || !classInfo.headerInfo.className) && classInfo.staticInitializerNames.length + classInfo.instanceInitializerNames.length > 0;
+
+    // Both static and instance initializers need a class name to use to invoke the initializer, so
+    // assign to one if necessary.
+    const needsCommaExpression =
+      (classInfo.headerInfo.isExpression || !classInfo.headerInfo.className) &&
+      classInfo.staticInitializerNames.length + classInfo.instanceInitializerNames.length > 0;
+
     let className = classInfo.headerInfo.className;
     if (needsCommaExpression) {
       className = this.nameManager.claimFreeName("_class");
       this.generatedVariables.push(className);
       this.tokens.appendCode(` (${className} =`);
     }
+
     const classToken = this.tokens.currentToken();
     const contextId = classToken.contextId;
     if (contextId == null) {
@@ -34208,14 +28078,25 @@ class RootTransformer {
     while (!this.tokens.matchesContextIdAndLabel(TokenType.braceL, contextId)) {
       this.processToken();
     }
+
     this.processClassBody(classInfo, className);
-    const staticInitializerStatements = classInfo.staticInitializerNames.map((name) => `${className}.${name}()`);
+
+    const staticInitializerStatements = classInfo.staticInitializerNames.map(
+      (name) => `${className}.${name}()`,
+    );
     if (needsCommaExpression) {
-      this.tokens.appendCode(`, ${staticInitializerStatements.map((s) => `${s}, `).join("")}${className})`);
+      this.tokens.appendCode(
+        `, ${staticInitializerStatements.map((s) => `${s}, `).join("")}${className})`,
+      );
     } else if (classInfo.staticInitializerNames.length > 0) {
       this.tokens.appendCode(` ${staticInitializerStatements.map((s) => `${s};`).join(" ")}`);
     }
   }
+
+  /**
+   * We want to just handle class fields in all contexts, since TypeScript supports them. Later,
+   * when some JS implementations support class fields, this should be made optional.
+   */
   processClassBody(classInfo, className) {
     const {
       headerInfo,
@@ -34223,7 +28104,7 @@ class RootTransformer {
       constructorInitializerStatements,
       fields,
       instanceInitializerNames,
-      rangesToRemove
+      rangesToRemove,
     } = classInfo;
     let fieldIndex = 0;
     let rangeToRemoveIndex = 0;
@@ -34233,18 +28114,30 @@ class RootTransformer {
     }
     this.tokens.copyExpectedToken(TokenType.braceL);
     if (this.isReactHotLoaderTransformEnabled) {
-      this.tokens.appendCode("__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}");
+      this.tokens.appendCode(
+        "__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}",
+      );
     }
-    const needsConstructorInit = constructorInitializerStatements.length + instanceInitializerNames.length > 0;
+
+    const needsConstructorInit =
+      constructorInitializerStatements.length + instanceInitializerNames.length > 0;
+
     if (constructorInsertPos === null && needsConstructorInit) {
-      const constructorInitializersCode = this.makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className);
+      const constructorInitializersCode = this.makeConstructorInitCode(
+        constructorInitializerStatements,
+        instanceInitializerNames,
+        className,
+      );
       if (headerInfo.hasSuperclass) {
         const argsName = this.nameManager.claimFreeName("args");
-        this.tokens.appendCode(`constructor(...${argsName}) { super(...${argsName}); ${constructorInitializersCode}; }`);
+        this.tokens.appendCode(
+          `constructor(...${argsName}) { super(...${argsName}); ${constructorInitializersCode}; }`,
+        );
       } else {
         this.tokens.appendCode(`constructor() { ${constructorInitializersCode}; }`);
       }
     }
+
     while (!this.tokens.matchesContextIdAndLabel(TokenType.braceR, classContextId)) {
       if (fieldIndex < fields.length && this.tokens.currentIndex() === fields[fieldIndex].start) {
         let needsCloseBrace = false;
@@ -34264,7 +28157,10 @@ class RootTransformer {
         }
         this.tokens.appendCode("}");
         fieldIndex++;
-      } else if (rangeToRemoveIndex < rangesToRemove.length && this.tokens.currentIndex() >= rangesToRemove[rangeToRemoveIndex].start) {
+      } else if (
+        rangeToRemoveIndex < rangesToRemove.length &&
+        this.tokens.currentIndex() >= rangesToRemove[rangeToRemoveIndex].start
+      ) {
         if (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {
           this.tokens.removeInitialToken();
         }
@@ -34275,7 +28171,13 @@ class RootTransformer {
       } else if (this.tokens.currentIndex() === constructorInsertPos) {
         this.tokens.copyToken();
         if (needsConstructorInit) {
-          this.tokens.appendCode(`;${this.makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className)};`);
+          this.tokens.appendCode(
+            `;${this.makeConstructorInitCode(
+              constructorInitializerStatements,
+              instanceInitializerNames,
+              className,
+            )};`,
+          );
         }
         this.processToken();
       } else {
@@ -34284,15 +28186,29 @@ class RootTransformer {
     }
     this.tokens.copyExpectedToken(TokenType.braceR);
   }
-  makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className) {
+
+  makeConstructorInitCode(
+    constructorInitializerStatements,
+    instanceInitializerNames,
+    className,
+  ) {
     return [
       ...constructorInitializerStatements,
-      ...instanceInitializerNames.map((name) => `${className}.prototype.${name}.call(this)`)
+      ...instanceInitializerNames.map((name) => `${className}.prototype.${name}.call(this)`),
     ].join(";");
   }
+
+  /**
+   * Normally it's ok to simply remove type tokens, but we need to be more careful when dealing with
+   * arrow function return types since they can confuse the parser. In that case, we want to move
+   * the close-paren to the same line as the arrow.
+   *
+   * See https://github.com/alangpierce/sucrase/issues/391 for more details.
+   */
   processPossibleArrowParamEnd() {
     if (this.tokens.matches2(TokenType.parenR, TokenType.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {
       let nextNonTypeIndex = this.tokens.currentIndex() + 1;
+      // Look ahead to see if this is an arrow function or something else.
       while (this.tokens.tokens[nextNonTypeIndex].isType) {
         nextNonTypeIndex++;
       }
@@ -34307,15 +28223,31 @@ class RootTransformer {
     }
     return false;
   }
+
+  /**
+   * An async arrow function might be of the form:
+   *
+   * async <
+   *   T
+   * >() => {}
+   *
+   * in which case, removing the type parameters will cause a syntax error. Detect this case and
+   * move the open-paren earlier.
+   */
   processPossibleAsyncArrowWithTypeParams() {
-    if (!this.tokens.matchesContextual(ContextualKeyword._async) && !this.tokens.matches1(TokenType._async)) {
+    if (
+      !this.tokens.matchesContextual(ContextualKeyword._async) &&
+      !this.tokens.matches1(TokenType._async)
+    ) {
       return false;
     }
-    const nextToken2 = this.tokens.tokenAtRelativeIndex(1);
-    if (nextToken2.type !== TokenType.lessThan || !nextToken2.isType) {
+    const nextToken = this.tokens.tokenAtRelativeIndex(1);
+    if (nextToken.type !== TokenType.lessThan || !nextToken.isType) {
       return false;
     }
+
     let nextNonTypeIndex = this.tokens.currentIndex() + 1;
+    // Look ahead to see if this is an arrow function or something else.
     while (this.tokens.tokens[nextNonTypeIndex].isType) {
       nextNonTypeIndex++;
     }
@@ -34326,12 +28258,15 @@ class RootTransformer {
         this.tokens.removeToken();
       }
       this.tokens.removeToken();
+      // We ate a ( token, so we need to process the tokens in between and then the ) token so that
+      // we remain balanced.
       this.processBalancedCode();
       this.processToken();
       return true;
     }
     return false;
   }
+
   processPossibleTypeRange() {
     if (this.tokens.currentToken().isType) {
       this.tokens.removeInitialToken();
@@ -34343,20 +28278,105 @@ class RootTransformer {
     return false;
   }
 }
+
+var build = {};
+
+(function (exports) {
+exports.__esModule = true;
+exports.LinesAndColumns = void 0;
+var LF = '\n';
+var CR = '\r';
+var LinesAndColumns = /** @class */ (function () {
+    function LinesAndColumns(string) {
+        this.string = string;
+        var offsets = [0];
+        for (var offset = 0; offset < string.length;) {
+            switch (string[offset]) {
+                case LF:
+                    offset += LF.length;
+                    offsets.push(offset);
+                    break;
+                case CR:
+                    offset += CR.length;
+                    if (string[offset] === LF) {
+                        offset += LF.length;
+                    }
+                    offsets.push(offset);
+                    break;
+                default:
+                    offset++;
+                    break;
+            }
+        }
+        this.offsets = offsets;
+    }
+    LinesAndColumns.prototype.locationForIndex = function (index) {
+        if (index < 0 || index > this.string.length) {
+            return null;
+        }
+        var line = 0;
+        var offsets = this.offsets;
+        while (offsets[line + 1] <= index) {
+            line++;
+        }
+        var column = index - offsets[line];
+        return { line: line, column: column };
+    };
+    LinesAndColumns.prototype.indexForLocation = function (location) {
+        var line = location.line, column = location.column;
+        if (line < 0 || line >= this.offsets.length) {
+            return null;
+        }
+        if (column < 0 || column > this.lengthOfLine(line)) {
+            return null;
+        }
+        return this.offsets[line] + column;
+    };
+    LinesAndColumns.prototype.lengthOfLine = function (line) {
+        var offset = this.offsets[line];
+        var nextOffset = line === this.offsets.length - 1
+            ? this.string.length
+            : this.offsets[line + 1];
+        return nextOffset - offset;
+    };
+    return LinesAndColumns;
+}());
+exports.LinesAndColumns = LinesAndColumns;
+exports["default"] = LinesAndColumns;
+}(build));
+
+/**
+ * Special case code to scan for imported names in ESM TypeScript. We need to do this so we can
+ * properly get globals so we can compute shadowed globals.
+ *
+ * This is similar to logic in CJSImportProcessor, but trimmed down to avoid logic with CJS
+ * replacement and flow type imports.
+ */
 function getTSImportedNames(tokens) {
   const importedNames = new Set();
   for (let i = 0; i < tokens.tokens.length; i++) {
-    if (tokens.matches1AtIndex(i, TokenType._import) && !tokens.matches3AtIndex(i, TokenType._import, TokenType.name, TokenType.eq)) {
+    if (
+      tokens.matches1AtIndex(i, TokenType._import) &&
+      !tokens.matches3AtIndex(i, TokenType._import, TokenType.name, TokenType.eq)
+    ) {
       collectNamesForImport(tokens, i, importedNames);
     }
   }
   return importedNames;
 }
-function collectNamesForImport(tokens, index, importedNames) {
+
+function collectNamesForImport(
+  tokens,
+  index,
+  importedNames,
+) {
   index++;
+
   if (tokens.matches1AtIndex(index, TokenType.parenL)) {
+    // Dynamic import, so nothing to do
     return;
   }
+
   if (tokens.matches1AtIndex(index, TokenType.name)) {
     importedNames.add(tokens.identifierNameAtIndex(index));
     index++;
@@ -34364,21 +28384,32 @@ function collectNamesForImport(tokens, index, importedNames) {
       index++;
     }
   }
+
   if (tokens.matches1AtIndex(index, TokenType.star)) {
+    // * as
     index += 2;
     importedNames.add(tokens.identifierNameAtIndex(index));
     index++;
   }
+
   if (tokens.matches1AtIndex(index, TokenType.braceL)) {
     index++;
     collectNamesForNamedImport(tokens, index, importedNames);
   }
 }
-function collectNamesForNamedImport(tokens, index, importedNames) {
+
+function collectNamesForNamedImport(
+  tokens,
+  index,
+  importedNames,
+) {
   while (true) {
     if (tokens.matches1AtIndex(index, TokenType.braceR)) {
       return;
     }
+
+    // We care about the local name, which might be the first token, or if there's an "as", is the
+    // one after that.
     let name = tokens.identifierNameAtIndex(index);
     index++;
     if (tokens.matchesContextualAtIndex(index, ContextualKeyword._as)) {
@@ -34398,19 +28429,26 @@ function collectNamesForNamedImport(tokens, index, importedNames) {
     }
   }
 }
+
 function transform(code, options) {
   validateOptions(options);
   try {
     const sucraseContext = getSucraseContext(code, options);
-    const transformer = new RootTransformer(sucraseContext, options.transforms, Boolean(options.enableLegacyBabel5ModuleInterop), options);
-    let result = { code: transformer.transform() };
+    const transformer = new RootTransformer(
+      sucraseContext,
+      options.transforms,
+      Boolean(options.enableLegacyBabel5ModuleInterop),
+      options,
+    );
+    let result = {code: transformer.transform()};
     if (options.sourceMapOptions) {
       if (!options.filePath) {
         throw new Error("filePath must be specified when generating a source map.");
       }
-      result = __spreadProps(__spreadValues({}, result), {
-        sourceMap: computeSourceMap(result.code, options.filePath, options.sourceMapOptions)
-      });
+      result = {
+        ...result,
+        sourceMap: computeSourceMap(result.code, options.filePath, options.sourceMapOptions),
+      };
     }
     return result;
   } catch (e) {
@@ -34420,22 +28458,49 @@ function transform(code, options) {
     throw e;
   }
 }
+
+/**
+ * Call into the parser/tokenizer and do some further preprocessing:
+ * - Come up with a set of used names so that we can assign new names.
+ * - Preprocess all import/export statements so we know which globals we are interested in.
+ * - Compute situations where any of those globals are shadowed.
+ *
+ * In the future, some of these preprocessing steps can be skipped based on what actual work is
+ * being done.
+ */
 function getSucraseContext(code, options) {
-  const isJSXEnabled2 = options.transforms.includes("jsx");
-  const isTypeScriptEnabled2 = options.transforms.includes("typescript");
-  const isFlowEnabled2 = options.transforms.includes("flow");
+  const isJSXEnabled = options.transforms.includes("jsx");
+  const isTypeScriptEnabled = options.transforms.includes("typescript");
+  const isFlowEnabled = options.transforms.includes("flow");
   const disableESTransforms = options.disableESTransforms === true;
-  const file = parse(code, isJSXEnabled2, isTypeScriptEnabled2, isFlowEnabled2);
+  const file = parse(code, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled);
   const tokens = file.tokens;
   const scopes = file.scopes;
+
   const nameManager = new NameManager(code, tokens);
   const helperManager = new HelperManager(nameManager);
-  const tokenProcessor = new TokenProcessor(code, tokens, isFlowEnabled2, disableESTransforms, helperManager);
+  const tokenProcessor = new TokenProcessor(
+    code,
+    tokens,
+    isFlowEnabled,
+    disableESTransforms,
+    helperManager,
+  );
   const enableLegacyTypeScriptModuleInterop = Boolean(options.enableLegacyTypeScriptModuleInterop);
+
   let importProcessor = null;
   if (options.transforms.includes("imports")) {
-    importProcessor = new CJSImportProcessor(nameManager, tokenProcessor, enableLegacyTypeScriptModuleInterop, options, options.transforms.includes("typescript"), helperManager);
+    importProcessor = new CJSImportProcessor(
+      nameManager,
+      tokenProcessor,
+      enableLegacyTypeScriptModuleInterop,
+      options,
+      options.transforms.includes("typescript"),
+      helperManager,
+    );
     importProcessor.preprocessTokens();
+    // We need to mark shadowed globals after processing imports so we know that the globals are,
+    // but before type-only import pruning, since that relies on shadowing information.
     identifyShadowedGlobals(tokenProcessor, scopes, importProcessor.getGlobalNames());
     if (options.transforms.includes("typescript")) {
       importProcessor.pruneTypeOnlyImports();
@@ -34443,8 +28508,77 @@ function getSucraseContext(code, options) {
   } else if (options.transforms.includes("typescript")) {
     identifyShadowedGlobals(tokenProcessor, scopes, getTSImportedNames(tokenProcessor));
   }
-  return { tokenProcessor, scopes, nameManager, importProcessor, helperManager };
+  return {tokenProcessor, scopes, nameManager, importProcessor, helperManager};
+}
+
+function pad (hash, len) {
+  while (hash.length < len) {
+    hash = '0' + hash;
+  }
+  return hash;
+}
+
+function fold (hash, text) {
+  var i;
+  var chr;
+  var len;
+  if (text.length === 0) {
+    return hash;
+  }
+  for (i = 0, len = text.length; i < len; i++) {
+    chr = text.charCodeAt(i);
+    hash = ((hash << 5) - hash) + chr;
+    hash |= 0;
+  }
+  return hash < 0 ? hash * -2 : hash;
+}
+
+function foldObject (hash, o, seen) {
+  return Object.keys(o).sort().reduce(foldKey, hash);
+  function foldKey (hash, key) {
+    return foldValue(hash, o[key], key, seen);
+  }
+}
+
+function foldValue (input, value, key, seen) {
+  var hash = fold(fold(fold(input, key), toString(value)), typeof value);
+  if (value === null) {
+    return fold(hash, 'null');
+  }
+  if (value === undefined) {
+    return fold(hash, 'undefined');
+  }
+  if (typeof value === 'object' || typeof value === 'function') {
+    if (seen.indexOf(value) !== -1) {
+      return fold(hash, '[Circular]' + key);
+    }
+    seen.push(value);
+
+    var objHash = foldObject(hash, value, seen);
+
+    if (!('valueOf' in value) || typeof value.valueOf !== 'function') {
+      return objHash;
+    }
+
+    try {
+      return fold(objHash, String(value.valueOf()))
+    } catch (err) {
+      return fold(objHash, '[valueOf exception]' + (err.stack || err.message))
+    }
+  }
+  return fold(hash, value.toString());
+}
+
+function toString (o) {
+  return Object.prototype.toString.call(o);
+}
+
+function sum (o) {
+  return pad(foldValue(0, o, '', []).toString(16), 8);
 }
+
+var hashSum = sum;
+
 const COMP_IDENTIFIER = `__sfc__`;
 async function transformTS(src) {
   return transform(src, {
@@ -34452,7 +28586,6 @@ async function transformTS(src) {
   }).code;
 }
 async function compileFile(store, { filename, code, compiled }) {
-  var _a;
   if (!code.trim()) {
     store.state.errors = [];
     return;
@@ -34477,7 +28610,7 @@ async function compileFile(store, { filename, code, compiled }) {
     store.state.errors = [];
     return;
   }
-  const id = await hashId(filename);
+  const id = hashSum(filename);
   const { errors, descriptor } = store.compiler.parse(code, {
     filename,
     sourceMap: true
@@ -34521,13 +28654,13 @@ async function compileFile(store, { filename, code, compiled }) {
   } else {
     ssrCode += clientScript;
   }
-  if (descriptor.template && !descriptor.scriptSetup) {
-    const clientTemplateResult = doCompileTemplate(store, descriptor, id, bindings, false, isTS);
+  if (descriptor.template && (!descriptor.scriptSetup || store.options?.script?.inlineTemplate === false)) {
+    const clientTemplateResult = await doCompileTemplate(store, descriptor, id, bindings, false, isTS);
     if (!clientTemplateResult) {
       return;
     }
     clientCode += clientTemplateResult;
-    const ssrTemplateResult = doCompileTemplate(store, descriptor, id, bindings, true, isTS);
+    const ssrTemplateResult = await doCompileTemplate(store, descriptor, id, bindings, true, isTS);
     if (ssrTemplateResult) {
       ssrCode += ssrTemplateResult;
     } else {
@@ -34545,7 +28678,7 @@ export default ${COMP_IDENTIFIER}`);
     compiled.js = clientCode.trimStart();
     compiled.ssr = ssrCode.trimStart();
   }
-  let css2 = "";
+  let css = "";
   for (const style of descriptor.styles) {
     if (style.module) {
       store.state.errors = [
@@ -34553,45 +28686,47 @@ export default ${COMP_IDENTIFIER}`);
       ];
       return;
     }
-    const styleResult = await store.compiler.compileStyleAsync(__spreadProps(__spreadValues({}, (_a = store.options) == null ? void 0 : _a.style), {
+    const styleResult = await store.compiler.compileStyleAsync({
+      ...store.options?.style,
       source: style.content,
       filename,
       id,
       scoped: style.scoped,
       modules: !!style.module
-    }));
+    });
     if (styleResult.errors.length) {
       if (!styleResult.errors[0].message.includes("pathToFileURL")) {
         store.state.errors = styleResult.errors;
       }
     } else {
-      css2 += styleResult.code + "\n";
+      css += styleResult.code + "\n";
     }
   }
-  if (css2) {
-    compiled.css = css2.trim();
+  if (css) {
+    compiled.css = css.trim();
   } else {
     compiled.css = "/* No <style> tags present */";
   }
   store.state.errors = [];
 }
 async function doCompileScript(store, descriptor, id, ssr, isTS) {
-  var _a, _b, _c, _d;
   if (descriptor.script || descriptor.scriptSetup) {
     try {
       const expressionPlugins = isTS ? ["typescript"] : void 0;
-      const compiledScript = store.compiler.compileScript(descriptor, __spreadProps(__spreadValues({
-        inlineTemplate: true
-      }, (_a = store.options) == null ? void 0 : _a.script), {
+      const compiledScript = store.compiler.compileScript(descriptor, {
+        inlineTemplate: true,
+        ...store.options?.script,
         id,
-        templateOptions: __spreadProps(__spreadValues({}, (_b = store.options) == null ? void 0 : _b.template), {
+        templateOptions: {
+          ...store.options?.template,
           ssr,
           ssrCssVars: descriptor.cssVars,
-          compilerOptions: __spreadProps(__spreadValues({}, (_d = (_c = store.options) == null ? void 0 : _c.template) == null ? void 0 : _d.compilerOptions), {
+          compilerOptions: {
+            ...store.options?.template?.compilerOptions,
             expressionPlugins
-          })
-        })
-      }));
+          }
+        }
+      });
       let code = "";
       if (compiledScript.bindings) {
         code += `
@@ -34612,9 +28747,9 @@ async function doCompileScript(store, descriptor, id, ssr, isTS) {
 const ${COMP_IDENTIFIER} = {}`, void 0];
   }
 }
-function doCompileTemplate(store, descriptor, id, bindingMetadata, ssr, isTS) {
-  var _a, _b, _c;
-  const templateResult = store.compiler.compileTemplate(__spreadProps(__spreadValues({}, (_a = store.options) == null ? void 0 : _a.template), {
+async function doCompileTemplate(store, descriptor, id, bindingMetadata, ssr, isTS) {
+  const templateResult = store.compiler.compileTemplate({
+    ...store.options?.template,
     source: descriptor.template.content,
     filename: descriptor.filename,
     id,
@@ -34623,27 +28758,26 @@ function doCompileTemplate(store, descriptor, id, bindingMetadata, ssr, isTS) {
     ssr,
     ssrCssVars: descriptor.cssVars,
     isProd: false,
-    compilerOptions: __spreadProps(__spreadValues({}, (_c = (_b = store.options) == null ? void 0 : _b.template) == null ? void 0 : _c.compilerOptions), {
+    compilerOptions: {
+      ...store.options?.template?.compilerOptions,
       bindingMetadata,
       expressionPlugins: isTS ? ["typescript"] : void 0
-    })
-  }));
+    }
+  });
   if (templateResult.errors.length) {
     store.state.errors = templateResult.errors;
     return;
   }
   const fnName = ssr ? `ssrRender` : `render`;
-  return `
+  let code = `
 ${templateResult.code.replace(/\nexport (function|const) (render|ssrRender)/, `$1 ${fnName}`)}
 ${COMP_IDENTIFIER}.${fnName} = ${fnName}`;
+  if ((descriptor.script || descriptor.scriptSetup)?.lang === "ts") {
+    code = await transformTS(code);
+  }
+  return code;
 }
-async function hashId(filename) {
-  const msgUint8 = new TextEncoder().encode(filename);
-  const hashBuffer = await crypto.subtle.digest("SHA-256", msgUint8);
-  const hashArray = Array.from(new Uint8Array(hashBuffer));
-  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
-  return hashHex.slice(0, 8);
-}
+
 const defaultMainFile = "App.vue";
 const welcomeCode = `
 <script setup>
@@ -34673,6 +28807,7 @@ class ReplStore {
   constructor({
     serializedState = "",
     defaultVueRuntimeURL = `https://unpkg.com/@vue/runtime-dom@${version}/dist/runtime-dom.esm-browser.js`,
+    defaultVueServerRendererURL = `https://unpkg.com/@vue/server-renderer@${version}/dist/server-renderer.esm-browser.js`,
     showOutput = false,
     outputMode = "preview"
   } = {}) {
@@ -34690,6 +28825,7 @@ class ReplStore {
       };
     }
     this.defaultVueRuntimeURL = defaultVueRuntimeURL;
+    this.defaultVueServerRendererURL = defaultVueServerRendererURL;
     this.initialShowOutput = showOutput;
     this.initialOutputMode = outputMode;
     let mainFile = defaultMainFile;
@@ -34701,9 +28837,12 @@ class ReplStore {
       files,
       activeFile: files[mainFile],
       errors: [],
-      vueRuntimeURL: this.defaultVueRuntimeURL
+      vueRuntimeURL: this.defaultVueRuntimeURL,
+      vueServerRendererURL: this.defaultVueServerRendererURL
     });
     this.initImportMap();
+  }
+  init() {
     watchEffect(() => compileFile(this, this.state.activeFile));
     for (const file in this.state.files) {
       if (file !== defaultMainFile) {
@@ -34769,6 +28908,10 @@ class ReplStore {
           json.imports.vue = this.defaultVueRuntimeURL;
           map.code = JSON.stringify(json, null, 2);
         }
+        if (!json.imports["vue/server-renderer"]) {
+          json.imports["vue/server-renderer"] = this.defaultVueServerRendererURL;
+          map.code = JSON.stringify(json, null, 2);
+        }
       } catch (e) {
       }
     }
@@ -34787,8 +28930,10 @@ class ReplStore {
     this.state.files["import-map.json"].code = JSON.stringify(map, null, 2);
   }
   async setVueVersion(version2) {
+    this.vueVersion = version2;
     const compilerUrl = `https://unpkg.com/@vue/compiler-sfc@${version2}/dist/compiler-sfc.esm-browser.js`;
     const runtimeUrl = `https://unpkg.com/@vue/runtime-dom@${version2}/dist/runtime-dom.esm-browser.js`;
+    const ssrUrl = `https://unpkg.com/@vue/server-renderer@${version2}/dist/server-renderer.esm-browser.js`;
     this.pendingCompiler = import(
       /* @vite-ignore */
       compilerUrl
@@ -34796,31 +28941,47 @@ class ReplStore {
     this.compiler = await this.pendingCompiler;
     this.pendingCompiler = null;
     this.state.vueRuntimeURL = runtimeUrl;
+    this.state.vueServerRendererURL = ssrUrl;
     const importMap = this.getImportMap();
-    (importMap.imports || (importMap.imports = {})).vue = runtimeUrl;
+    const imports = importMap.imports || (importMap.imports = {});
+    imports.vue = runtimeUrl;
+    imports["vue/server-renderer"] = ssrUrl;
     this.setImportMap(importMap);
     console.info(`[@vue/repl] Now using Vue version: ${version2}`);
   }
   resetVueVersion() {
+    this.vueVersion = void 0;
     this.compiler = defaultCompiler;
     this.state.vueRuntimeURL = this.defaultVueRuntimeURL;
+    this.state.vueServerRendererURL = this.defaultVueServerRendererURL;
+    const importMap = this.getImportMap();
+    const imports = importMap.imports || (importMap.imports = {});
+    imports.vue = this.defaultVueRuntimeURL;
+    imports["vue/server-renderer"] = this.defaultVueServerRendererURL;
+    this.setImportMap(importMap);
+    console.info(`[@vue/repl] Now using default Vue version`);
   }
 }
-var Repl_vue_vue_type_style_index_0_scoped_true_lang = "";
+
+var Repl_vue_vue_type_style_index_0_scoped_true_lang = '';
+
 const _hoisted_1 = { class: "vue-repl" };
-const _sfc_main = /* @__PURE__ */ defineComponent({
+const _sfc_main = defineComponent({
+  name: "Repl",
   props: {
-    store: { type: null, required: false, default: () => new ReplStore() },
-    autoResize: { type: Boolean, required: false, default: true },
-    showCompileOutput: { type: Boolean, required: false, default: true },
-    showImportMap: { type: Boolean, required: false, default: true },
-    clearConsole: { type: Boolean, required: false, default: true },
-    sfcOptions: { type: null, required: false },
-    layout: { type: String, required: false }
+    store: { default: () => new ReplStore() },
+    autoResize: { type: Boolean, default: true },
+    showCompileOutput: { type: Boolean, default: true },
+    showImportMap: { type: Boolean, default: true },
+    clearConsole: { type: Boolean, default: true },
+    sfcOptions: null,
+    layout: null,
+    ssr: { type: Boolean, default: false }
   },
   setup(__props) {
     const props = __props;
     props.store.options = props.sfcOptions;
+    props.store.init();
     provide("store", props.store);
     provide("autoresize", props.autoResize);
     provide("import-map", toRef(props, "showImportMap"));
@@ -34833,8 +28994,9 @@ const _sfc_main = /* @__PURE__ */ defineComponent({
           ]),
           right: withCtx(() => [
             createVNode(Output, {
-              showCompileOutput: props.showCompileOutput
-            }, null, 8, ["showCompileOutput"])
+              showCompileOutput: props.showCompileOutput,
+              ssr: !!props.ssr
+            }, null, 8, ["showCompileOutput", "ssr"])
           ]),
           _: 1
         }, 8, ["layout"])
@@ -34842,5 +29004,6 @@ const _sfc_main = /* @__PURE__ */ defineComponent({
     };
   }
 });
-var Repl = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-75fc3196"]]);
-export { File, Repl, ReplStore, compileFile };
+var Repl = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-2f69a4f0"]]);
+
+export { File, Preview, Repl, ReplStore, compileFile };
